<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逆版本战士の部落格</title>
  
  
  <link href="http://adversarr.github.io/atom.xml" rel="self"/>
  
  <link href="http://adversarr.github.io/"/>
  <updated>2022-04-19T15:28:52.722Z</updated>
  <id>http://adversarr.github.io/</id>
  
  <author>
    <name>Adversarr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Programming</title>
    <link href="http://adversarr.github.io/2022/04/19/study/ComputerScience/fragments/WhyProgramming/"/>
    <id>http://adversarr.github.io/2022/04/19/study/ComputerScience/fragments/WhyProgramming/</id>
    <published>2022-04-19T15:25:31.924Z</published>
    <updated>2022-04-19T15:28:52.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="范式">范式</h3><p>第一公民。</p><p>逻辑、表达能力</p><h3 id="词法语法解析与执行">词法、语法、解析与执行</h3><h3 id="nfl">NFL</h3><p>简单 + 舒适 复杂 + 舒适 简单 + 难受 复杂 + 难受</p><h3 id="section"></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;范式&quot;&gt;范式&lt;/h3&gt;
&lt;p&gt;第一公民。&lt;/p&gt;
&lt;p&gt;逻辑、表达能力&lt;/p&gt;
&lt;h3 id=&quot;词法语法解析与执行&quot;&gt;词法、语法、解析与执行&lt;/h3&gt;
&lt;h3 id=&quot;nfl&quot;&gt;NFL&lt;/h3&gt;
&lt;p&gt;简单 + 舒适 复杂 + 舒适 简单 + 难受 复杂 + 难受</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>102-03-参数曲线拟合</title>
    <link href="http://adversarr.github.io/2022/04/19/CG/GAMES/g102-03/"/>
    <id>http://adversarr.github.io/2022/04/19/CG/GAMES/g102-03/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-19T03:40:08.873Z</updated>
    
    <content type="html"><![CDATA[<p>几何建模与处理</p><span id="more"></span><h2 id="多元函数">多元函数</h2><div class="story post-story"><p><span class="math display">\[f:\R ^n \rightarrow \R\]</span></p><h3 id="二元函数基函数构造">二元函数基函数构造</h3><p>方法：<strong>张量积</strong>（两两相乘）</p><figure><img src="g102-03/image-20220419111126729.png" class="lazyload" data-srcset="g102-03/image-20220419111126729.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="张量基函数" /><figcaption aria-hidden="true">张量基函数</figcaption></figure><p>优点：定义简单，多个一元基函数的乘积形式</p><p>不足：</p><ul><li>维数增加 – 基函数个数 <span class="math inline">\(n^2\)</span> –变量（参数数量）增加</li></ul><h3 id="神经网络表达">神经网络表达</h3><ul><li>用单变量函数 <span class="math inline">\(\sigma(x)\)</span>和不同的仿射变换来构造基函数。</li></ul></div><h2 id="向量值函数">向量值函数</h2><div class="story post-story"><p><span class="math display">\[f:\R^m \rightarrow \R^n\]</span></p><ul><li>看成多个单变量函数，各个函数独立无关。</li><li>共享基函数</li></ul><p>几何上：</p><ul><li>对于<span class="math inline">\(m=1\)</span> – 轨迹为曲线 —本质维度=1</li><li>对于 <span class="math inline">\(\R^2 \rightarrow \R^3\)</span> —参数曲面 — 本质维度=2 —</li><li><span class="math inline">\(3\rightarrow3\)</span> — 变形 –应用：有限元、图像变形</li><li><span class="math inline">\(3\rightarrow 2\)</span> — 降维映射 —例如 AutoEncoder</li></ul><figure><img src="g102-03/image-20220419112717602.png" class="lazyload" data-srcset="g102-03/image-20220419112717602.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="总结" /><figcaption aria-hidden="true">总结</figcaption></figure></div><h2 id="曲线拟合">曲线拟合</h2><div class="story post-story"><h3 id="曲线拟合问题">曲线拟合问题</h3><ul><li>输入：给定平面上的点</li><li>输出：一条参数曲线，拟合这些点</li></ul><p><span class="math display">\[f:\R \rightarrow \R^2\]</span></p><p>参数化 — <span class="math display">\[\begin{cases}x = x(t)\\y = y(t)\end{cases}\]</span></p><ul><li><p>问题转化为：对数据点 <spanclass="math inline">\((x_i,y_i)\)</span>，对应哪个参数<spanclass="math inline">\(t_i\)</span>？</p></li><li><p><span class="math inline">\(E = \sum\|\mathbf p (t_i) - \mathbfp_i\|\)</span></p></li></ul><p>如何确定 <span class="math inline">\(t\)</span></p><ul><li><p>均匀参数化（Equidistant Parameterization）</p></li><li><p>弦长参数化 <span class="math inline">\(t_{i+1} - t_i =\|\mathbfb_{i+1} -\mathbf b\|\)</span></p></li><li><p>中心参数化</p></li></ul><blockquote><p><strong>需要好的参数化</strong></p><p>目的：保持原有结构！</p></blockquote><h3 id="曲面参数化">曲面参数化</h3><ul><li>三维点找二维的参数 — 降维问题</li></ul><p>例如：</p><ul><li>纹理映射</li><li>世界地图</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;几何建模与处理&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-04-三次样条函数</title>
    <link href="http://adversarr.github.io/2022/04/19/CG/GAMES/g102-04/"/>
    <id>http://adversarr.github.io/2022/04/19/CG/GAMES/g102-04/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-19T07:52:10.194Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 102 – 几何建模与处理</p><span id="more"></span><h2 id="三次样条函数">三次样条函数</h2><div class="story post-story"><h3 id="力学解释">力学解释</h3><ul><li><p>曲线：弹性梁 — 弹性模量为 <spanclass="math inline">\(E\)</span></p></li><li><p>利用贝努利-欧拉方程，得到近似为分段三次函数</p></li><li><p>2次 — 无法表达拐点、三次 — <spanclass="math inline">\(C^2\)</span>，四次 — 误差大</p></li></ul><p>如何求？满足什么条件？</p><h3 id="思路">思路</h3><p>分段三次多项式，四个变量待定 <span class="math display">\[y_{i}(x) = a_i + b_i x. + c_i x ^ 2 + d_i x ^ 3\]</span> 从而有 <span class="math inline">\(4n-2\)</span>个约束条件，加上两个边界条件。</p><p>列出三弯矩方程组（对称、三对角、对角占优），可以使用追赶法来计算。</p><h3 id="边界条件">边界条件</h3><ul><li>自由端 — 指定二阶导数</li><li>夹持端 — 指定一阶导数</li></ul><h3 id="三次基样条">三次基样条</h3><p>使用三次基函数，计算在基函数下的“坐标”</p></div><h2 id="三次样条曲线">三次样条曲线</h2><div class="story post-story"><ul><li>取 <span class="math inline">\(x,y,z\)</span></li><li>参数化</li></ul></div><h2 id="曲线的连续性">曲线的连续性</h2><div class="story post-story"><p>参数连续性：<span class="math inline">\(C^2\)</span>连续 —和参数有关</p><p>几何连续性：设 <span class="math inline">\(\phi(t)\)</span>是给定曲线的参数方程，存在参数变换，可以达到的连续性是几何连续性。记为<spanclass="math inline">\(G^n\)</span></p><p>具体：</p><ul><li><span class="math inline">\(G^0\)</span>，连续</li><li><span class="math inline">\(G^1\)</span> 切线相同</li><li><span class="math inline">\(G^2\)</span> 曲率相同</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 102 – 几何建模与处理&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>实时布料仿真</title>
    <link href="http://adversarr.github.io/2022/04/14/CG/ContactDetection/ClothSimu/"/>
    <id>http://adversarr.github.io/2022/04/14/CG/ContactDetection/ClothSimu/</id>
    <published>2022-04-14T12:58:15.554Z</published>
    <updated>2022-04-14T14:07:32.651Z</updated>
    
    <content type="html"><![CDATA[<p>Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021</p><span id="more"></span><h2 id="introduction">Introduction</h2><div class="story post-story"><p>Dynamic Solver：</p><ul><li>High resolution</li><li>High nonlinearity</li><li>High stiffness — 多次迭代、计算量</li></ul><p>Collision:</p><ul><li>Collision detection</li><li>Collision Response.</li></ul><h3 id="problem-definitions">Problem Definitions</h3><h4 id="terms">Terms</h4><p>Position Vector: <span class="math display">\[\mathbf x = [\mathbf x_0 \mathbf x_1 \cdots \mathbf x_N]&#39;\]</span> Velocity: <span class="math display">\[\mathbf v = \dot {\mathbf x}\quad \mathbf M = diag(m_0, \dots, m_N)\]</span> Energy – Holonomic(Position only): <spanclass="math display">\[E(\mathbf x)\]</span> 例如：</p><ol type="1"><li>重力势能</li><li>弹簧能量</li><li>Fixing Energy — <span class="math inline">\(\frac{\sigma}2 (\mathbfx_i -\mathbf y_i)^2\)</span></li></ol><h4 id="time-integration">Time Integration</h4><p>常用：隐式欧拉法</p><p>求解方法：</p><ol type="1"><li>消去 <span class="math inline">\(\mathbf v^{t + \Deltat}\)</span></li><li>转化为非线性优化问题</li></ol><p>从而，整个问题都变为： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x)\]</span> 其中 <span class="math inline">\(F\)</span>由动能和势能组成。</p><h4 id="碰撞">碰撞</h4><p>作为约束项出现： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad \mathbf x^{t + \Delta t} \in \Omega\]</span> <img src="ClothSimu/image-20220414210701587.png"alt="image-20220414210701587" /></p><p>上式存在隧穿问题(Tunnel)。故采用CCD。 <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad s \mathbf x^t + (1-s)  \mathbf x^{t + \Delta t} \in \Omega\forall s\in [0,1]\]</span></p></div><h2 id="dynamics">Dynamics</h2><div class="story post-story"><p>非线性优化通常有如下的形式： <span class="math display">\[\mathbf x ^{k+1} = \mathbf x^k - \alpha^{k + 1}\left(A^{k+1}\right)^{-1} \mathrm{grad}\]</span></p><h3 id="newton-法">Newton 法</h3><p>优点</p><ul><li>2 阶方法</li><li>Hessian Matrix</li></ul><p>问题</p><ul><li>如何求解 <span class="math inline">\(A^{-1}f\)</span> —计算量大</li><li>不一定收敛<ul><li>减小 <span class="math inline">\(\alpha\)</span></li><li>要求 Hessian 正定</li></ul></li></ul><h3 id="梯度下降">梯度下降</h3><p><span class="math display">\[A = \mathrm{id}\]</span></p><p>优点</p><ul><li>GPU++</li><li>简单</li></ul><p>缺点</p><ul><li>1阶收敛 – 慢</li><li>没有任何实时模拟器使用</li></ul><h3 id="projective-dynamics">Projective Dynamics</h3><p>用常矩阵代替 <span class="math inline">\(A\)</span></p><p>优点：</p><ul><li>CPU++，（C 可以被预分解）</li><li>收敛快 — smoother</li></ul><p>缺点</p><ul><li>GPU不友好</li><li>1阶收敛速度（总体上很慢）</li></ul><h3 id="diagonal-hessian">Diagonal Hessian</h3><p><span class="math display">\[\mathbf A^{k+1} = \mathrm{diag\ grad}\]</span></p><p>优点</p><ul><li>收敛快于GD</li><li>GPU++</li></ul><p>缺点</p><ul><li>速度仍然差于牛顿</li></ul><h3 id="lower-hessian">Lower Hessian</h3><p>使用hessian的下三角</p><p>优缺点同 Diag Hess</p><figure><img src="ClothSimu/image-20220414212056199.png" class="lazyload" data-srcset="ClothSimu/image-20220414212056199.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="总结对比" /><figcaption aria-hidden="true">总结对比</figcaption></figure><h3 id="acceleration">Acceleration</h3><ul><li>Chebyshev — GPU Firendly</li><li>Multiscale Acceleration</li></ul><h3 id="conclusion">Conclusion</h3><p>CPU：Projective Dynamics + Newton-Raphson</p><p>GPU：Chebyshev + Diagonal Hessian / Newton + PCG</p><h3 id="more">More</h3><h4 id="pbd-position-based-dynamics">PBD — Position-Based Dynamics</h4><p><strong>NVCLOTH</strong></p><h4 id="regular-grid-mesh">Regular Grid Mesh</h4><ul><li>Avoid Topology info</li><li>mem access</li><li>more suitable for high resolution</li></ul></div><h2 id="碰撞-1">碰撞</h2><div class="story post-story"><p>两部分：碰撞检测 + 碰撞响应 具体看综述</p><h3 id="检测">检测</h3><p>mesh -&gt; pair -&gt; collision</p><h3 id="response">Response</h3><ol type="1"><li>Iterative Position-Based Repulsion</li><li>Impact Zone Method</li><li>Untangling</li></ol></div><h2 id="other-topics">Other Topics</h2><div class="story post-story"><ul><li>Friction</li><li>Nonelastic</li><li>Locking</li><li>Physical model and measurement</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="仿真模拟" scheme="http://adversarr.github.io/tags/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="布料" scheme="http://adversarr.github.io/tags/%E5%B8%83%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 6 - 综述</title>
    <link href="http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/"/>
    <id>http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-15T04:13:25.291Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测 学习笔记</p><span id="more"></span><p>[toc]</p><h2 id="碰撞处理简述">碰撞处理简述</h2><div class="story post-story"><p>碰撞处理的难度是不大的，主要问题是如何进行快速、准确的碰撞检测。碰撞检测主要算法执行流程如下图：</p><figure><img src="2022-04-05-17-32-22.png" class="lazyload" data-srcset="2022-04-05-17-32-22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GAMES-103-Wang" /><figcaption aria-hidden="true">GAMES-103-Wang</figcaption></figure></div><h2 id="碰撞检测----introduction">碰撞检测 -- Introduction</h2><div class="story post-story"><p>首先再次引一下 PhyX 里面的内容，这也是这篇文章整体的一个思路。</p><blockquote><p><strong>Overview of Collision in PhysX</strong></p><ul><li>Broad Phase<ul><li>AABB vs AABB, 3 axis sweep and prune</li></ul></li><li>Mid Phase<ul><li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABBtree</li></ul></li></ul><p>对于 Narrow Phase：</p><ul><li><p>流体-SPH Fluids (CCD)</p><ul><li>Particles vs static triangle mesh • Particles vs dynamicprimitives</li></ul></li><li><p>布料-Cloth (CCD)</p><ul><li>Vertices vs static triangle mesh • Vertices vs dynamicprimitives</li></ul></li><li><p>刚体-Rigid body (Discrete) – GJK or SAT</p><ul><li><p>Convex mesh and primitives vs static triangle mesh</p></li><li><p>Convex, primitives vs Convex, primitives</p></li></ul></li></ul></blockquote><p>解释一些事情：</p><ol type="1"><li><p>对于<strong>大多数</strong>情况下的碰撞，我们只考虑<strong>物体之间</strong>的情况，而不是物体内部。</p></li><li><p>Broad-Phase做的实际上是<em>生成式</em>的，而非<em>筛选式</em>的，Mid-Phase对于Broad-Phase进行筛选，Narrow-Phase是筛选结果来精确计算是否真正发生了碰撞。</p><blockquote><p>很多研究认为 Narrow-Phase的效率并不需要太多考虑，而前两个筛选的效率大大影响了结果</p></blockquote></li><li><p>对于Narrow-Phase中的三类物体，它们有不同的属性：</p><ol type="1"><li>流体 -- SPH模拟假设为一个个小的水块，自相交检测策略不同</li><li>布料 -- Mass-Spring orPBD，约束为任何物体不能穿透布料表面，也适用于自身，所以需要进行自碰撞处理</li><li>刚体 -- 不可能发生自碰撞，只考虑物体之间的碰撞。</li></ol></li></ol></div><h2 id="broad-phase">Broad-Phase</h2><div class="story post-story"><p>实际上这个没啥好讲的，主要思路就是建立空间数据结构，然后加速计算。</p><ol type="1"><li>BVHs</li><li>Spatial Hashing</li></ol><h3 id="加速结构">加速结构</h3><p>就如之前提到的，Broad-Phase主要是使用<strong>空间数据结构</strong>来加速碰撞检查，这类数据结构按照欧氏空间的坐标来对于整个空间进行索引加速，从而实现快速查找近邻的目的。</p><h4 id="oct-treekdtree">OCT-tree/kdTree</h4><ul><li><p><strong>八叉树</strong>：将一个Box按照点<spanclass="math inline">\(P\)</span>和经过<spanclass="math inline">\(P\)</span>平行于<spanclass="math inline">\(xOy,yOz,zOx\)</span>的平面划分。</p></li><li><p><strong>kd树</strong>：每一次选择一个超平面划分所有点，超平面的选择依照<spanclass="math inline">\(xOy, yOz,zOx,xOy,yOz,\cdots\)</span>的顺序选择。</p></li></ul><p>可能碰撞转化为查询轨迹和物体是否相交，等价于查询是否和当前节点的覆盖范围相交，若检查到轨迹和结点覆盖范围</p><ol type="1"><li>相交：<ul><li>叶子节点，认定为可能碰撞的目标</li><li>非叶结点，继续递归查询</li></ul></li><li>不相交： 停止递归查询</li></ol><p>这样构造层次结构的问题是：</p><ol type="1"><li>过于规则：容易出现不均匀分割，从而导致内存浪费和查询效率下降。</li><li>不利于并行计算—这也是层次结构的通病</li></ol><h4 id="bvh">BVH</h4><p>BVH可以看作是OCT-Tree和kdTree的一个推广：Bounding VolumnHierarchy（BVH） 将全空间进行划分，对于维度为 1的情况，BVH与<em>线段树</em>几乎没有区别。不过，BVH和OCT-Tree等的最大的区别在于OCT-Tree 和kdTree进行划分时使用的是边界去切分整个平面，而BVH用的是<strong>有限体积的“框”</strong>去做空间细分。典型的BVH包括：</p><ul><li>AABB：轴对齐包围盒</li><li>OBB：旋转包围盒</li><li>kDOP：k边形包围盒</li><li>Bounding Sphere：包围球</li></ul><p>可以看出，各个算法不同的部分是选用的“框”的形状。另外，在构造上BVH有启发算法，可以是的其构造的层次结构尽量均匀，进一步提高BVH的加速能力。</p><h4 id="spatial-hashing-spatial-partitioning">Spatial Hashing / SpatialPartitioning</h4><p>Spatial Hashing的思想是为每一个空间一个编号。最简单的方法是均匀的使用格点来对于全空间进行划分。最基础的Spatial Hashing在为每一个格子建立列表，列表中存放所有和该格子有重合区域的物体（即一个物体可能出现在多个格子内），在查询碰撞时即对于同一列表中的不同物体进行查询即可。</p><figure><img src="image-20220409103734403.png" class="lazyload" data-srcset="image-20220409103734403.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Spatial Partitioning" /><figcaption aria-hidden="true">Spatial Partitioning</figcaption></figure><p>如图所示，其将全空间划分为16个格子。考虑到减少空间浪费的问题，将这些物体的按id进行排序，即可在不为每一个id建立表格的情况下完成筛选。</p><p>该算法的主要问题在于，现代的渲染常常物体、面元分布极不均匀，在可能在几个小的cell中包含大量物体，而产生大量的可能碰撞物体对，极大的降低了其查询效率。</p><p>但是得益于其可以轻松在并行计算环境，特别是GPU上进行实现，其在物理引擎中也得到了广泛的应用。</p><h3 id="mid-phase">Mid-Phase</h3><p>之所以把Mid-Phase放在BroadPhase中是因为它用的算法和数据结构实际上和BroadPhase几乎是一致的。</p><p>Mid-Phase会对Broad-Phase筛选出的pair进行进一步筛选，针对每一个物体，其通过细分为更小的物体块（如凸包，面元组等），然后继续应用加速结构进行筛选。</p><blockquote><p>在这个的基础上还有一些 local 的加速方法，但这也不能算是 Broad-Phase的方法，因为这个方法针对于 <em>Deformed</em>的物体进行计算的效率较高。这些方法在曲面上进行划分，相当于在曲面上定义了一个空间划分。比如通过形变能量来指导在其上的空间划分，最后精细化求解使用三次方程法求解。例如：该论文提出，可以依照形变能量，在曲面的表面上建立BVH，来指导Culling进行。</p></blockquote><figure><img src="image-20220413220403382.png"alt="Energy-based Self-Collision Culling for Arbitrary Mesh Deformations" /><figcaption aria-hidden="true">Energy-based Self-Collision Culling forArbitrary Mesh Deformations</figcaption></figure></div><h2 id="narrow-phase-1-刚体">Narrow-phase 1 刚体</h2><div class="story post-story"><h3 id="dcd">DCD</h3><h4 id="signed-distance-function">Signed Distance Function</h4><p>如果我们能为刚体定义一个连续函数，使得对于<spanclass="math inline">\(\mathbf x \in \Omega -\partial\Omega\)</span>有<span class="math inline">\(\phi(\mathbf x) &lt;0\)</span>对于所有<span class="math inline">\(x\not \in \overline\Omega\)</span>，有<span class="math inline">\(\phi(x) &gt;0\)</span>，则可以很简单的通过函数零点的存在性来判断是否碰撞。</p><p>但对于一般的网格，难以定义这样一个带符号的距离函数。</p><h4 id="凸包刚体的dcd计算">凸包/刚体的DCD计算</h4><p>对于一般的刚体之间的碰撞检测，一般采用分解为凸包的算法来进行精准的碰撞检测。因此，最基础的针对凸物体的碰撞检测算法（即凸物体之间的碰撞检测）</p><h5 id="gjk算法">GJK算法</h5><h6 id="idea">Idea</h6><p>设<span class="math inline">\(\mathcal A = \{\mathbfx\}\)</span>，<span class="math inline">\(\mathcal B = \{\mathbfx\}\)</span>是两个凸集，定义其 Minkowski 差为： <spanclass="math display">\[\mathcal A - \mathcal B :=\{\mathbf x_1 - \mathbf x_2| \mathbf x_1 \in\mathcal A, \mathbf x_2 \in \mathcal B \}\]</span> 不难证明，<span class="math inline">\(\mathcalA\)</span>和<span class="math inline">\(\mathcalB\)</span>碰撞，当且仅当<span class="math inline">\(0 \in \mathcal A -\mathcal B\)</span>。</p><p>问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于<strong>凸物体</strong>，我们可以有快速算法实现。</p><h6 id="support-函数和-simplex-单纯形">Support 函数和 Simplex单纯形</h6><p>其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski差的一个子集包含了<spanclass="math inline">\(0\)</span>，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。</p><p>为了生成这样的单纯形，我们计算 support函数来快速获取给定方向上的支撑点，如图所示[^1]。</p><p><img src="v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg" class="lazyload" data-srcset="v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h6 id="迭代求解">迭代求解</h6><p>有了如上的论述，我们可以通过如此构造单纯形：</p><ol type="1"><li>随机生成一个单纯形</li><li>假定当前的单纯形为<spanclass="math inline">\(\{v\}\)</span>则选择距离原点最远的抛弃，对于 n - 1维单纯形求法向量，求support（两个）</li><li>直到<ol type="1"><li>检查到 0 =&gt; 碰撞</li><li>如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞</li></ol></li></ol><p>可以证明，这样的算法一定在有限步内结束。</p><h5 id="sat算法">SAT算法</h5><p>一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个<spanclass="math inline">\(n - 1\)</span>维的超平面能够完全分开这两个凸集合。遍历所有的边（三维则是面），投影到其正交补空间上。若<strong>存在</strong>一个边，能使得投影完全分离，则其是不相交的，反之相交。具体实现为遍历所有的边来进行判断。</p><h5 id="凸包分解和碰撞检测">凸包分解和碰撞检测</h5><p>对于一般的刚体，我们可以选择使用<strong>凸包分解（V-HACD）</strong>，将刚体“拆分”成小的凸包。并使用适用于凸包的Collision Detect 来进行碰撞的判断。</p><h3 id="ccd">CCD</h3><p>刚体的CCD算法大致有如下几类：</p><ol type="1"><li>求解代数方程</li><li>滑动体积法（Swept Volume）</li><li>二分搜索</li><li>Conservative Advancement上述大部分都难以处理一般的多面体情况。但也有一些特殊情况。</li></ol><!-- 也可以使用分离轴定理计算CCD --><h4 id="代数方程求解">代数方程求解</h4><p>这种方法仅适用于简单而特殊的情况，例如<ahref="http://www.realtimerendering.com/intersections.html">Ref</a>：</p><ol type="1"><li>光线</li><li>平面</li><li>球体、圆柱、圆锥、视锥</li><li>AABB、OBB、kDOP</li><li>凸包</li></ol><h4 id="近似ccd">“近似CCD”</h4><p>通过减小模拟的时间步长，可以将 DCD 近似为 CCD。</p><h4 id="二分搜索">二分搜索</h4><p>这个方法仅仅用于确定 TOI</p><p>物理模拟中有时会使用二分法（二分搜索）来查找撞击时间：使用这种方案，可以非常快速地到达撞击时间，但我们不涉及Tunnel问题，因为如果在第i 帧和第 i + 1 帧没有碰撞，二分就不会开始。</p><h4 id="swept-volumn">Swept Volumn</h4><p>考察<span class="math inline">\(t\)</span>和<spanclass="math inline">\(t+1\)</span>时刻物体对应点连线（按物体形状、沿直线执行扫描）构成的体积区域，不难发现，如果有相交，则可能会出现碰撞。计算TOI（碰撞时间）后将物体移动到改时间，执行碰撞处理（如计算速度等）然后重新扫描。</p><p>在物体角速度很大的情况下会产生不精确的结果 <ahref="https://docs.unity3d.com/Manual/ContinuousCollisionDetection.html">Ref</a>：</p><figure><img src="2022-04-14-15-52-26.png" class="lazyload" data-srcset="2022-04-14-15-52-26.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Unity 3D" /><figcaption aria-hidden="true">Unity 3D</figcaption></figure><h4 id="speculative-ccd">Speculative CCD</h4><p>Speculative CCD的工作原理是根据物体的速度和角速度，计算物体的AABB，从而推测出下一个物理步骤中所有潜在的接触。然后将所有可能接触送入求解器，以确保满足所有接触约束，以便对象不会通过任何穿模（Tunnel）的情况。求解器使用速度、体积来精确计算CCD。</p><p><img src="2022-04-14-15-55-41.png" class="lazyload" data-srcset="2022-04-14-15-55-41.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>但该方法并不能完全解决所有碰撞问题。考虑如下的情况，小球因为被杆击打而获得更大的速度，先前计算的AABB并不能检测到这样的速度变化：</p><p><img src="2022-04-14-16-00-14.png" class="lazyload" data-srcset="2022-04-14-16-00-14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="ray-cast">Ray-cast</h4><p>小而高速和大而低速物体之间的碰撞检测中可以视作光投射到低速物体上的过程，该方法在Unreal Engine中被作为试验性功能提供（支持GPU加速）。算法将光线从对象中心点投射到低速物体上，在高速物体中放置更多的采样点并投射出多条光线，可以获得更好的结果。缺点在于，由于假设了其速度差距极大，该方法不适合计算两个运动的物体的碰撞检测。</p><h4 id="conservasive-advancement">Conservasive Advancement</h4><blockquote><p>Ref:</p><ol type="1"><li>C<sup>2</sup>A: Controlled Conservative Advancement for ContinuousCollision Detection of Polygonal Models</li></ol></blockquote><p>在每次迭代中，计算两个对象的最近点（例如使用GJK）。使用此信息，计算对象可以在避免碰撞的同时移动的安全距离。仅经过几次迭代，就可以找到影响时间。</p></div><h2 id="narrow-phase-2-变形体">Narrow-Phase 2 变形体</h2><div class="story post-story"><h3 id="dcd-1">DCD</h3><p>DCD检查的是如下的方程的解的问题（考察 V-E)：</p><p><span class="math display">\[\begin{cases}   \left( ((1-t)\mathbf{x}_a + t \mathbf x _ b - \mathbf x_0 ) \quad\mathbf x _{10} \quad x_{20}\right) = 0\\   t = (\mathbf x_{0a} \mathbf x_{10}\mathbf  x_{20}) / (\mathbf x_{ba}\mathbf   x_{10} \mathbf x_{20})\\   t \in [0, 1]\\   \mathbf x(t) \text{ inside } \triangle\end{cases}\]</span></p><p>分为三步求解：</p><ol type="1"><li>求解前两行的方程</li><li>判断<span class="math inline">\(t\)</span>是否在<spanclass="math inline">\([0, 1]\)</span></li><li>判断<span class="math inline">\(\mathbfx(t)\)</span>是否在三角形内</li></ol><p>这一部分基本很少有人做，原因在于现代的模拟算法越来越追求计算效率，使用较大的时间步长来进行模拟计算。若仅仅使用DCD，容易产生“穿模”的问题。</p><h3 id="ccd-1">CCD</h3><p>对于变形体（主要是三角网格）的连续碰撞检测处理算法研究主体还是对于三次方程（即VT/EE条件求解），同时也借鉴了一些在刚体碰撞检测中常用的技巧：</p><ol type="1"><li>二分法<ol type="1"><li>IRF：interval-root-finder</li><li>UIRF：Unifromed-Interval-Root-Finder</li></ol></li><li>（针对三角网格）求解三次方程：<ol type="1"><li>FPRF：floating-point time-of-impact root finder</li><li>TightCCD(TCCD)</li><li>BSC</li></ol></li><li>光线投射<ol type="1"><li>Root Parity(RP)</li><li>Rational implementation of RP （RRP）</li></ol></li><li>分割空间微元</li></ol><h4 id="preliminaries">Preliminaries</h4><p>沿用IPC中的记号。对于碰撞检测而言，最基本的模型是假设其在两个迭代步骤之间是线性的，即</p><p><span class="math display">\[\mathbf x(t) = t \cdot \mathbf x ^{i + 1}  + (1 - t) \cdot \mathbf x^{i}\]</span></p><p>其中：</p><p>-<span class="math inline">\(t\)</span>为归一化后的时间，即<spanclass="math inline">\(t = (t - t_{i}) / (t_{i + 1} - t _i)\)</span>其中右侧的<span class="math inline">\(t\)</span>是模拟运行时间-<span class="math inline">\(\mathbfx\)</span>是坐标，是关于时间的函数。上标表示迭代代数</p><p>为了简单期间，用<span class="math inline">\(\mathcal A = \mathbfx_1\cdots \mathbf x_i\)</span>来表示一个<spanclass="math inline">\(n\)</span>维单纯形，用<spanclass="math inline">\(\mathbf x_{ij}\)</span>来表示<spanclass="math inline">\(\mathbf x_{i} - \mathbf x_{j}\)</span>。</p><p>在这样的记号下，碰撞可以用<spanclass="math inline">\(t\)</span>来描述，即：</p><p>单纯形<span class="math inline">\(\mathcal A = \{\mathbf x_1\cdots\mathbf x_n\}\)</span>和<span class="math inline">\(\mathcal B =\{\mathbf x_1 \cdots \mathbf x_m\}\)</span>碰撞，当且仅当：</p><p><span class="math display">\[\exists t\in[0, 1]\quad s.t. \  \mathcal A(t) \cap \mathcal B(t) \ne\emptyset\]</span></p><p>这个公式仅仅是一个定义，并没有很大的计算价值，因此我们需要对于这样的问题进行适当的简化。主要有几种思路：</p><ol type="1"><li>二分搜索，找可能的碰撞时间<spanclass="math inline">\(t\)</span></li><li>约束为三角网格再：<ol type="1"><li>求解重心坐标<span class="math inline">\((u,v)\)</span>和<spanclass="math inline">\(t\)</span></li><li>简化为三次方程求根</li></ol></li><li>光线投射方法</li><li></li></ol><h4 id="二分法">二分法</h4><h5 id="irf">IRF</h5><blockquote><p>Ref:</p><ol type="1"><li>Interval Analysis For Computer Graphics</li><li>Interval Methods for Multi-Point Collisions between Time-DependentCurved Surfaces</li></ol></blockquote><p>逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p><p>优点：</p><ol type="1"><li>不会有遗漏的碰撞情况，并且每一步都保证包含 <spanclass="math inline">\(0\)</span>，所以能够确保检查到碰撞</li><li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li></ol><p>缺点：</p><ol type="1"><li>基于二分查找 — 太慢</li><li>难以实施编译优化</li></ol><h5 id="uirf">UIRF</h5><p>差不多的思路，但是是用二分法求的是单变量的方程根。</p><blockquote><p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p><p>与此同时，它不能满足控制求解器的运行精度</p></blockquote><h4id="针对三角网格的三次方程求解方法">针对三角网格的三次方程求解方法</h4><blockquote><p>Ref:</p><ol type="1"><li>Collision and self-collision handling in cloth model dedicated todesign garments</li></ol></blockquote><p>针对于三角网格，上文提出：</p><dl><dt>Theorem</dt><dd>碰撞发生，当且仅当至少发生以下一种碰撞：</dd></dl><ol type="1"><li>Vertex-Triangle</li><li>Edge-Edge</li></ol><p>在这篇论文中，还提出了这两类条件的符号语言描述：</p><p><span class="math display">\[VT\iff \exists t\in [0, 1]\quad \begin{cases}\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\\mathbf x_4 \in \left\{ x_1 x_2 x_3 \right\}\end{cases}\]</span></p><p>其中：<span class="math inline">\(1,2,3\)</span>为三角形顶点，<spanclass="math inline">\(4\)</span>为顶点</p><p><span class="math display">\[EE\iff \exists t\in [0, 1] \quad \begin{cases}\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\\left\{\mathbf x_1 \mathbf x_2\right\} \cap \left\{\mathbf x_3 \mathbfx_4\right\} \ne \emptyset\end{cases}\]</span></p><p>对于上述两种做法，我们观察到条件中都有一个关于<spanclass="math inline">\(t\)</span>的三次方程（因为每一个<spanclass="math inline">\(\mathbf x_i\)</span>都是关于<spanclass="math inline">\(t\)</span>仿射），因此我们的解决思路就是：</p><ol type="1"><li>求三次方程在<span class="math inline">\([0, 1]\)</span>内的根</li><li>检查这个根是否满足第二个条件</li></ol><p>其中的<strong>数值精度</strong>问题体现在：</p><ol type="1"><li>三次方程求解：<ol type="1"><li>不能使用求根公式（误差放大几个数量级） -- 只能用牛顿法求</li><li>何时停止迭代</li></ol></li><li>判断是否碰撞时的误差上界？</li></ol><h5 id="fprf">FPRF</h5><p>最老、最经典的一篇论文</p><blockquote><p>Ref:</p><ol type="1"><li>Collision and self-collision handling in cloth model dedicated todesign garments</li></ol></blockquote><p>思想：解三次方程，解出来的解对应函数值是小于一常数，则判断为碰撞。</p><p>主要问题：</p><ol type="1"><li>FN太多，即有很多碰撞点不被检测到。</li><li>当平行时无法处理 EE 的情况。</li></ol><p>优点：</p><ol type="1"><li>速度</li></ol><h5 id="tightccd">TightCCD</h5><blockquote><p>Ref:</p><ol type="1"><li>TightCCD: Efﬁcient and Robust Continuous Collision Detection usingTight Error Bounds</li></ol></blockquote><p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算，观察的是</p><p><span class="math display">\[Y(0),Y&#39;(0),Y&#39;(1),Y&#39;&#39;(0),Y&#39;&#39;(1)\]</span></p><p><img src="2022-04-14-19-56-39.png" class="lazyload" data-srcset="2022-04-14-19-56-39.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>优点：</p><ol type="1"><li>速度快，准确率也高，几乎是最好的算法</li><li>完全没有检测不出的碰撞</li></ol><p>问题：</p><ol type="1"><li>为了 FN == 0，牺牲了 FP</li><li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li></ol><h5 id="bsc">BSC</h5><blockquote><p>Ref:</p><ol type="1"><li>Fast and exact continuous collision detection with bernstein signclassification</li></ol></blockquote><p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p><p>缺点：</p><ol type="1"><li>False Positive + False Negative</li></ol><blockquote><p>实际上这两个思路和我一开始想的是一致的：</p><p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p><p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p></blockquote><p>原理上：给定一个三次函数 <span class="math inline">\(Y(t)\)</span>用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p><p><img src="image-20220412105920274.png" class="lazyload" data-srcset="image-20220412105920274.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>从而通过观察：</p><p><span class="math display">\[Y(0), Y(1/3), Y(2/3), Y(1)\]</span></p><p>（其中 <span class="math inline">\(Y\)</span>即为三次方程对应的函数）的值来减少计算开销并提升精度。</p><h4 id="光线投射-rp-rrp">光线投射 RP / RRP</h4><p>转化为光线投射问题：设 <span class="math inline">\(\partial\Omega\)</span>是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p><p>问题：</p><ol type="1"><li>实际上只能做DCD – 小TS</li><li>容易出现漏报的问题：在 <span class="math inline">\([t,t+\Deltat]\)</span> 内有 2 解</li></ol><p>原理：</p><blockquote><p>根据 Brouwer topological degree theory：</p><p>假设 <span class="math inline">\(\Omega\)</span> 是一个 <spanclass="math inline">\(n\)</span> 多面体，设 <spanclass="math inline">\(F:\Omega \rightarrow \mathbb R^{n}\)</span>满足<spanclass="math inline">\(C^2\)</span>，且有有限多个根，且没有在边界<spanclass="math inline">\(\Gamma=\partial \Omega\)</span>上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <spanclass="math inline">\(0\)</span> 出发，记交点数为 <spanclass="math inline">\(q\)</span> ，<spanclass="math inline">\(F\)</span> 在交点处光滑且不相切于光线，那么 <spanclass="math inline">\(p,q\)</span> 有相同的奇偶性。</p></blockquote><p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p><h3 id="碰撞处理">碰撞处理</h3><blockquote><p>在这里假设在上一步已经获取了碰撞的时刻（TOI）</p><p>Ref:</p><ol type="1"><li>Robust Treatment of Collisions, Contact and Friction for ClothAnimation</li></ol></blockquote><p>根据王老师在GAMES103和2021图形学大会讲的内容（Real-Time ClothSimulation on GPUs），其程序流程如下：</p><figure><img src="image-20220414221444102.png" class="lazyload" data-srcset="image-20220414221444102.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="A Practical System" /><figcaption aria-hidden="true">A Practical System</figcaption></figure><p>前两种方法都是基于如下公式： <span class="math display">\[\mathbf x^{k+1} = \arg\min \|\mathbf x - \mathbf x ^ *\|\]</span> 而Untangle Cloth不基于上式直接进行解除相交问题。</p><h4 id="interior-point-method-内点法">Interior Point Method 内点法</h4><p>思想：添加<spanclass="math inline">\(\log\)</span>边界函数，保持在可行域内，逐步迭代：</p><p>优点</p><ul><li>Always succeed</li></ul><p>缺点：</p><ul><li>可能达到局部最优解</li><li>需要计算所有的顶点来迭代</li><li>小步长 — 速度慢</li></ul><figure><img src="image-20220414221940838.png" class="lazyload" data-srcset="image-20220414221940838.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Interior Point Method" /><figcaption aria-hidden="true">Interior Point Method</figcaption></figure><h4 id="impact-zone-optimization">Impact Zone Optimization</h4><p>思想：直接从 <span class="math inline">\(\mathbf x^*\)</span>开始迭代，逐步逼进可行域，如下图</p><figure><img src="image-20220414222918767.png" class="lazyload" data-srcset="image-20220414222918767.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Impact Zone Optimization" /><figcaption aria-hidden="true">Impact Zone Optimization</figcaption></figure><p>优点：</p><ul><li>很容易得到一个可能的解。</li><li>只需要对不满足约束的点处理</li><li>可以使用大步长</li></ul><p>缺点：</p><ul><li>可能不收敛到可行域内</li></ul><h4 id="相交解除-untangle-cloth">相交解除 — Untangle Cloth</h4><blockquote><p>Ref</p><ol type="1"><li>Untangle Cloth</li><li>Resolving Surface Collisions through Intersection ContourMinimization</li></ol></blockquote><p>当拿到碰撞点后，使用“注水”法，可以直接求出交叉的区域。对于这两个交叉的边界，假设为“紧密贴合”。</p><p>优点：</p><ol type="1"><li>保证在绝大部分情况下能够处理</li></ol><p>缺点：</p><ol type="1"><li>原文中之处理了相交的闭区域，对于边界交叉处理不方便。</li><li>物理上不真实</li><li>难以在GPU上实现</li></ol><h4 id="rigid-impact-zone">Rigid Impact Zone</h4><p>如果上述方法都失败了，那么就考虑使用该方法，其对于不满足要求的点，直接回退到上一模拟步的状态（无相交的状态）。</p></div><h2 id="非接触方法">非接触方法</h2><div class="story post-story"><p>这一类方法都将原有的碰撞条件增强为保持一些点/面之间的距离大于一定值，从而避免CCD 过程。正如zhihu上所说：</p><blockquote><p>之前大家试过很多方法，比如定义物体表面距离很近的“点-三角”对和“边-边”对（接触元对）组成的四面体的有符号体积要恒大于0；或者在每个时间歩开始时，找到距离近的每个接触元对上距离最近的点对，限定这些点对的距离大于0等。这些定义的问题在于，如果物体在某个时间歩移动比较多，他们可能无法正确描述无穿透这件事。另外这类方法大多基于sequentialquadraticprogramming优化方法，没法像无约束条件时的牛顿迭代那样方便地通过linesearch保证稳定收敛。</p><p>By Minchen Li.</p></blockquote><h3 id="ipc">IPC</h3><blockquote><p>Ref:</p><ol type="1"><li>Incremental potential contact: intersection-and inversion-free,large-deformation dynamics</li><li>Medial IPC: accelerated incremental potential contact with medialelastics</li><li>Codimensional incremental potential contact</li><li>BFEMP: Interpenetration-Free MPM-FEM Coupling with BarrierContact</li></ol></blockquote><p>主要思路：迭代的每一步，都把所有 primitive pair 分成两类：</p><ol type="1"><li><span class="math inline">\(0&lt;\min \mathrm{distance} \le \hatd\)</span>：设置 <span class="math inline">\(\log\)</span>-barrier函数，防止直接碰撞</li><li><span class="math inline">\(\min \mathrm{distance} &gt; \hatd\)</span>：设置迭代最大步长，避免距离在迭代路径上碰撞（穿透）</li></ol><p>依据这两个基本假设来避免 CCD。</p><p>首先，其主要处理的是如何<strong>避免连续碰撞检测</strong>，在论文中，其提出：</p><blockquote><p>我们称一个状态是可接受的，当且仅当存在一条可行路径，到达该状态，或以该状态为极限。</p><p>一个迭代路径是可接受的，当且仅当其可以作为上述的极限过程中的状态序列</p></blockquote><p><span class="math display">\[\mathbf x \in \Omega \iff \exists \mathbf x_i \in \Omega.\\lim_{i\rightarrow \infty} = \mathbf x\]</span></p><p>那么，基于以上假设，我们完全可以不去度量是否<strong>产生了</strong>碰撞，而把约束换成</p><p><span class="math display">\[\|\mathbf x - \mathbf x&#39;\| &gt; 0,\quad \forall \mathbf x&#39; \in\partial \Omega\]</span></p><p>这样，我们可以将问题转化为：</p><p><span class="math display">\[\|\mathbf x - \mathbf y\| \ge \epsilon, \forall \mathbf x ,\mathbfy\text{ from different primitives}\]</span></p><p>那么，可以将动力学方程和约束放在一起求解即：</p><p><span class="math display">\[\begin{aligned}\min_{\mathbf x}\quad &amp;F(\mathbf x) + G(\min\mathrm{distance}(\mathbf x))\\\text{s.t.}\quad &amp;\mathbf x \text{ is feasible}\end{aligned}\]</span></p><p>其中：</p><ul><li><span class="math inline">\(F\)</span> 为动力学方程中的能量</li><li><span class="math inline">\(G\)</span> 为障碍函数</li></ul><p>这是一个几乎没有约束的优化问题：因为原来的碰撞处理的全套流程转化为在迭代求解过程中，保证迭代路径是可接受的！</p><p>具体而言，Log函数为了避免在不充分接近时也出现“抵抗力”，其在保证<spanclass="math inline">\(C^2\)</span>的情况下，构造了如下的“log-barrier”：</p><p><img src="2022-04-15-08-56-06.png" class="lazyload" data-srcset="2022-04-15-08-56-06.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><blockquote><p>该方法可以看作是一个“内点法”</p></blockquote><h4 id="如何计算-距离">如何计算 “距离”</h4><p>IPC方法中并不限于三角网格等具体的空间结构，因此距离的计算并不需要依赖于物体表示的维数。基本思路是通过重心坐标构造两个primitive 上的点<span class="math inline">\(\mathbf x\)</span>和<spanclass="math inline">\(\mathbf y\)</span>，从而计算</p><p><span class="math display">\[d(\mathbf x, \mathbf y) = \min \|\mathbf x - \mathbf y\|\]</span></p><p>来得到距离。</p><h4 id="constraint-set">Constraint Set</h4><p>通过 Spatial Hashing 算法来加速 Constraint Set 计算，定义为：</p><p><span class="math display">\[\{\langle i , j \rangle | d(\mathbf x_i, \mathbf x_j) \le \hat d \}\]</span></p><h4 id="迭代过程中如何保证约束">迭代过程中如何保证约束</h4><p>算法使用 Intersection-AwareLine-Search（回溯线搜索）来进行迭代。并且在每次执行搜索之前，重新计算Constraint Set。而观察到对于：</p><ol type="1"><li>Constraint Set中的元素对：一定出现在优化的能量函数中，通过barrier函数避免碰撞</li><li>不在其中的元素对：初始距离<span class="math inline">\(&gt;\hatd\)</span></li></ol><p>从而可以通过 <span class="math inline">\(\hat d\)</span>指导迭代的最大步长。</p><p>从而将原本难以解决的CCD问题避免。</p><h4 id="总结">总结</h4><p>优点：</p><ol type="1"><li>不需要繁琐的 CCD -- 速度、精度都有保证</li><li>嵌入到 Dynamic Solver 迭代过程中</li><li>容易在GPU上实现</li></ol><p>缺点：</p><ol type="1"><li>非接触方法，摩擦难以解决</li></ol><h3 id="siggraph-2021----repulsion-method">SIGGRAPH 2021 -- RepulsionMethod</h3><blockquote><p>Ref:</p><ol type="1"><li>A Safe and Fast Repulsion Method for GPU-based Cloth SelfCollisions</li></ol></blockquote><p>思路：找到使不产生VT/EE碰撞的充分条件，且该充分条件仅需要考虑顶点之间的距离，而和三角网格无关。</p><p><span class="math display">\[\min d(\mathbf v_i, \mathbf v_j) \ge \hat d = L / 2\]</span></p><p>其中<span class="math inline">\(L\)</span>为三角网格的最大边长。</p><p>求解过程分为两部分：</p><ol type="1"><li>Soft-Phase</li><li>Hard-Phase</li></ol><p>并且为了避免约束过强，使用了自适应的重采样方法。</p><h4 id="soft-phase">Soft-Phase</h4><p><span class="math display">\[\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm{init}} \| − \rho \min \left\{c_{ij} (\mathbf x) − \varepsilon_{slack} ,0  \right\}\right\}\]</span></p><h4 id="hard-phase">Hard-Phase</h4><p><span class="math display">\[\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm{init}} \| − \mu \sum {\log (f(c_{ij}(x), \varepsilon_{slack}))}\right\}\]</span></p><p>其中的 <span class="math inline">\(f\)</span> 是满足 <spanclass="math inline">\(C^1\)</span> 的分段函数：</p><p><span class="math display">\[f = \begin{cases}   x &amp; x\le 0\\   ax^3 + bx^2 + cx + d &amp; 0 &lt;x \le \varepsilon\\   \varepsilon&amp; \text{otherwise}\end{cases}\]</span></p><h4 id="adaptive-resampling">Adaptive Resampling</h4><p>由于要求所有距离大于 <span class="math inline">\(L /2\)</span>，为了使得这个条件不是过于充分的，要求最小边长和最大边长<spanclass="math inline">\(l\)</span>与<spanclass="math inline">\(L\)</span>的比例大于一定值。</p><p><img src="2022-04-15-11-19-43.png" class="lazyload" data-srcset="2022-04-15-11-19-43.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测 学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 5 - 2021 A large scale benchmark and an Inclusion-based Algorithm</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:32.603Z</updated>
    
    <content type="html"><![CDATA[<p>Collision Detection 整理5 – CCD 算法对比</p><span id="more"></span><p>准确说，这篇blog是一篇论文的整理emmm，但由于老板的任务就是做 collsion的汇总，这篇论文的涉及面也算是相对 Broad 的了。</p><p>论文主要用了：</p><ol type="1"><li>IRF：interval-root-finder</li><li>UIRF：Unifromed-Interval-Root-Finder</li><li>FPRF：floating-point time-of-impact root finder</li><li>TightCCD(TCCD)</li><li>Root Parity(RP)</li><li>Rational implementation of RP</li><li>MSRF：minimum seperation floating-point time-of-impact rootfinder</li></ol><h2 id="预备知识">预备知识</h2><div class="story post-story"><p>首先论文对于 CCD的数学背景进行了简要的介绍：考虑三角网格，每一个时间步长内都以线性轨迹运动。那么CCD可以简化为VT和EE检查。</p><h3 id="multivariate-ccd-formulation">Multivariate CCD Formulation</h3><p>最简单的方法是直接对于CCD条件参数化，转化为关于 <spanclass="math inline">\(u,v,t\)</span> 的方程求解即可。</p><h3 id="univariate-ccd-单变量ccd">Univariate CCD 单变量CCD</h3><p>实际上上面一种求解方法一步到位解出了 <spanclass="math inline">\(u,v,t\)</span>但没有注意到在接触时，四点共面的事实，所以，在[Provot 97]中，改为先求解三次方程，然后检查是否满足条件的问题</p></div><h2 id="方法介绍">方法介绍</h2><div class="story post-story"><h3 id="irf">IRF</h3><p>类似于计算 Minkowski差，逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p><p>优点：</p><ol type="1"><li>保守估计，每一步都保证包含 <spanclass="math inline">\(0\)</span>，所以能够确保检查到碰撞</li><li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li></ol><p>缺点：</p><ol type="1"><li>基于二分查找 — 慢</li><li>难以实施编译优化</li></ol><h3 id="uirf">UIRF</h3><p>差不多的思路，但是是用二分法求的是单变量的方程根。</p><blockquote><p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p><p>与此同时，它不能满足控制求解器的运行精度</p></blockquote><h3 id="fprf">FPRF</h3><blockquote><p>Robust treatment of simultaneous collisions.</p></blockquote><p>主要问题：</p><ol type="1"><li>FN太多，即有很多碰撞点不被检测到。</li><li>当平行时无法处理 EE 的情况。</li></ol><p>优点：</p><ol type="1"><li>速度</li></ol><h3 id="tightccd">TightCCD</h3><p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算。</p><p>优点：</p><ol type="1"><li>速度快</li><li>完全没有检测不出的点</li></ol><p>问题：</p><ol type="1"><li>为了 FN == 0，牺牲了 FP</li><li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li></ol><h3 id="rp-rrp">RP / RRP</h3><p>转化为光线投射问题：设 <span class="math inline">\(\partial\Omega\)</span>是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p><p>问题：</p><ol type="1"><li>实际上只能做DCD – 小TS</li><li>容易出现漏报的问题：在 <span class="math inline">\([t,t+\Deltat]\)</span> 内有 2 解</li></ol><p>原理：</p><blockquote><p>根据 Brouwer topological degree theory：</p><p>假设 <span class="math inline">\(\Omega\)</span> 是一个 <spanclass="math inline">\(n\)</span> 多面体，设 <spanclass="math inline">\(F:\Omega \rarr \mathbb R^{n}\)</span>满足 <spanclass="math inline">\(C^2\)</span>，且有有限多个根，且没有在边界<spanclass="math inline">\(\Gamma=\partial \Omega\)</span>上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <spanclass="math inline">\(0\)</span> 出发，记交点数为 <spanclass="math inline">\(q\)</span> ，<spanclass="math inline">\(F\)</span> 在交点处光滑且不相切于光线，那么 <spanclass="math inline">\(p,q\)</span> 有相同的奇偶性。</p></blockquote><p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p><h3 id="bsc">BSC</h3><blockquote><p>Fast and exact continuous collision detection with bernstein signclassification</p></blockquote><p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p><p>缺点：</p><ol type="1"><li>False Positive + False Negative</li></ol><blockquote><p>实际上这个思路和我一开始想的是几乎一致的：</p><p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p><p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p></blockquote><p>原理上：给定一个三次函数 <span class="math inline">\(Y(t)\)</span>用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p><p><img src="image-20220412105920274.png" class="lazyload" data-srcset="image-20220412105920274.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div><h2 id="其他思路">其他思路</h2><div class="story post-story"><h3 id="bridson-2009">Bridson 2009</h3><p>添加一个时间维度，通过在四维空间中的相交检测来实现碰撞检测。</p><p>问题：</p><ol type="1"><li>不直观、不常用</li><li>导致了 FP 的出现 — 平行的两个三角形认定为碰撞。</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Collision Detection 整理5 – CCD 算法对比&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>201-02-拉格朗日视角1</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/GAMES/g201-02/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/GAMES/g201-02/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-13T05:59:19.797Z</updated>
    
    <content type="html"><![CDATA[<p>games201 拉格朗日视角</p><span id="more"></span><h2 id="拉格朗日视角简介">拉格朗日视角简介</h2><div class="story post-story"><p>两种视角：</p><ol type="1"><li>拉格朗日视角 – 粒子，携带位置、速度等<ol type="1"><li>MPM、弹簧质点模型……</li></ol></li><li>欧拉视角 – 通过固定的“传感器”来表示<ol type="1"><li>烟雾模拟</li></ol></li></ol><h2 id="弹簧质点模型-mass-spring-system">弹簧质点模型 Mass-SpringSystem</h2><ul><li>Extremely example</li><li>But very useful. – cloth/hair</li></ul><h3 id="基本原理">基本原理</h3><p>利用 <strong>胡克定律</strong> 和 <strong>牛顿第二定律</strong>来计算 加速度-速度-位置</p><ul><li><span class="math inline">\(k\)</span> — stiffness — 刚度</li></ul><h3 id="时间积分">时间积分</h3><h4 id="forward-euler-前向欧啦">Forward Euler 前向欧啦</h4><p><span class="math display">\[v_{t+1} = v_t + \frac{f_t}{m}\Delta t\]</span></p><h4 id="半隐式欧拉法">半隐式欧拉法</h4><p>用 <span class="math inline">\(t+1\)</span> 时刻的 <spanclass="math inline">\(v\)</span> 计算 <spanclass="math inline">\(x\)</span> 的更新。</p><h4 id="implementation">Implementation</h4><ul><li>使用 substep — 保证小步长</li></ul><h3 id="积分器对比">积分器对比</h3><blockquote><p><strong>数值分析</strong></p></blockquote><h4 id="显式积分器">显式积分器</h4><ol type="1"><li>未来仅仅基于过去</li><li>简单</li><li>容易出现数值爆炸问题 — 前向欧拉</li><li>对于 <span class="math inline">\(stiff \gg 1\)</span>效果很差。</li></ol><h4 id="隐式积分器">隐式积分器</h4><ol type="1"><li>未来需要基于自己和过去</li><li>复杂！难以实现、难以优化、GPU……</li><li>Timestep 更大，但是计算更加昂贵</li><li>Numerical damping</li></ol><h3 id="弹簧质点的隐式积分器">弹簧质点的隐式积分器</h3><p>假设： <span class="math display">\[\begin{cases}\mathbf x_{t+1} = \mathbf x_t + \Delta t \mathbf v_{t+1}\\\mathbf v_{t+1} = \mathbf v_t + \Delta t \mathbf M ^{-1}\mathbf f_{t+1}\end{cases}\]</span> 在上式中消除 <span class="math inline">\(\mathbfx_{t+1}\)</span>，使用泰勒公式： <span class="math display">\[\left[I - \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbf f}{\partial\mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbf v_t + \Delta t\mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span> 在这一节课中，仅仅使用 Jacobbi 迭代解上述方程。</p><h3 id="在显式和隐式之间转换">在显式和隐式之间转换</h3><p><span class="math display">\[\left[I - \beta \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbff}{\partial \mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbfv_t + \Delta t \mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span></p><p>其中 <span class="math inline">\(\beta\)</span>控制了在显式、隐式之间的“比例”</p><ul><li><span class="math inline">\(\beta = 1\)</span> — Explicit</li><li><span class="math inline">\(\beta = .5\)</span> — Semi-Implicit</li><li><span class="math inline">\(\beta = 0\)</span> — Implicit</li></ul><h3 id="大规模情况">大规模情况</h3><ol type="1"><li>稀疏矩阵</li><li>共轭梯度法</li><li>Preconditioning</li><li>PBD</li></ol></div><h2 id="拉格朗日法流体模拟-sph">拉格朗日法流体模拟 — SPH</h2><div class="story post-story"><p>用一些粒子（并附带物理量）以及一个核函数去模拟一个物理场。</p><p>优点：</p><ol type="1"><li>不需要 Mesh、适合自由表面物体</li><li>容易理解</li></ol><h3 id="wcsph">WCSPH</h3><blockquote><p>可压缩物体模拟</p></blockquote><p>Momentum Equation: <span class="math display">\[\frac{D\mathbf v}{D t} = - 1/\rho \nabla p + \mathbf g,\quad p =B\left(\left( \frac{\rho}{\rho_0}\right)^\gamma - 1\right)\]</span></p><ol type="1"><li>表面张力、粘滞力</li></ol><h3 id="sph-simulation-cycle">SPH simulation Cycle</h3><p>通过半隐式欧拉法计算</p><h3 id="sph-变种">SPH 变种</h3><h3 id="cfl条件">CFL条件</h3><p>对于显式积分，<span class="math inline">\(dt\)</span> 具有上界：<span class="math display">\[C = \frac{u\Delta t}{\Delta x} \le C_\max \sim ~\]</span></p><ol type="1"><li><span class="math inline">\(C\)</span>: CFL number</li></ol><p>Application</p><ol type="1"><li>SPH: <span class="math inline">\(C_\max\sim 0.4\)</span></li><li>MPM:<span class="math inline">\(C_\max -0.3\sim1\)</span></li></ol><h3 id="加速-sph">加速 SPH</h3><p>通过 Neighbour search with hashing（空间数据结构）</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;games201 拉格朗日视角&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>libigl 简述</title>
    <link href="http://adversarr.github.io/2022/04/10/CG/Libigl/"/>
    <id>http://adversarr.github.io/2022/04/10/CG/Libigl/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:19.081Z</updated>
    
    <content type="html"><![CDATA[<p>TODO: Libigl 教程（翻译和解释）</p><p>现挖个坑，后面补上。 <span id="more"></span></p><h1 id="libigl-tutorial">libigl Tutorial</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;TODO: Libigl 教程（翻译和解释）&lt;/p&gt;
&lt;p&gt;现挖个坑，后面补上。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>102-08-离散微分几何</title>
    <link href="http://adversarr.github.io/2022/04/09/CG/GAMES/g102-08/"/>
    <id>http://adversarr.github.io/2022/04/09/CG/GAMES/g102-08/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-04-13T05:59:16.345Z</updated>
    
    <content type="html"><![CDATA[<p>Games 102 - 离散微分几何</p><span id="more"></span><h2 id="三角网格存储">三角网格存储</h2><div class="story post-story"><p>常用的是<strong>半边数据结构</strong>（Half-Edge）数据结构</p><ul><li>将网络连接关系存储在边上，表达为两条半边</li><li>目的：提高点线面和查找效率</li></ul></div><h2 id="曲线曲面微分几何">曲线、曲面微分几何</h2><div class="story post-story"><h3 id="曲线的微分几何学">曲线的微分几何学</h3><ul><li><p>Frenet标架</p></li><li><p>Curvature <span class="math inline">\(\kappa\)</span> 和密切圆</p></li><li><p>与参数选择无关 — 本征量</p></li></ul><h3 id="曲面的微分几何学">曲面的微分几何学</h3><ul><li>关于 <span class="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 的偏导 — 切平面</li><li>切平面的法向 — <span class="math inline">\(r_u\timesr_v\)</span></li><li>法平面和曲面求交线，可以定义出一个空间曲线，可以定义其曲率 –方向曲率（法曲率）— 描述曲面沿着方向的弯曲程度</li></ul><h3 id="曲面的曲率">曲面的曲率</h3><p>观察法曲率：</p><ol type="1"><li>有两个正交的方向，使得其能够取最大 <spanclass="math inline">\(\kappa_1\)</span> 和最小<spanclass="math inline">\(\kappa_2\)</span></li></ol><p>有 Euler's Equation 成立： <span class="math display">\[\kappa = \kappa_1 \cos^2\theta +  \kappa_2 \sin^2\theta\]</span> 高斯曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \kappa_1\kappa_2\)</span></li><li><strong>等距变换的不变量</strong></li><li>处处为 0 的曲面 — 可展曲面</li><li><strong>可展曲面</strong>可以分类为：<ul><li>柱面</li><li>锥面</li><li>切线面</li></ul></li></ol><p>平均曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \frac {\kappa_1 +\kappa_2}{2}\)</span></li><li>处处平均曲率为 0 的曲面 — 极小曲面 — 所有点都是鞍点</li></ol></div><h2 id="离散微分几何">离散微分几何</h2><div class="story post-story"><p>考虑到三角网格只有 <span class="math inline">\(C^0\)</span>，使用采样的点来估计原有曲面属性。</p><h3 id="方法">方法</h3><h4 id="连续逼近">连续逼近</h4><p>考虑使用一个简单的曲面来拟合曲面的局部。从而就能计算出</p><h4 id="离散估计">离散估计</h4><p>用面积/角度等特征来进行计算</p><h3 id="例子">例子</h3><h4 id="平均曲率计算">平均曲率计算</h4><p>由 Laplace-Beltrami 定理： <span class="math display">\[\mathbf K (\mathbf x_i) = \frac{1}{2\mathcal A_M} \sum_{j\in N_1(i)}(\cot \alpha_{ij}+ \cot \beta_{ij})(\mathbf x_i - \mathbf x_j)\]</span></p><h4 id="高斯曲率计算">高斯曲率计算</h4><p>由 Gauss-Bonnet 定理： <span class="math display">\[\kappa(\mathbf x_i) = (2\pi - \sum_{j = 1}^{\#f} \theta_j) / \mathcalA_M\]</span></p><blockquote><p>Discrete differential-geometry operators for trangulated 2-manifolds.– 2003</p></blockquote><h3 id="极小曲面">极小曲面</h3></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Games 102 - 离散微分几何&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的微分几何整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/</id>
    <published>2022-03-28T03:44:29.465Z</published>
    <updated>2022-04-19T09:30:53.580Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p><h2 id="测地曲率和测地线">测地曲率和测地线</h2><div class="story post-story"><p>根据 Gauss 绝妙定理，<span class="math inline">\(K\)</span>只决定于曲面的第一基本形式，在保长对应下不变，是曲面的内蕴性质。在这里继续研究曲面内蕴几何的主要研究对象。</p><h3 id="测地曲率和测地线-1">测地曲率和测地线</h3><p>我们考虑正则曲面<span class="math inline">\(S:\mathbf r = \mathbfr(u^1, u^2)\)</span>，设有曲线<span class="math inline">\(u^\alpha =u^\alpha (s)\)</span> 是一条弧长参数曲线。其作为空间中的曲线参数方程为：<span class="math display">\[\mathbf r = \mathbf r(s) = \mathbf r (u^1, u^2)\]</span> 建立新的正交标架： <span class="math display">\[\begin{aligned}\mathbf e_1  &amp;= \frac {d\mathbf r(s)}{ds} = \alpha(s)\\\mathbf e_2 &amp;= \mathbf n(s)\times \alpha(s) \\\mathbf  e_3 &amp;= \mathbf n(s)\end{aligned}\]</span> 对于该曲线来考察原曲面的性质： <span class="math display">\[\begin{cases}\frac{d\mathbf r}{ds} &amp;= \mathbf e_1&amp;\\\frac{d\mathbf e_1}{ds} &amp;= &amp; +\kappa _g\mathbf e_2 &amp; +\kappa_n\mathbf e_3\\\frac{d\mathbf e_2}{ds} &amp;= -\kappa_g\mathbf e_1 &amp;&amp;+\tau_g\mathbf e_3 \\\frac{d\mathbf e_3}{ds} &amp;= -\kappa_n \mathbf e_1 &amp; +\tau_g\mathbf e_2\\\end{cases}\]</span> 显然，式中的：</p><ul><li><span class="math inline">\(\kappa_n\)</span> 就是曲面<spanclass="math inline">\(S\)</span>沿着曲线<spanclass="math inline">\(C\)</span>的切方向的法曲率；</li></ul><p>而也可以求解出其他的参数： <span class="math display">\[\kappa_g = \left( \mathbf n, \mathbf r&#39;, \mathbf r&#39;&#39; \right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地曲率</strong>； <span class="math display">\[\tau_g = \left( \mathbf n, \mathbf n&#39;,\mathbf r&#39;\right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地挠率</strong>。</p><p>下面的定理描述了测地曲率和测地挠率的几何意义：</p><dl><dt><strong>Theo</strong></dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条正则曲线，其在 <spanclass="math inline">\(p\)</span>处的测地曲率等于将其投影到切平面上的曲线的相对曲率，其平面的正向由曲面<span class="math inline">\(S\)</span> 在点 <spanclass="math inline">\(p\)</span> 的法向量给出。</dd><dt><strong>Theo</strong></dt><dd>曲面<span class="math inline">\(S\)</span>上任一条曲线<spanclass="math inline">\(C\)</span>的测地曲率是保长对应的不变量，即：<strong>测地曲率是内蕴量</strong>。</dd></dl><p>在取正交参数系的情况下，计算测地曲率有如下的<strong>Liouville公式</strong>：</p><dl><dt><strong>Theo</strong></dt><dd>设<span class="math inline">\((u,v)\)</span>是<spanclass="math inline">\(S\)</span>上的正交参数系，从而<spanclass="math inline">\(S\)</span>的第一基本形式为 <spanclass="math display">\[I = E(du)^2 + G(dv)^2\]</span> 假设<span class="math inline">\(C\)</span>与<spanclass="math inline">\(u\)</span>曲线的夹角为<spanclass="math inline">\(\theta\)</span>，那么其测地曲率是 <spanclass="math display">\[\kappa_g = \frac{d\theta}{ds} - \frac{1}{2\sqrt G} \frac{\partial \logE}{\partial v} \cos \theta + \frac{1}{2\sqrt E} \frac{\partial \logG}{\partial u}\sin \theta\]</span></dd></dl><p>最后我们讨论测地挠率，从自然标架的运动公式可以得出： <spanclass="math display">\[\tau _ g = \frac{1} {\sqrt g}\begin{vmatrix}&amp;\left(\frac{du^2}{ds} \right)^2 &amp; - \frac{du^1du^2}{dsds} &amp;\left(\frac{du^1}{ds} \right)^2 \\&amp;g_{11} &amp;g_{12} &amp; g_{22}\\&amp;b_{11} &amp;b_{22} &amp; b_{22}\end{vmatrix}\]</span> 故测地挠率和测地曲率一样，是<spanclass="math inline">\(S\)</span>上切方向的函数，反映的是曲面<spanclass="math inline">\(S\)</span>本身的性质，但其不是内蕴量。</p><p>对比主方向的方程，主方向恰好是测地挠率为 0的切方向。同时也有如下定理成立：</p><dl><dt>Theo</dt><dd>在曲面上非直线的渐进曲线<span class="math inline">\(C\)</span>的挠率是<span class="math inline">\(S\)</span>沿着曲面<spanclass="math inline">\(C\)</span>的切方向的测地挠率。</dd></dl><h3 id="测地线">测地线</h3><p>观察到测地曲率是内蕴量，从而要观察曲面上测地曲率为 0的曲线（测地线）</p><dl><dt>Theo</dt><dd>曲面上曲线<spanclass="math inline">\(C\)</span>是测地线，当且仅当，它或是一条直线，或者其主法向量处处是曲面的法向量</dd></dl><blockquote><p>例如：</p><ol type="1"><li>旋转面上的经线是测地线</li><li>若曲面上运动的质点 <span class="math inline">\(p\)</span>只受到将它约束在曲面上的力的作用，而不受到任何其他外力作用，则<spanclass="math inline">\(p\)</span>的轨迹是测地线</li></ol></blockquote><dl><dt>Theo</dt><dd>对于曲面上任意一点<span class="math inline">\(p\)</span>和曲面在<spanclass="math inline">\(p\)</span>的任意单位切向量<spanclass="math inline">\(v\)</span>，在曲面上存在唯一的一条弧长参数测地线通过<spanclass="math inline">\(p\)</span>且以<spanclass="math inline">\(v\)</span>为切向量</dd></dl><blockquote><p>平面 – 直线</p><p>曲面 – 测地线</p></blockquote><dl><dt>Theo</dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条曲线，则<spanclass="math inline">\(C\)</span>的弧长在任意一个有固定端点的变分<spanclass="math inline">\(C_t\)</span>中达到临界值的充分必要条件是<spanclass="math inline">\(C\)</span>是<spanclass="math inline">\(S\)</span>的测地线。</dd></dl><p>从而我们有：若曲线<span class="math inline">\(C\)</span>是连接<spanclass="math inline">\(p,q\)</span>的最短线，则<spanclass="math inline">\(C\)</span>是测地线。</p><h3 id="测地坐标系和法坐标系">测地坐标系和法坐标系</h3><h4 id="测地线族">测地线族</h4><p>在研究了测地线的性质后，我们研究测地线族的性质。</p><dl><dt>Theo</dt><dd>设<span class="math inline">\(\Sigma\)</span>是曲面<spanclass="math inline">\(S\)</span>上覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族，<spanclass="math inline">\(\Sigma_1\)</span>是由在区域<spanclass="math inline">\(D\)</span>内与<spanclass="math inline">\(\Sigma\)</span>中的曲线正交的轨线构成的曲线组，则其中任意两条曲线在<spanclass="math inline">\(\Sigma\)</span>中各条测地线上截出的曲线段长度相等。</dd></dl><blockquote><p>也就是说，测地线族的任意两条正交轨线之间的距离是处处相等的。</p><p>即：测地线族的任意两条正交轨线是<strong>测地平行</strong>的</p></blockquote><dl><dt>Theo</dt><dd>设<span class="math inline">\(C\)</span>是曲面<spanclass="math inline">\(S\)</span>上连接了<spanclass="math inline">\(p,q\)</span>两点的一条测地线，若曲线<spanclass="math inline">\(C\)</span>能够潜入到覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族<spanclass="math inline">\(\Sigma\)</span>中，且<spanclass="math inline">\(p,q\in D\)</span>，则其是区域内连接两点的最短线</dd></dl><h4 id="测地平行坐标系">测地平行坐标系</h4><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点<spanclass="math inline">\(p\)</span>的一个充分小的邻域内必定存在参数系<spanclass="math inline">\((u,v)\)</span>使得<spanclass="math inline">\(p\rightarrow (0,0)\)</span>，而第一基本形式可以写作 <span class="math display">\[I = (du)^2 + G(u,v) (dv)^2\]</span> 函数 <span class="math inline">\(G\)</span> 满足：$G(0, v)=1<span class="math inline">\(，\)</span>(0, v) =0<spanclass="math inline">\(，参数系\)</span>(u,v)$是<strong>测地平行坐标系</strong></dd></dl><h4 id="测地极坐标系">测地极坐标系</h4><p>定义指数映射： <span class="math display">\[\exp_p : T_pS \rightarrow S\quad \mathbf v\rightarrowtail\gamma(|\mathbf v|, \mathbf v_0)\]</span> <span class="math inline">\(\gamma\)</span>对于点<spanclass="math inline">\(p\)</span>处的单位切向量<spanclass="math inline">\(\mathbfv_0\)</span>，映射为弧长参数测地线上的参数为<spanclass="math inline">\(s\)</span>的位置。</p><p>显然指数映射 <span class="math inline">\(\exp_p\)</span>是连续可微的。于是有 <strong>法坐标系</strong>： <spanclass="math display">\[u^\alpha = u ^ \alpha(\exp_p(\mathbf v)) = u ^ \alpha(v^1, v^2)\]</span> 从而有<strong>测地圆</strong>（以<spanclass="math inline">\(p\)</span>为中心，<spanclass="math inline">\(s_0\)</span>为半径）</p><dl><dt>Theo 高斯引理</dt><dd>从<span class="math inline">\(p\)</span>出发的测地线与以点<spanclass="math inline">\(p\)</span>为中心的测地圆是彼此正交的。（即曲线族<spanclass="math inline">\(\Sigma_1\)</span>中的每一条曲线都是测地线族<spanclass="math inline">\(\Sigma\)</span>的正交轨线。</dd></dl><p>由此可以推导出测地极坐标系 <spanclass="math inline">\(（s,\theta)\)</span></p><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点的<spanclass="math inline">\(p\)</span>邻域内，出去从点<spanclass="math inline">\(p\)</span>出发的一条测地线外，也存在测地极坐标系，使得曲面第一形式为<span class="math display">\[I = (ds)^2 + G(d\theta)^2\quad \begin{cases}\lim _{s\rightarrow 0} \sqrt G = 0\\\lim_{s\rightarrow 0} \frac{\partial }{\partial S} \sqrt{G(s,\theta)} =1\end{cases}\]</span> 对应了平面上的极坐标系</dd></dl><h3 id="常曲率曲面">常曲率曲面</h3><p>高斯曲率为常数的曲面为<strong>常曲率曲面</strong>。</p><p>由于高斯曲率为内蕴量，我们不难考虑如下的定理：</p><dl><dt>Theo</dt><dd>有相同高斯曲率的任意两块常曲率曲面在局部上有保长对应。</dd></dl><blockquote><p>从现在的观点来看：</p><ol type="1"><li>常曲率曲面的第一基本形式是由其高斯曲率完全决定的</li><li>非欧几何学：将平面几何学推广到常曲率曲面</li></ol></blockquote><h3 id="平行移动">平行移动</h3><blockquote><p>考虑切向量场的协变微分和平行移动</p></blockquote><h3 id="gauss-bonnet公式">Gauss-Bonnet公式</h3><p>假定曲线是邮箱曲面上的一条分段光滑简单闭曲线，其包围的区域是曲面<span class="math inline">\(S\)</span> 的一个单连通区域，则 <spanclass="math display">\[\oint _C. \kappa _ g \mathrm d s + \iint _D K \mathrm d \sigma = 2 \pi -\sum _ {i = 1} ^ n \alpha _ i\]</span></p><ul><li><span class="math inline">\(\kappa_g\)</span>是曲线的测地曲率，</li><li><span class="math inline">\(K\)</span> 是曲面的高斯曲率</li><li>$_ i $ 表示曲线在角点<spanclass="math inline">\(i\)</span>的外角</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="微分几何" scheme="http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 2 - Broad Phase 阶段</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T16:05:28.166Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几种在各类代码库中应用的 Broad Phase 算法</p><span id="more"></span><blockquote><p>来源包括但不限于：</p><ol type="1"><li>Unity</li><li>UE</li><li>Nvidia</li><li>PhyX</li><li>各大博客</li><li>论文</li></ol></blockquote><h2 id="broad-phase-algorithms">Broad Phase Algorithms</h2><div class="story post-story"><p>根据 Nvidia-GPU Gems 3<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>的描述，BroadPhase最主要的还是依靠一些最基础的<code>观察</code>来降低时间复杂度。主要的算法有：</p><ol type="1"><li><code>Sort and Sweep</code>：按Axis排序，然后扫描分段，认为每一个在Axis上相邻的即可能会相交。</li><li><code>Spatial Subdivision</code>：空间细分算法。可以有两种主要的形式，包括固定空间划分（每个格子尺寸一致）</li><li><code>BVH</code>（层次包围盒 –AABB/k-DOP/OBB，更基础的还有oct-tree这些数据结构）算法。实际上固定的空间划分算法和SortAnd Sweep可以互相转化。</li></ol><blockquote><p>不考虑并行的情况下，固定的空间划分算法是明显慢的。但考虑到SpatialSubdivision可以在GPU上运行，实际上这类算法也很常用。</p></blockquote><p>在实际的游戏引擎中，为了达到实时的要求，使用的算法也相对简单：</p><ol type="1"><li><code>Sweep-based</code>：考察物体运动所划过的面积，是否相互接触。计算TOI（impact产生时刻），然后重新计算。 — 会增加 CPU的负载、角速度大时会产生误差。</li><li><code>Speculative CCD</code>：计算运动过程中的AABB，然后对于覆盖到的物体进行针对性检查。– maybe cheaper，但是会出现误检为collision 的问题。</li></ol><p>其次，对于每一个物体，其也可能有针对性的优化措施，例如在UnrealEngine中，每一个物体的碰撞处理可以设置为不同的细度，从而获取不同的效果。同时其也对于输入的物体Mesh/Obj进行</p><ol type="1"><li>凸包变换（V-HACD<a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>），并使用适用于凸包的 CollisionDetect 来进行碰撞的判断</li><li>设置 k-DOP</li></ol><p>无一例外，这些算法都是BVH的变体。</p><p>其他的，例如 PhysX中，碰撞检测还可以通过光线投射（<code>Raycast</code>）算法计算得出。</p><ul><li>对于高速物体–低速物体的情形，可以考虑在每一次计算得到无碰撞位移后，通过Raycast算法得出运动路径上是否与其余物体有碰撞产生。</li></ul><blockquote><p><strong>Overview of Collision in PhysX</strong></p><ul><li>Broadphase<ul><li>AABB vs AABB, 3 axis sweep and prune</li></ul></li><li>Midphase<ul><li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABBtree</li></ul></li></ul><p>对于 Narrow Phase：</p><ul><li><p>流体-SPH Fluids (CCD)</p><ul><li>Particles vs static triangle mesh • Particles vs dynamicprimitives</li></ul></li><li><p>布料-Cloth (CCD)</p><ul><li>Vertices vs static triangle mesh • Vertices vs dynamicprimitives</li></ul></li><li><p>刚体-Rigid body (Discrete) – GJK or SAT</p><ul><li><p>Convex mesh and primitives vs static triangle mesh</p></li><li><p>Convex, primitives vs Convex, primitives</p></li></ul></li></ul></blockquote><figure><imgsrc="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/32fig01.jpg"alt="Nvidia- Sort and sweep" /><figcaption aria-hidden="true">Nvidia- Sort and sweep</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD1.gif"alt="Sweep Method 的角速度过大，导致CCD失败" /><figcaption aria-hidden="true">Sweep Method的角速度过大，导致CCD失败</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD2.png"alt="speculative ccd" /><figcaption aria-hidden="true">speculative ccd</figcaption></figure><p>考虑两种情形：</p><ol type="1"><li>只有 Rigid Body：不可能产生自交问题，这样子的话</li><li>Rigid +Deformed：Rigid肯定不会自交，但是Deformed物体可能存在自交问题、Rigid-Deformed之间可能产生相交</li></ol><p>BVH 和 Spatial Hashing 来实现</p><hr /><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"role="doc-endnote"><p>https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>https://github.com/kmammou/v-hacd<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍几种在各类代码库中应用的 Broad Phase 算法&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 4 - Deformed Object</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/Deformed/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/Deformed/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-10T06:39:13.320Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测 4 - Deformed Object</p><span id="more"></span><h2 id="初">90-00初</h2><div class="story post-story"><p>变形体和三角网格的处理的经典论文是：</p><ol type="1"><li>[Bridson02] Robust Treatment of Collisions, Contact and Friction forCloth Animation</li><li>[Provet97] Collision and self-collision handling in cloth modeldedicated to design garments</li></ol><p>其中这两篇论文几乎可以说是篇篇论文都在引了。其主要的思想在于</p><h3 id="provet-97">Provet 97</h3><h4 id="简介">简介</h4><p>这篇论文之所以重要，是因为其提出了三角网格产生碰撞一个充分必要条件：对于三角网格而言，其产生碰撞，当且仅当，存在</p><ol type="1"><li>Vertical - Triangle （原文 Point Triangle collision）碰撞</li><li>Edge - Edge 碰撞</li></ol><p>之一（或兼有）</p><p>显然的是，两个碰撞都导致了<strong>四点共面</strong>的情况。根据空间几何的知识，<spanclass="math inline">\(\mathbf x_{1}\cdots\mathbf x_4\)</span>共面，当且仅当： <span class="math display">\[(\mathbf x_{12}\quad \mathbf x_{13} \quad \mathbf x_{14}) = 0\]</span> 其中 <span class="math inline">\((\quad)\)</span>记号为混合积。因此为检测碰撞，转化为求解一个关于 <spanclass="math inline">\(t\)</span> 的三次方程，即： <spanclass="math display">\[\exists t \in [0, 1]\quad (\mathbf x_{12}\quad \mathbf x_{13} \quad\mathbf x_{14}) = 0\]</span></p><blockquote><p>其中的三次方程采用牛顿法求解。</p></blockquote><p>求解出 <span class="math inline">\(t\)</span>是不够的，因为方程可能出现 V 不处于 T 内部，或 E 和 E不交的情况，但考虑到已经共面，下一步的判断是简单的，几乎不需要计算。因此该算法主要的计算量在于三次方程的求解上。</p><h4 id="broad-phase-剔除">Broad Phase 剔除</h4><ol type="1"><li>BVH</li><li>计算曲率：根据显然的事实 —给定一个曲面局部，如果它是凸的，且有充分低的曲率，则其不可能产生自相交。</li></ol><h4 id="impact-zone">Impact Zone</h4><p>为了消除一个碰撞，可能会引入其他的碰撞，这是因为在处理碰撞的时候，我们只针对当前选出来的碰撞对进行更新，在该更新过程中是不考虑其他点的情况的。</p><p>因此，若一个 Impact Zone在充分大的时候，考虑Frozen，并通过群速度、群角速度进行整体更新。</p><h4 id="相关内容">相关内容</h4><ol type="1"><li>Fast CCD</li><li>Safe CCD</li><li><strong>Tight CCD</strong></li></ol><h3 id="bridson-02">Bridson 02</h3><p>这篇嘛是一个完整的Workflow介绍了，从文章标题也能看出来主要是为了准确和高鲁棒性来实现的。主要还是处理了自碰撞的问题。</p><h4 id="碰撞检测">碰撞检测</h4><p>Broad-Phase：AABB，自下而上构造。</p><p>Narrow-Phase：还是基于上面的共面，但是判断是否在内部改进为解线性方程组（分解到现有基底上）</p><h4 id="处理">处理</h4><p>摩擦：库伦定律（摩擦角）用于静摩擦和动摩擦。</p><p>Rigid Impact Zone：用于失败的补偿机制</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测 4 - Deformed Object&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 1 - Introduction</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/Introduction/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/Introduction/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-14T14:12:34.457Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测相关介绍</p><span id="more"></span><h1 id="碰撞检测">碰撞检测</h1><p>众所又周知啊，碰撞检测是一个老大难的问题，在很多的仿真模拟、游戏引擎中间都会用哈</p><p>碰撞检测的主要流程是 <a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>：</p><figure><img src="2022-04-05-17-32-22.png"alt="GAMES 103- Collision Handling" /><figcaption aria-hidden="true">GAMES 103- CollisionHandling</figcaption></figure><p>其中：</p><ul><li><span class="math inline">\(\{\mathbf x, \mathbf x^{new}\}\)</span>分别是更新前后的顶点位置向量</li><li>Pair Condidates 是指可能发生碰撞的 primitive pairq</li><li>Colliding Pairs 是指真实发生碰撞的 primitive pair</li></ul><blockquote><p><strong>注意</strong>：</p><p>一般而言，所谓的 primitive 是指组成这个 body (不管是 deformable 还是rigid) 的单位元素，例如：</p><ol type="1"><li>三角网格 (mass-spring 模型）中的三角面片</li><li>多边形模型（例如 FEM ）中的面片</li><li>图的顶点、边</li></ol></blockquote><p>可以看出，总体上的碰撞检测分为两个阶段：第一阶段（Broad-Phase）去除不可能出现的pairs（当然肯定使用反向计算出可能产生collision 的 pair去做的。第二阶段（Narrow-Phase）去针对每一个pair计算。</p><h2 id="broad-phase">Broad-Phase</h2><div class="story post-story"><p>碰撞剔除两种常见的方法：</p><ol type="1"><li>Spatial Hashing：空间哈希</li><li>BVH：层次包围盒</li></ol><h3 id="空间划分">空间划分</h3><h4 id="基本思想">基本思想</h4><p>将整个空间划分为各自，然后将Primitive存在单元格内。（有相交就存储，可能出现在多个格子里面）</p><p>对于每一个格子里面的所有 Primitive-Pair 输出。</p><h4 id="动态过程">动态过程</h4><p>我们将 <span class="math inline">\(x^{new}\)</span> 和 <spanclass="math inline">\(x\)</span> 都认为是其位置，再进行划分。</p><h4 id="存在的问题">存在的问题</h4><p>三维空间的格子 – 100x100x100 – 计算量大</p><p>可能出现：分布不均匀</p><ol type="1"><li>浪费存储空间</li><li>大量的三角形聚集在几个格子里</li></ol><h4 id="改进方案">改进方案</h4><h5 id="排序">排序</h5><figure><img src="image-20220409103734403.png" class="lazyload" data-srcset="image-20220409103734403.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="排序" /><figcaption aria-hidden="true">排序</figcaption></figure><p><strong>目的</strong>：所有的Pair都按照格子的编号排列（类似于稀疏矩阵压缩），从而节约内存开销。</p><h5 id="为了达到连续内存访问">为了达到连续内存访问</h5><p>使用 <code>Morton Code</code> 编码，</p><h3 id="bvh-层次包围盒">BVH 层次包围盒</h3><p>递归的建立一棵树，例如：</p><figure><img src="image-20220409104753151.png" class="lazyload" data-srcset="image-20220409104753151.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BVH" /><figcaption aria-hidden="true">BVH</figcaption></figure><p>Idea：把包围盒组合成新的包围盒</p><p>如何检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ProcessNode(A) &#123;</span><br><span class="line">for_each(B: A.child)&#123;</span><br><span class="line">ProcessNode(B);</span><br><span class="line">&#125;</span><br><span class="line">for_each([B, C]: A.childrenPair) &#123;</span><br><span class="line"><span class="keyword">if</span> B-C intersect &#123;</span><br><span class="line">ProcessPair(B, C)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessPair(B, C) &#123;</span><br><span class="line">for_each(B<span class="number">&#x27;</span>: B.child) &#123;</span><br><span class="line">for_each(C<span class="number">&#x27;</span>: C.child) &#123;</span><br><span class="line"><span class="keyword">if</span> B<span class="number">&#x27;</span>-C<span class="number">&#x27;</span> intersect &#123;</span><br><span class="line">ProcessPair(B<span class="number">&#x27;</span>, C<span class="number">&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见的包围盒">常见的包围盒</h4><ol type="1"><li><strong>AABB</strong>：intersect 当且仅当在轴上有相交</li><li>球</li><li>OBB：任意方向的包围盒</li></ol><h4 id="问题">问题</h4><p>难以处理紧邻的情况。 – 只有便利到底层才能解决</p><blockquote><p>Energy-based Self-Collision Culling for Arbitary MeshDeformations</p><ol type="1"><li>形变越大，越容易相交</li></ol></blockquote><h3 id="对比">对比</h3><p>SH =&gt; Edge-Triangle</p><ol type="1"><li>Easy to implement</li><li>GPU-Friendly</li><li>Need to recompute after updating obj.</li></ol><p>BVH =&gt; VT &amp; EE</p><ol type="1"><li>More Involved</li><li>Not GPU Friendly</li><li>To update BVH, just update BV</li></ol></div><h2 id="narrow-phase">Narrow Phase</h2><div class="story post-story"><p>进一步看是否真的有碰撞，两种：DCD和CCD</p><h3 id="dcd-相交检测">DCD — 相交检测</h3><p>只考虑是否相交（而非碰撞）</p><p>对于Triangle Mesh，只考虑 Edge-Triangle. <spanclass="math display">\[\begin{cases}((1-t) x_a+tx_b -x_0)\cdot x_{10} \times x_{20} =0\\t = \frac{x_{0a}\cdot x_{10} \times x_{20}}{x_{ba}\cdot x_{10} \timesx_{20}}\end{cases}\]</span> 若解出来的 <span class="math inline">\(t\in [0, 1]\)</span>则能够判断出在 <span class="math inline">\(t\)</span> 处相交</p><figure><img src="image-20220409111138061.png" class="lazyload" data-srcset="image-20220409111138061.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DCD" /><figcaption aria-hidden="true">DCD</figcaption></figure><h4 id="问题-1">问题</h4><p>可能会产生穿透问题（运动很快的情况）。对于大体积问题的概率低，但是如果是cloth等薄物体，容易发生。</p><ol type="1"><li>减少dt</li></ol><h3 id="ccd">CCD</h3><p>测试两个状态（之间）有无碰撞产生。</p><p>一般是做 VT 和 EE 的检测：</p><figure><img src="image-20220409111542472.png" class="lazyload" data-srcset="image-20220409111542472.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="V-T测试" /><figcaption aria-hidden="true">V-T测试</figcaption></figure><figure><img src="image-20220409111601254.png" class="lazyload" data-srcset="image-20220409111601254.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="EE测试" /><figcaption aria-hidden="true">EE测试</figcaption></figure><p>共同点：</p><ol type="1"><li>解一元三次方程。观察解的情况</li></ol><h4 id="数值问题">数值问题</h4><ol type="1"><li>公式法：开三次方的数值误差大</li><li>牛顿法：速度</li><li>GPU — 单精度</li><li>Expensive — 可以考虑加强 Broad-Phase</li></ol><blockquote><p>Bridson2002-Robust … …</p></blockquote><h1 id="碰撞处理">碰撞处理</h1><figure><img src="image-20220409112929873.png" class="lazyload" data-srcset="image-20220409112929873.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IPM / IZO" /><figcaption aria-hidden="true">IPM / IZO</figcaption></figure><h3 id="内点法">内点法</h3><blockquote><p>截断 – IPC</p></blockquote><figure><img src="image-20220409112859592.png" class="lazyload" data-srcset="image-20220409112859592.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内点法" /><figcaption aria-hidden="true">内点法</figcaption></figure><p>反复进行碰撞检测</p><blockquote><p>Robust……</p></blockquote><h3 id="impact-zone-method.">Impact Zone Method.</h3><h3 id="备选">备选</h3><ol type="1"><li>Rigid Impact Zone</li></ol><figure><img src="image-20220409113154440.png" class="lazyload" data-srcset="image-20220409113154440.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="一个常见的思路为" /><figcaption aria-hidden="true">一个常见的思路为</figcaption></figure><h1 id="相交解除">相交解除</h1><blockquote><p>碰撞不是灾难，可以在发生之后进行解除</p></blockquote><p>处理当前已有的相交情况。</p><blockquote><p>Untangling Cloth.</p></blockquote><p>改进方法：</p><p>期望相交曲线变短，直到相交解除</p><ul><li>Not always work.</li></ul><blockquote><p>Resolving Service Collisons through</p></blockquote><hr /><blockquote><p>实际上，Narrow Phase 还可以继续细分：</p><p>The narrow phase obtains the collision pair list and for every pair,using their actual geometry, it checks whether the two partners arecolliding. This phase can get arbitrarily complex, so in the context ofreal-time physics simulation, the participating colliding shapes areusually restricted to being convex. For nonconvex shapes, only theconvex hull will then be used for collision detection. In most casesthis is good enough—for example if the concavities are small orconstitute object parts where you don't want a game character to goanyway, such as the exhaust pipes of a spacecraft or other irrelevantplaces. To improve collision quality and performance, we can decomposebig or concave objects into convex pieces. A game object therefore mighthold a simplified collision geometry that is different from the onedisplayed. In this chapter we investigate a narrow-phase algorithm fordetermining the distance between two convex objects. For the two objectsin Figure 33-1b, the contact point marked with the yellow star isdetected, and its location is calculated and stored with the collisionpair.（转化为凸包，进一步简化加速）</p></blockquote><p>根据 [Provet97] <a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a> 的描述，其可以通过</p><hr /><p>UE4 中的碰撞检测：</p><ul><li>射线检测RayCasts</li><li>重叠检测Overlaps</li><li>渗透深度计算Penetration Depth</li><li>Sweeps检测</li><li>InitialOverlaps检测</li></ul><blockquote><p>https://zhuanlan.zhihu.com/p/33529865</p></blockquote><p>刚体碰撞</p><p>Penalty Method</p><p>Impulse Method</p><p>空间划分 — Spatial Hashing</p><ul><li>Easy Implement</li><li>GPU Friendly</li><li>Recompute after updating. 包围盒 AABB</li><li>More involved</li><li>Not gpu friendly</li><li>Update BVH -&gt; Update Bounding Volumes.</li></ul><p>两种碰撞检测方式：</p><p>DCD — Discrete Collision Detection</p><ul><li>当前状态下有无自相交 CCD — Continuous Collision Detection</li><li>两个状态之间是否相交</li><li>对于三角网格：<ul><li>点 - 三角</li><li>边 - 边</li></ul></li><li>Co-planar</li><li>Issues:<ul><li>误差 - 三次方程 - GPU-float32</li><li>比 DCD 慢很多</li><li>难以实现</li></ul></li></ul><p>处理方法：</p><ul><li>Interior Point Method<ul><li>每一步都是安全的</li><li>Slow - far from solution - all of vertices - cautiously by smallsteps</li><li>Log-Barrier IPM. E(x) = -log |xij| + Gradient Descent<ul><li>IPC - not GD.</li><li></li></ul></li></ul></li><li>Impact Zone Optimization<ul><li>逐步满足 Constraint</li><li>Fast - Close To solution - only vertices in collision - can takelarge steps sizes</li><li>May not succeed. (Due to large dT)</li></ul></li><li>Rigid Impact Zones.<ul><li>回到前一帧 -&gt; 没有碰撞（视为刚体） CCD -&gt; IZO -&gt; IPM orRIZ</li></ul></li></ul><p>相交解除</p><ul><li>Not always intersection free.</li></ul><p>V-V intersection C-V intersection</p><ul><li>推出即可 C-C</li><li>无法处理边界</li><li>难以在 GPU 上实现</li></ul><hr /></div><h2 id="reference">Reference</h2><div class="story post-story"><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>GAMES103 Collision Handling<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Collision and self-collision handlingin cloth model dedicated to design garments<a href="#fnref2"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测相关介绍&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 3 - Narrow Phase 阶段</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/NarrowPhase/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/NarrowPhase/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T12:43:58.767Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测笔记 3 — Narrow Phase</p><span id="more"></span><p>一般而言的 Narrow Phase是基于点线面的关系推导得到的。而且在很多情况下，我们不需要知道碰撞在两个插值点之间的具体位置，而只需要知道其是否碰撞。针对不同的物体，一可以有不同的优化策略。</p><h2 id="一般物体间的碰撞检测">一般物体间的碰撞检测</h2><div class="story post-story"><ol type="1"><li>凸物体</li><li>刚体</li><li>变形体 &amp; 三角网格</li></ol><h3 id="凸物体的碰撞检测">凸物体的碰撞检测</h3><p>一般而言，凸物体的碰撞可以通过 GJK 和 SAT 方法来判断。</p><h4 id="gilbert-johnson-keerthi-gjk-算法">Gilbert-Johnson-Keerthi (GJK)算法</h4><h5 id="idea">Idea</h5><p>设 <span class="math inline">\(\mathcal A = \{\mathbf x\}\)</span>，<span class="math inline">\(\mathcal B = \{\mathbf x\}\)</span>是两个点集，定义其 Minkowski 差为： <span class="math display">\[\mathcal A - \mathcal B :=\{\mathbf x_1 - \mathbf x_2| \mathbf x_1 \in\mathcal A, \mathbf x_2 \in \mathcal B \}\]</span> 不难证明，<span class="math inline">\(\mathcal A\)</span> 和<span class="math inline">\(\mathcal B\)</span> 碰撞，当且仅当 <spanclass="math inline">\(0 \in \mathcal A - \mathcal B\)</span>。</p><p>问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于<strong>凸物体</strong>，我们可以有快速算法实现。</p><h5 id="support-函数和-simplex-单纯形">Support 函数和 Simplex单纯形</h5><p>其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski差的一个子集包含了 <spanclass="math inline">\(0\)</span>，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。</p><p>为了生成这样的单纯形，我们计算 support函数来快速获取给定方向上的支撑点，如图所示<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg"alt="Support 函数返回的点" /><figcaption aria-hidden="true">Support 函数返回的点</figcaption></figure><h5 id="迭代求解">迭代求解</h5><p>有了如上的论述，我们可以通过如此构造单纯形：</p><ol type="1"><li>随机生成一个单纯形</li><li>假定当前的单纯形为 <span class="math inline">\(\{v\}\)</span>则选择距离原点最远的抛弃，对于 n - 1维单纯形求法向量，求support（两个）</li><li>直到<ol type="1"><li>检查到 0 =&gt; 碰撞</li><li>如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞</li></ol></li></ol><p>可以证明，这样的算法一定在有限步内结束。</p><h4 id="sat-分离轴算法">SAT 分离轴算法</h4><p>一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个<span class="math inline">\(n - 1\)</span>维的超平面能够完全分开这两个凸集合。遍历所有的边（三维则是面），投影到其正交补空间上。若<strong>存在</strong>一个边，能使得投影完全分离，则其是不相交的，反之相交。</p><h3 id="刚体碰撞检测">刚体碰撞检测</h3><p>刚体碰撞的检测正如在 <a href="BroadPhase">Broad Phase</a>里提到：</p><blockquote><p><strong>凸包变换（V-HACD）</strong>，并使用适用于凸包的 CollisionDetect 来进行碰撞的判断。</p></blockquote><p>这类方法将原来的刚体预计算处理为凸包，用户可以控制其分割的<em>粒度</em>，从而权衡其加速/精度。</p><h3 id="变形体-三角网格">变形体 &amp; 三角网格</h3><p>基本思路为：</p><ol type="1"><li>求解三次方程；</li><li>设置两个非邻接顶点/面的距离下界为一个固定/可变的非零数（可以按照siggraph2022的论文结果强化到点-点距离）</li><li>在变形体网格上建立局部 BVH 来增加一部，返回1/2求解</li></ol><hr /><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"role="doc-endnote"><p>https://zhuanlan.zhihu.com/p/127844705<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测笔记 3 — Narrow Phase&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的抽象代数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/Algebra/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/Algebra/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-03-28T03:49:07.263Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="抽象代数" scheme="http://adversarr.github.io/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的复变函数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/ComplexAnalysis/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/ComplexAnalysis/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-06T03:03:56.421Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="复变函数" scheme="http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的实变函数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/RealAnalysis/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/RealAnalysis/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-20T04:09:11.507Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><details ><summary> 目录 </summary>              <div class='content'>              <ul><li><a href="#集合论">集合论</a><ul><li><a href="#集合">集合</a><ul><li><a href="#集合运算">集合运算：</a></li><li><a href="#上极限和下极限相关内容">上极限和下极限相关内容：</a></li></ul></li><li><a href="#映射">映射</a></li><li><a href="#rn空间">Rn空间</a><ul><li><a href="#闭集开集borel集">闭集、开集、Borel集</a></li><li><a href="#开集结构连续性">开集结构、连续性</a></li><li><a href="#基本定理">基本定理</a></li></ul></li></ul></li><li><a href="#勒贝格测度">勒贝格测度</a><ul><li><a href="#外测度可测集">外测度、可测集</a><ul><li><a href="#外侧度">外侧度</a></li><li><a href="#lebesgue可测集">Lebesgue可测集</a></li><li><a href="#测度空间">测度空间</a></li></ul></li><li><a href="#可测函数">可测函数</a><ul><li><a href="#基本性质">基本性质</a></li><li><a href="#测度空间上的可测函数">测度空间上的可测函数</a></li></ul></li><li><a href="#lesbegue可测函数列的收敛性">Lesbegue可测函数列的收敛性</a><ul><li><ahref="#几乎处处收敛几乎一致收敛">几乎处处收敛/几乎一致收敛</a></li><li><a href="#依测度收敛">依测度收敛</a></li><li><ahref="#可测函数和连续函数的关系">可测函数和连续函数的关系</a></li></ul></li></ul></li><li><a href="#lebesgue-积分">Lebesgue 积分</a></li></ul>              </div>            </details><h2 id="集合论">集合论</h2><div class="story post-story"><h3 id="集合">集合</h3><h4 id="集合运算">集合运算：</h4><ol type="1"><li>代数 -- 交并补差</li><li>分析 -- 上下极限</li><li>直积</li></ol><p>上下极限可以有两种定义方式：</p><p><span class="math display">\[\lim\sup _{n\rightarrow \infty} A_n =\lim _{ n \rightarrow\infty}\bigcup_{k = n}  ^ \infty A_n  = \bigcap _ { n = 1} ^\infty\bigcup_{k = n}  ^ \infty A_n\]</span></p><p>对于下极限同样定义。</p><h4 id="上极限和下极限相关内容">上极限和下极限相关内容：</h4><p>集合的上下确界 <span class="math inline">\(\sup, \inf\)</span></p><dl><dt>Theo</dt><dd>确界存在定理</dd></dl><p>上下极限也可以通过上下界定义：</p><p><span class="math display">\[\lim \sup = \inf \sup \quad \lim \inf = \sup \inf\]</span></p><blockquote><p>类比点列、函数的上下极限定义</p></blockquote><h3 id="映射">映射</h3><ol type="1"><li>映射</li><li>集合势</li></ol><p>研究可列：</p><ol type="1"><li>任何无穷集合中包含可列的子集</li><li>可列集的无穷子集可列</li><li>可列集的交并都可列</li></ol><h3 id="rn空间">Rn空间</h3><ol type="1"><li>定义<span class="math inline">\({\mathbb R}^n\)</span></li><li>线性空间、范数、柯西不等式、距离、球</li></ol><p>考察点集：</p><ol type="1"><li>点：内点、边界点、聚点</li><li>诱导集合：闭包、边界</li><li>相互关系：稠密</li></ol><h4 id="闭集开集borel集">闭集、开集、Borel集</h4><ol type="1"><li>闭集、开集的定义</li></ol><p>极限性质： 1. 开集的并始终是开的，两个开集的交是开的 2.闭集的交始终是闭的，两个闭集的并是闭的 3. 从而定义<spanclass="math inline">\(F_\sigma\)</span>型集（可数闭集并）和<spanclass="math inline">\(G_\delta\)</span>型集（可数开集的交）</p><p>推广上述性质：<span class="math inline">\(\sigma\)</span>-代数</p><h4 id="开集结构连续性">开集结构、连续性</h4><dl><dt>Theo</dt><dd><span class="math inline">\({\mathbb R}\)</span>上任意非空开集是至多可数个开集的并</dd><dt>Theo</dt><dd><span class="math inline">\({\mathbb R}^n\)</span>上的任意非空开集是之多可数个互不相交的半开矩体的并。</dd></dl><p>通过这两个定理，我们来观察函数的连续性：</p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(f:{\mathbb R}^n \rightarrow {\mathbbR}\)</span> 则TFAE： 1. <span class="math inline">\(f\in C\)</span> 2.<span class="math inline">\(\forall \lambda, \{f &lt; \lambda\}, \{f&gt; \lambda \}\)</span> 是开的 2. <span class="math inline">\(\forall\lambda, \{f &lt;= \lambda\}, \{f &gt;= \lambda \}\)</span> 是闭的</dd></dl><h4 id="基本定理">基本定理</h4><ol type="1"><li>Cauchy-收敛原理</li><li>有限覆盖定理</li><li>闭区间套定理</li><li>魏尔斯特拉斯定理</li></ol><p>关于紧集：</p><ol type="1"><li>定义：任意开覆盖有有限子覆盖</li><li>性质：在 <span class="math inline">\({\mathbb R} ^ n\)</span>中就是有界闭集</li></ol></div><h2 id="勒贝格测度">勒贝格测度</h2><div class="story post-story"><h3 id="外测度可测集">外测度、可测集</h3><h4 id="外侧度">外侧度</h4><dl><dt>外测度</dt><dd>设 <span class="math inline">\(E\)</span> 是 <spanclass="math inline">\({\mathbb R} ^ n\)</span> 中的点集，若<spanclass="math inline">\(\{I_k\}\)</span>是一列开矩体，且为<spanclass="math inline">\(E\)</span>的一个开覆盖，确定了一个实数：<spanclass="math inline">\(u = \sum _{k} I_k\)</span>，令： <spanclass="math display">\[m^*(E) = \inf \{u\}\]</span> 称为其的<span class="math inline">\(Lebesgue\)</span>外测度。</dd></dl><p>关于外测度的性质： 1. 非负性 2. 单调性 3. 次可加性 4. 平移不变性</p><blockquote><ol type="1"><li>单点集、可数点集的外测度都为 0</li><li><span class="math inline">\(n-1\)</span> 维超平面测度为0</li><li>康托集外测度为0</li></ol></blockquote><h4 id="lebesgue可测集">Lebesgue可测集</h4><p>外测度不符合可加性！因此在集合上加Carathedory条件：</p><dl><dt>可测</dt><dd>设 <span class="math inline">\(E \subseteq {\mathbb R} ^ n\)</span>如果<span class="math inline">\(\forall T \subset {\mathbb R} ^n\)</span>，有 <span class="math display">\[m^*(T) = m^*(T \cap E) + m^*(T\cap E^c)\]</span> 则称之为 Lebesgue 可测，全体记为 <spanclass="math inline">\(\mathcal M\)</span> 测度即其外侧度</dd></dl><blockquote><p>上述条件中实际上只需要<spanclass="math inline">\(\ge\)</span>成立即可（另一侧自然成立）</p></blockquote><p>考虑原来的简单集合：</p><dl><dt>Theo</dt><dd><ol type="1"><li>外测度的零测集是可测的，即为零测集。</li><li>对开矩体而言，其测度为其“长度”</li></ol></dd></dl><p>对于可测集，其具有如下性质：</p><ol type="1"><li>空集可测，测度为0</li><li>可测集的交并补差都是可测集</li><li><strong>可数可加性</strong>：对于互不相交的可测集<spanclass="math inline">\(E_i\)</span>，取并和取测度可换</li><li>平移不变性</li></ol><p>进一步考察和极限的关系：</p><dl><dt>Theo</dt><dd>可测集合的可数交是可测的</dd></dl><p>考虑极限和测度交换：</p><dl><dt>Theo</dt><dd>对于递增的可测集列<spanclass="math inline">\(E_i\)</span>，则其极限可测，且有极限和测度可换</dd><dt>Theo</dt><dd>对于递减的可测集列<span class="math inline">\(E_i\)</span>，若存在<spanclass="math inline">\(m(E_i) &lt;+\infty\)</span>，则其极限可测，且有极限和测度可换</dd></dl><blockquote><p>上式要求存在一个集合测度有限：考察<span class="math inline">\(E_i =[i, \infty)\)</span>的极限的测度和其测度的极限</p></blockquote><p>下面的定理表述了可测集和 Borel 集的关系</p><dl><dt>Theo</dt><dd>若<span class="math inline">\(E\)</span>可测，则存在 Borel 集<spanclass="math inline">\(G, F\)</span>，使得<spanclass="math inline">\(F\subset E\subset G\)</span> 且 <spanclass="math inline">\(m(F) = m(E) = m(G)\)</span>换句话说，对于任意可测集，存在 Borel 集来从两侧（在测度意义上）逼近。</dd></dl><h4 id="测度空间">测度空间</h4><blockquote><p>TODO</p></blockquote><h3 id="可测函数">可测函数</h3><p>对于函数，正如我们一开始用开集闭集来表征连续性一样，考察用可测集来表述可测性。</p><dl><dt>可测函数</dt><dd>设 <span class="math inline">\(E \subseteq \mathbb R^n\)</span>可测，<span class="math inline">\(f\)</span> 是 <spanclass="math inline">\(E\)</span> 上的函数，若对于任何<spanclass="math inline">\(t\in {\mathbb R}\)</span>有 <spanclass="math display">\[E(f&gt;t) := \{x\in E| f(x) &gt; t\}\]</span> 都可测，则称函数在<spanclass="math inline">\(E\)</span>上可测，用<spanclass="math inline">\(M(E)\)</span>表示。</dd></dl><ol type="1"><li>对于上述定理中的<span class="math inline">\(t\inE\)</span>，只需要考察稠密的<span class="math inline">\(t\inE&#39;\subset E\)</span>即可</li><li>对于 <span class="math inline">\(&gt;\)</span>，可以等价替换为 <spanclass="math inline">\(\ge, \le , &lt;\)</span></li></ol><p>我们考察在这个定义下的简单函数，他们通过特征函数来定义：</p><dl><dt>简单函数</dt><dd>设有互不相交的<span class="math inline">\(E_i\)</span>是<spanclass="math inline">\(E\)</span>的一个分划，称 <spanclass="math display">\[\varphi (x) = \sum_{i = 1} ^ m \alpha _ i \chi _{E_i} (x)\]</span> 是简单函数，当<spanclass="math inline">\(E_i\)</span>是矩体时，<spanclass="math inline">\(\varphi\)</span>是阶梯函数</dd></dl><p>显然，简单函数是可测的。而下面的定理说明了简单函数能够构建出一个可测函数：</p><h4 id="基本性质">基本性质</h4><dl><dt>Theo</dt><dd>对于可测函数集， 1. 是线性空间（对非零除法也是） 2. 连续函数都可测</dd></dl><p>下面考察其极限性质：</p><dl><dt>Theo</dt><dd>对于可测函数列的 <span class="math inline">\(f_k\)</span>的上确界，下确界，上极限，下极限 都是可测函数</dd><dt>Theo</dt><dd>对于可测函数列，若<span class="math inline">\(f_k \rightarrowf\)</span>，则 <span class="math inline">\(f\)</span> 可测。</dd></dl><p>下面考虑取绝对值前后的可测性：</p><dl><dt>Theo</dt><dd>对于实值函数，可测的充要条件是正部和负部都是可测的，且若<spanclass="math inline">\(f\)</span>可测，则<spanclass="math inline">\(|f|\)</span>可测</dd></dl><p>考虑复合函数的可测性：</p><dl><dt>Theo</dt><dd>对于 <span class="math inline">\(f\in C\)</span> 和 <spanclass="math inline">\(g\in M\)</span> 有 <spanclass="math inline">\(h=f\circ g\)</span>可测</dd></dl><p>下面引入几乎处处的概念：</p><dl><dt>几乎处处</dt><dd>称E在<spanclass="math inline">\(A\)</span>几乎处处满足P(E)，是指存在一个固定的零测的<spanclass="math inline">\(Z\)</span>使得对<span class="math inline">\(A -Z\)</span>满足P(E)</dd></dl><p>从而，我们有：</p><dl><dt>Theo</dt><dd>对于实函数，若<span class="math inline">\(f = g\quada.e.\)</span>则<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>有相同的可测性。</dd></dl><p>从上面的描述中不难看出，相比于<strong>连续性</strong>，可测性在极限运算下具有良好的性质（保持、交换），这也是我们需要可测的原因。</p><h4 id="测度空间上的可测函数">测度空间上的可测函数</h4><blockquote><p>TODO</p></blockquote><h3 id="lesbegue可测函数列的收敛性">Lesbegue可测函数列的收敛性</h3><p>这一节，我们详细讨论收敛的概念。</p><h4 id="几乎处处收敛几乎一致收敛">几乎处处收敛/几乎一致收敛</h4><dl><dt>几乎处处收敛</dt><dd>（直接从几乎处处收敛的定义得到）</dd></dl><p>相对于几乎处处收敛，我们有稍弱一些的几乎一致收敛，其描述的是定义域极限意义下的收敛性。（即我们不需要得到零测集，而得到测度充分小的集合）</p><dl><dt>几乎一致收敛</dt><dd><span class="math inline">\(\forall \delta &gt; 0, \exists E_\delta\subset E\)</span> 使得（测度充分小）<spanclass="math inline">\(m(E_\delta) &lt; \delta\)</span>，且在 <spanclass="math inline">\(E - E_\delta\)</span>上满足一直收敛到<spanclass="math inline">\(f\)</span>。</dd></dl><p>下面的定理说明了这两个收敛行的关系：</p><dl><dt>叶戈罗夫定理</dt><dd>对于<strong>有限测度集</strong>上的几乎处处<strong>有限</strong>的可测函数列，若函数列几乎处处收敛，则函数列几乎一致收敛</dd></dl><p>有限和有界是不同的：<span class="math inline">\(y = 1/x\)</span>在<span class="math inline">\((0,1)\)</span>无界，但其是有限的。有界是对于区间而言，而有限是对于点（<spanclass="math inline">\(&lt; +\infty\)</span>而言）</p><h4 id="依测度收敛">依测度收敛</h4><p>条件更弱，去掉的集合甚至不一定“稳定”，即该集合只需要测度的极限为0，而不需要考虑其极限是否存在。</p><dl><dt>依测度收敛</dt><dd>对于几乎处处有限的可测函数，对于给定的<spanclass="math inline">\(\epsilon&gt;0\)</span>，其能够满足 <spanclass="math display">\[m(E(|f_k - f| &gt; \epsilon)) \rightarrow 0\]</span> 则其是在<spanclass="math inline">\(E\)</span>上依测度收敛到<spanclass="math inline">\(f\)</span>（<spanclass="math inline">\(f_k\rightarrow_m f\)</span>）</dd></dl><p>显然，几乎处处收敛和几乎一致收敛蕴含了依测度收敛。但依测度收敛给出了收敛到什么函数的本质问题。</p><dl><dt>Theo</dt><dd>若函数列 <span class="math inline">\(f_k\)</span> 依测度收敛于<spanclass="math inline">\(f, g\)</span> ，则 <span class="math inline">\(f=g \quad a.e.\)</span></dd></dl><!-- 如果我们将几乎处处相等作为等价关系，考虑其等价类： --><dl><dt>Theo — 勒贝格定理</dt><dd>对于有限测度集上的几乎处处有限的可测函数，则其依测度收敛到该极限函数</dd></dl><p>考虑从依测度收敛到几乎处处收敛的条件：</p><dl><dt>Theo — Riesz 引理</dt><dd>若 <span class="math inline">\(f_k \rightarrow _mf\)</span>，则存在子列几乎处处收敛到<spanclass="math inline">\(f\)</span></dd></dl><p>依测度收敛意义下，我们可以类比柯西收敛准则：</p><dl><dt>依测度基本列</dt><dd>设有<span class="math inline">\(f_k\)</span>为<spanclass="math inline">\(E\)</span>上几乎处处有限的可测函数列，若 <spanclass="math display">\[\forall \varepsilon &gt; 0, \quad \lim_{k , j \rightarrow \infty}m(E(|f_i - f_j| &gt; \varepsilon)) = 0\]</span> 则称其为<span class="math inline">\(E\)</span>上的依测度基本列</dd></dl><p>类似柯西收敛准则：</p><dl><dt>Theo</dt><dd>对于几乎处处有限的可测函数列，依测度收敛当且仅当它是依测度基本列</dd></dl><h4 id="可测函数和连续函数的关系">可测函数和连续函数的关系</h4><p>连续函数在数学分析中具有重要的作用（特别是一致连续的函数）。因此我们考察连续和可测之间是否有一定的联系。</p><p>下面的定理描述了函数可测和连续之间的差别。</p><dl><dt>Theo — 鲁金定理</dt><dd>设<spanclass="math inline">\(f\)</span>是<strong>有限测度集</strong>上几乎处处有限的可测函数，对于任一（充分小的）<spanclass="math inline">\(\delta &gt; 0\)</span>，存在<spanclass="math inline">\(E\)</span>中的闭集<spanclass="math inline">\(F\)</span>，满足<span class="math inline">\(m(E\backslash F) &lt; \delta\)</span> 使<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(F\)</span>上连续。</dd></dl><p>下面的定理描述了如何从连续函数构造一个可测函数：</p><dl><dt>Theo</dt><dd>对于任意可测函数<spanclass="math inline">\(f\)</span>，存在连续函数列<spanclass="math inline">\(g_k\)</span>，使得<span class="math inline">\(g_k\rightarrow f\quad a.e.\)</span></dd></dl><p>上面的定理可以推广为：</p><dl><dt>Theo</dt><dd>对于几乎处处有限的函数<span class="math inline">\(f\)</span>，<spanclass="math inline">\(f\)</span>可测，当且仅当<spanclass="math inline">\(\exists g_k\in C\)</span>使得<spanclass="math inline">\(g_k \rightarrow f\quad a.e.\)</span></dd></dl></div><h2 id="lebesgue-积分">Lebesgue 积分</h2><div class="story post-story"><p>至此，我们得到了可测函数优秀的极限性质，我们开始考虑一类特殊的极限 --积分，这也是实变函数论目的：给积分 -极限之间的互换关系一个完备的解释。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="实变函数" scheme="http://adversarr.github.io/tags/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hexo in 30 Minutes</title>
    <link href="http://adversarr.github.io/2022/01/08/talk-chat/hexo-in-30-minutes/"/>
    <id>http://adversarr.github.io/2022/01/08/talk-chat/hexo-in-30-minutes/</id>
    <published>2022-01-07T16:00:00.000Z</published>
    <updated>2022-01-08T14:25:55.702Z</updated>
    
    <content type="html"><![CDATA[<p>三十分钟实现你的Hexo博客。</p><span id="more"></span><div class="note "><p><strong>Prerequisite</strong></p><ol type="1"><li>一定的命令行操作基础（<code>cd</code>等基础命令的使用）</li><li>（可能需要）科学上网，以登入 Github</li><li>一定的耐心（来调bug）</li></ol><p>软件上：</p><ol type="1"><li>代码编辑器，例如vscode</li><li><a href="http://nodejs.cn/download/">Node.js</a></li><li>git：下载地址<ahref="https://mirrors.tuna.tsinghua.edu.cn/">tuna</a>点右侧的<code>获取下载链接</code>按钮，找Git。安装时全默认即可。</li></ol></div><h2 id="创建你的-github-账号和与你的账号关联的repo">创建你的 Github账号和与你的账号关联的repo</h2><blockquote><p>Reference: <ahref="https://pages.github.com">https://pages.github.com</a></p></blockquote><h3 id="github-账号">Github 账号</h3><p>这个超级简单，就不展开了，但需要记住你的<code>username</code>（例如我的是Jerryyang2001）</p><h3 id="创建repo">创建repo</h3><p>repo创建时，必须满足：</p><ol type="1"><li>Public访问权限（通过下面的选项来确定）</li><li>名字：必须是 <code>username.github.io</code></li></ol><p>例如：</p><p><img src="2022-01-08-17-54-19.png" class="lazyload" data-srcset="2022-01-08-17-54-19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h3 id="测试效果">测试效果</h3><p>实际上，你已经完成了这里面（<ahref="https://pages.github.com">https://pages.github.com</a>）最难的一个部分，下面要测试你的网站的代码仓库是否成功创建：</p><h2 id="配置网站">配置网站</h2><div class="story post-story"><h3 id="下载-repo-到本地">下载 repo 到本地</h3><p>首先，先打开一个terminal（Windows下的Powershell），并且用cd命令转到一个用来存放你的网站源码的文件夹，例如我的：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">cd D:<span class="regexp">/Documents/</span><span class="keyword">Repositories</span>/</span><br></pre></td></tr></table></figure><p>通过：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/username/u</span>sername.github.io</span><br></pre></td></tr></table></figure><p>来下载你这个网站对应的代码。</p><h4 id="打开你的repo">打开你的repo</h4><p>首先，你需要一个vscode（或者sublime，或者任何一个轻量级的代码编辑器），用它打开这个repo的文件夹（想必大家都很熟悉）</p><details ><summary> 这个时候，如果你不放心是否你的repo已经设置好了，可以看看这里 </summary>              <div class='content'>              <p>创建一个新的 <code>index.html</code> 文件</p><p>内容简单的写一句：</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>就可以了～</p><p>然后将它push到远端：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span> <span class="comment">--all</span></span><br><span class="line">git <span class="keyword">commit</span> <span class="operator">-</span>m &quot;Initial commit&quot;</span><br><span class="line">git push <span class="operator">-</span>u origin main</span><br></pre></td></tr></table></figure><p>然后稍微等等，然后访问：<code>https://username.github.io</code>网站，应该就能看到结果。</p>              </div>            </details><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>接着，执行：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">hexo init .</span><br><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><p>然后，在当前文件夹应该就能看到hexo和npm自动生成了你的blog源码，配置好了相关环境。从这里起，你的Blog之旅将正式开始。</p><h3 id="站点配置">站点配置</h3><p>一个Hexo站点主要由五部分组成：</p><ol type="1"><li>软件框架环境（Hexo、Nodejs等）</li><li>主题文件（一个主题一个文件夹，可以通过npm指令安装，也可以直接放在<code>themes</code>文件夹下）</li><li>sourse文件夹下的blog内容，markdown格式<ol type="1"><li>其中的<code>_posts</code>为内容</li><li>其他的文件夹下为一些特殊页面的内容，例如aboutme，categories，tags页面的布局和特殊设置</li></ol></li><li>不同的branch！一般而言，repo中需要包含【源代码】和用源代码生成的、用于给用户看到的【网页源码】，但是【网页源码】和【源代码】不需要放在一起，就像开发人员开发了一个app，给你的只是一个软件，而不是源代码一样。我们希望实现这样的功能<ol type="1"><li>在一个分支部署网站，用来存放【网站源码】，供github<strong>自动</strong>部署。</li><li>在另一个分支存放自己的源代码。例如：</li></ol></li><li>github远端</li></ol><h3 id="部署">部署</h3><blockquote><p><ahref="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a>只有Git章节有用</p></blockquote><p>先讲讲第四部分，就是不同的branch组织源码库。这一部分需要：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">git branch gh-pages-<span class="keyword">source</span></span><br><span class="line">git checkout gh-pages-<span class="keyword">source</span></span><br></pre></td></tr></table></figure><p>然后在你的<code>_config.yml</code>文件中添加：</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">deploy:</span></span><br><span class="line"><span class="language-xml">  type: git</span></span><br><span class="line"><span class="language-xml">  repository: git@github.com:username/username.github.io.git</span></span><br><span class="line"><span class="language-xml">  branch: master # 这里就是你存放【网站源码】的地方</span></span><br><span class="line"><span class="language-xml">  message: Site updated:</span><span class="template-variable">&#123;&#123; <span class="name">now</span>(<span class="name">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>) &#125;&#125;</span><span class="language-xml">)</span></span><br></pre></td></tr></table></figure><p>然后试试看：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure><p>就能直接把生成的【网站源码】push到github仓库中，让github自动部署网站到<code>username.github.io</code>。<details ><summary> 当然你也可以在 github repo 的设置中设置你想要的branch作为【网站源码】的路径 </summary>              <div class='content'>              <p><img src="2022-01-08-22-07-28.png" class="lazyload" data-srcset="2022-01-08-22-07-28.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>              </div>            </details></p></div><h2 id="资料">资料</h2><div class="story post-story"><p>我正在用的主题：<a href="https://volantis.js.org">Volantis</a></p><p>曾经用过，感觉还行的一个主题：<ahref="https://fluid-dev.github.io/hexo-fluid-docs/start/">Fluid文档</a><a href="https://hexo.fluid-dev.com">Fluid 官网</a></p><p>一些更多的折腾资料：</p><p>一定要多看 hexo 的官网介绍：</p><ol type="1"><li><ahref="https://hexo.io/docs/one-command-deployment#Git">一键部署</a></li><li><a href="https://hexo.io/docs/setup">站点基础组织结构</a></li><li><a href="https://hexo.io/docs/configuration">站点配置文件</a></li></ol></div><h2 id="当然也可以">当然也可以：</h2><div class="story post-story"><p>如果你懒的话，也可以直接clone我的源码嘛。毕竟都是配置好的东西，拿来就用就是了。（记得把我的内容全都删了）</p><p>在clone完我的源码之后需要注意的是：</p><p>我的【源代码】在<code>gh-pages-volantis</code>分支下。记得checkout到这个分支上，然后：</p><ol type="1"><li>删除<code>sourse/_posts</code>文件夹下的所有文件</li><li>修改<code>sourse/about</code> <code>sourse/categories</code><code>sourse/chat</code> 等源码中的一些不属于你的标题……</li><li>修改所有的config文件中的东西（<code>_config.volantis.yml</code> 和<code>_config.yml</code></li></ol><p>就这样？后面挺复杂的（细节太多了）各位慢慢摸索吧，百度上都有相应的解决方案的。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;三十分钟实现你的Hexo博客。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="http://adversarr.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库原理</title>
    <link href="http://adversarr.github.io/2021/12/27/study/ComputerScience/fragments/DB2021/"/>
    <id>http://adversarr.github.io/2021/12/27/study/ComputerScience/fragments/DB2021/</id>
    <published>2021-12-26T16:00:00.000Z</published>
    <updated>2022-04-06T03:32:23.577Z</updated>
    
    <content type="html"><![CDATA[<p>数据库原理复习提纲。</p><span id="more"></span><h2 id="引言">引言</h2><div class="story post-story"><h3 id="数据管理的发展">数据管理的发展</h3><h4 id="数据密集型应用">数据密集型应用</h4><p>数据密集型应用</p><ol type="1"><li>数据量大</li><li>数据不随程序的结束而消失</li><li>数据为多个 app 共享</li></ol><p>数据库对比文件系统：</p><ol type="1"><li>编写应用程序很不方便</li><li>文件设计难以满足多种应用程序的不同要求 → 产生数据冗余</li><li>文件结构的修改导致应用程序修改，应用程序的维护工作量大</li><li>文件系统一般不支持文件的并发访问</li></ol><h4 id="数据库系统">数据库系统</h4><p>DBMS — 管理数据库的软件 → 数据库的<strong>核心</strong></p><p>DBA — 数据库管理员</p><p>数据库系统 — app+DBMS+DBA</p><p>现代 DBMS 的功能：</p><ol type="1"><li>提供高级的数据接口（抽象出物理存储的细节 →物理形式和逻辑形式能够互相映射、GUI、非过程的 sql 语言）</li><li>查询处理和查询优化（性能）</li><li>数据目录管理（包含数据的逻辑属性、存储结构定义、访问、管理的信息）</li><li>并发控制</li><li>恢复功能</li><li>完整性约束检查（数据在<strong>语义</strong>上的约束—完整性约束）</li><li>访问控制</li></ol><blockquote><p>数据管理—如何有效的组织、存储、维护和使用大量的相关数据</p></blockquote><blockquote><p>数据库 — 利用计算机进行数据管理的一种技术</p></blockquote><div class="note "><p><strong>数据库中的数据的性质</strong></p><p>数据库是一个按<strong>数据结构</strong>来存储和管理数据的计算机软件系统。</p><p>与数据文件相比，有如下的优点：</p><ol type="1"><li>数据库中的数据具有数据整体性</li><li>数据库中的数据具有数据共享性<ol type="1"><li>用法不同 -为用户提供不同的数据是图，满足个别用户对于数据结构、数据命名、约束条件的特殊要求</li><li>同时共享 - 不同的用户可以同时存取数据库中的同一个数据</li></ol></li></ol><p>和文件系统相比的主要特点：</p><ol type="1"><li>以数据模型为基础</li><li>数据冗余度小、数据共享度高</li><li>数据和程序之间具有较高的独立性<ol type="1"><li><u>物理独立性</u>：指应用程序对于数据<strong>存储结构（物理结构）</strong>的依赖程度。</li><li><u>逻辑独立性</u>：应用程序对于数据全局<strong>逻辑结构</strong>的依赖程序。</li></ol></li><li>通过 DBMS 实现数据安全性和数据完整性控制</li><li>最小存取单位是数据项</li></ol></div><div class="timeline"><p class='p h2'>数据库系统发展</p><div class="timenode"><div class="meta"><p><p>手工管理数据阶段</p></p></div><div class="body"><ol type="1"><li>不保存大量的数据</li><li>没有软件系统对于数据进行管理</li><li>没有文件的概念<ul><li>数据组成和数据存储过程必须由程序员自行设计</li></ul></li><li>一组数据对应一个程序<ul><li>相同数据重复多</li></ul></li></ol></div></div><div class="timenode"><div class="meta"><p><p>文件系统管理阶段</p></p></div><div class="body"><p>特点：</p><ol type="1"><li>管理的数据以文件的形式存储在计算机的外村中</li><li>文件系统由专门数据管理软件提供有关数据的存取、查询、维护功能</li><li>文件系统的数据文件已经具有对氧化</li><li>文件系统的数据存取是以记录为单位</li></ol><p>缺点：</p><ol type="1"><li>表现<ol type="1"><li>数据冗余度大（Redundancy）</li><li>缺乏程序间的独立性</li></ol></li><li>反映<ol type="1"><li>数据文件为某一特定应用服务，可重复使用率低</li><li>数据的逻辑结构改变时，必须改应用程序，修改文件结构的定义</li><li>反之，应用程序的改变，影响文件数据结构的改变</li></ol></li></ol></div></div></div><h3 id="数据数据模型数据模式">数据、数据模型、数据模式</h3><h4 id="数据">数据</h4><p>对事物描述的符号记录是数据</p><ol type="1"><li>从数据中获取有意义的内容 → 信息</li><li>数据是信息的一种存在形式，通过解释处理才成为有用的信息</li></ol><h4 id="数据模型">数据模型</h4><p>数据模型是用来描述数据的一组<strong>概念</strong>和<strong>定义</strong>，数据库的设计基础是数据模型。</p><blockquote><p>例如：层次模型、网状模型、关系模型等</p></blockquote><ol type="1"><li>数据结构：数据的静态属性 →数据的基本结构、数据间的联系(、数据的约束)</li><li>数据操作：数据的动态属性 → 定义在数据上的操作</li><li>数据约束条件</li></ol><blockquote><p>数据模型应该能自然的反应现实世界、接近现实世界的观察和理解；同时接近数据在计算机中的物理表示，便于实现、减少开销。</p></blockquote><ol type="1"><li>概念数据模型（需求导向）：面向用户的、面向现实世界的数据模型，和DBMS 无关，是用来描述一个单位的概念化结构。<ol type="1"><li>和 DBMS 无关</li><li>需要相关工作人员的参与</li><li>常常用 ER 图表示</li></ol></li><li>逻辑数据模型 — 用户从数据库看到的数据模型<ol type="1"><li>和 DBMS 有关</li><li>关系数据模型是目前最常用的逻辑数据模型</li><li>面向用户 且 面向实现</li></ol></li><li>物理数据模型 —数据的逻辑结构（文件、记录、字段等）不反映存储结构，例如物理块、指针、索引等<ol type="1"><li>和 DBMS 有关、和 OS 和硬件有关</li></ol></li></ol><p>对某一类数据的结构、联系、约束的描述（型的描述），成为<strong>数据模式</strong>。</p><p>例如：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">数据模式：</span><br><span class="line">  <span class="comment">(name, id, gender, birth)</span></span><br><span class="line">数据实例：</span><br><span class="line">  <span class="comment">(yang, 615, male, 2001)</span></span><br></pre></td></tr></table></figure><p>有三级<strong>数据模式</strong>结构：</p><ol type="1"><li>概念模式（逻辑模式）：用<strong>逻辑数据模型</strong>对一个单位的数据的描述— 最基础任务</li><li>外模式 — 对用户用到的数据描述（从概念模式推导） — 逻辑数据模型</li><li>内模式 — 物理数据模型对数据的描述（和内模式相互映射） —物理数据模型</li></ol><p>关系为：</p><ol type="1"><li>概念数据库是物理数据库的逻辑抽象形式。</li><li>物理数据库是概念数据库的具体实现</li><li>用户数据库是概念数据库的子集、是物理数据库子集的逻辑描述</li></ol><div class="timeline"><p class='p h2'>三级数据模型</p><div class="timenode"><div class="meta"><p><p>概念模式</p></p></div><div class="body"><p>包括：</p><ol type="1"><li>数据记录型、数据项的型、记录间联系的描述</li><li>安全性定义、数据库完整性约束、寻址方式等</li></ol><p>目的：</p><ol type="1"><li>减小数据冗余</li><li>实现数据共享</li><li>对所有用户的数据进行综合抽象的全局统一视图</li></ol></div></div><div class="timenode"><div class="meta"><p><p>外模式</p></p></div><div class="body"><p>对于各个用户或程序设计的数据逻辑结构和数据特征的描述。</p><p>设计对于子模式的数据结构、数据域、数据构造规则和数据安全性和完整性等属性的描述。</p><p>优点如下：</p><ol type="1"><li>不必考虑与自己无关的数据，无需了解数据的存储结构，简化用户、程序设计工作</li><li>有利于数据的安全和保密</li><li>有利于数据的独立性和共享性</li></ol></div></div><div class="timenode"><div class="meta"><p><p>内模式和物理数据库</p></p></div><div class="body"><p>对于数据的内部表示、底层描述。</p><p>设计目标：将全局逻辑模式组织称最优的无力模式，提高数据的存取效率，改善系统的性能指标。</p><p>在数据库系统中，只有物理数据库是真实存在的，是存放在外存中的数据文件。</p></div></div></div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">内模式 --&gt; a[概念模式] --&gt; 外模式1 --&gt; 用户1</span><br><span class="line">a--&gt;外模式2--&gt;用户2</span><br><span class="line">a--&gt;外模式3--&gt;用户3</span><br></pre></td></tr></table></figure><p><strong>物理独立性</strong>是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。即，数据在磁盘上怎样存储由DBMS(DataBase Management System数据库管理系统)管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变。</p><p><strong>逻辑独立性</strong>是指用户的应用程序与数据库的逻辑结构是相互独立的，即：</p><ul><li>当数据的逻辑结构改变时，用户程序也可以不变。</li></ul><details ><summary> 数据、数据模型、数据模式区分 </summary>              <div class='content'>              <h4id="数据data数据模型data-model数据模式data-schema区分">数据(data)，数据模型(datamodel)，数据模式(data schema)区分</h4><h5 id="数据">数据</h5><p>数据是对事物描述的符号记录，是信息的存在的一种形式，只有经过解释和处理才能成为有用的信息。</p><p>数据使用数据操作语言(DML)进行修改和访问</p><h5 id="数据模型">数据模型</h5><p>模型是现实世界特征的模拟和抽象。数据模型是现实世界数据特征的抽象，用来描述某种数据的概念和定义。数据模型通常由数据结构、数据操作、完整性约束三部分组成。使用数据模型描述数据时不仅要描述数据本身，还要描述数据之间的联系。其中，三级数据模型分别为：概念数据模型、逻辑数据模型、物理数据模型。</p><ol type="1"><li>数据结构：数据结构是对系统静态特性的描述。常见结构有层次结构、网状结构、关系结构。</li><li>数据操作：数据操作是对系统动态特性的描述。指对数据库中各种对象(型)的实例(值)运行执行的操作的集合，包括操作及有关操作的规则。数据库主要有检索和更新两大类操作，数据模型必须定义这些操作的确切含义、操作符号、操作规则(优先级)以及实现这些操作的语言。</li><li>完整性约束：数据的约束条件是一组完整性规则的集合。完整性规则用以限定符合数据模型的数据库的状态以及状态的变化，以保证数据的正确、有效、相容。</li></ol><h5 id="数据模式">数据模式</h5><p>数据模式是以一定的数据模型对一个单位的类型、结构、及其相互间的关系所进行的描述。</p><p>数据模型有型与值之分，型——框架，值——实例。</p><p>ps:数据模型是描述现实世界数据的手段、工具。数据模式是利用这个手段和工具对具体对象相互间关系所进行的描述。是关于型的描述。数据模型可类比为c 语言，数据模式可类为 c 语言编写的程序。</p><h4 id="数据库的三级模式levels-of-abstraction">数据库的三级模式(levelsof abstraction)</h4><ol type="1"><li>物理模式 physical schema(内模式):表示数据库的存储结构</li><li>逻辑模式 conceptual/logical schema:定义了数据模型的逻辑结构</li><li>外模式 external schema(视图view):对用户所用到的那部分数据的描述</li></ol><p>物理模式、逻辑描述、外模式都存储与数据目录中，是数据目录的最基本内容。DBMS通过数据目录管理和访问数据模式。</p><p>模式使用数据定义语言(DDL)定义。</p><div class="note"><p><strong>数据模式、数据模型</strong></p><p>数据模型是描述数据的手段，而数据模式是用给定的数据模型对具体数据的描述。</p></div><div class="note"><p><strong>三级数据模式、两级数据映像</strong></p><p><strong>两级映像</strong>：</p><ol type="1"><li><strong>外模式/模式映像</strong>。模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。数据库中的同一模式可以有任意多个外模式，对于每个外模式，都存在一个外模式/模式映像，它确定了数据的局部逻辑结构与全局逻辑结构之间的对应关系。例如，在原有的记录型之间增加新的联系，或在某些记录型中增加新的数据项时，由数据库管理员对各个外模式/模式映像作相应改变，这一映像功能保证了数据的局部逻辑结构不变（即外模式保持不变）。由于应用程序是根据数据的局部逻辑结构编写的，所以应用程序不必修改，从而保证了数据与程序间的逻辑独立性。</li><li><strong>模式/内模式映像</strong>。数据库中的模式和内模式只有一个，所以模式/内模式映像是唯一的。它确定了数据的全局逻辑结构与储存逻辑结构之间的对应关系。存储结构变化时，如果采用了更先进的存储结构，由数据库管理员对模式/内模式映像作相应的变化，使其模式仍保持不变，即把存储结构变化的影响限制在模式之下，这使数据的存储结构和存储方法较高地独立于应用程序，通过映像功能保证数据存储结构的变化不影响数据的全局逻辑结构的改变，从而不必修改应用程序，即保证了数据的物理独立性。</li></ol><p><strong>好处</strong>：</p><ol type="1"><li>保证数据独立性。将模式和内模式分开，保证了数据的物理独立性；将外模式和模式分开，保证了数据的逻辑独立性。</li><li>简化了用户接口。按照外模式编写应用程序或输入命令，而不需要了解数据库内部的存储结构，方便用户使用系统。</li><li>有利于数据共享。在不同的外模式下可以有多个用户共享系统中数据，减少了数据冗余。</li><li>有利于数据的安全保密。在外模式下根据需要进行操作，只能对限定的数据操作，保证了其他数据的安全。</li></ol></div>              </div>            </details><h3 id="数据独立性database-independence">数据独立性(databaseindependence)</h3><p>两级数据独立性分别为逻辑数据性和物理独立性，数据独立性表示应用访问数据库时不受数据结构和存储的影响。即在我们修改数据之间的关系和数据的存储方式之后，我们无需对应用进行修改，而只需修改物理模式到逻辑模式及逻辑模式到外模式的映射。(因为应用访问的是外模式下的数据，我们只需保证用户看到的数据库视图不变)</p><div class="note "><p><strong>数据独立性为什么越高越好</strong></p><blockquote><p>要回答独立性具体是什么（物理独立性、逻辑独立性）</p><p>与此同时阐明 独立性的意义即可</p></blockquote><p>总的来说：</p><ol type="1"><li>数据的物理独立性：<ol type="1"><li>数据的存取和程序分离，数据存储结构与存取方法改变不要求修改程序</li><li>使得数据共享成为可能，只要知道数据测存取结构，不同程序可以共用同一个数据文件</li></ol></li><li>数据的逻辑独立性：<ol type="1"><li>数据的使用和数据的逻辑结构分离</li></ol></li></ol><p>数据独立性是指建立在数据的逻辑结构和物理结构分离的基础上，用户以简单的逻辑结构操作数据而无需考虑数据的物理结构，转换工作由数据库管理系统实现。数据独立性分为数据的物理独立和数据的逻辑独立。</p></div></div><h2 id="数据模型-1">数据模型</h2><div class="story post-story"><ol type="1"><li>层次数据模型</li><li>网状数据模型</li></ol><h3 id="关系数据模型">关系数据模型</h3><h4 id="基本概念和定义">基本概念和定义</h4><h5 id="属性域">属性、域</h5><ol type="1"><li>属性（attribute） — 描述事物的特征</li><li>域（domain） — 属性可以取值的范围。</li><li>1NF 的限制 — 所有的域都是原子数据</li><li>有条件的有 NULL 存在</li></ol><h5 id="关系元组">关系、元组</h5><p><span class="math display">\[R=(A_1/D_1, \cdots, A_n /D_n)\]</span></p><p>上式事对于<span class="math inline">\(R\)</span>的型的描述。→ R的模式</p><p><span class="math display">\[r = \{ t_1, t_2 \cdots , t_m\}\]</span></p><p><span class="math inline">\(r\)</span>是 <spanclass="math inline">\(R\)</span> 的一个值。</p><ol type="1"><li>一般来说，关系模式相对稳定、关系的值相对变化</li></ol><h5 id="键">键</h5><p>候选键 candidate key— 唯一决定一个元组的“最小”集合</p><p>超键 superkey — 一个真子集是候选键</p><p>主键 primary key</p><p>全键 all key</p><p>主属性 prime attribute — 包含在任何一个候选键中的属性</p><p>非主属性 non-prime attribute</p><p>外键 foreign key</p><h4 id="约束">约束</h4><p>完整性约束 — 语义限制。一般有四类</p><ol type="1"><li><strong>域完整性约束</strong>（最基本的、最简单的）</li><li>实体完整性约束</li><li>引用完整性约束</li><li>一般完整性约束</li></ol><div class="note "><p><strong>常用的两个完整性约束</strong></p><ul><li>域完整性约束: 插入属性的值是否符合值域</li><li>实体完整性约束: 主键不能为空</li><li>引用完整性约束: 外键要么是空缺的要么是实际存在的主键值</li></ul></div><h4 id="操作">操作</h4><p>关系代数操作— 关系操作。（关系专用、集合操作）</p><ol type="1"><li>选择操作： <span class="math inline">\(\sigma_C(R)\)</span></li><li>投影操作： <span class="math inline">\(\Pi_A(R)\)</span></li><li>集合操作：交并补</li><li>连接操作：连接、等连接、自然连接</li><li>除操作： <span class="math inline">\(R\div S = \Pi _X(R) -\Pi_X(\Pi_X(R) \times S) - R)\)</span></li><li>外连接操作</li><li>外并操作</li></ol><h4 id="关系演算">关系演算</h4><h5 id="元组关系演算">元组关系演算</h5><ol type="1"><li>投影</li><li>选择</li><li>并</li><li>差</li><li>连接</li></ol><p>和关系代数有相同的表达能力 — 关系完备</p><p>基本形式为：</p><p><span class="math display">\[\{t|P(t)\}\]</span></p><p>其中，<span class="math inline">\(t\)</span>为元组变量。</p><p>其中 <span class="math inline">\(P(t)\)</span> 可以由：</p><ol type="1"><li><span class="math inline">\(s\in R,s[A]\text{ op } C,s[A]\text{ op }u[B]\)</span></li><li><span class="math inline">\(\neg P\)</span></li><li><span class="math inline">\(P_1\vee P_2,P_1\wedge P_2\)</span></li><li><span class="math inline">\(\exists t\in R.P(t),\quad \forall t\inR.P(t)\)</span></li></ol><h3 id="对传统数据模型的评价">对传统数据模型的评价</h3><p>继承了文件的字段、记录的概念</p><p>物理级 — 借鉴了文件索引、散列的存取方法 —在记录的基础上定义了各自数据的基本结构，约束和操作</p><p>向用户提供了统一的数据模型和相应的数据库语言。</p><ol type="1"><li>以记录为基础，不能很好的面向用户和应用</li><li>不能以自然的方式表示实体之间的联系</li><li>语义信息贫乏</li><li>数据类型少、难以满足需要</li></ol><h3 id="er-数据模型">ER 数据模型</h3><h4 id="基本概念">基本概念</h4><p>E-R 模型— 实体联系数据模型 → 面向现实世界的，不考虑如何实现</p><p>提出目的：</p><ol type="1"><li>建立一个统一的数据模型来概括三种传统数据模型</li><li>作为三种传统数据模型转换的中间模型</li><li>作为超脱 DBMS 的一种概念数据模型，以比较自然的方式模拟现实世界</li></ol><p>三类抽象概念：</p><ol type="1"><li>实体</li><li>属性</li><li>联系</li></ol><h4 id="er-图">ER 图</h4></div><h2 id="sql">SQL</h2><div class="story post-story"><ul><li>集数据定义语言(DDL),数据操纵语言(DML)，数据控制语言(DCL)功能于一体</li><li>可以独立完成数据库生命周期中的全部活动</li><li>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行</li><li>数据操作符统一</li><li>高度非过程</li><li>面向集合的操作方式</li><li>以同一种语法结构提供多种使用方式</li><li>语言简洁，易学易用</li></ul><h3 id="数据库的用户接口">数据库的用户接口</h3><p>DBMS 需要给用户提供命令和语言 → 非过程性语言 → SQL</p><h3 id="sql-语言概况">SQL 语言概况</h3><p>四个部分：</p><ol type="1"><li>DDL → 数据定义语言</li><li>QL → 查询语言</li><li>DML → 增删改</li><li>DCL → 权限控制</li></ol><h3 id="数据定义语言">数据定义语言</h3><h4 id="术语数据类型">术语、数据类型</h4><p>在 SQL 中，表分为：</p><ol type="1"><li>基表 base table</li><li>视图 view</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line"> (sno <span class="type">char</span>(<span class="number">7</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  sname <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  ...</span><br><span class="line">  height <span class="type">dec</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="keyword">primary</span> key(sno));</span><br><span class="line">注意要写分号</span><br></pre></td></tr></table></figure><h4 id="基表模式的修改">基表模式的修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>[<span class="operator">&lt;</span>creator<span class="operator">&gt;</span>, ...] <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">add</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">add</span> <span class="keyword">primary</span> key (<span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>t1<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">add</span> <span class="keyword">foreign</span> key [<span class="operator">&lt;</span>fk_name<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>)</span><br><span class="line">    <span class="keyword">references</span> <span class="operator">&lt;</span>t2<span class="operator">&gt;</span></span><br><span class="line">      [<span class="keyword">on</span> <span class="keyword">delete</span>&#123;restrict<span class="operator">|</span>cascade<span class="operator">|</span><span class="keyword">set</span> <span class="keyword">null</span>&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sql-查询语言">SQL 查询语言</h3><h4 id="基本-sql-查询">基本 SQL 查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><h4 id="一些例子">一些例子</h4><h5 id="union-操作的实现">Union 操作的实现</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">where</span> c1 <span class="keyword">or</span> c2</span><br></pre></td></tr></table></figure><h5 id="intersect-操作的实现">Intersect 操作的实现</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">where</span> c1 <span class="keyword">and</span> c2</span><br></pre></td></tr></table></figure><h5 id="嵌套查询">嵌套查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span></span><br><span class="line">  (<span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要考虑是否消除非<strong>闭包</strong>运算。</p><h5 id="找出只被-1-个水手预定的船">找出只被 1 个水手预定的船</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> bid</span><br><span class="line"><span class="keyword">from</span> reserves r1</span><br><span class="line"><span class="keyword">where</span> bid <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> bid</span><br><span class="line">  <span class="keyword">from</span> reserves r2</span><br><span class="line">  <span class="keyword">where</span> r2.sid <span class="operator">!=</span> r1.sid);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>只被 1 个预定 iff 对于第一个人，不存在第二个人也预定了这条船</p></blockquote><h5 id="除法">除法</h5><p>用集合差实现：不存在一个船，不被这个人预定。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name</span><br><span class="line"><span class="keyword">from</span> sailors s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">  (<span class="keyword">select</span> b.bid <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span></span><br><span class="line">   <span class="keyword">select</span> r.bid <span class="keyword">from</span> reserves r <span class="keyword">where</span> r.sid <span class="operator">=</span> s.sid)</span><br></pre></td></tr></table></figure><p>不用集合差实现：不存在不被我预定的船</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name</span><br><span class="line"><span class="keyword">from</span> sailors s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">  <span class="keyword">select</span> b.bid</span><br><span class="line">  <span class="keyword">from</span> boats b</span><br><span class="line">  <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.bid <span class="operator">=</span> b.bid <span class="keyword">and</span> r.sid <span class="operator">=</span> s.sid))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="其他的集合比较操作">其他的集合比较操作</h5><ol type="1"><li>EXIST</li><li>IN</li><li>UNIQUE</li><li><op> ANY/ALL</li></ol><h5 id="聚合函数">聚合函数</h5><p>count, sum, avg, max, min</p><h5 id="分组-group-by">分组 GROUP-BY</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">distinct</span>] target<span class="operator">-</span>list</span><br><span class="line"><span class="keyword">from</span> relation<span class="operator">-</span>list</span><br><span class="line"><span class="keyword">where</span> qualification</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">grouping</span><span class="operator">-</span>list</span><br><span class="line"><span class="keyword">having</span> group_qualification</span><br></pre></td></tr></table></figure><p>需要满足：</p><ol type="1"><li>group_qualification 单值</li><li>target-list 必须包含一个 group-list 的子集</li></ol><h5 id="嵌套查询汇总">嵌套查询汇总</h5><p>分为 3 类：</p><ol type="1"><li>标量子查询</li><li>表表达式</li><li>公共表表达式</li></ol><h5 id="递归查询">递归查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> agents(name, salary) <span class="keyword">as</span></span><br><span class="line">  ((<span class="keyword">select</span> name, salary <span class="keyword">from</span> FedEmp</span><br><span class="line">    <span class="keyword">where</span> manager <span class="operator">=</span> &quot;Hover&quot;)</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">   (<span class="keyword">select</span> f.name, f.salary</span><br><span class="line">    <span class="keyword">from</span> agents <span class="keyword">as</span> a, FedEmp <span class="keyword">as</span> f))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实质上是不动点算法</p><h3 id="sql-操纵语言">SQL 操纵语言</h3><h4 id="insert">insert</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(attr<span class="operator">-</span>list) <span class="keyword">values</span> (...)</span><br></pre></td></tr></table></figure><h4 id="delete">delete</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sc</span><br><span class="line">  <span class="keyword">where</span> c;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="update">update</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> xxx</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">new</span><span class="operator">-</span>vals</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><h3 id="视图">视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> xxx</span><br><span class="line">  <span class="keyword">as</span> <span class="operator">&lt;</span><span class="keyword">SQL</span><span class="operator">-</span>statement<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="和表的区别">和表的区别</h4><ol type="1"><li>从基表或其他视图导出的虚表，</li></ol><p>对于查询：原则上可以操作</p><p>对于更新，有三个要求：</p><ol type="1"><li>三个基表的主键都在视图中 → 可以唯一确定构成它的元组</li><li>……</li></ol><h3 id="嵌入式-sql">嵌入式 SQL</h3><p>主要是嵌入式 C 语言</p><h4 id="说明部分">说明部分</h4><p>sql 语句需要用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span></span><br></pre></td></tr></table></figure><p>开头。例如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">  <span class="type">char</span> SNO[<span class="number">7</span>];</span><br><span class="line">  <span class="type">char</span> GIVENSNO[<span class="number">7</span>];</span><br><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="可执行语句">可执行语句</h4><p>例如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL SELECT GRADE</span><br><span class="line">  INTO: GRADE, : GRADEI</span><br><span class="line">  FROM SC</span><br><span class="line">  WHERE SNO=:GIVENSNO AND CNO=:GIVENSNO;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用游标需要下面四条语句</p><h5 id="说明游标">说明游标</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL DECLARE &lt;cursor-name&gt; CURSOR FOR</span><br><span class="line">  SELECT ...</span><br><span class="line">  FROM ...</span><br><span class="line">  WHERE ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="打开游标">打开游标</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL OPEN &lt;cursor-name&gt;;</span><br></pre></td></tr></table></figure><h5 id="取数语句">取数语句</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL FETCH &lt;cursor-name&gt; INTO: hostvar1, hostvar2, ...;</span><br></pre></td></tr></table></figure><h5 id="关闭游标语句">关闭游标语句</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL CLOSE &lt;cursor-name&gt;;</span><br></pre></td></tr></table></figure><h5 id="完整实例">完整实例</h5><p>简单版本：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL DECLARE C1 CURSOR FOR</span><br><span class="line">  SELECT SNO, GRADE</span><br><span class="line">  FROM SC</span><br><span class="line">  WHERE CNO = :GIVENCNO;</span><br><span class="line">EXEC SQL OPEN C1;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line">  EXEC SQL FETCH C1 INTO :SNO, :GRADE, :GRADEI;</span><br><span class="line">  <span class="keyword">if</span> (SQLCA.SQLCODE == <span class="number">100</span>) <span class="comment">// 表示当前游标中的数已经取完</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (SQLCA.SQLCODE &lt; <span class="number">0</span>) <span class="comment">// 出错</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  处理游标</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE C1;</span><br></pre></td></tr></table></figure><p>复杂一些的，打印绩点在 3.5 以上的学生名单：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说明部分</span></span><br><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">char</span> sname[<span class="number">20</span>];</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"><span class="comment">// 游标说明</span></span><br><span class="line">EXEC SQL DECLARE student_cursor CURSOR FOR</span><br><span class="line">    SELECT sname</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE gpa &gt; <span class="number">3.5</span>;</span><br><span class="line"><span class="comment">// 打开游标</span></span><br><span class="line">EXEC SQL OPEN student_cursor;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取数</span></span><br><span class="line">    EXEC SQL FETCH student_cursor INTO :sname;</span><br><span class="line">    <span class="keyword">if</span> (SQLCA.SQLCODE == <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (SQLCA.SQLCODE &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭游标</span></span><br><span class="line">EXEC SQL CLOSE student_cursor;</span><br></pre></td></tr></table></figure><p>几个环节都不能少</p></div><h2 id="数据库管理系统">数据库管理系统</h2><div class="story post-story"><ul><li>基本功能 → 安全可靠的执行数据库语言的语句</li></ul><h3 id="事务">事务</h3><p>事务是 DBMS 的执行单位，它由有限个数据库操作序列组。事务有 ACID性质：</p><ol type="1"><li>原子性（Atomic）：遵守 nothing or all 的原则 — 不允许部分完成</li><li>更新操作的保持一致性（Consistency）：事务对数据库的作用应该让数据库从一个一致状态</li><li>隔离性（Isolation）：如果多个并发的事务执行，应该和各个事务独立执行相同</li><li>持久性（Durability）：成功执行的事务，对数据库的影响是持久的，可恢复的</li></ol><blockquote><p>上述四个性质被称为 ACID 准则</p></blockquote><h3 id="dbms-的进程结构">DBMS 的进程结构</h3><p>以进程为执行者的缺点</p><ol type="1"><li>创建、撤销、切换、通信开销大</li><li>并发运行的进程数量过多 → 系统开销太大 → 性能下降</li><li>不利于事务共享内存空间</li></ol><p>以线程为执行者的优点：</p><ol type="1"><li>按照 DBMS 的需要进行线程调度</li><li>线程切换可以在操作系统的用户态进行，不必进入内核态</li><li>提高可移植性</li></ol></div><h2 id="存储结构">存储结构</h2><div class="story post-story"><h3 id="dmbs-的系统结构">DMBS 的系统结构</h3><ol type="1"><li>集中式</li><li>分布环境下的客户、服务器结构</li><li>Web 下的三层客户、服务器结构</li><li>高可用、高缩放、高性能的数据库系统结构</li></ol><h3 id="数据目录">数据目录</h3><p>数据目录是关于数据的数据 → 元数据</p><p>DBMS的任务是管理大量的、共享的，持久的数据。关于数据的定义、描述必须长期保存在系统中→ 数据目录。</p><p>数据目录中的数据按易变程度可以非为两类：</p><ol type="1"><li>一类来自基表、视图和索引 — 相对稳定</li><li>一类来自数据库状态的统计 — 进程变化</li></ol><h3 id="数据库存储介质的特点">数据库存储介质的特点</h3><blockquote><p>数据库是大量、持久数据的集合</p></blockquote><p>内存/磁盘：</p><ol type="1"><li>容量</li><li>易失存储器</li><li>成本</li></ol><p>磁盘 — 物理存储以块为单位</p><p>延迟写入、预先读取</p><h3 id="记录的存储结构">记录的存储结构</h3><h4 id="物理表示">物理表示</h4><p>记录分为若干的字段、每个字段有一个域、有定长和变长的区别，大致有是那种：</p><ol type="1"><li>定位法</li><li>相对法 — 变长</li><li>计数法 — 变长</li></ol><h4 id="物理块上的分配">物理块上的分配</h4><p>记录必须分配到物理块中：</p><ol type="1"><li>不跨块组织</li><li>跨块组织</li></ol><h4 id="数据压缩">数据压缩</h4><h3 id="文件结构和存取路径">文件结构和存取路径</h3><p>对数据库的操作最重要落实到对于文件的操作。文件的访问方式大致有：</p><ol type="1"><li>查询全部 or 相当多的记录 ≥15%</li><li>查询特定记录</li><li>查询某些记录 — ≤ 15%</li><li>范围查询</li><li>数据更新</li></ol><h4 id="数据库对于文件的要求">数据库对于文件的要求</h4><ol type="1"><li>需要附加信息 — 文件目录、文件描述块、物理块等部分；</li><li>传统的文件系统主要面向批处理。但数据库要求即时访问、动态修改；</li><li>传统文件都是为某一用户或某类用户服务的，用途单一；数据库文件需要被所有用户共享</li><li>采用文件管理系统 → 不利于移植</li><li>传统文件一旦建立，数据稳定；数据库的文件数据量变化大，文件结构应该能适应这样的变化。</li></ol><h4 id="文件的基本类型">文件的基本类型</h4><ol type="1"><li><p>堆文件</p><ol type="1"><li>最简单、最原始的一种文件结构</li><li>不是所有记录都物理邻接</li><li>唯一的存取路径是：顺序搜索（扫描）</li><li>排序费时、需要解决空间回收问题</li></ol></li><li><p>直接文件</p><p>记录的某一个属性用散列函数直接映射成记录的地址，散列的属性称为散列键</p><ol type="1"><li>地址空间固定</li><li>只对于散列键到记录的访问有效</li><li>不便于处理变长记录</li><li>散列函数难找</li></ol></li><li><p>索引文件</p><ol type="1"><li>如果以主键为索引键，则称该索引为主索引</li><li>与此同时更新时也用主索引做主键唯一性检查</li></ol></li></ol><p>主要分为非稠密索引、稠密索引</p><div class="note "><p><strong>索引分类</strong></p><ol type="1"><li>主索引（索引是主键）<ol type="1"><li>按主键排序-非稠密索引</li><li>不按主键排序 - 稠密索引</li></ol></li><li>次索引<ol type="1"><li>簇集索引 - 按索引键排序并簇集，稠密</li><li>非簇集索引 - 不安索引键排序，稠密</li></ol></li></ol></div><div class="note "><p><strong>优缺点</strong></p><ol type="1"><li>提高查询的效率</li><li>更新时，增加了维护的开销。 - 根据应用的要求选择。</li></ol><p>如果在文件的所有属性上都建立索引，则称为<strong>倒排文件</strong>。</p><ol type="1"><li>有利于多属性条件的查找</li><li>数据更新时开销很大</li></ol></div><div class="note "><p><strong>非稠密索引</strong></p><p>不为每个键值都设立索引项的索引称为非稠密索引。</p><p>同一时间，只能为一个索引键（一般是主键）建立非稠密索引。</p><p>当某个单元的存储区溢出，则可以放在溢出区。</p><ol type="1"><li>可以节省索引的存储空间</li><li>要求对于文件按索引键排序</li><li>溢出过多时，指针链接次数增加，性能下降</li></ol></div><div class="note "><p><strong>稠密索引</strong></p><p>记录不按索引键排序，每个键值都有一个索引项。</p><p>如果键值不唯一，那么对应的是一个地址集。</p></div><p>对于次索引，一个键值可能对应多个记录。如果它们分散在不同的物理块中，则索引带来的好处有时是有限的-- 并不能减少io。为了解决这个问题，开发了簇集索引。簇集索引的缺点如下：</p><ol type="1"><li>建立开销大、整个文件都要重新组织，建立的索引也要重建。</li><li>对于和索引键相关的查询有力，对于与簇集索引键无关的访问没有影响。</li></ol><h3 id="动态索引">动态索引</h3><ul><li>静态索引：多分树</li><li>动态索引：B-树、B+树</li></ul><p>索引集的节点结构：</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">节点类型|<span class="string">索引键数</span>|<span class="string">P0</span>|<span class="string">K0</span>|<span class="string">P1</span>|<span class="string">K1</span>|<span class="string">...</span>|<span class="string">Kn-1</span>|Pn</span><br></pre></td></tr></table></figure><p>（主索引）顺序集的节点结构</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">节点类型|<span class="string">索引键数</span>|<span class="string">前向指针</span>|<span class="string">后向指针</span>|<span class="string">K0</span>|<span class="string">tid0</span>|<span class="string">K1</span>|<span class="string">tid1</span>|<span class="string">...</span>|<span class="string">Kn</span>|tidn</span><br></pre></td></tr></table></figure><p>（次索引）顺序集节点结构</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">类型|<span class="string">块中索引键数</span>|<span class="string">前向指针</span>|<span class="string">后向指针</span>|<span class="string">K0</span>|<span class="string">P0</span>|<span class="string">...</span>|<span class="string">Kn-1</span>|<span class="string">Pn-1</span></span><br></pre></td></tr></table></figure><div class="note "><p><strong>P和tid的区别</strong></p><p>这里，由于次索引的一个键值可能对应了<strong>多个TID</strong>，数量可变，所以需要一个块来存放这些 tid（可以组成链表存储）</p></div><p>tid由<code>块号</code>和块中的<code>指针号</code>组成。这样在块中移动的时候不需要修改B+树索引的 tid，只需要修改指针号对应的块内指针。</p><p>B+树有如下的约束：</p><ol type="1"><li>秩为 k 的 B+树每个节点最多有 2k 个键值</li><li>根节点至少有一个键值、其他节点至少有 k 个键值</li><li>除了叶节点（顺序集节点）没有子女外，其他的节点，若有 J个键值，则有(J+1)个子女</li><li>所有叶节点都在树的同一级上（树保持平衡）</li></ol><div class="note "><p><strong>B+树相关计算</strong></p><p>B+树实现的索引都是稠密索引。保证其提供顺序搜索功能。</p><p>搜索 B+树所需 IO 次数取决于级数。</p><p>级数取决于 N（不同的索引键值对数-区别于记录数）。若顺序集为 L 级、秩为k，则顺序集至少有<span class="math inline">(2(k+1)^{L-2})</span>个节点。</p><p><span class="math display">[ N (k+1)^{L-2} k ]</span></p><p>那么对于 L 做估计：</p><p><span class="math display">[ L + <em>{k+1}(N/2k) + </em>{k+1} N / 2]</span></p></div></div><h2 id="查询优化">查询优化</h2><div class="story post-story"><ol start="4" type="1"><li>查询语句 → 查询结果的处理过程 — 查询处理</li><li>DBMS 需要确定一个合理有效的执行策略 — 查询优化</li></ol><p>不同方法：</p><ol type="1"><li>对查询语句本身变换 — 代数优化</li><li>对根据系统所提供的存取路径的优化，选择合理的存取策略 — 物理优化</li></ol><h3 id="代数优化">代数优化</h3><p>基本原则为：</p><ol type="1"><li>尽量所见查询过程中的中间结果</li><li>选择和投影先做 → 二元操作</li><li>连接时先做小关系的连接，再做大关系的连接</li><li>公共表表达式</li></ol><p>具体而言：</p><ol type="1"><li>以 select 子句对应投影操作、From 子句对应笛卡尔成绩、Where子句对应选择操作，生成原始查询树</li><li>应用变换规则：<ol type="1"><li><span class="math inline">\(\sigma\)</span>的交换律</li><li>$_C(RS) = _C(R)S $其中 <span class="math inline">\(Attr(C)\subseteqAttr(R)\)</span></li><li><span class="math inline">\(\sigma_{C_1 \wedge C_2}(R\times S) =\sigma_{C_1}(R)\times \sigma_{C_2}(S)\)</span>其中 <spanclass="math inline">\(Attr(C_1)\subseteq Attr(R)\)</span><spanclass="math inline">\(Attr(C_2)\subseteq Attr(S)\)</span></li><li>交、并、差运算对于 <spanclass="math inline">\(\sigma\)</span>的分配律</li><li>投影和集合并运算的分配律</li></ol></li><li>应用连接和笛卡尔积的结合律，按照小关系先做的原则，重新安排连接的次序</li><li>如果笛卡尔乘积后还需要按照按连接条件进行选择操作，可以将两者组合成连接操作</li><li>对叶节点进行必要的投影操作，消除对于查询无用的属性。</li></ol><h3 id="物理优化-依赖于存取路径的规则优化">物理优化 —依赖于存取路径的规则优化</h3><h4 id="选择操作实现和优化">选择操作实现和优化</h4><p>选择条件有等值、范围、集合之分。</p><ol type="1"><li>最原始的实现方法：<strong>顺序扫描</strong>。</li><li>B+树索引、Hash 散列</li></ol><h4 id="连接操作的实现和优化">连接操作的实现和优化</h4><ol type="1"><li>嵌套循环法：应当将物理块绍的关系作为外关系</li><li>利用索引或散列寻找匹配元组法</li><li>归并排序法：需要 RS 都按照连接属性排序</li><li>散列连接法</li></ol><h4 id="投影操作的实现">投影操作的实现</h4><p>如果在投影的属性集合中没有主键，投影结果中可能出现重复元组 →排序或散列去重</p><h4 id="集合操作的实现">集合操作的实现</h4><p>笛卡尔积一般用嵌套循环法实现 — 少用</p><h4 id="组合操作">组合操作</h4></div><h2 id="事务-1">事务</h2><div class="story post-story"><h3 id="恢复引论">恢复引论</h3><p>主要可能有四类错误：</p><ol type="1"><li><p>事务内部的故障：事务在运行至正常终点前被终止有的是可以由事务程序发现的，有些是非预期的事务终止；事务可以通过rollback修复预期之中故障，更多的故障是非预期的，如运算溢出、死锁</p></li><li><p>系统故障（软故障）：CPU 错误、系统断电等造成的系统运转停止系统故障不破坏数据库，只会造成事务的非正常终止，内存中数据库缓冲区丢失</p><p>系统故障的恢复需要：</p><ol type="1"><li>撤销（undo）所有未完成的事务（事务非正常终止）</li><li>重做（redo）所有已提交的事务（有些已完成的事务可能有部分留在缓冲区尚未写入数据库）</li></ol></li><li><p>介质故障（硬故障）：磁盘损坏、强磁场干扰造成的介质故障</p></li><li><p>计算机病毒</p></li></ol><p>两个措施：</p><ol type="1"><li>可靠性</li><li>故障恢复</li></ol><p>对于恢复：数据<strong>冗余是必须的</strong>。</p><ol type="1"><li><p>单纯以后背副本为基础的恢复技术</p></li><li><p>以<strong>后备副本</strong>和<strong>运行记录</strong>为基础的恢复技术</p><ol type="1"><li>前像 BI — 更新前的映像 — undo</li><li>后像 AI — 更新后的映像 — redo</li><li>事务状态：<ol type="1"><li>提交 commit — 成功执行标志</li><li>消除事务对数据库的影戏那个 — rollback / abort</li></ol></li></ol><p>用的最多、独立失效模式</p></li><li><p>基于多副本的恢复技术 — 独立的失效模式</p></li></ol><h3 id="运行记录的结构">运行记录的结构</h3><p>记录和数据库一般不在一张磁盘上。</p><p>运行记录一般包括：</p><ol type="1"><li>活动事务表 ATL：正在执行、未提交的事务标识符 TID</li><li>提交事务表 CTL：已经提交的事务 TID</li><li>前像文件：<code>undo(undo(..undo(x)..)) = undo(x)</code></li><li>后像文件：<code>redo(redo(..redo(x)..)) = redo(x)</code></li></ol><h3 id="更新事务的执行和恢复">更新事务的执行和恢复</h3><p>更新事务应该满足如下的原则：</p><ol type="1"><li>提交原则：后像必须在事务提交之前写入非易失存储器中</li><li>先记后写规则</li></ol><p>因此有三种可能的解决方案，都可以通过判断所在 ATL 和 CTL的位置来进行恢复。</p><h4 id="ai-在-commit-前写入">AI 在 Commit 前写入</h4><ol type="1"><li>TID→ATL</li><li>BI→log</li><li>AI→DB,log</li><li>TID→CTL</li><li>ATL 删除 TID</li></ol><h4 id="ai-在提交后写入">AI 在提交后写入</h4><ol type="1"><li>TID→ATL</li><li>AI → LOG</li><li>TID → CTL</li><li>AI → DB</li><li>从 ATL 删除 TID</li></ol><h4 id="ai-在提交前后写入">AI 在提交前后写入</h4><ol type="1"><li>TID→ATL</li><li>AI, BI → LOG</li><li>AI → DB（部分）</li><li>TID → CTL</li><li>AI → DB（继续）</li><li>ATL 删除 TID</li></ol><h3 id="消息的处理">消息的处理</h3><h3 id="失效类型和恢复对策">失效类型和恢复对策</h3><h4 id="事务失效">事务失效</h4><ol type="1"><li>事务无法执行、自行夭折（例如没有要访问的数据、输入数据类型不对、除数=0）</li><li>操作员操作失误，撤销事务</li><li>调度原因，终止事务执行（死锁等）</li></ol><p>恢复策略：</p><ol type="1"><li>丢弃事务的消息队列</li><li>如果需要 undo</li><li>从 ATL 删除事务的 TID，删除事务资源</li></ol><h4 id="系统失效">系统失效</h4><ol type="1"><li>掉电</li><li>除了储存介质故障之外的软硬件故障</li></ol><p>策略：</p><ol type="1"><li>重启 DMBS 和操作系统</li><li>恢复到一致状态</li></ol><div class="note "><p><strong>存在的问题-CP的意义</strong></p><p>因为事务可以在提交前和提交后将数据的 AI 分别写入数据库，因此，对于 CTL中的事物只能<strong>全部</strong>redo，很费时间。</p><blockquote><p>虽然可能 CTL 中的很多事务都已经写入，但是鉴别的代价很大</p></blockquote></div><blockquote><p>可以设置检查点 CP，来强制写入已提交但没有更新数据库的后像。</p></blockquote><p>取 CP 的过程一般如下：</p><ol type="1"><li>暂停事务的执行和接受新的事务</li><li>上一个 CP 之后的所有事物 AI 写入数据库</li><li>在运行记录的 CTL 中记下检查点</li><li>恢复数据库、恢复事务的正常运行</li></ol><p>好处：对于<strong>系统失效</strong>恢复，只需要对于最近的检查点之后提交的更新事务进行redo。</p><p>缺点：影响数据库的正常运行。</p><h4 id="介质失效">介质失效</h4><p>磁盘故障导致的数据库受损。</p><p>恢复如下：</p><ol type="1"><li>修复系统、磁盘</li><li>重新启动系统</li><li>加载最近的后备副本</li><li>用档案存储器内<code>运行记录</code>中的 AI，redo后备副本之后的所有更新事务</li></ol><h3 id="并发控制">并发控制</h3><h4 id="数据库系统中的并发">数据库系统中的并发</h4><h4 id="目的">目的</h4><ol type="1"><li>改善利用率和吞吐率</li><li>改善短事务的响应时间</li></ol><h4 id="问题">问题</h4><ol type="1"><li>丢失更新 — 写-写冲突</li><li>读脏数据 — 读-写冲突</li><li>读值不可复现 — 读-写冲突</li></ol><h4 id="正确性原则">正确性原则</h4><dl><dt>调度</dt><dd>对 n 个事务的安排</dd><dt><strong>目标等价</strong></dt><dd>对于同一个事务集，可能有多种调度。如果其中两个调度在任何初始状态下读出的数据相同，最终数据库状态相同，那么称两个调度是目标等价的。</dd></dl><p><strong>冲突等价</strong></p><ol type="1"><li>冲突的操作 — 冲突的操作会影响执行的结果</li><li>不冲突的操作 — 次序可以相互调换，不会影响结果</li></ol><dl><dt><strong>可串行化的</strong></dt><dd>调度和一个串行调度等价</dd></dl><p>冲突可串行化 → 目标可串行化（充分条件）</p><p>一般指冲突可串行化</p><h3 id="加锁协议">加锁协议</h3><h4 id="x-锁">X 锁</h4><p>X-排他锁</p><table><tbody><tr class="odd"><td>请求</td><td>NL</td><td>X</td></tr><tr class="even"><td>X</td><td>y</td><td>n</td></tr><tr class="odd"><td>NL</td><td>y</td><td>y</td></tr></tbody></table><div class="note "><p><strong>连锁卷回问题</strong></p><p>过早的释放了锁，导致了读值不可复现。</p><p>解决方法：锁保持到事务结束</p></div><h4 id="两段加锁">两段加锁</h4><ol type="1"><li>若加锁动作都在所有释放锁之前 — 两段事务</li><li>合式事务 Well-Formed</li></ol><p>若所有事务都是合式、两段事务 → 可串行化的</p><blockquote><p>加锁机制发展- 提高并发控制能力</p></blockquote><blockquote><p>应该规定 FCFS</p></blockquote><h4 id="sx-锁">SX 锁</h4><ul><li>S（Share Lock）用于读访问</li><li>X（eXclusive Lock）用于写访问</li></ul><table><thead><tr class="header"><th>请求</th><th>NL</th><th>S</th><th>X</th></tr></thead><tbody><tr class="odd"><td>S</td><td>y</td><td>y</td><td>n</td></tr><tr class="even"><td>X</td><td>y</td><td>n</td><td>y</td></tr><tr class="odd"><td>NL</td><td>y</td><td>y</td><td>y</td></tr></tbody></table><h4 id="sux-锁">SUX 锁</h4><table><thead><tr class="header"><th>请求</th><th>S</th><th>U</th><th>X</th><th>NL</th></tr></thead><tbody><tr class="odd"><td>S</td><td>y</td><td>y</td><td>n</td><td>y</td></tr><tr class="even"><td>U</td><td>y</td><td>n</td><td>n</td><td>y</td></tr><tr class="odd"><td>X</td><td>n</td><td>n</td><td>n</td><td>y</td></tr><tr class="even"><td>NL</td><td>y</td><td>y</td><td>y</td><td>y</td></tr></tbody></table><p>注意 U-U 是不允许的，因为会导致死锁问题。</p><div class="note "><p><strong>是否SUX锁能保证没有死锁</strong></p><p>不能，需要有正确的锁顺序。例如：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">A: <span class="constructor">X(<span class="params">a</span>)</span> -&gt; <span class="constructor">S(<span class="params">b</span>)</span></span><br><span class="line">B: <span class="constructor">X(<span class="params">b</span>)</span> -&gt; <span class="constructor">S(<span class="params">a</span>)</span></span><br></pre></td></tr></table></figure><p>发生循环等待。</p><p>可以用相同的加锁顺序来防止死锁发生。</p></div><h3 id="死锁的检测处理和防止">死锁的检测处理和防止</h3><ol type="1"><li>检测、处理<ol type="1"><li>超时法</li><li>等待图法</li></ol></li><li>防止<ol type="1"><li>等待死亡法</li><li>击伤等待法</li></ol></li></ol></div><h2 id="关系数据库规范化">关系数据库规范化</h2><div class="story post-story"><h3 id="规范化的必要性">规范化的必要性</h3><p>基本要求：</p><ol type="1"><li>满足 1NF：每一个分量必须是不可分的数据项</li><li>数据库中的数据冗余尽可能少</li><li>不能因为数据更新导致数据不一致的问题</li><li>不能在执行插入时发生插入一场</li><li>不能在执行删除时产生删除一场问题</li><li>考虑查询需求，数组组织合理</li></ol><p>可能出现的问题：</p><ol type="1"><li>数据冗余大</li><li>插入一场</li><li>删除异常</li><li>更新异常</li></ol><h3 id="关系表示法">关系表示法</h3><p>关系的简化表示法：</p><p><span class="math display">\[R\langle U,D,Dom,F\rangle\]</span></p><p>分别表示：</p><ol type="1"><li>关系属性集合<span class="math inline">\(U\)</span></li><li>属性集<span class="math inline">\(U\)</span>中属性的数据域</li><li><span class="math inline">\(Dom\)</span>为从属性到域的映射</li><li><span class="math inline">\(F\)</span> 为函数依赖集</li></ol><h3 id="范式">范式</h3><dl><dt>1NF</dt><dd>所有属性都是简单属性（每个属性都不可再分）</dd><dt>2NF</dt><dd>1NF 的前提下，每一个非主属性都完全依赖于<strong>码</strong>。</dd><dt>3NF</dt><dd>2NF 前提下，不存在这样的码 X、属性组 Y、非主属性 Z，使得 X<spanclass="math inline">\(\rightarrow\)</span>Y，Y<spanclass="math inline">\(\not\rightarrow\)</span>X，Y<spanclass="math inline">\(\rightarrow\)</span>Z。</dd><dt>BCNF</dt><dd>满足如下条件</dd></dl><ol type="1"><li>非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码是完全依赖</li><li>没有任何属性依赖于非码的任何一组属性</li></ol><h3 id="关系模式分解方法">关系模式分解方法</h3><dl><dt>函数依赖闭包</dt><dd>逻辑蕴含的函数依赖全体（从 <span class="math inline">\(F\)</span> 到<span class="math inline">\(F^+\)</span>）</dd><dt>属性集闭包</dt><dd>对<span class="math inline">\(X\)</span>，从<spanclass="math inline">\(F\)</span>中能够推出的属性集<spanclass="math inline">\(X_F^+\)</span></dd><dt>函数依赖集的等价</dt><dd>闭包相等</dd></dl><h4 id="函数依赖集的最小化">函数依赖集的最小化</h4><dl><dt>最小依赖集</dt><dd>满足如下条件</dd></dl><ol type="1"><li>F 中的任一函数依赖的右部只有 1 个属性</li><li>不存在函数依赖<span class="math inline">\(X\rightarrowA\)</span>使得<span class="math inline">\(F\sim F-\{X\rightarrowA\}\)</span></li><li>不存在函数依赖<span class="math inline">\(X\rightarrowA\)</span>，<span class="math inline">\(X\)</span>有真子集<spanclass="math inline">\(Z\)</span>使得<spanclass="math inline">\(F-\{X\rightarrow A\}\cup\{Z\rightarrow A\}\simF\)</span></li></ol><div class="note "><p><strong>最小依赖集的求法</strong></p><ol type="1"><li>检查函数依赖，对于条件 1 拆分</li><li>逐个检查函数依赖<span class="math inline">(X A)</span>，检查条件2，若<span class="math inline">(A X_{F-{XA}}^+)</span>则从 F中消除这个依赖</li><li>逐个检查函数依赖<span class="math inline">(X A)</span>，对于<spanclass="math inline">(X=B_1 B_m)</span>，若<span class="math inline">(A(X-B_i)^+_F)</span>那么用<spanclass="math inline">(X-B_i)</span>取代<spanclass="math inline">(X)</span></li></ol></div><dl><dt>码</dt><dd>设 <span class="math inline">\(R\langle A_1, ..., A_n\rangle\)</span>是一个关系模式，<span class="math inline">\(F\)</span>是一组函数依赖，如果 X 满足：（1）<spanclass="math inline">\(X\rightarrow A_1,...,A_n \inF^+\)</span>（2）真子集 Y 都不满足（1）条件；那么称 X 是 R 的码。</dd></dl><h4 id="算法">算法</h4><div class="note "><p><strong>转化为保持函数依赖的3nf</strong></p><ol type="1"><li>先求出正则覆盖 Fc</li><li>对于 Fc 里面的所有函数依赖 a-&gt;b,均转化为 Ri=ab</li><li>对于所有的模式 Ri<ol type="1"><li>如果包含候选码，进行第 4</li><li>如果都不包含候选码， 将任意一个候选码添加到模式 Ri 里面</li></ol></li><li>如果一个模式被另一个模式包含，则去掉此被包含的模式。</li></ol></div><div class="note "><p><strong>转化为无损链接、保持函数依赖的3nf</strong></p><ol type="1"><li>求出保持函数依赖的3nf分解 <span class="math inline">()</span>，设 X 是 R的码，<spanclass="math inline">(= { R ^*X, F_X})</span></li><li>观察新组成的分解模式中，是否存在包含关系，有则去掉被包含的。</li></ol></div><details ><summary> 例题 </summary>              <div class='content'>              <p>【例】关系模型R&lt; U, F&gt;，U={A，B，C，D，E}，F={A→BC，ABD→CE，E→D}</p><p><strong>算法一</strong>：将关系R转化3NF的保持函数依赖的分解</p><p>第一步：首先计算出F的最小依赖集（算法详见最小函数依赖），得到F'={A→BC，AD→E，E→D}。</p><p>第二步：观察U中是否有属性不在F'中的出现，如果有，则这个个属性组成一对关系R,并在原来的U中删除这些属性。而例子中U中的属性都出现在F中，则可以跳过这一步。</p><p>第三步：对F'中的函数依赖，把左边的相同分为一组，一组中出现的所有属性为一个关系。如F={A→B，A→C，……}，左边都为A的分为一组，出项的所有属性组为一个关系R{A，B，C，……}。例题中左边都不相同，所以一个函数依赖组为一个关系得到转化为3NF的保持依赖分解R1{A,B,C}，R2{A,D,E}，R3{E,D}。</p><p><strong>算法二</strong>：将关系R转化3NF的既有无损连接性又保持函数依赖的分解</p><p>第一步：先将R转化3NF的保持函数依赖的分解，由算法一得出R1{A,B,C}，R2{A,D,E}，R3{E,D}。</p><p>第二步：求出F的候选码（算法相见候选码算法）得出候选码X为AD和AE。</p><p>第三步：将候选码单独组成关系得R4{A,D}和R5{A,E}，然后与保持函数依赖后的分解取并集。得R1{A,B,C}，R2{A,D,E}，R3{E,D}，R4{A,D}，R5{A,E}。</p><p>第四步：观察新组成的分解模式中，是否存在包含关系，有则去掉被包含的。如R3{E,D}，R4{A,D}，R5{A,E}都包含于R2{A,D,E}，则删去，最终得到转化3NF的既有无损连接性又保持函数依赖的分解R1{A,B,C}，R2{A,D,E}。</p>              </div>            </details><div class="note "><p><strong>转换为BCNF无损分解</strong></p><ol type="1"><li>let <span class="math inline">(= RU , F )</span></li><li>检查 <span class="math inline">()</span> 是否满足BCNF</li><li>对于不满足BCNF的 Ri 分解，因为Ri中必然有 <spanclass="math inline">(XAF_i,AX)</span>且X不是Ri的码，XA是Ui的真子集。Ri分解为 <spanclass="math inline">({S_1, S _ 2})</span>，<spanclass="math inline">(U_{S_1} = XA, U_{S_2} = U_i-{A})</span>返回2</li></ol></div></div><h2 id="题目汇总">题目汇总</h2><div class="story post-story"><div class="note "><p><strong>B+树计算</strong></p><p>假设物理块的有效大小 B=492 字节，块的指针为 6 字节，Sailors 表的 sid属性 2 字节，sname 占 4 字节，rating 占 1 字节，age 占 1 字节，master 占2 字节。每个记录除属性外，还需增加一个字节作为删除标记。</p><ol type="1"><li><p>若 Sailors 表的 rating 属性上建有 B+树簇集索引，求 B+树的秩 k？（6 分）</p><p>索引集 ： 2k * 1 (K) + (2k+1)* 6 (P) ≤ 492</p><p>顺序集 ： 2k * 1 (K) + 2 * 6 (前后向指针) + 2k * 6 (P 因为是次索引) ≤492</p></li><li><p>若 Sailors 表的 sid 属性上建有 B+树的主索引，求 B+树的秩 k？（6 分）</p><p>索引集 ： 2k * 2 + (2k + 1)* 6 ≤ 492</p><p>顺序集 ： 2k * 2 (K) + 2 * 6 (前后向指针) + 2k * (6+2) (tid= P +块内偏移值 = 6+2，因为是主索引、块有效大小为 492，需要 2B作为块内偏移值) ≤ 492</p></li><li><p>数据块的块因子是指一个块能够存放的记录数目：p = B/(2+4+1+1+2+1) = 492/11= 44</p></li></ol></div><div class="note "><p><strong>触发器</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> <span class="operator">&lt;</span>trigger_name<span class="operator">&gt;</span></span><br><span class="line">&#123;before <span class="operator">|</span> after&#125; <span class="operator">&lt;</span>trigger_event<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">referencing</span> <span class="operator">&lt;</span>ref_name<span class="operator">&gt;</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> &#123;<span class="type">row</span> <span class="operator">|</span> statement&#125;</span><br><span class="line"><span class="keyword">when</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>action<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>trigger_event<span class="operator">&gt;</span>:<span class="operator">=</span> <span class="keyword">insert</span> <span class="operator">|</span> <span class="keyword">update</span> <span class="operator">|</span> <span class="keyword">delete</span> [<span class="keyword">of</span> <span class="operator">&lt;</span>attribute_list<span class="operator">&gt;</span>]</span><br><span class="line"><span class="operator">&lt;</span>ref_name<span class="operator">&gt;</span> :<span class="operator">=</span> <span class="keyword">old</span> [<span class="type">row</span>] [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br><span class="line">              <span class="keyword">new</span> [<span class="type">row</span>] [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br><span class="line">              <span class="keyword">old</span> <span class="keyword">table</span> [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br><span class="line">              <span class="keyword">old</span> <span class="keyword">table</span> [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>其中的<code>action</code>常为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span></span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ne</span><br><span class="line">    <span class="keyword">where</span> ne.grade <span class="operator">&lt;</span> <span class="number">3.0</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><p>其中的 insert 语句的语法为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">values</span> (...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">    [<span class="keyword">SQL</span>]</span><br></pre></td></tr></table></figure><p>其中的<code>[SQL]</code>部分为一个查询语句，它导致插入可能不止一个元组。</p></div><div class="timeline"><p class='p h2'>概念题</p><div class="timenode"><div class="meta"><p><p>什么是基本表?什么是视图?两者的区别和联系是什么?</p></p></div><div class="body"><p>基本表是实际存储在数据库中的二维表，它是本身独立存在的表，在 SQL中一个关系就对应一个表。</p><p>区别:视图是从一个或几个基本表(或视图)中导出的表，是一个虚表，数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。</p><p>视图是关系数据库系统提供给用户以多种角度观察数据库中数据的重要机制。</p></div></div><div class="timenode"><div class="meta"><p><p>什么叫数据与程序的物理独立性?什么叫数据与程序的逻辑独立性?</p></p></div><div class="body"><p>数据与程序的物理独立性是指当数据库的存储结构改变，将模式 /内模式映象作相应改变，使模式保持不变，从而应用程序不必改变。</p><p>数据与程序的逻辑独立性是指当模式改变时，将外模式 /模式的映象作相应改变，使外模式保持不变，从而应用程序不用修改。</p></div></div><div class="timenode"><div class="meta"><p><p>事务所具有的 ACID 特性。</p></p></div><div class="body"><p>事务的 ACID 特性是:</p><ul><li>原子性:事务是一个不可分割的单位。</li><li>一致性:事务对数据库操作的结果是将数据库从一个一致性状态变为另一个一致性状态。</li><li>隔离性:多个事务的并发执行不互相干扰。</li><li>持续性:事务一旦提交，它对数据库中数据的改变就是永久性的。</li></ul></div></div><div class="timenode"><div class="meta"><p><p>登记日志文件时为什么必须先写日志文件，后写数据库?</p></p></div><div class="body"><p>答:把数据的修改写到数据库和把对数据的修改操作写到日志文件是两个不同的操作，在两个操作之间可能会发 生故障如果先写了数据库修改，而在日志文件中没有登记这个修改， 在恢复的时候就无法恢复这个修改了;如果先写日志，但没有修改数据库，按日志恢复时只是多执行一次撤消操作，并不影响数据库的正确性，为了安全，一定要先写日志文件。</p></div></div><div class="timenode"><div class="meta"><p><p>DBMS的完整性控制机制应具有哪些功能?</p></p></div><div class="body"><p>应具有三方面的功能:</p><ol type="1"><li>定义功能，提供定义完整性条件的机制</li><li>检查功能，检查用户发出的操作请求是否违背了完整性约束条件。</li><li>如果发现用户的操作请求违背了完整性约束条件，则采取一定的动作来保证数据的完整性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>什么是数据字典?数据字典的作用是什么?</p></p></div><div class="body"><p>数据字典是系统中各类数据描述的集合</p><p>作用:供 DBMS 在处理数据存取时快速查找有关对象的信息，供 DBA查询掌握系统的运行情况，支持数据库 设计和系统分析。</p></div></div><div class="timenode"><div class="meta"><p><p>什么样的并发调度是正确的调度?</p></p></div><div class="body"><p>多个事务的并发执行的结果与按某一次序串行的执行它们时的结果相同，我们说这样的并发调度是可串行化的调度，如果一个调度是可串行化的，那么认为它是正确的调度。</p></div></div><div class="timenode"><div class="meta"><p><p>试叙述事务的 4个性质，并结实每一个性质由DBMS的哪个子系统实现?每一个性质对DBS有什么益处?</p></p></div><div class="body"><ol type="1"><li>事务的原子性是指一个事务对 DB的所有操作，是一个不可分割的工作单位。原子性是由 DBMS的事务管理子系统实现的。事务的原子性保证了 DB 的完整性。</li><li>事务的一致性是指数据不会因事务的执行而遭受破坏。事务的一致性是由DBMS 的完整性子系统实现的。 事务的一致性保证数据库的完整性。</li><li>事务的隔离性是指事务的并发执行与这些事务单独执行时结果一样。事务的隔离性是由DBMS的并发控制子系统实现的。隔离性使并发执行的事务不必关心其他事务，如同在单用户环境下执行一样。</li><li>事务的持久性，是指事务对 DB 的更新应永久地反映在 DB 中。持久性是由DBMS 的恢复管理子系统实现的。 持久性能保证 DB 具有可恢复性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>事务的COMMIT语句和ROLLBACK语句的功能是什么?</p></p></div><div class="body"><ul><li>COMMIT 语句表示事务执行成功地接结束(提交)，此时告诉系统，DB要进入一个新的正确状态，该事务对 DB 的所有更新都已交付实施(写入磁盘)。</li><li>ROLLBACK语句表示事务执行不成功地结束(应该“回退”)此时告诉系统，已发生错误，DB可能处在不正确的状态，该事务对 DB 的所有更新必须被撤消，DB应恢复该事务到初始状态。</li></ul></div></div><div class="timenode"><div class="meta"><p><p>日志文件中记载了哪些内容?</p></p></div><div class="body"><p>答:日志文件中记载了事务开始标记、事务结束标记以及事务对 DB的插入、删除和修改的每一次操作前后的值。</p></div></div><div class="timenode"><div class="meta"><p><p>并发操作会产生几种不一致情况?用什么方法避免各种不一致的情况?</p></p></div><div class="body"><p>答:并发操作可能会产生丢失修改，不能重复读和读”脏”数据这三种不一致情况，采用封锁机制来进行并发控制，可避免各种不一致情况。一级封锁协议可以避免丢失修改，二级封锁协议可以避免丢失修改和读”脏”数据，三级封锁协议可以避免丢失修改、不能重复读和读”脏”数据。</p></div></div><div class="timenode"><div class="meta"><p><p>X封锁与S封锁有什么区别?</p></p></div><div class="body"><table><colgroup><col style="width: 38%" /><col style="width: 61%" /></colgroup><thead><tr class="header"><th>X 锁</th><th>S 锁</th></tr></thead><tbody><tr class="odd"><td>只允许一个事务独锁数据</td><td>允许多个事务并发 S 锁某一数据</td></tr><tr class="even"><td>获准 X 锁的事务可以修改数据</td><td>获准 S 锁的事务只能读取数据，但不能修改数据</td></tr><tr class="odd"><td>事务的并发度低</td><td>事务的并发度高，但增加了死锁的可能性</td></tr><tr class="even"><td>X 锁必须保留到事务终点</td><td>根据需要，可随时解除 S 锁</td></tr><tr class="odd"><td>解决“丢失更新”问题</td><td>解决“读不一致性”问题</td></tr></tbody></table></div></div><div class="timenode"><div class="meta"><p><p>为什么要设立日志文件</p></p></div><div class="body"><p>答:设立日志文件的目的，是为了记录对数库中数据的每一次更新操作，从而DBMS可以根据日志文件进行事务故障的恢复和糸统故障的恢复，并可结合后授副本进去介质故障的恢复。</p></div></div><div class="timenode"><div class="meta"><p><p>怎样进行系统故障的恢复?</p></p></div><div class="body"><p>系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤消故障发生时未完成的事务，重做已完成的事务。</p><ol type="1"><li>正向扫描日志文件(即从头扫描日志文件)，找出在故障发生前已经提交的事务(这些事务既有BEGIN TRANSACTION 记录，也有 COMMIT 记录)，将其事务标识记入重做(REDO)队列。同时找出故障发生时尚未完成的 事务(这些事务只有 BEGINTRANSACTION 记录，无相应的 COMMIT 记录)，将其事务标识记入撤消(UNDO)队列。</li><li>对撤消队列中的各个事务进行撤消 (UNDO)处理。进行 UNDO处理的方法是，反向扫描日志文件，对每个 UNDO 事务的更新操作执行逆操作，即将日志记录中 “更新前的值”写入数据库。</li><li>对重做队列中的各个事务进行重做 (REDO)处理。进行 REDO 处理的方法是:正向扫描日志文件， 对每个 REDO 事务重新执行日志文件登记的操作。即将日志记录中“更新后的值”写入数据库。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行介质故障的恢复?</p></p></div><div class="body"><p>发生介质故障后，磁盘上的物理数据和日志文件被破坏，恢复方法是重装数据库，然后重做已完成的事务。具体地说就是:</p><ol type="1"><li>装入最新的数据库后备副本 (离故障发生时刻最近的转储副本)，使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还须同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法(即REDO+UNDO)，才能将数据库恢复到一致性状态。</li><li>装入相应的日志文件副本(转储结束时刻的日志文件副本)，重做已完成的事务。即:首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>数据库在运行过程中可能产生的故障有哪几类?</p></p></div><div class="body"><ol type="1"><li><p>事物故障</p><p>事物在运行过程中由于种种原因，如输入数据的错误，运算溢出，违反了某些完整性限制，某些应用程序的错误，以及并行事物发生死锁等，使事物未能运行到正常中指点之前就被撤消了，这种情况称为“事物故障”。</p></li><li><p>系统故障</p><p>系统故障是指系统在运行过程中，由于某些原因，如 OS 和 DBMS代码错误，操作员操作事物。特定类型的硬件错误(CPU故障)，突然停电等造成系统停止运行，致使事物在执行过程中以非控方式中指。这时。内存中的信息丢失，而存储在外存储上的数据未受影响，这种情况称为“系统故障”。</p></li><li><p>介质故障</p><p>系统在运行过程中，由于某种硬件故障，如磁盘损坏，磁头碰撞，或由于 OS的某种潜在的错误。瞬间强磁场干扰，使存储在外存的数据部分损失或全部损失，称之为“介质故障”。</p></li><li><p>计算机病毒</p><p>计算机病毒是一种人为的故障和破坏，它是一种计算机程序，通过读写染有病毒的计算机系统中的程序和数据这些病毒可以迅速繁殖和传播，危害计算机系统和数据库。</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行事务故障的恢复</p></p></div><div class="body"><p>事务故障是指事务在运行至正常终止点前被中止，这时恢复子系统应利用日志文件撤消(UNDO)此事务已对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。系统的恢复步骤是:</p><ol type="1"><li>反向扫描文件日志(即从最后向前扫描日志文件)，查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。这样，如果记录中是插入操作，则相当于做删除操作(因此时“更新前的值”为空)。若记录中是删除操作，则做插入操作，若是修改操作，则相当于用修改前值代替修改后值。</li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。 (4)如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述文件系统与数据库系统的区别和联系</p></p></div><div class="body"><p>文件系统与数据库系统的区别是:</p><ol type="1"><li>文件系统面向某一应用程序，共享性差，冗余度大，数据独立性差，记录内有结构，整体无结构，由应用程序自己控制。</li><li>数据库系统面向现实世界， 共享性高， 冗余度小，具有较高的物理独立性和一定的逻辑独立性，整体结构化，用数据模型描述，由数据库管理系统提供数据的安全性、完整性、并发控制和恢复能力。</li></ol><p>文件系统与数据库系统的联系:</p><ol type="1"><li>文件系统与数据库系统都是计算机系统中管理数据中管理数据的软件。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>DBA的职责是什么?</p></p></div><div class="body"><ol type="1"><li>决定数据库中的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据的安全性要求和完整性约束条件</li><li>监控数据库的使用和运行</li><li>数据库的改进和重组重构</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述查询优化的一般步骤。</p></p></div><div class="body"><ol type="1"><li>把查询转换成某种内部表示</li><li>把语法树转换成标准(优化)形式</li><li>择低层的存取路径</li><li>生成查询计划，选择代价最小的</li></ol></div></div><div class="timenode"><div class="meta"><p><p>数据库中为什么要有恢复子系统?它的功能是什么?</p></p></div><div class="body"><p>因为计算机系统中硬件的故障、软件的错误、操作员的失误以及恶意的破坏是不可避免的，这些故障轻则造成运行事务非正常中断，影响数据库中数据的正确性，重则破坏数据库，使数据库中全部或部分数据丢失。</p><p>功能:</p><ul><li>是把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)，这就是数据库的恢复。</li></ul></div></div><div class="timenode"><div class="meta"><p><p>数据库转储的意义是什么?常用的有几种方法?</p></p></div><div class="body"><p>数据转储是数据库恢复中采用的基本技术，所谓转储即 DBA定期将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本或后援副本。当数据库遭到破坏后可以将后备副本重新载入，将数据库恢复到转储时的状态。</p><p>转储可分为静态转储和动态转储。静态转储是在系统中无运行事务时进行的转储操作。动态转储是指转储期间允许对数据库进行存取或修改。即转储和用户事务可以并发执行。转储还可分为海量转储和增量转储两种方式。</p></div></div><div class="timenode"><div class="meta"><p><p>试述使用检查点方法进行恢复的步骤。</p></p></div><div class="body"><ol type="1"><li><p>从重新开始文件中找到追后一个检查点记录在日志文件中的地址，由该地址在体制文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列:</p><ol type="1"><li>UNDO-LIST:需要执行 undo 操作的事务集合;</li><li>REDO-LIST 需要执行 redo 操作的事务集合。</li></ol><p>把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列， REDO 队列暂时为空。</p></li><li><p>检查点开始正向扫描日志文件:</p><ol type="1"><li>如果有新开始的事务 Ti ，把 Ti 暂时放入 UNDO-LIST 队列;</li><li>如有提交的事务 T j ，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST队列，直到日志文件结束;</li></ol></li><li><p>对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST中的每个事务执行 REDO 操作。</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>什么是数据库镜像?它有什么用途?</p></p></div><div class="body"><p>根据 DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS 自动把更新后的数据恢复过去，即 DBMS自动保证镜像数据与主数据的一致性。 用途:</p><ol type="1"><li>一旦出现介质故障， 可由镜像磁盘继续提供使用， 同时 DBMS自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本。</li><li>在没有出现故障时，数据库镜像还可以并发操作。提高数据库的可用性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>请给出预防死锁的若干方法。</p></p></div><div class="body"><p>在数据库中，产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。</p><p>预防死锁通常有两种方法:</p><ol type="1"><li>一次封锁法。一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。</li><li>顺序封锁法。顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>请给出检测死锁发生的方法，当发生死锁后如何解决死锁?答:一般使用超时法或事务等待图法。</p></p></div><div class="body"><ol type="1"><li>超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显。一是有可能误判死锁，事务因为其他原因使等待时间超过时限， 系统会误认为发生了死锁。二是时限若设置得太长， 死锁发生后不能及时发现。</li><li>等待图法：事务等待图是一个有向图 G=(T,U) 。 T为结点的集合，每个结点表示正运行的事务; U 为边的集合，每条边表示事务等待的情况。若 T1 等待 T2 , 则 T1、T2 之间划一条有向边，从 T1指向 T2。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地(比如每隔 1分钟)检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。</li></ol><p>DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务得以继续运行下去。当然，对撤消的事务所执行的数据修改操作必须加以恢复。</p></div></div><div class="timenode"><div class="meta"><p><p>试述两段锁协议的概念。</p></p></div><div class="body"><p>所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。</p><ol type="1"><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁;</li><li>在释放一个封锁之后，事务不再申请和获得对该数据的封锁。</li></ol><p>所谓“两段”锁的含义是，事务分为两个阶段，第一阶段是获得封锁，也称为扩展阶段。在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这个阶段，事务可以释放任何数据项上的任何类型锁，但是不能再申请任何锁。</p></div></div><div class="timenode"><div class="meta"><p><p>什么是数据库的完整性约束条件?</p></p></div><div class="body"><p>答:完整性约束条件是指数据库中的数据应满足的语义约束条件。一般可以分为六类:</p><ol type="1"><li>静态列级约束</li><li>静态元组约束</li><li>静态关系约束</li><li>动态列级约束</li><li>动态元组约束</li><li>动态关系约束</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试说明数据、数据库、数据库管理系统和数据库系统的概念以及它们之间的关系。</p></p></div><div class="body"><ol type="1"><li>数据(Data)：描述事物的符号记录称为数据。数据的种类有数字、文字、图形、图像、声音、正文等。数据与其语义是不可分的。</li><li>数据库(Database, 简称DB)：数据库是长期储存在计算机内的、有组织的、可共享的数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。</li><li>数据库系统(Database System，简称DBS)：数据库系统是指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统(及其开发工具) 、应用系统、数据库管理员构成。</li><li>数据库管理系统（ Database Management System，简称 DBMS)：数据库管理系统是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据、高效地获取和维护数据。DBMS的主要功能包括数据库的建立和维护功能、数据定义功能、数据组织存储和管理功能、数据操作功能、事务的管理和运行功能。</li></ol><p>它们之间的联系：数据库系统包括数据库、数据库管理系统、应用系统、数据库管理员，所以数据库系统是个大的概念。数据库是长期存储在计算机内的有组织、可共享的大量的数据集合，数据库管理系统是由管理员操作管理数据库的查询、更新、删除等操作的，数据库应用系统是用来操作数据库的。</p></div></div><div class="timenode"><div class="meta"><p><p>比较用文件管理和用数据库管理数据的主要区别。</p></p></div><div class="body"><p>数据库系统与文件系统相比实际上是在应用程序和存储数据的数据库之间增加了一个系统软件，即数据库管理系统，使得以前在应用程序中由开发人员实现的很多繁琐的操作和功能，都可以由这个系统软件完成，这样应用程序不再需要关心数据的存储方式，而且数据的存储方式的变化也不再影响应用程序。而在文件系统中，应用程序和数据的存储是紧密相关的，数据的存储方式的任何变化都会影响到应用程序，因此不利于应用程序的维护。</p></div></div><div class="timenode"><div class="meta"><p><p>解释数据模型的概念，为什么要将数据模型分成两个层次？</p></p></div><div class="body"><p>数据模型是对现实世界数据特征的抽象。数据模型一般要满足三个条件：第一是数据模型要能够比较真实地模拟现实世界；第二是数据模型要容易被人们理解；第三是数据模型要能够很方便地在计算机上实现。由于用一种模型同时很好地满足这三方面的要求在目前是比较困难的，因此在数据库系统中就可以针对不同的使用对象和应用目的，采用不同的数据模型。根据模型应用的不同目的，将这些模型分为概念层数据模型和组织层数据模型两大类，以方便对信息的描述。</p></div></div><div class="timenode"><div class="meta"><p><p>数据库系统包含哪三级模式？试分别说明每一级模式的作用？</p></p></div><div class="body"><p>数据库系统包含的三级模式为：内模式、模式和外模式。外模式是对现实系统中用户感兴趣的整体数据结构的局部描述，用于满足不同数据库用户需求的数据视图，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是对数据库整体数据结构的子集或局部重构。模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。内模式是对整个数据库的底层表示，它描述了数据的存储结构。</p></div></div><div class="timenode"><div class="meta"><p><p>数据库系统的两级映像的功能是什么？它带来了哪些功能？</p></p></div><div class="body"><p>数据库系统的两级映像是外模式／模式映像和模式／内模式映像。模式／内模式映像定义了概念视图和存储的数据库的对应关系，它说明了概念层的记录和字段在内部层次怎样表示。如果数据库的存储结构改变了，那么，必须对模式／内模式映像进行必要的调整，使模式能够保持不变。外模式／模式映像定义了特定的外部视图和概念视图之间的对应关系，当概念模式的结构可发生改变时，也可以通过调整外模式／模式映像间的映像关系，使外模式可以保持不变。</p></div></div><div class="timenode"><div class="meta"><p><p>什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？</p></p></div><div class="body"><p>数据与程序的物理独立性是指当数据库的存储结构改变，将模式/内模式映象作相应改变，使模式保持不变，从而应用程序不必改变。数据与程序的逻辑独立性是指当模式改变时，将外模式/模式的映象作相应改变，使外模式保持不变，从而应用程序不用修改。</p></div></div><div class="timenode"><div class="meta"><p><p>数据库三级模式划分的优点是什么？它能带来哪些数据独立性？</p></p></div><div class="body"><p>数据库的三级模式的划分实际上将用户、逻辑数据库与物理数据库进行了划分，使彼此之间的相互干扰减到最少。这三个模式的划分实际上带来了两个数据独立性，即物理独立性和逻辑独立性。这使得底层的修改和变化尽量不影响到上层。</p></div></div><div class="timenode"><div class="meta"><p><p>试说明使用视图的好处。</p></p></div><div class="body"><ol type="1"><li>简化数据查询语句</li><li>使用户能从多角度看待同一数据</li><li>提高了数据的安全性</li><li>提供了一定程度的逻辑独立性</li><li></li></ol></div></div><div class="timenode"><div class="meta"><p><p>使用视图可以加快数据的查询速度，这句话对吗？为什么？</p></p></div><div class="body"><p>不对。因为数据库管理系统在对视图进行查询时，首先检查要查询的视图是否存在，如果存在，则从数据字典中提取视图的定义，把视图的定义语句对视图语句结合起来，转换成等价的对基本表的查询，然后再执行转换后的查询，所以使用视图不可以加快数据的查询速度。</p></div></div><div class="timenode"><div class="meta"><p><p>登记日志文件时为什么必须先写日志文件，后写数据库？</p></p></div><div class="body"><p>把数据的修改写到数据库和把对数据的修改操作写到日志文件是两个不同的操作，在两个操作之间可能会发生故障如果先写了数据库修改，而在日志文件中没有登记这个修改，在恢复的时候就无法恢复这个修改了；如果先写日志，但没有修改数据库，按日志恢复时只是多执行一次撤消操作，并不影响数据库的正确性，为了安全，一定要先写日志文件。</p></div></div><div class="timenode"><div class="meta"><p><p>试叙述事务的4个性质，并结合每一个性质由DBMS的哪个子系统实现？每一个性质对DBS有什么益处？</p></p></div><div class="body"><ol type="1"><li>事务的原子性是指一个事务对 DB的所以操作，是一个不可分割的工作单位。原子性是由 DBMS的事务管理子系统实现的。事务的原子性保证了 DBS 的完整性。</li><li>事务的一致性是指数据不会因事务的执行而遭受破坏。事务的一致性是由DBMS 的完整性子系统实现的。事务的一致性保证数据库的完整性。</li><li>事务的隔离性是指事务的并发执行与这些事务单独执行时结果一样。事务的隔离性是由DBMS的并发控制子系统实现的。隔离性使并发执行的事务不必关心其他事务，如同在单用户环境下执行一样。</li><li>事务的持久性，是指事务对 DB 的更新应永久地反映在 DB 中。持久性是由DBMS 的恢复管理子系统实现的。持久性能保证 DB 具有可恢复性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>在数据库中为什么要有并发控制机制？</p></p></div><div class="body"><p>数据库系统一个明显的特点是多个用户共享数据库资源，尤其是多个用户可以同时存取相同数据。在这样的系统中，在同一时刻同时运行的事务可达数百个。若对多用户的并发操作不加控制，就会造成数据库存、取的错误，破坏数据的一致性和完整性。所以数据库中要有并发控制机制。</p></div></div><div class="timenode"><div class="meta"><p><p>怎样进行系统故障的恢复?</p></p></div><div class="body"><p>系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤消故障发生时未完成的事务，重做已完成的事务。</p><ol type="1"><li>正向扫描日志文件（即从头扫描日志文件），找出在故障发生前已经提交的事务（这些事务既有 BEGIN TRANSACTION记录，也有 COMMIT记录），将其事务标识记入重做（REDO）队列。同时找出故障发生时尚未完成的事务（这些事务只有BEGIN TRANSACTION 记录，无相应的 COMMIT记录），将其事务标识记入撤消(UNDO)队列。</li><li>对撤消队列中的各个事务进行撤消(UNDO)处理。进行 UNDO 处理的方法是，反向扫描日志文件， 对每个 UNDO 事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。</li><li>对重做队列中的各个事务进行重做(REDO)处理。进行 REDO 处理的方法是：正向扫描日志文件， 对每个 REDO事务重新执行日志文件登记的操作。即将日志记录中“更新后的值”写入数据库</li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行介质故障的恢复?</p></p></div><div class="body"><p>发生介质故障后，磁盘上的物理数据和日志文件被破坏，恢复方法是重装数据库，然后重做已完成的事务。具体地说就是：</p><ol type="1"><li>装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还须同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。</li><li>装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务。即：首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行事务故障的恢复</p></p></div><div class="body"><p>事务故障是指事务在运行至正常终止点前被中止，这时恢复子系统应利用日志文件撤消（UNDO）此事务已对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。系统的恢复步骤是：</p><ol type="1"><li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。这样，如果记录中是插入操作，则相当于做删除操作（因此时“更新前的值”为空）。若记录中是删除操作，则做插入操作，若是修改操作，则相当于用修改前值代替修改后值</li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li><li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述使用检查点方法进行恢复的步骤。</p></p></div><div class="body"><ol type="1"><li><p>从重新开始文件中找到追后一个检查点记录在日志文件中的地址，由该地址在体制文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST 。 这里建立两个事务队列：</p><ol type="1"><li>UNDO-LIST：需要执行 undo 操作的事务集合；</li><li>REDO-LIST 需要执行 redo 操作的事务集合。把 ACTIVE-LIST 暂时放入UNDO-LIST 队列，REDO 队列暂时为空。</li></ol></li><li><p>检查点开始正向扫描日志文件：</p><ol type="1"><li>如果有新开始的事务 Ti ，把 Ti 暂时放入 UNDO-LIST 队列；</li><li>如有提交的事务 Tj ，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST队列，直到日志文件结束；</li></ol></li><li><p>对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST中的每个事务执行 REDO 操作。</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>什么是数据库镜像？它有什么用途？</p></p></div><div class="body"><p>根据 DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS 自动把更新后的数据恢复过去，即 DBMS自动保证镜像数据与主数据的一致性。用途：</p><ol type="1"><li>一旦出现介质故障， 可由镜像磁盘继续提供使用， 同时 DBMS自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本。</li><li>没有出现故障时，数据库镜像还可以并发操作。提高数据库的可用性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述两段锁协议的概念。</p></p></div><div class="body"><p>所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。</p><ol type="1"><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；</li><li>在释放一个封锁之后，事务不再申请和获得对该数据的封锁。</li></ol><p>所谓“两段”锁的含义是，事务分为两个阶段，第一阶段是获得封锁，也称为扩展阶段。在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这个阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。</p></div></div><div class="timenode"><div class="meta"><p><p>数据模型的优化包含哪些方法？</p></p></div><div class="body"><ol type="1"><li>确定各属性间的函数依赖关系。根据需要分析阶段得出的语义，分别写出每个关系模式的各属性之间的函数依赖以及不同关系模式中各属性之间的数据依赖关系。</li><li>对各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</li><li>判断每个关系模式的范式，根据实际需要确定最合适的范式。</li><li>根据需要分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行分解或合并。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>B-树为代表的树形索引成为当前数据库系统主流索引具有必然性?</p></p></div><div class="body"><p>索引文件是一种适应面比较广的文件结构，因此在数据库系统中得到了广泛的应用。对于经常变动的文件，静态索引的性能会随时间变化而变坏，所以目前在数据库系统中应用更多的是动态索引。而B-数就是为了磁盘或其它存储设备而设计的一种平衡多分树，能很好地进行动态索引。B-树提供了三种存取路径:</p><ol type="1"><li>通过索引集进行树形搜索;</li><li>通过顺序集进行顺序搜索;</li><li>先通过索引找到入口，再沿顺序集顺序搜索。</li></ol><p>B-树不仅提供了灵活的存取路径，而且能够自动保持平衡，不须定期重组，因此B-树为代表的树索引系列在数据库系统中应用甚广，成为数据库主流具有必然性。</p></div></div><div class="timenode"><div class="meta"><p><p>SUX锁是否能保证死锁不发生</p></p></div><div class="body"><p>不能解决并发事务中的死锁问题。当一个事物 A 占用数据对象 a 的 X锁，事务 B 占用数据 对象 b 的 X 锁，事务 A 和事务 B 又分别申请数据对象 b和数据对象 a 的锁，在(S,X)和(S,U,X)锁中，均无法获准，需要等待对方事务释放锁，而进入等待状态则无法释放自己所占用的锁，从而陷入循环等待，即死锁。</p><p>解决方法：资源按相同的顺序上锁来避免死锁。</p></div></div></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库原理复习提纲。&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="数据库" scheme="http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论复习</title>
    <link href="http://adversarr.github.io/2021/12/22/study/ComputerScience/fragments/AI2021/"/>
    <id>http://adversarr.github.io/2021/12/22/study/ComputerScience/fragments/AI2021/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2022-03-28T03:37:15.043Z</updated>
    
    <content type="html"><![CDATA[<p>🐔寄！人工智能导论复习</p><span id="more"></span><h1 id="人工智能导论">人工智能导论</h1><h2 id="第-1-章-绪论">第 1 章 绪论</h2><div class="story post-story"><ul><li>分数：5 分。</li><li>题目范围：<ol type="1"><li>您认为什么是人工智能？</li></ol></li></ul><div class="note "><p><strong>答题重点</strong></p><p>从两个角度：</p><ol type="1"><li><code>像人一样</code> 还是 <code>理性</code></li><li><code>思考</code> 还是 <code>行动</code></li></ol><blockquote><p>不同人会对 AI 有不同的思考。要问的两个重要问题是:你关心的是思考还是行为?你是想模拟人还是按照理想标准工作?</p></blockquote><p>例如：</p><p>我认为 AI 是像人一样行动的系统：</p><blockquote><p>“创造能执行一些功能的机器的技艺,当由人来执行这些功能时需要智能”(Kurzweil,1990)</p><p>“研究如何使计算机能做那些目前人比计算机更擅长的事情”(Rich 和Knight,1991)</p></blockquote></div><h3 id="什么是人工智能">什么是人工智能</h3><dl><dt><strong>人工智能</strong></dt><dd>用人工的方法在机器(计算机)上实现的智能;或者说是人们使机器具有类似于人的智能。</dd></dl><blockquote><ol type="1"><li>定义一:像人一样思考的系统(评价:计算机从定义开始)像人一样思考:认知建模的途径</li><li>定义二:理性地思考的系统 合理地思考:“思维法则”的途径</li><li>定义三:像人一样行动的系统 合理地行动:合理 Agent 的途径</li><li>定义四:理性地行动的系统</li></ol></blockquote><dl><dt>图灵测试(Turing test)</dt><dd>1950 年图灵发表的《计算机与智能》中设计了一个测试，用以说明人工智能的概念。</dd></dl><ol type="1"><li>目的是为智能提供一个满足可操作要求的定义。</li><li>与其提出一个长长的、可能有争议的清单来列举智能所需要的能力,不如采用一项基于人类这种无可置疑的智能实体的辨别能力的测试。如果人类询问者在提出一些书面问题后,无法判断答案是否由人写出,那么计算机就通过了测试。</li></ol><p>需要的能力：</p><ol type="1"><li>自然语言处理</li><li>知识表示</li><li>自动推理</li><li>机器学习</li></ol></div><h2 id="第-2-章-智能化-agent">第 2 章 智能化 Agent</h2><div class="story post-story"><ul><li>分数：5 分。</li><li>题目范围：<ul><li>Agent 的架构，尤其是基于模型和效用的 Agent 架构。</li><li>准确理解基于模型和效用 Agent 的任务、环境、评价标准等。</li><li>!基于学习 Agent 的一般模型。</li></ul></li></ul><div class="note "><p><strong>考试内容</strong></p><p>画出架构图</p></div><h3 id="peasagent-的任务环境评价标准">PEAS：Agent的任务、环境、评价标准</h3><p>根据首字母缩写,我们称之为 PEAS 描述( Performance(性能),Environment(环境), Actuators(执行器), Sensors (传感器))。设计 Agent时,第一步就是尽可能完整地详细说明任务环境</p><h3 id="agent-架构">Agent 架构</h3><dl><dt>智能体(Agent)</dt><dd>某种能够行动的东西。不同于简单程序,它可以实现:自主控制的操作、感知环境、持续能力、适应变化、以及有能力承担其它Agent 的目标。</dd><dt>理性智能体(Rational Agent)</dt><dd>可以通过自己的行动获得最佳结果。或者在不确定的情况下,获得最佳期望的结果。</dd></dl><p>在任何给定时间，什么是<strong>理性</strong>取决于四件事：</p><ul><li>定义成功标准的绩效衡量标准。</li><li>代理对环境的先验知识。</li><li>代理可以执行的操作。</li><li>代理迄今为止的感知序列。</li></ul><p>For each possible percept sequence, a rational agent should select anaction that is expected to maximize its performance measure, given theevidence provided by the percept sequence and whatever built-inknowledge the agent has.</p><blockquote><p>对于每个可能的感知序列，考虑到感知序列提供的证据以及智能体拥有的任何内置知识，理性智能体应该选择一个预期能够最大化其性能度量的动作。</p></blockquote><p><strong><em>agent = architecture + program</em></strong></p><h4 id="简单反射-agent">简单反射 Agent</h4><p><img src="image-20211220143334629.png" class="lazyload" data-srcset="image-20211220143334629.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于模型的-agent">基于模型的 Agent</h4><p><img src="image-20211220143752397.png" class="lazyload" data-srcset="image-20211220143752397.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于目标的-agent">基于目标的 Agent</h4><p><img src="image-20211220143820462.png" class="lazyload" data-srcset="image-20211220143820462.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于效用的-agent">基于效用的 Agent</h4><p><img src="image-20211220143846402.png" class="lazyload" data-srcset="image-20211220143846402.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于学习的-agent">基于学习的 Agent</h4><p><img src="image-20211220144250626.png" class="lazyload" data-srcset="image-20211220144250626.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>学习 Agent 可以被划分为 4 个概念上的组件,如图 2.15所示。最重要的区别体现在学习元件和性能元件之间,学习元件负责改进提高,而性能元件负责选择外部行动。性能元件是我们前面考虑的整个Agent:它接受感知信息并决策。学习元件利用来自评判元件的反馈评价Agent.做得如何,并确定应该如何修改性能元件以便将来做得更好。</p></div><h2 id="第-7-章-逻辑-agent">第 7 章 逻辑 Agent</h2><div class="story post-story"><ul><li>分数：5 分。</li><li>题目范围：<ol type="1"><li>命题逻辑的语法、命题逻辑的推理模式或推理方法</li><li>理解书中怪兽世界任务的推理，包括 𝑹𝟏~𝑹𝟏𝟎 的证明，以及 𝑹𝟏𝟏~𝑹𝟏𝟓的将句子转换成合取范式</li><li>基于归结或反证法的证明。</li><li>理解推理规则及公理，以便用于命题逻辑的推理。</li><li>!命题逻辑的连接符及其语义</li></ol></li></ul><div class="note "><p><strong>往年题目</strong></p><p>推导 R1-R10，R11-R15</p></div><h3 id="命题逻辑">命题逻辑</h3><dl><dt>Knowledge base (KB)</dt><dd>A set of <strong>sentences</strong></dd><dt>Sentence</dt><dd>Represents some assertion about the world</dd><dt>Axiom</dt><dd>Not derived from other sentences</dd></dl><p>经典问题为：</p><figure><img src="image-20211220144803757.png" class="lazyload" data-srcset="image-20211220144803757.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="魔兽世界问题" /><figcaption aria-hidden="true">魔兽世界问题</figcaption></figure><h4 id="语法">语法</h4><p>对于命题：</p><p><span class="math display">\[\alpha |= \beta\quad \iff\quad M(\alpha)\subseteq M(\beta)\]</span></p><p>对于命题逻辑：</p><ol type="1"><li><spanclass="math inline">\(\neg,\wedge,\vee,\implies,\iff\)</span></li><li>True, False</li></ol><h4 id="语义">语义</h4><p>注意 <span class="math inline">\(\implies\)</span> 的语义</p><h4 id="命题推理">命题推理</h4><p>命题推理的目标： <span class="math inline">\(KB|=\alpha\)</span></p><h5 id="简单推理过程">简单推理过程</h5><ol type="1"><li>逻辑推理：用蕴含关系来证明</li><li>模型检验：枚举所有的可能</li></ol><h5 id="定理证明">定理证明</h5><blockquote><p>Applying inference <strong>rules</strong> without models.</p><p>利用逻辑等价的命题逻辑。</p></blockquote><p><strong>单调性</strong>：随着信息添加到知识库中，所包含的句子集只会增加。</p><blockquote><p>产生了 R6-R10</p></blockquote><p>使用搜索算法证明</p><ul><li>INITIAL STATE：The initial knowledge base</li><li>ACTIONS：Match the top half of the inference rule</li><li>RESULT：Add the sentence in the bottom half of the inference</li><li>GOAL：The sentence to prove</li></ul><p>使用如下的方法：</p><p><span class="math display">\[\begin{aligned}\alpha \implies \beta,\quad \alpha\\-----------\\\beta\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\alpha \wedge \beta\\-----------\\\beta\end{aligned}\]</span></p><p>逻辑等价</p><p><span class="math display">\[\begin{aligned}\alpha \iff \beta\\-----------\\(\alpha\implies \beta)\wedge (\beta\implies\alpha)\\\\(\alpha\implies \beta)\wedge (\beta\implies\alpha)\\-----------\\\alpha \iff \beta\end{aligned}\]</span></p><h5 id="消解法归结法">消解法（归结法）</h5><p>消解规则：</p><p><span class="math display">\[\begin{aligned}l_1 \vee l_2\quad \neg l_2\vee l_3\\----------\\l_1\vee l_3\end{aligned}\]</span></p><p><strong>思路</strong></p><ul><li>要证明：<span class="math inline">\(KB|=\alpha\)</span>即证明：<spanclass="math inline">\(KB\wedge\neg\alpha\)</span>不可满足的</li></ul><p><strong>方法</strong>：</p><ol type="1"><li><p>转换<span class="math inline">\(KB\wedge \neg\alpha\)</span>为<strong>合取范式</strong></p></li><li><p>消解</p></li><li><p>如果新子句尚不存在，则将其添加到集合中</p><p>该过程一直持续到：</p><ol type="1"><li>不能添加新的条款</li><li>产生了空条款 -- 不可满足</li></ol></li></ol><blockquote><p>产生了 R11-R15</p></blockquote></div><h2 id="第-10-章-知识表示">第 10 章 知识表示</h2><div class="story post-story"><ul><li>分数：6 分。</li><li>题目范围：<ol type="1"><li>情景演算、情景、流、前提条件公理、效应公理等概念。</li><li>!本体论、类别、对象，并举例说明</li></ol></li></ul><h3 id="本体论相关">本体论相关</h3><h4 id="本体">本体</h4><dl><dt>本体</dt><dd>Organize everything in the world into a hierarchy of categories</dd></dl><ul><li>主要着重于一些在许多不同领域都会出现的通用概念例如事件、时间、物理对象以及信念。表示这些抽象概念有时被称为本体论工程（ontologicalengineering）。</li><li>念的通用框架被称为上位本体论( upperontology),因为按照画图惯例，更一般概念在上面而更具体的概念在它们的下面。如图</li></ul><figure><img src="image-20211220161459787.png"alt="Upper ontology: the general framework of concepts" /><figcaption aria-hidden="true">Upper ontology: the general framework ofconcepts</figcaption></figure><ul><li>Concentrate on general concepts in differentdomains：专注于不同领域的一般概念<ul><li><em>Events, Time, Physical Objects</em>, and <em>Beliefs</em></li></ul></li></ul><blockquote><p>本体（ontology）的几个代表性定义： (1)本体是对于“概念化”的某一部分的明确的总结或表达[2]。 (2)本体在不同的场合分别指“概念化”或“本体理论”[3]。 (3)本体是对于“概念化”的明确表达[4]。 (4)本体是用于描述或表达某一领域知识的一组概念或术语。它可以用来组织知识库较高层次的知识抽象，也可以用来描述特定领域的知识[5]。(5) 本体属于人工智能领域中的内容理论（contenttheories），它研究特定领域知识的对象分类、对象属性和对象间的关系，它为领域知识的描述提供术语[6]。从以上定义我们可以知道，本体通过对于概念、术语及其相互关系的规范化描述，勾画出某一领域的基本知识体系和描述语言。其中定义1、2 和 3 以“概念化”的定义为基础，概念化（以及定义 2中的“本体理论”）的定义见下文。 与本体相关的概念和术语：本体论（Ontology，o 大写）：特指哲学的分支学科[3]。</p></blockquote><h4 id="类别和对象">类别和对象</h4><dl><dt>类别、对象</dt><dd>用一阶逻辑表示类别有两种选择: 谓词和对象。就是说,我们可以使用谓词Basketball(b),或者可以将类别物化(reify)为一个对象,Basketball。然后,我们可以用 Member(b, Basketballs)(我们将它缩写为b∈Basketballs)来说明 b 是篮球类别的一个成员。 我们用 Subset(Basketball,Bals)(缩写为 Basketballs c Balls)来说明 Basketball.s 是Ball.s的一个子类(subcategory)。我们将交替使用术语子类(subcategory)和子集(subclass,subset)。</dd></dl><ul><li>将对象组织成类别是知识表示的重要组成部分。很多推理发生在<strong>类别</strong>层面。<ol type="1"><li>一种是从感知输入推断某些对象的存在，从对象的感知属性推断类别成员资格，然后使用类别信息对对象进行预测。</li><li>一种是通过<strong>继承</strong>来组织和简化知识库，子类关系构成一个层次结构</li></ol></li></ul><dl><dt>（部分关系、a 组成了 b）Partof</dt><dd>一个对象可以是另一个对象的一部分</dd></dl><ul><li><em>PartOf</em> is transitive（传递） and reflexive（自反）</li><li>反之有：BunchOf: define composite objects with definiteparts（定义一个物体由有限个 Part 组成）</li></ul><dl><dt>事物</dt><dd>现实中有相当一部分对象没有明显的个性化(<strong>individuation</strong>)。即划分成独特对象—事物</dd></dl><ul><li>现实世界可以视为由原始对象(粒子)和由其构成的复合对象组成的、</li><li>事物和物体(<strong>thing</strong>)的最大区别：（如果将一只土豚切成两半，不会得到两只土豚。）</li><li>对象=事物</li></ul><p>stuff-物质、thing-物体</p><dl><dt>测度</dt><dd>Objects have height, mass, cost, and so on. The values that we assignfor these properties are called <strong>measures.</strong></dd></dl><h3 id="情景演算">情景演算</h3><dl><dt>Event calculus</dt><dd>Based on points of time rather than on situations</dd><dt>Predicate <strong><em>T</em></strong></dt><dd>断言 <em>流体</em> 在某个时间点是正确的</dd></dl><figure><img src="image-20211220212336898.png" class="lazyload" data-srcset="image-20211220212336898.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="谓词" /><figcaption aria-hidden="true">谓词</figcaption></figure><h4 id="过程">过程</h4><dl><dt>过程（process / <strong>liquid event</strong>)</dt><dd>具有这种属性的事件类别被称为过程( process)类别或者流事件( liquidevent)类别。发生在一个时间区间的任何过程 e 也在任何子区间里发生。</dd></dl><ul><li>如果 fluent 是由过去某个时间的事件启动并且没有被中间事件变为false（剪切），则 fluent 在某个时间点成立。</li><li>流(<strong>fluent</strong>)指的是使情景从一个变换到下一个的函数和谓词。</li></ul><dl><dt>一个特殊的事件-<strong><em>Start</em></strong></dt><dd>通过说明在开始时间启动或终止哪些流来描述初始状态。</dd></dl><p>一个物理对象是一块时空</p><ul><li>Physical objects can be viewed as generalized events</li></ul></div><h2 id="第-14-章-概率推理">第 14 章 概率推理</h2><div class="story post-story"><ul><li>分数：8 分。</li><li>题目范围：<ol type="1"><li>贝叶斯网络的定义、贝叶斯网络的语义。</li><li>给定贝叶斯网络，要求能够写出相应的联合概率分布。</li><li>针对书中的盗贼警报任务，理解贝叶斯网络的精确推理，并且能够在给定证据的情况下进行推理。</li></ol></li></ul><h3 id="定义语义">定义/语义</h3><blockquote><p>Represent the dependencies among variables</p></blockquote><dl><dt>贝叶斯网络</dt><dd>贝叶斯网络是一个有向图,其中每个结点都标注了定量的概率信息。其完整的说明如下:</dd></dl><ol type="1"><li>每个结点对应一个随机变量,这个变量可以是离散的或者连续的。</li><li>一组有向边或箭头连接结点对。如果有从结点 X 指向结点 Y 的箭头,则称 X是 Y 的一个父结点。图中没有有向回路(因此被称为有向无环图,或简写为DAG)。</li><li>每个结点 X 有一个条件概率分布 P( K|Parents(X)),量化其父结点对该结点的影响。</li></ol><p><img src="image-20211222103056286.png" class="lazyload" data-srcset="image-20211222103056286.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><blockquote><p>有两种方式可以理解贝叶斯网络的语义。</p><ol type="1"><li>第一种是将贝叶斯网络视为对联合概率分布的表示。</li><li>第二种则将其视为是对一组条件依赖性语句的编码。</li></ol><p>这两种观点是等价的,但是前者可以帮助我们理解如何构造网络,而后者则可以帮助我们设计推理过程</p></blockquote><h3 id="如何计算联合概率">如何计算联合概率？</h3><figure><img src="image-20211222104003250.png" class="lazyload" data-srcset="image-20211222104003250.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="遍历DAG" /><figcaption aria-hidden="true">遍历DAG</figcaption></figure><blockquote><p>如何构造贝叶斯网络：链式法则</p></blockquote><h3 id="如何进行精确推理">如何进行精确推理</h3><p><strong>原理</strong>：精确推理就是<strong>计算后验概率</strong>：随机变量：<spanclass="math inline">\(X\)</span>，条件<spanclass="math inline">\(e\)</span>，隐藏的节点<spanclass="math inline">\(y\)</span>：</p><p><spanclass="math display">\[P(X|e)=\frac{P(X,e)}{P(e)}\mathop{=}^{\alpha:=P(e)^{-1}}\alpha\sum_yP(x,y,e)\]</span></p><p><strong>计算方法</strong>：</p><blockquote><p>重点：<span class="math inline">\(\alpha\)</span>不计算，通过求出 X不同取值下的联合概率，然后归一化得到</p></blockquote><ol type="1"><li>求随机变量各个取值的联合概率</li><li>归一化得到结果</li></ol><h4 id="例题">例题</h4><figure><img src="image-20211222105523724.png"alt="注意其中的B是大写的变量，而jmea都是取值！" /><figcaptionaria-hidden="true">注意其中的B是大写的变量，而jmea都是取值！</figcaption></figure><p>最暴力的方法：</p><table><thead><tr class="header"><th>Scene</th><th>Probability</th><th>Result</th></tr></thead><tbody><tr class="odd"><td>b,e,a</td><td>0.001 0.002 0.95 0.9 0.7</td><td>1.197*10^-6</td></tr><tr class="even"><td>b,e,-a</td><td>0.001 0.002 0.05 0.05 0.01</td><td>5.*10^-11</td></tr><tr class="odd"><td>b,-e,a</td><td>0.001 0.998 0.94 0.90 0.70</td><td>0.000591016</td></tr><tr class="even"><td>b,-e,-a</td><td>0.001 0.998 0.06 0.05 0.01</td><td>2.994*10^-8</td></tr><tr class="odd"><td>-b,e,a</td><td>0.999 0.002 0.29 0.9 0.7</td><td>0.000365035</td></tr><tr class="even"><td>-b,e,-a</td><td>0.999 0.002 0.71 0.05 0.01</td><td>7.0929*10^-7</td></tr><tr class="odd"><td>-b,-e,a</td><td>0.999 0.998 0.001 0.9 0.7</td><td>0.000628111</td></tr><tr class="even"><td>-b,-e,-a</td><td>0.999 0.998 0.999 0.05 0.01</td><td>0.000498002</td></tr></tbody></table><p>所以</p><ul><li><span class="math inline">\(P(b|j, m)=0.000592243\alpha\)</span></li><li><span class="math inline">\(P(\negb|j,m)=0.00149186\alpha\)</span></li></ul><p>归一化后：（实际上<span class="math inline">\(\alpha=1/(0.000592243+0.00149186)\)</span>）</p><ul><li><span class="math inline">\(P(b|j, m)=0.000592243\alpha=0.284172\)</span></li><li><span class="math inline">\(P(\negb|j,m)=0.00149186\alpha=0.715828\)</span></li></ul><p>从而：</p><p><spanclass="math display">\[P(B|j,m)=\langle0.283172,0.715828\rangle\]</span></p></div><h2 id="第-16-章-制定简单决策">第 16 章 制定简单决策</h2><div class="story post-story"><ul><li>分数：8 分。</li><li>题目范围：<ol type="1"><li>理解什么是最大期望效用原则。</li><li>理解决策网络，尤其是决策网络中的节点类型。</li><li>给定一个决策网络，能够计算不同动作的期望效用，并选择具有最大期望效用的动作。</li><li>!偏好、效用</li></ol></li></ul><h3 id="最大期望效用原则">最大期望效用原则</h3><p><strong>最大期望效用(MEU)原则</strong>：理性 Agent应该选择能<strong>最大化</strong>该 Agent的<strong>期望效用</strong>的那个动作。</p><p><strong>效用函数</strong>：效用是从状态映射到实数的函数。</p><h3 id="决策网络">决策网络</h3><p><img src="image-20211222171626214.png" class="lazyload" data-srcset="image-20211222171626214.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><ul><li><strong>机会结点(Chancenode)(椭圆)代表随机变量</strong>,就像它们在贝叶斯网中所表示的一样。关于建设费用、空中交通级别和诉讼可能性以及Deaths、 Noise 和总体 Cosr 变量一其中每一个又依赖于选址一 Agent可能是不确定的。每个机会结点关联着一个以父结点的状态为索引的条件分布。在决策网络中,父结点既可以包括决策结点也可以包括机会结点。注意到为了评估建设费用、空中交通级别或者诉讼可能性,每个当前状态机会结点都可能是一个大的贝叶斯网络的部分。</li><li><strong>决策结点(decisionnode)(矩形)代表在该结点上决策制定者有一个对行动的选择</strong>。在这个案例中,Airport site行动可以对考虑中的每个位置呈现不同的值。选择影响到费用、安全以及会产生的噪音。在本章中,我们假设我们处理的是单一决策结点。第17 章将处理必须制定多于一个决策的情况效用结点(utility node)(菱形)代表Agent 的效用函数'。</li><li><strong>效用结点把所有那些描述直接影响效用的结果状态的变量作为父结点</strong>。与效用结点关联的是一个描述,它将Agent 效用描述为对父结点属性的一个函数。这个描述可能只是函数的表格形式,或者它可能是参数化的属性值的加法或线性函数。</li></ul><h3id="给定决策网络计算不同动作的期望效用">给定决策网络，计算不同动作的期望效用</h3><p>行动的选择是通过对决策结点的每种可能设定的决策网络进行评价而完成的。一旦决策结点被设定,它的行为表现完全像一个被设定为证据变量的机会结点。评价决策网络的算法如下:</p><ol type="1"><li>为当前状态设定证据变量。</li><li>对于决策结点的每个可能值;<ol type="1"><li>把决策结点设为该值。</li><li>对该效用结点的父结点,使用一个标准的概率推理算法计算其后验概率。</li><li>为该行动计算结果效用。</li></ol></li><li>返回有最高效用的行动这是贝叶斯网络算法的一个直接扩展,可以直接结合到图13.1 给出的 Agent T 设计中去。</li></ol><blockquote><p>依次执行几个行动的可能性使问题变得有趣得多</p></blockquote><h3 id="偏好和效用">偏好和效用</h3><p>下面六条约束被称为<strong>效用理论公理</strong>。它们指定附加在偏好和彩票上的明显的语义约束。</p><ol type="1"><li>有序性(Orderability)。给定任意两个状态,一个理性 Agent必须偏好一个状态甚于另一个。或者认为偏好两者的程度一样。也就是说,该Agent 不能逃避决策。拒绝打赌就如同拒绝时间逝去一样。</li><li>传递性(Transitivity)。给定任意三个状态,如果一个理性 Agent 偏好 A甚于 B,偏好 B 甚于 C,则该 Agent 一定偏好 A 甚于 C。</li><li>连续性(Continuity)。如果某个状态 B 在偏好上处于 A 和 C之间,那么一定存在概率 p,使得该理性 Agent 在【肯定得到 B】、【以概率得到A,并以概率 1 − p 得到 C】的彩票之间无偏向。</li><li>可替换性(Substituitability)。如果一个 Agent 在两个彩票 A 和 B之间无偏向,则该 Agent在更复杂的两个彩票之间也是无偏向的。这样的两个彩票,除了一个彩票中的 A 被B 替换以外是一样的。这是成立的,而不用考虑彩票中的概率和其它结果。</li><li>单调性( Monotonicity)。假设存在两个彩票有两个结果 A 和 B,如果一个Agent 偏好 A 甚于 B,那么该 Agent 一定偏好 A的概率高的彩票。反之亦然。</li><li>可分解性(Decomposability)。复合彩票可以通过概率法则被简化为简单一些的彩票。由于两个相继的彩票能够被压缩成个等价的单个彩票,这曾被称为“赌博无乐趣”规则。</li></ol><blockquote><p>注意:效用理论的公理没有提到任何关于效用的内容：它们只谈论了<strong>偏好</strong>。<strong>偏好被假定为理性Agent 的一个基本属性。</strong>一个效用函数的存在遵循下列效用公理:</p><ol type="1"><li>效用原则(Existence of Utility Function)。如果一个 Agent的偏好遵循效用公理，则存在一个在状态上进行运算的实值函数 U,使得U(A)&gt;U(B),当且仅当 Agent 偏好 A 甚于 B 时。并且 U(A)=U(B),当且仅当该Agent 在 A 和 B 之间无偏向时。</li><li>最大期望效用原则(Expected Utility of aLottery)。一个彩票的效用是把每个结果的概率乘以每个结果的效用的乘积，然后求和。</li></ol><p>换句话说,一旦可能结果状态的概率和效用被指定,涉及到那些状态的复合彩票的效用就被完全确定了。一个非确定性动作的结果是一个彩票,这将提供根据公式(16.1)得到的MEU 决策规则。</p></blockquote><blockquote><p><strong>效用函数刻画的是偏好关系</strong>，假如你相比梨来说更偏好苹果，那么苹果给你带来的效用就应当大于梨所带来的效用。但<strong>注意效用函数虽然是一个数学函数，但在本例中它仅表示不同消费组合之间效用的排序关系</strong>，而非真正的，可以用数字来刻画的“效用量”。换言之，你可以说你相对梨来说更偏好苹果，但绝对没办法说“苹果大于梨n个效用单位”。当然，在某些特定的领域也有用基数效用方程的，比如在期望效用理论中。</p><p>作者：徐惟能链接：https://www.zhihu.com/question/22310615/answer/20962418 来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;🐔寄！人工智能导论复习&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="人工智能" scheme="http://adversarr.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
</feed>
