<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Adversarr&#39;s Blog</title>
  
  
  <link href="http://adversarr.github.io/atom.xml" rel="self"/>
  
  <link href="http://adversarr.github.io/"/>
  <updated>2023-03-04T03:01:03.416Z</updated>
  <id>http://adversarr.github.io/</id>
  
  <author>
    <name>Adversarr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流体-表面张力</title>
    <link href="http://adversarr.github.io/2023/02/24/CG/Things/Fluid/SurfaceTension/"/>
    <id>http://adversarr.github.io/2023/02/24/CG/Things/Fluid/SurfaceTension/</id>
    <published>2023-02-24T01:44:02.000Z</published>
    <updated>2023-03-04T03:01:03.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="surface-tension">Surface tension</h1><div class="story post-story"><h2 id="summary">Summary</h2><ol type="1"><li>单个流体、空气、固体边界：决定了弯月面形状、角度、对固体附加的切向力等<ol type="1"><li>常规流体（例如水滴等，形状规则）： 仍然是NS方程主导，附加表面张力<ol type="1"><li>流体+刚体（Static）：刚体不动，流体动；</li><li>流体+刚体（Dynamic）：刚体动，流体也动；</li><li>流体+软体：Position-based Surface Tension Flow（2022）</li></ol></li><li>形变不规则的流体（例如肥皂泡）： 表面张力主导</li></ol></li><li>多流体边界，溶解，分离等现象： Multi Phase (Multiple) Fluidsimulation<ol type="1"><li>流体+流体+刚体：Multiple-Fluid SPH Simulation Using a MixtureModel</li><li>流体+流体+软体（不混合）：Interlinked sph pressure solvers forstrong fluid-rigid coupling（2019）</li></ol></li></ol></div><div class="story post-story"><h2 id="资料汇总">资料汇总</h2><h3 id="单流体">单流体</h3><h4 id="常规">常规</h4><h5 id="fluid-simulation-in-computer-graphics-bridson-15-book">FluidSimulation in Computer Graphics (Bridson 15-Book)</h5><p>Chapter 8 Water - Section 5 Surface Tension P131</p><blockquote><p>The physical chemistry of surface tension is conceptually simple.<strong>Water molecules are more attracted to other water molecules thanto air molecules, and vice versa.</strong> Thus, water molecules nearthe surface tend to be pulled in towards the rest of the water moleculesand vice versa. In a way they are seeking to minimize the area exposedto the other fuid, bunching up around their own type. <strong>Thesimplest linear model of surface tension can in fact be phrased in termsof a potential energy equal to a surface-tension coefhicient ay timesthe surface area between the two fuids</strong> (<spanclass="math inline">\(\gamma\)</span> for water and air at normalconditions is approximatelv <spanclass="math inline">\(0.073J/m^2\)</span>). The force seeks to minimizethe surface area.</p></blockquote><p>欧拉方法</p><p>Surface Area of Fluid = <span class="math display">\[A = \iint_{\partial\Omega}1=\cdots =\iiint_\Omega \nabla \cdot \nabla\phi\]</span> "Pressure" at the surface of water = <spanclass="math display">\[p = \gamma \nabla \cdot \nabla \phi = \gamma \kappa\]</span> 其中 <span class="math inline">\(\kappa\)</span>为流体表面的平均曲率。</p><p>由此推出：</p><ol type="1"><li>Explicit 方法：容易出现数值问题<span class="math inline">\(\Delta t\le O(\Delta x^{3/2} \sqrt{\rho / \gamma})\)</span></li><li>Implicit 方法：仍然需要改进（难整合进现有求解器）</li><li>……</li></ol><h5 id="versatile-surface-tension-and-adhesion-for-sph-fluids">Versatilesurface tension and adhesion for SPH fluids</h5><blockquote><ul><li>SIG 13</li><li>Nadir Akinci</li><li><ahref="https://cg.informatik.uni-freiburg.de/publications/siggraphasia2013/2013_SIGGRAPHASIA_surface_tension_adhesion.pdf">PDF</a></li></ul></blockquote><p>SPH方法，分为Adhesion和Cohesion。与综述中一致。</p><h5id="an-extended-cut-cell-method-for-sub-grid-liquids-tracking-with-surface-tension.">AnExtended Cut-Cell Method for Sub-Grid Liquids Tracking with SurfaceTension.</h5><blockquote><p>TOG 2020</p><p><a href="https://dl.acm.org/doi/10.1145/3414685.3417859">Link</a></p><p><strong>Abstract</strong>: Simulating liquid phenomena utilizingEulerian frameworks is challenging, since highly energetic flows ofteninduce <strong>severe topological changes, creating thin and complexliquid surfaces</strong>. Thus, capturing structures that are smallrelative to the grid size become intractable, since continuallyincreasing the resolution will scale sub-optimally due to the pressureprojection step. Previous methods successfully relied on using higherresolution grids for tracking the liquid surface implicitly; howeverthis technique comes with drawbacks. The mismatch of pressure samplesand surface degrees of freedom will cause artifacts such as hangingblobs and permanent kinks at the liquid-air interface. In this paper, wepropose an extended cut-cell method for handling liquid structures thatare smaller than a grid cell. At the core of our method is a noveliso-surface Poisson Solver, which converges with second-order accuracyfor pressure values while maintaining attractive discretizationproperties such as symmetric positive definiteness. Additionally, weextend the iso-surface assumption to be also compatible with surfacetension forces. Our results show that the proposed method provides anovel framework for handling arbitrarily small splashes that can alsocorrectly interact with objects embodied by complex geometries.</p></blockquote><ul><li>欧拉网格</li><li>主要处理计算速度问题</li></ul><h5id="solid-fluid-interaction-with-surface-tension-dominant-contact">Solid-fluidinteraction with surface-tension-dominant contact</h5><blockquote><ul><li>SIG 21</li><li>Liangwang Ruan (PKU)</li><li><a href="https://arxiv.org/pdf/2105.08471.pdf">PDF</a></li></ul></blockquote><p>主要在MPM框架下进行，</p><p>我们将我们的技术贡献总结如下：</p><ol type="1"><li>一种新颖的拉格朗日薄膜表示，可准确捕获由强表面张力驱动的固体和流体之间的接触相互作用。</li><li>整体耦合框架，满足所有速度和位置约束，同时保持动量。</li><li>预测-校正接触处理方案，以实际物理参数准确处理流固接触。</li></ol><img src="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230224104219-5wb9ihv.png" class="lazyload" data-srcset="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230224104219-5wb9ihv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="image"><h5id="a-deformable-surface-model-for-real-time-water-drop-animation.">Adeformable surface model for real-time water drop animation.</h5><blockquote><p>IEEE Trans on Visualization &amp; Computer Graphics 2012</p><p><a href="http://kunzhou.net/2011/surface_water_drop.pdf">Link</a></p><p><strong>Abstract</strong>: A water drop behaves differently from alarge water body because of its strong viscosity and surface tensionunder the small scale. Surface tension causes the motion of a water dropto be largely determined by its boundary surface. Meanwhile, viscositymakes the interior of a water drop less relevant to its motion, as thesmooth velocity field can be well approximated by an interpolation ofthe velocity on the boundary. Consequently, we propose a fast deformablesurface model to realistically animate water drops and their flowingbehaviors on solid surfaces. Our system efficiently simulates water dropmotions in a Lagrangian fashion, by reducing 3D fluid dynamics over thewhole liquid volume to a deformable surface model. In each time step,the model uses an <strong>implicit mean curvature flow operator toproduce surface tension effects</strong>, a <strong>contact angleoperator to change droplet shapes on solid surfaces</strong>, and a setof mesh connectivity updates to handle topological changes and improvemesh quality over time. Our numerical experiments demonstrate a varietyof physically plausible water drop phenomena at a real-time rate,including capillary waves when water drops collide, pinch-off of waterjets, and droplets flowing over solid materials. The whole systemperforms orders-of-magnitude faster than existing simulation approachesthat generate comparable water drop effects.</p></blockquote><figure><img src="./SurfaceTension/image-20230303193834629.png" class="lazyload" data-srcset="./SurfaceTension/image-20230303193834629.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><ul><li>处理了流体-固体-气体边界</li><li>流体动，固体不动</li></ul><h5 id="surface-only-liquids">Surface-only liquids</h5><blockquote><p>TOG 16</p><p><strong>Abstract</strong>: We propose a novel surface-only techniquefor simulating incompressible, inviscid and uniform-density liquids withsurface tension in three dimensions. The liquid surface is captured by atriangle mesh on which a Lagrangian velocity field is stored. Becauseadvection of the velocity field may violate the incompressibilitycondition, we devise an orthogonal projection technique to remove thedivergence while requiring the evaluation of only two boundary integralsThe forces of surface tension, gravity, and solid contact are alltreated by a boundary element solve, allowing us to perform detailedsimuIations of a wide range of liquid phenomena, including waterbe lls,droplet and jet collisions, fuid chains, and crown splashes.</p></blockquote><ul><li>处理了流体-固体-气体边界，同样假定固体不动</li><li>只在流体表面进行计算，计算速度快</li></ul><h5id="semi-implicit-surface-tension-formulation-with-a-lagrangian-surface-mesh-on-an-eulerian-simulation-grid.">Semi-implicitsurface tension formulation with a Lagrangian surface mesh on anEulerian simulation grid.</h5><blockquote><p>JCP 2012</p><p><ahref="https://www.researchgate.net/publication/220207188_Semi-implicit_surface_tension_formulation_with_a_Lagrangian_surface_mesh_on_an_Eulerian_simulation_grid">Link</a></p><p><strong>Abstract</strong>: We present a method for applyingsemi-implicit forces on a Lagrangian mesh to an Eulerian discretizationof the Navier Stokes equations in a way that produces a sparse symmetricpositive definite system. The resulting method has semi-implicit andfully-coupled viscosity, pressure, and Lagrangian forces. We apply ournew framework for forces on a Lagrangian mesh to the case of a surfacetension force, which when treated explicitly leads to a tight time steprestriction. By applying surface tension as a semi-implicit Lagrangianforce, the resulting method benefits from improved stability and theability to take larger time steps. The resulting discretization is alsoable to maintain parasitic currents at low levels.</p></blockquote><h5id="a-new-incompressibility-discretization-for-a-hybrid-particle-mac-grid-representation-with-surface-tension.">Anew incompressibility discretization for a hybrid particle MAC gridrepresentation with surface tension.</h5><blockquote><p>JCP 2012</p><p><strong>Abstract</strong>: We take a particle based approach toincompressible free surface flow motivated by the fact that an explicitrepresentation of the interface geometry and internal deformations givesprecise feedback to an implicit solver for surface tension. Methods thatenforce incompressibility directly on the particles are typicallynumerically inefficient compared to those that utilize a backgroundgrid. However, background grid discretizations suffer from inaccuracynear the free surface where they do not properly capture the interfacegeometry. Therefore, our incompressibility discretization utilizes aparticle based projection near the interface and a background MAC gridbased projection for efficiency in the vast interior of the liquiddomain - as well as a novel method for coupling these two disparateprojections together. We show that the overall coupled elliptic solveris second order accurate, and remains second order accurate when used inconjunction with an appropriate temporal discretization for parabolicproblems. A similar second order accurate discretization is derived whenthe MAC grid unknowns are located on faces (as opposed to cell centers)so that Navier-Stokes viscosity can be solved for implicitly as well.Finally, we present a fully implicit approach to surface tension that isrobust enough to achieve a steady state solution in a single time step.Beyond stable implicit surface tension for our novel hybriddiscretization, we demonstrate preliminary results for both standardfront tracking and the particle level set method.</p></blockquote><h4 id="肥皂泡">肥皂泡</h4><h5id="codimensional-surface-tension-flow-on-simplicial-complexes">CodimensionalSurface Tension Flow on Simplicial Complexes</h5><blockquote><ul><li>SIG 14</li><li>Bo Zhu (Stanford University)</li><li><ahref="http://physbam.stanford.edu/~fedkiw/papers/stanford2014-01.pdf">PDF</a></li></ul></blockquote><p>主要工作是在类似于肥皂泡的“一层”流体上进行的：</p><img src="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230224103303-4bvtqki.png" class="lazyload" data-srcset="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230224103303-4bvtqki.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="i"><p>拉格朗日视角下，基于单纯复形进行。</p><h5id="codimensional-surface-tension-flow-using-moving-least-squares-particles">CodimensionalSurface Tension Flow using Moving-Least-Squares Particles</h5><blockquote><ul><li>SIG 2020</li><li>Hui Wang (Shanghai Jiao Tong University)</li></ul></blockquote><p>利用codimensional surface tension model，利用MLS进行求解。</p><h5 id="simulation-of-bubbles">Simulation of bubbles</h5><blockquote><p>SIGGRAPH 2006</p><p><ahref="https://dl.acm.org/doi/10.1016/j.gmod.2009.08.001">Link</a></p><p><strong>Abstract</strong>: We present a novel framework based on acontinuous fluid simulator for general simulation of realistic bubbles,with which we can handle as many significant dynamic bubble effects aspossible. To capture a very thin liquid film of bubbles, we havedeveloped <strong>a regional level set method allowing multi-manifoldinterface tracking</strong>. Based on the definitions of regionaldistance and its five operators, the implementation of the regionallevel set method is very easy. An implicit surface of liquid film witharbitrary thickness can be reconstructed from the regional level setfunction. To overcome the numerical instability problem, we exploit anew semi-implicit surface tension model which is unconditionally stableand makes the simulation of surface tension dominated phenomena muchmore efficient. An approximated film thickness evolution model isproposed to control the bubble's lifecycle. All these new techniquescombine into a general framework that can produce various realisticdynamic <strong>effects of bubbles</strong>.</p></blockquote><ul><li>主要侧重点在于气泡的模拟</li><li>流体-空气边界</li></ul><h5 id="a-hyperbolic-geometric-flow-for-evolving-films-and-foams.">Ahyperbolic geometric flow for evolving films and foams.</h5><blockquote><p>TOG 17</p><p><strong>Abstract</strong>: Simulating the behavior of soap films andfoams is a challenging task. A direct numerical simulation of films andfoams via the Navier-Stokes equations is still computationally tooexpensive. We propose an alternative formulation inspired by geometricflow. Our model exploits the fact, according to Plateau's laws, that thesteady state of a film is a union of constant mean curvature surfacesand minimal surfaces. Such surfaces are also well known as the steadystate solutions of certain curvature flows. We show a link between theNavier-Stokes equations and a recent variant of mean curvature flow,called hyperbolic mean curvature flow, under the assumption of constantair pressure per enclosed region. Instead of using hyperbolic meancurvature flow as is, we propose to replace curvature by the gradient ofthe surface area functional. This formulation enables us to robustlyhandle non-manifold configurations; such junctions connecting multiplefilms are intractable with the traditional formulation using curvature.We also add explicit volume preservation to hyperbolic mean curvatureflow, which in fact corresponds to the pressure term of theNavier-Stokes equations. Our method is simple, fast, robust, andconsistent with Plateau's laws, which are all due to our reformulationof film dynamics as a geometric flow.</p></blockquote><ul><li>主要处理气泡（薄的、“一层”液体）</li></ul><figure><img src="./SurfaceTension/Figure1.png" class="lazyload" data-srcset="./SurfaceTension/Figure1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h5id="double-bubbles-sans-toil-and-trouble-discrete-circulation-preserving-vortex-sheets-for-soap-films-and-foams">Doublebubbles sans toil and trouble: Discrete circulation-preserving vortexsheets for soap films and foams</h5><blockquote><p>TOG 2015</p><p><a href="https://dl.acm.org/doi/10.1145/2767003">Link</a></p><p><strong>Abstract</strong>: Simulating the delightful dynamics of soapfilms, bubbles, and foams has traditionally required the use of a fullythree-dimensional many-phase Navier-Stokes solver, even though theirvisual appearance is completely dominated by the thin liquid surface. Wedepart from earlier work on soap bubbles and foams by noting that theirdynamics are naturally described by a Lagrangian vortex sheet model inwhich circulation is the primary variable. This leads us to derive anovel circulation-preserving surface-only discretization of foamdynamics driven by surface tension on a non-manifold triangle mesh. Werepresent the surface using a mesh-based multimaterial surface trackerwhich supports complex bubble topology changes, and evolve the surfaceaccording to the ambient air flow induced by a scalar circulation fieldstored on the mesh. Surface tension forces give rise to a simple updaterule for circulation, even at non-manifold Plateau borders, based on adiscrete measure of signed scalar mean curvature. We further incorporatevertex constraints to enable the interaction of soap films with wires.The result is a method that is at once simple, robust, and efficient,yet able to capture an array of soap films behaviors including foamrearrangement, catenoid collapse, blowing bubbles, and double bubblesbeing pulled apart.</p></blockquote><ul><li>只考虑单层的流体 – 肥皂泡等</li></ul><p><imgsrc="https://camo.githubusercontent.com/b2973d6c4872e860879fbaa3c0d4ffa3914848754749a9d2c2112a095a5a1c29/687474703a2f2f7777772e63732e636f6c756d6269612e6564752f63672f646f75626c65627562626c65732f7469746c652e6a7067" /></p><h3 id="多流体">多流体</h3><h4id="multiple-fluid-sph-simulation-using-a-mixture-model">Multiple-FluidSPH Simulation Using a Mixture Model</h4><blockquote><p>TOG 2014</p><p><a href="https://dl.acm.org/doi/10.1145/2645703">Link</a></p><p><strong>Article</strong>: This article presents a versatile androbust SPH simulation approach for multiple-fluid flows. The spatialdistribution of different phases or components is modeled using thevolume fraction representation, the dynamics of multiple-fluid flows iscaptured by using an improved mixture model, and a stable and accurateSPH formulation is rigorously derived to resolve the complex transportand transformation processes encountered in multiple-fluid flows. Thenew approach can capture a wide range of real-world multiple-fluidphenomena, including mixing/unmixing of miscible and immiscible fluids,diffusion effect and chemical reaction, etc. Moreover, the newmultiple-fluid SPH scheme can be readily integrated into existingstate-of-the-art SPH simulators, and the multiple-fluid simulation iseasy to set up. Various examples are presented to demonstrate theeffectiveness of our approach.</p></blockquote><ul><li>多流体</li></ul><p><img src="./SurfaceTension/image-20230304104113576.png" class="lazyload" data-srcset="./SurfaceTension/image-20230304104113576.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4id="a-stable-and-efficient-method-for-treating-surface-tension-in-incompressible-two-phase-flow.">Astable and efficient method for treating surface tension inincompressible two-phase flow.</h4><blockquote><p>SIAM Journal on Scientific Computing, 2009</p><p><ahref="https://www.math.fsu.edu/~sussman/SussmanOhta08.pdf">PDF</a></p><p><a href="https://epubs.siam.org/doi/10.1137/080732122">Link</a></p><p><strong>Abstract</strong>: A new approach based on volume preservingmotion by mean curvature for treating surface tension in<strong>two-phase flows</strong> is introduced. Many numerical tests anda theoretical justification are included which provide evidenceregarding the efficacy of the new approach. For many flows, whichexhibit stiff surface tension effects, the new approach gives a factorof at least three and sometimes five or more speed-up for a givenaccuracy. The new method is easy to implement in the context of (1)level set methods, or coupled level set and volume-of-fluid methods, (2)complicated interfaces separating gas from liquid, and (3)three-dimensional axisymmetric, or fully three-dimensional adaptive meshrefinement.</p></blockquote><h4id="interlinked-sph-pressure-solvers-for-strong-fluid-rigid-coupling">Interlinkedsph pressure solvers for strong fluid-rigid coupling</h4><blockquote><p><a href="https://dl.acm.org/doi/10.1145/3284980">Link</a></p></blockquote><p><img src="./SurfaceTension/image-20230304104323251.png" class="lazyload" data-srcset="./SurfaceTension/image-20230304104323251.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div><div class="story post-story"><h2 id="物理解释">物理解释</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Surface_tension">SurfaceTension</a></p><p>表面张力在概念上很简单。水分子比空气分子更容易被其他水分子吸引，反之亦然。因此，表面附近的水分子倾向于被拉向其余的水分子，反之亦然。在某种程度上，他们正在寻求最小化暴露于其他流体的区域，聚集在他们自己的同类型流体周围。表面张力最简单的线性模型实际上可以用势能等于两个流体之间的表面积的超临界值r乘以（在正常条件下的水和空气约为<spanclass="math inline">\(0.073J/m^2\)</span>）来表述。该力提供将表面积降至最低的趋势。</p></blockquote><p>表面张力是静止液体表面收缩到尽可能小表面积的趋势。</p><p>在液体-空气边界面上，表面张力源于「液体分子间吸引力」（Cohesion）大于「液体和空气分子间吸引力」（Adhesion）：</p><ul><li>Adhesion：不相同（相似）的粒子或表面“粘附”在一起的力（流体和其他物体之间）</li><li>Cohesion：相同（相似）的粒子或表面“粘附”在一起的力（流体内部产生）</li></ul><blockquote><p>与不同物体的 Adhesion 以及自身 Cohesion的大小关系，给出了液体和其他物体之间的<strong>润湿程度</strong>、<strong>接触角</strong>和<strong>弯月面形状</strong>。</p><img src="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230224095819-wdisr0n.png" class="lazyload" data-srcset="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230224095819-wdisr0n.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="image"></blockquote><p>流体内部<strong>在平衡情况下</strong>，表面张力为0，不平衡情况下，有缩小表面积的趋势。物理中的（在平衡状态下）表面张力（参数）实际上对应上图中的几个向量，即发生在流体与其他物体<strong>接触面的边界</strong>上，但并没有给出整个接触面上如何进行表面张力的计算公式（Wikipedia中没有给出）。</p><p>之前讨论的SPH方法中，其中有一项<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>是人为指定的参数，其实考虑的也只是流体和空气的边界面，即不需要算出流体对于空气的作用力。</p><img src="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230225111005299.png" class="lazyload" data-srcset="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230225111005299.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><img src="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230225110955456.png" class="lazyload" data-srcset="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230225110955456.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><img src="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230225110720208.png" class="lazyload" data-srcset="/2023/02/24/CG/Things/Fluid/SurfaceTension/image-20230225110720208.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><p>对于流体-固体边界面，则需要通过公式算出流体对于固体的力，可以进行双向耦合。(SIGGRAPH21)Solid-fluid interaction with surface-tension-dominant contact给出了基于MPM流体的流固耦合方法，该方法基于物理公式，求解了计算流固边界上表面张力。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;surface-tension&quot;&gt;Surface tension&lt;/h1&gt;
&lt;div class=&quot;story post-story&quot;&gt;&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;单个流体、空气、固体边界：决定了</summary>
      
    
    
    
    <category term="Physical Simlation" scheme="http://adversarr.github.io/categories/Physical-Simlation/"/>
    
    
    <category term="Surface Tension" scheme="http://adversarr.github.io/tags/Surface-Tension/"/>
    
    <category term="Fluid" scheme="http://adversarr.github.io/tags/Fluid/"/>
    
  </entry>
  
  <entry>
    <title>Siggraph 2021 course - An Introduction to Physics-based Animation</title>
    <link href="http://adversarr.github.io/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/"/>
    <id>http://adversarr.github.io/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/</id>
    <published>2022-12-04T15:15:08.000Z</published>
    <updated>2023-02-05T04:00:01.093Z</updated>
    
    <content type="html"><![CDATA[<p>Siggraph 2021 course notes.</p><p>See more in Siyuan.</p><span id="more"></span><hr /><ul><li>Title: Introduction to PBA 笔记</li><li>Tags: #Tutorial#, #PhysicalSimulation#, #SiggraphCourse#</li></ul><hr /><blockquote><p><a href="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf">AnIntroduction to Physics-based Animation</a></p></blockquote><h2 id="a-simple-start-particle-dynamics">A simple start: ParticleDynamics</h2><h3 id="passive-particle-in-velocity-field">Passive Particle in VelocityField</h3><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=5">IPBA-optimized.pdf- p5 - IPBA-optimized-P5-20230128114412</a></p><img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P5-20230128114412-20230128114414-famhayj.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P5-20230128114412-20230128114414-famhayj.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><p>问题：给定速度场<span class="math inline">\(v(x,t)\)</span>，求运动</p><p>本质上：I.V.P（初值问题）</p><p><span class="math display">\[\begin{aligned}x_p(0) = x_0 \\\dot{x}_p = v(x_p, t)\end{aligned}\]</span></p><p>常微分方程 -- 只有 <span class="math inline">\(t\)</span>。且是一阶ODE。用有限差分法求。具体从解析到离散的推导为：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=5">IPBA-optimized.pdf- p5 - IPBA-optimized-P5-20230128114500</a></p><img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P5-20230128114500-20230128114502-ls19xtk.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P5-20230128114500-20230128114502-ls19xtk.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><h3 id="particle-with-mass">Particle with mass</h3><p>如果给定的不是速度场，而是力场，可以用牛顿第二定律来进行计算：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=6">IPBA-optimized.pdf- p6 - IPBA-optimized-P6-20230128114553</a></p><img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P6-20230128114553-20230128114553-g0pl6qk.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P6-20230128114553-20230128114553-g0pl6qk.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><p><span class="math display">\[\begin{aligned}x_p(0) = x_0 \\\ddot{x}_p = f / m\end{aligned}\]</span></p><p>或者替换为两个一阶ODE耦合的形式：</p><p><span class="math display">\[\begin{aligned}x_p(0) = x_0 \\\dot{x}_p = v_p\dot{v}_p = f/m\end{aligned}\]</span></p><p>最简单的，我们可以直接用差分代替微分，实现SymplecticEuler方法。（以及显式欧拉）</p><blockquote><p>区别于半隐式欧拉。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Particle</span> &#123;</span><br><span class="line">  mass</span><br><span class="line">  position</span><br><span class="line">  velocity</span><br><span class="line">  force_accumulator</span><br><span class="line">  ...</span><br><span class="line">  (i.e. color, size, age, type)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=6">IPBA-optimized.pdf- p6 - Particle structure would typically store, at a minimum: mass,position, velocity, and a force accumulator.</a></p></blockquote><blockquote><p>Question: use field (SoA + ECS)</p></blockquote><h3 id="mass-spring-system">Mass Spring System</h3><p>System = Particle + Constraint</p><p><span class="math display">\[f_p = k(\| x_q - x_p \|/ r - 1) (x_q - x_p) / \| x_q - x_p \|\]</span></p><p>两个弹簧节点之间的相互作用力可以如上定义。算法实现如下：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=8">IPBA-optimized.pdf- p8 - IPBA-optimized-P8-20230128114851</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P8-20230128114851-20230128114851-2mt17ny.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P8-20230128114851-20230128114851-2mt17ny.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><div class="story post-story"><h2 id="mathematical-models">Mathematical Models</h2><blockquote><p>Continuum Mechanics: Assume the underlying materials arecontinuous.</p></blockquote><h3 id="physics-law">Physics Law</h3><p>主要是两大部分：</p><ol type="1"><li>牛顿力学 -- 第一定律、第二定律</li><li>分析力学(变分原理等)</li></ol><h4 id="ipba-optimized.pdf---p8---newtons-laws-of-motion."><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=8">IPBA-optimized.pdf- p8 - Newton’s Laws of Motion.</a></h4><blockquote><p>1, 2, 3 定律</p></blockquote><ol type="1"><li><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=8">IPBA-optimized.pdf- p8 - a body remains at rest or moves with a constant velocity unlessacted upon by a force</a></li><li><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=8">IPBA-optimized.pdf- p8 - Newton’s famous second law, 𝐟 = 𝑚𝐚,</a></li><li><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=9">IPBA-optimized.pdf- p9 - Newton’s third law states that for every action, there is anequal and opposite reaction. Specifically, in an interaction between twoparticles or bodies, if body A applies force 𝐟 to body B, then body Bapplies force −𝐟 to body A.</a></li></ol><h4id="质量守恒动量守恒能量守恒-ipba-optimized.pdf---p10---conservation-of-mass-momentum-energy">质量守恒、动量守恒、能量守恒<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=10">IPBA-optimized.pdf- p10 - Conservation of Mass, Momentum, Energy</a></h4><p>守恒视角下，牛顿定律：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=10">IPBA-optimized.pdf- p10 - IPBA-optimized-P10-20230128154753</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P10-20230128154753-20230128154755-ehci3f4.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P10-20230128154753-20230128154755-ehci3f4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=11">IPBA-optimized.pdf- p11 - Conservation laws forcontinua.</a>：对于连续介质，有质量守恒给出了如下公式</p><p><span class="math display">\[\frac{d}{dt} \int_\Omega \rho dV = - \oint _{\partial \Omega} \rho v(x,t) \cdot n(x) dS\]</span></p><p>利用散度定理，局部的有：</p><p><span class="math display">\[\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho v) dV = 0\]</span></p><h3 id="materials">Materials</h3><h4 id="ipba-optimized.pdf---p12---rigid-bodies"><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=12">IPBA-optimized.pdf- p12 - Rigid Bodies</a></h4><h5 id="dof-模型">6DoF 模型</h5><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=13">IPBA-optimized.pdf- p13 - IPBA-optimized-P13-20230128175401</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P13-20230128175401-20230128175403-2c2hb7d.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P13-20230128175401-20230128175403-2c2hb7d.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>一个刚体只有6dof，分为Object Space 和 World Space</p><ol type="1"><li>质心位置<span class="math inline">\(\mathbf x(t)\)</span></li><li>三维旋转<span class="math inline">\(\mathbf r(t)\)</span></li><li>质心计算：质量加权的平均位置<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=12">IPBA-optimized.pdf- p12 - IPBA-optimized-P12-20230128175004</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P12-20230128175004-20230128175007-tkts5k7.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P12-20230128175004-20230128175007-tkts5k7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></li></ol><p>计算刚体上的点的世界坐标： <ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=13">IPBA-optimized.pdf- p13 - IPBA-optimized-P13-20230129095515</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P13-20230129095515-20230129095517-q2bn9cu.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P13-20230129095515-20230129095517-q2bn9cu.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>通过上式对时间求微分，得到（刚体上某点的）速度方程：</p><p><span class="math display">\[v(t) = \dot{x}(t) + \dot{R} (t) r_0\]</span></p><h5id="线速度角速度ipba-optimized.pdf---p13---linear-and-angular-velocity">线速度、角速度<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=13">IPBA-optimized.pdf- p13 - Linear and Angular Velocity</a></h5><p>线速度：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=13">IPBA-optimized.pdf- p13 - 𝐱(𝑡), is referred as the rigid body linear velocity</a></p><p>Euler 旋转定理：任意旋转是沿某轴进行的。</p><p><span class="math display">\[\dot{R} (t) r_0 = \omega(t) \times r(t)\]</span></p><p><span class="math inline">\(\omega(t)\)</span> 称为角速度。</p><p><strong>动量(Linear Momentum)</strong>：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=14">IPBA-optimized.pdf- p14 - Linear Momentum.</a></p><p><span class="math display">\[P(t) = \sum_{i=1}^{N} m_i v_i(t) = \underline{\left(\sum_{i = 1}^N  m_i\right) \dot{x}(t)} + \omega(t)\times\sum_{i=1}^N m_i r_i(t)\]</span></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=15">IPBA-optimized.pdf- p15 - IPBA-optimized-P15-20230129111005</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P15-20230129111005-20230129111007-mfrq9hb.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P15-20230129111005-20230129111007-mfrq9hb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p><strong>角动量(Angular Momentum)</strong>:<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=15">IPBA-optimized.pdf- p15 - Angular Momentum.</a></p><p><span class="math display">\[\begin{aligned}L(t)&amp; = \sum_{i = 1}^{N} m_i r_i \times(\dot{x}(t) + \omega(t)\times r_i(t))\\&amp;= \sum_{i = 1}^N m_i r_i(t)\times (\omega(t)\times r_i(t))\end{aligned}\]</span></p><p>因为其中的<span class="math inline">\(\omega\)</span>不依赖于<spanclass="math inline">\(i\)</span>，交换叉乘顺序并定义：</p><p><span class="math display">\[r \times \omega = r^* \omega =\left(\begin{matrix}0 &amp; -r_z &amp; r_y\\r_z &amp; 0 &amp; -r_x\\-r_y &amp; r_x &amp; 0\end{matrix}\right) \omega\]</span></p><p>所以有：</p><p><span class="math display">\[\begin{aligned}L(t)&amp; = (\sum_i m_i r_i^{*} r_i^{*T}) \omega(t)\\&amp;=I(t) \omega (t)\end{aligned}\]</span></p><p>其中的<span class="math inline">\(I(t)\)</span>通过下式计算：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=16">IPBA-optimized.pdf- p16 - IPBA-optimized-P16-20230129112855</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P16-20230129112855-20230129112855-188q80d.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P16-20230129112855-20230129112855-188q80d.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p><strong>Force and Torque</strong></p><p><span class="math display">\[\frac{d}{dt} \left(P;L\right) = \left(f; \tau\right)\]</span></p><p>其中<span class="math inline">\(\tau = r \times f\)</span></p><p>Summary: <ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=16">IPBA-optimized.pdf- p16 - IPBA-optimized-P16-20230129113036</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P16-20230129113036-20230129113038-3ry5prx.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P16-20230129113036-20230129113038-3ry5prx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><h3 id="soft-bodies">Soft Bodies</h3><blockquote><p>Central: deformation gradient</p></blockquote><p><span class="math display">\[K(d) + D(\dot{d}) + M\ddot{d} = f_{ext}\]</span></p><p>其中</p><ol type="1"><li><span class="math inline">\(d\)</span> 是位移（指形变函数）</li><li><span class="math inline">\(K\)</span>表示弹性力（内部）→刚度矩阵</li><li><span class="math inline">\(D\)</span>表示衰减力</li><li><span class="math inline">\(M\)</span>是质量矩阵。</li></ol><p>形变梯度的引入：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=17">IPBA-optimized.pdf- p17 - Deformation Gradient</a></p><p><span class="math inline">\(u\)</span> 是 Rest-Space，<spanclass="math inline">\(x\)</span> 是 World-Space，最简单的情况是</p><p><span class="math display">\[x(u) = x(u_0) + A(u - u_0)\]</span></p><p><span class="math inline">\(A\)</span>是任意矩阵。如果是更复杂的情况，可以局部线性化为上面的形式。</p><p>即：<span class="math inline">\(\Psi\)</span>（形变函数）局部线性近似 -&gt; <span class="math inline">\(F = \partialx / \partial u\)</span> -&gt; SVD, RS, ... (Strain Measuring)</p><p>直觉上 SVD（<span class="math inline">\(F = U \SigmaV^T\)</span>）：</p><ol type="1"><li><span class="math inline">\(V^T\)</span>：Rest-&gt;Aligned</li><li><span class="math inline">\(\Sigma\)</span>：拉伸收缩</li><li><span class="math inline">\(U\)</span>：Aligned-&gt;World</li></ol><p>避免 Global Rotation后：RS 分解。</p><h4 id="strain">Strain</h4><blockquote><p>Dimension-less Quantity: measures the amount of deformation.</p><p>Strain represents the displacement between particles in the bodyrelative to a reference length.</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=18">IPBA-optimized.pdf- p18 - Strain. From the deformation gradient we define a strain metric.Strain is a dimension-less (or unit-less) quantity that measures theamount of deformation.</a></p></blockquote><p>仅仅是<strong>某一种</strong>刻画形变程度的方式！</p><p><span class="math display">\[Strain(x_r) = 0\]</span></p><p>例如：Mass-Spring: <span class="math inline">\(l / l_0\)</span></p><p>常用的应变</p><ol type="1"><li>Green's Finite Strain, -&gt; Right Cauchy-Green Strain</li><li>Cauchy infinitesimal strain,</li><li>co-rotated strain.</li></ol><p>E.g. Right Cauchy-Green Strain:</p><p><span class="math display">\[\epsilon_{ij} = \frac{1}{2} (F^T F - I)\]</span></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=18">IPBA-optimized.pdf- p18 - IPBA-optimized-P18-20230130113230</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P18-20230130113230-20230130113232-5ig88uv.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P18-20230130113230-20230130113232-5ig88uv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=18">IPBA-optimized.pdf- p18 - IPBA-optimized-P18-20230130113306</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P18-20230130113306-20230130113308-hca2udj.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P18-20230130113306-20230130113308-hca2udj.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>Cauchy infinitesimal strain: 如果 <spanclass="math inline">\(D^TD\)</span>项可以忽略。</p><p><span class="math display">\[\begin{aligned}\epsilon &amp; = \frac{1}{2} (F^T + F + D^TD) -I &amp;\mathrm{(Green)}\\  &amp; \approx \frac{1}{2} (F + F^T) - I &amp;\mathrm{(Cauchy~infinitesimal)}\end{aligned}\]</span></p><p>如果用Einstein Notation：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=19">IPBA-optimized.pdf- p19 - IPBA-optimized-P19-20230130113523</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P19-20230130113523-20230130113524-njqz5z9.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P19-20230130113523-20230130113524-njqz5z9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>主要好处在于，该strain是线性的，导出的形变能量是二次的，具有常数的Hessian。<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=19">IPBA-optimized.pdf- p19 - The primary advantage of this strain metric is that it islinear, which leads to a quadratic energy and a constant Hessian thatcan be pre-factored or otherwise analyzed</a></p><p>缺点在于，这个strain受到world-space rotation的影响。<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=19">IPBA-optimized.pdf- p19 - Unfortunately, this strain metric does penalize world-spacerotations, leading to a variety of unpleasant artifacts under largedeformations.</a></p><p>在图形学中最常用的是 co-rotated strain metric:</p><p><span class="math display">\[\epsilon = \frac{1}{2} \left( \tilde{F} + \tilde{F}^T \right) - I\]</span></p><ul><li>在式子中显式地丢掉了无关的旋转，<spanclass="math inline">\(F=Q\tilde{F}\)</span>（极分解）</li></ul><h4 id="stress">Stress</h4><blockquote><p>描述单位面积上的力，维度相关</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=19">IPBA-optimized.pdf- p19 - Stress. Unlike strain, stress is not a dimension-less quantity.In three dimensions, stress has units of Newton’s per meter squared (𝑁/𝑚2). Instead of measuring the amount of deformation, it measures thematerials reaction to that deformation.</a></p></blockquote><p>常用模型是为线性的</p><p><span class="math display">\[\sigma = C \epsilon\]</span></p><p>其中 <span class="math inline">\(C\)</span>是一个3x3x3x3的<strong>张量</strong>，但是！考虑到：</p><ol type="1"><li><span class="math inline">\(\sigma, \epsilon\)</span> 对称</li><li>Iso-tropic （各向同性）</li></ol><p>只有两个参数，Lame Coefficients:</p><p><span class="math display">\[\sigma_{ij} = \lambda \epsilon_{kk}\delta_{ij} + 2\mu \epsilon_{ij}\]</span></p><p>矩阵形式：</p><p><span class="math display">\[\sigma = \lambda Tr(\epsilon) I + 2 \mu \epsilon\]</span></p><blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=19">IPBA-optimized.pdf- p19 - the stress is some constant times the strain plus a scaledidentity matrix times the trace of the strain. The second termapproximately preserves volume.</a></p></blockquote><h4 id="弹性能量力">弹性能量、力</h4><p>势能密度：(Einstein Notation)</p><p><span class="math display">\[\eta = \frac{1}{2} \sigma_{ij} \epsilon_{ij}= \frac{1}{2} \sigma : \epsilon=\frac 1 2 \sum_{i, j} \sigma _{ij}\epsilon_{ij}\]</span></p><p>总能量是势能密度的积分。</p><p>Traction（切向力？）：</p><p><span class="math display">\[\tau = \sigma n\]</span></p><ul><li>其中 <span class="math inline">\(n\)</span> 是单位法向。</li></ul><blockquote><p><span class="math inline">\(F\)</span> 始终让总势能减少。</p></blockquote><p><span class="math display">\[f_i = -\frac{\partial \eta}{\partial x_i}\]</span></p><p>也可以被定义区域积分：</p><p><span class="math display">\[f = \int_{\partial R} \sigma n \mathrm{d}S\]</span></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=20">IPBA-optimized.pdf- p20 - IPBA-optimized-P20-20230130120242</a></p><img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P20-20230130120242-20230130120245-xqcxh2o.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P20-20230130120242-20230130120245-xqcxh2o.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><h4 id="stress-revisit">Stress Revisit</h4><p>Definition of Stress: Maps <em>normal</em> to <em>force</em></p><blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=20">IPBA-optimized.pdf- p20 - The definition of traction makes clear that stress maps fromnormals to forces (per unit area).</a></p></blockquote><p>问题在于定义的空间是 世界/物体？</p><ul><li><p>如果是<strong>世界坐标系</strong>下的法向和Stress 计算得到对应Cauchy Stress -- <span class="math inline">\(\sigma\)</span></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=20">IPBA-optimized.pdf- p20 - If both normals and forces are in world space, the stress isknown as a Cauchy stress and often written as 𝝈</a></p></li><li><p>物体坐标系的法向到物体坐标系的力 - 对应PK stress - <spanclass="math inline">\(S\)</span></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=20">IPBA-optimized.pdf- p20 - If the stress maps normals in material space to forces inmaterial space it is known as a second Piola-Kirchhoff stress andsometimes written as 𝐒.</a></p></li><li><p><strong>物体坐标系</strong>的法向到<strong>世界坐标系</strong>的力- 对应PK1 stress - P</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=20">IPBA-optimized.pdf- p20 - A first Piola-Kirchhoff stress maps normals in material space toforces in world space and is written 𝐏</a></p></li></ul><p>如果是material space-&gt;material space， -- PK2 -- <spanclass="math inline">\(S\)</span></p><p>常用的是 PK1: Material Space Normal -&gt; World Space Force</p><p><span class="math display">\[P = J \sigma F^{-T} = FS\]</span></p><p>好处在于，PK1 给出的是从参考到世界坐标的映射。</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=20">IPBA-optimized.pdf- p20 - IPBA-optimized-P20-20230130141155</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P20-20230130141155-20230130141201-t2scluh.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P20-20230130141155-20230130141201-t2scluh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><h4 id="塑性形变">塑性形变</h4><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=20">IPBA-optimized.pdf- p20 - Plasticity. Plasticity refers to permanent deformation thattypically occurs when a material fails</a></p><p><span class="math display">\[F = F_e F_p\]</span></p><h3 id="流体ipba-optimized.pdf---p21---fluids">流体<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=21">IPBA-optimized.pdf- p21 - Fluids</a></h3><p><span class="math display">\[\begin{aligned}\rho(u_t + u \cdot \nabla u) = - \nabla p + \mu \Delta u + f \\\nabla \cdot u = 0\end{aligned}\]</span></p><ul><li><span class="math inline">\(u\)</span> 为速度场 - 欧拉视角</li><li><span class="math inline">\(u_t\)</span> 为加速度场 - 欧拉视角</li><li><span class="math inline">\(p\)</span> 为压强 - 欧拉视角</li><li><span class="math inline">\(\mu\)</span> 描述粘性</li><li><span class="math inline">\(f\)</span> 为外力</li></ul><h4 id="ipba-optimized.pdf---p21---material-derivative"><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=21">IPBA-optimized.pdf- p21 - Material derivative</a></h4><p>欧拉视角下，流体的加速度是</p><p><span class="math display">\[a_p = \frac{d}{dt} v_p(t) = \frac{d}{dt} u(x_p(t), t) =u_t + u \cdot\nabla u\]</span></p><p>拉格朗日视角下的量 <spanclass="math inline">\(u\)</span>，材料导数（拉格朗日视角的）定义为</p><p><span class="math display">\[Du / Dt = u_t + u \cdot \nabla u\]</span></p><h4 id="ipba-optimized.pdf---p22---forces"><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=22">IPBA-optimized.pdf- p22 - Forces</a></h4><p><span class="math display">\[\rho(u_t + u \cdot \nabla u) = - \nabla p + \mu \Delta u + f\]</span></p><ul><li>压强 -- 用于抵消压缩<ul><li>在某些情况下，也被称为不可压缩流体的 Lagrange Multiplier -&gt;Divergence-Free Constraint</li></ul></li><li>粘性力 -- Penalizes Velocity Differences</li><li>外力 <span class="math inline">\(f\)</span></li></ul><h4 id="incompressibility">Incompressibility</h4><p>从质量守恒方程：</p><p><span class="math display">\[\rho_t + \Delta \cdot (\rho u) = 0\]</span></p><p>Apply Product Rule，Spartial Derivative term gives:</p><p><span class="math display">\[\nabla \cdot (\rho u) = u\cdot \nabla \rho + \rho \nabla \cdot u\]</span></p><h2 id="ipba-optimized.pdf---p24---spatial-discretization"><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=24">IPBA-optimized.pdf- p24 - SPATIAL DISCRETIZATION</a></h2><ol type="1"><li>Lagrange or Eulerian</li><li>Spatial data Structures.</li><li>FDM &amp; FEM</li></ol><h3 id="ipba-optimized.pdf---p24---lagrangian-vs-eulerian"><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=24">IPBA-optimized.pdf- p24 - Lagrangian vs Eulerian</a></h3><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=24">IPBA-optimized.pdf- p24 - IPBA-optimized-P24-20230130141500</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P24-20230130141500-20230130141502-v2eynn4.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P24-20230130141500-20230130141502-v2eynn4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><h3 id="ipba-optimized.pdf---p24---grids-meshes-particles"><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=24">IPBA-optimized.pdf- p24 - Grids, Meshes, Particles</a></h3><h4 id="grid">Grid</h4><blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=24">IPBA-optimized.pdf- p24 - Perhaps the most common spatial data structure is the regulargrid. In this structure all edges have the same length, called the gridspacing, which is often denoted ℎ or Δ𝑥.</a></p></blockquote><p>Describe a Grid: <ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=24">IPBA-optimized.pdf- p24 - The grid can be described by a few redundant parameters: thegrid spacing, the grid resolution (i.e. the number of cells in eachdimension), and the upper and lower extent of the gird.</a></p><p>对于记录一阶微分量，常用MAC-Grid（流速度场）<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=25">IPBA-optimized.pdf- p25 - A special case, known as the staggered grid (sometimesless-usefully referred to as the MAC grid</a>；<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=25">IPBA-optimized.pdf- p25 - This structure is commonly used in fluid simulation to achievesecond-order accuracy when using finite differences at small additionalcomputational cost.</a></p><h4 id="mesh">Mesh</h4><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=25">IPBA-optimized.pdf- p25 - “Meshes” itself is an ill-defined term, but typically the termis used to refer to simplicial complexes.</a></p><h4 id="particles">Particles</h4><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=26">IPBA-optimized.pdf- p26 - Given the difficulty of generating tetrahedral meshes, somechoose to represent geometry as a set of particles</a></p><p>缺点：Integration is Difficult</p><h4 id="hybrid-structures">Hybrid Structures</h4><p>MPM, FLIP ...</p><h3 id="interpolation">Interpolation</h3><p>1-d情况下，<strong>线性插值</strong>是指：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=26">IPBA-optimized.pdf- p26 - IPBA-optimized-P26-20230130143507</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P26-20230130143507-20230130143508-9rim08t.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P26-20230130143507-20230130143508-9rim08t.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>可以推广到双线性、三线性、重心坐标插值等等技术。</p><p>2d情况，可以考虑<strong>双线性插值</strong>：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=27">IPBA-optimized.pdf- p27 - IPBA-optimized-P27-20230130143733</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P27-20230130143733-20230130143735-ong722m.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P27-20230130143733-20230130143735-ong722m.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>3-d情况，<strong>三线性插值</strong>：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=27">IPBA-optimized.pdf- p27 - IPBA-optimized-P27-20230130144004</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P27-20230130144004-20230130144006-i91uidf.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P27-20230130144004-20230130144006-i91uidf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><blockquote><p>直观上来说，内部点对某一个采样点的权就是对边/面/体的测度。</p></blockquote><p>另外，对于mesh，有<strong>重心坐标</strong>插值：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=28">IPBA-optimized.pdf- p28 - IPBA-optimized-P28-20230130144137</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P28-20230130144137-20230130144139-whqxuaf.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P28-20230130144137-20230130144139-whqxuaf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p><strong>多项式插值：</strong>例如拉格朗日多项式</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=29">IPBA-optimized.pdf- p29 - IPBA-optimized-P29-20230130144224</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P29-20230130144224-20230130144226-jfxfgfe.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P29-20230130144224-20230130144226-jfxfgfe.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p><strong>逼近函数</strong>：例如傅立叶变换后的傅立叶系数，实际上是一种到某一组基函数的投影。<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=29">IPBA-optimized.pdf- p29 - Approximating functions.</a></p><h3 id="finite-differences">Finite Differences</h3><p>二阶差分格式：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=31">IPBA-optimized.pdf- p31 - IPBA-optimized-P31-20230130150631</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P31-20230130150631-20230130150632-kj6dnil.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P31-20230130150631-20230130150632-kj6dnil.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>也会带来一些问题（震荡）</p><blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=31">IPBA-optimized.pdf- p31 - When choosing a finite difference scheme, order of accuracy isonly one of several considerations. Other considerations include theoverall stability of the scheme, the nature of the errors produced bythe scheme (e.g., dissipative or dispersive), and the conservationproperties of the scheme.</a></p></blockquote><p>解决方法为：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=31">IPBA-optimized.pdf- p31 - Upwind discretizations are often preferred for advection.T</a></p><h4 id="ipba-optimized.pdf---p32---laplacian-operator."><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=32">IPBA-optimized.pdf- p32 - Laplacian operator.</a></h4><p>数值计算上：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=32">IPBA-optimized.pdf- p32 - IPBA-optimized-P32-20230130160916</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P32-20230130160916-20230130160918-mswzitq.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P32-20230130160916-20230130160918-mswzitq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><h3 id="finite-elements">Finite Elements</h3><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=34">IPBA-optimized.pdf- p34 - Arbitrary functions in the equations we wish to solve are thenprojected onto this piecewise linear space. This projection is oftenreferred to as a Galerkin projection.</a></p><h4 id="soft-bodies-1">Soft bodies</h4><blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=34">IPBA-optimized.pdf- p34 - Finite elements are commonly used in graphics for animatingelastic bodies</a></p></blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=35">IPBA-optimized.pdf- p35 - IPBA-optimized-P35-20230130165255</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P35-20230130165255-20230130165256-cog7h9a.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P35-20230130165255-20230130165256-cog7h9a.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>算法如下：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=36">IPBA-optimized.pdf- p36 - IPBA-optimized-P36-20230130165358</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P36-20230130165358-20230130165359-twfjsaw.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P36-20230130165358-20230130165359-twfjsaw.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>部分约定解释如下：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=35">IPBA-optimized.pdf- p35 - IPBA-optimized-P35-20230130165759</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P35-20230130165759-20230130165801-3vzf0pa.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P35-20230130165759-20230130165801-3vzf0pa.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p></div><div class="story post-story"><h2 id="integrators">Integrators</h2><ol type="1"><li><p>Explicit</p><ol type="1"><li><p>Trapzoidal / Mid point method</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=37">IPBA-optimized.pdf- p37 - IPBA-optimized-P37-20230130172105</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P37-20230130172105-20230130172106-12dl1ab.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P37-20230130172105-20230130172106-12dl1ab.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=37">IPBA-optimized.pdf- p37 - IPBA-optimized-P37-20230130172142</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P37-20230130172142-20230130172143-woug9rp.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P37-20230130172142-20230130172143-woug9rp.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Verlet_integration">VerletMethod</a></p><p><img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/image-20230130171940-pszeark.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/image-20230130171940-pszeark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="image"></p></li><li><p>Symplectic Euler</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=37">IPBA-optimized.pdf- p37 - IPBA-optimized-P37-20230130172220</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P37-20230130172220-20230130172222-eu032a6.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P37-20230130172220-20230130172222-eu032a6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p></li></ol></li></ol><h3 id="implicit-integration">Implicit Integration</h3><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=39">IPBA-optimized.pdf- p39 - Sometimes we wish to solve stiff problems. “Stiff problem” isnot particularly well defined, but they occur, for example, whenmaterials have very strong resistance to deformation.</a></p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=40">IPBA-optimized.pdf- p40 - IPBA-optimized-P40-20230130172324</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P40-20230130172324-20230130172326-a9ez1sm.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P40-20230130172324-20230130172326-a9ez1sm.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p></div><div class="story post-story"><h2 id="constraints">Constraints</h2><h3 id="bilateral-unilateral-constraints">Bilateral / Unilateralconstraints</h3><p>等式约束、不等式约束</p><h3 id="soft-or-hard">Soft or Hard？</h3><ol type="1"><li>Hard - 严格满足</li><li>Soft - “几乎”满足</li></ol><h3 id="solutions">Solutions</h3><p>几乎只有如下方案：</p><ol type="1"><li>惩罚力</li><li>拉格朗日乘子</li><li>广义坐标法</li></ol><h4 id="ipba-optimized.pdf---p43---penalty-methods."><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=43">IPBA-optimized.pdf- p43 - Penalty methods.</a></h4><blockquote><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=43">IPBA-optimized.pdf- p43 - Penalty methods attempt to enforce constraints by penalizingconstraint violation using spring-like restoring forces.</a></p></blockquote><p>优点：实现简单</p><p>缺点：</p><ol type="1"><li>给整个系统引入了Stiff Force，需要隐式积分来确保不发生数值爆炸</li><li>难以稳定在一个稳态上。</li></ol><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=43">IPBA-optimized.pdf- p43 - Nevertheless, penalty methods are still widely used, andresearchers continue to develop approaches to mitigate theirdrawbacks</a></p><h4 id="ipba-optimized.pdf---p43---lagrange-multipliers."><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=43">IPBA-optimized.pdf- p43 - Lagrange multipliers.</a></h4><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=43">IPBA-optimized.pdf- p43 - The method of Lagrange multipliers is an approach thatexplicitly includes in the equations of motion the constraint forcesnecessary to maintain the constraints.</a></p><p>虚功原理：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=44">IPBA-optimized.pdf- p44 - IPBA-optimized-P44-20230131111140</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P44-20230131111140-20230131111142-sa2z13y.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P44-20230131111140-20230131111142-sa2z13y.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>总的来说，牛顿第二定律为：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=45">IPBA-optimized.pdf- p45 - IPBA-optimized-P45-20230131111424</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P45-20230131111424-20230131111425-0hx295w.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P45-20230131111424-20230131111425-0hx295w.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><p>总体推导为(185)：</p><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=45">IPBA-optimized.pdf- p45 - IPBA-optimized-P45-20230131111637</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P45-20230131111637-20230131111638-iwwaidy.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P45-20230131111637-20230131111638-iwwaidy.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><h4id="广义坐标法ipba-optimized.pdf---p45---generalized-coordinates.">广义坐标法<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=45">IPBA-optimized.pdf- p45 - Generalized coordinates.</a></h4><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=46">IPBA-optimized.pdf- p46 - IPBA-optimized-P46-20230131111727</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P46-20230131111727-20230131111729-vw0jg4x.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P46-20230131111727-20230131111729-vw0jg4x.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><h3id="ipba-optimized.pdf---p48---practical-constrained-rigid-body-systems"><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=48">IPBA-optimized.pdf- p48 - Practical Constrained Rigid Body Systems</a></h3><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=50">IPBA-optimized.pdf- p50 - IPBA-optimized-P50-20230131111915</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P50-20230131111915-20230131111916-i9h4egr.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P50-20230131111915-20230131111916-i9h4egr.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p><h3 id="collisions">Collisions</h3><p>主要研究：</p><ol type="1"><li><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=50">IPBA-optimized.pdf- p50 - Collision detection. Before collisions can be resolved, theymust first be detected by checking for interpenetration of objectgeometry.</a></p><ol type="1"><li><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=50">IPBA-optimized.pdf- p50 - Polygonal geometry is commonly used to represent both rigid anddeformable bodies. Many algorithms have been developed for findingintersections of polytopes, particularly convex polytopes (illustratedabove).</a></p><p>SAT：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=50">IPBA-optimized.pdf- p50 - Separating Axis Theorem</a></p><p>Convex Decomposition：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=50">IPBA-optimized.pdf- p50 - Convex decompositions</a></p></li><li><p>SDF：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - signed distance field.</a></p></li><li><p>数据结构上：BV<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - bounding volumes</a>、<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - hierarchical bounding volumes</a>、Spatial Partition<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - spatial partitions</a></p></li><li><p>DCD：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - discrete collision detection</a>；CCD：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - Continuous collision detection</a> （<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - Ray casting</a>、<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=51">IPBA-optimized.pdf- p51 - numerical solvers</a>）</p></li></ol></li><li><p>Response：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=52">IPBA-optimized.pdf- p52 - Collision response</a></p><ol type="1"><li><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=53">IPBA-optimized.pdf- p53 - Deformable object collisions</a></p></li><li><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=53">IPBA-optimized.pdf- p53 - Rigid body collisions.</a>：不允许形变：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=53">IPBA-optimized.pdf- p53 - Typically, collision laws are used to relate quantities beforeand after the collision [Chatterjee and Ruina 1998].</a></p></li><li><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=54">IPBA-optimized.pdf- p54 - Frictional collisions.</a>：切向力</p><ol type="1"><li><p><ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=54">IPBA-optimized.pdf- p54 - Coulomb friction model</a></p><p>摩擦锥：<ahref="assets/IPBA-optimized-20221205101915-1a7vn7h.pdf?p=54">IPBA-optimized.pdf- p54 - IPBA-optimized-P54-20230131112746</a> <img src="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P54-20230131112746-20230131112747-y9uc0wl.png" class="lazyload" data-srcset="/2022/12/04/CG/siggraph-courses/Sig2021course-Intro-to-PBA/IPBA-optimized-P54-20230131112746-20230131112747-y9uc0wl.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></p></li></ol></li></ol></li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Siggraph 2021 course notes.&lt;/p&gt;
&lt;p&gt;See more in Siyuan.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读：Incremental Potential Contact 大杂烩</title>
    <link href="http://adversarr.github.io/2022/11/30/CG/SortByCato/Unified/ipc/"/>
    <id>http://adversarr.github.io/2022/11/30/CG/SortByCato/Unified/ipc/</id>
    <published>2022-11-29T16:00:00.000Z</published>
    <updated>2023-02-24T04:25:47.981Z</updated>
    
    <content type="html"><![CDATA[<p>Incremental Potential Contact</p><span id="more"></span><div class="story post-story"><h2 id="c-ipc">C-IPC</h2><h3 id="related-works">Related Works</h3><h4 id="shell-and-rods">Shell and Rods</h4><h4 id="strain-limiting">Strain Limiting</h4><p>目的：对于膜(Shell)的形变进行限制。</p><p>主要四个技术：</p><ol type="1"><li>施加约束（Eq, In-Eq）</li><li>DoF限制</li><li>Splitting Model</li><li>Solver</li></ol><h4 id="modeling-thickness-厚度建模">Modeling Thickness: 厚度建模</h4><h4 id="ccd">CCD</h4><h4 id="对于多维度物体的统一建模">对于多维度物体的统一建模</h4><h3 id="formulation">Formulation</h3><p>Elasto Dynamics: Implicit Time(Optimize-based) Integration.</p><p><span class="math display">\[E = \frac{1}{2} \| x - \hat{x}^n \|^2 + \alpha h^2 \Psi (\beta x +\gamma x^n)\]</span></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Incremental Potential Contact&lt;/p&gt;</summary>
    
    
    
    <category term="Physical Simlation" scheme="http://adversarr.github.io/categories/Physical-Simlation/"/>
    
    
    <category term="Computer Graphics" scheme="http://adversarr.github.io/tags/Computer-Graphics/"/>
    
    <category term="Paper Reading" scheme="http://adversarr.github.io/tags/Paper-Reading/"/>
    
    <category term="IPC" scheme="http://adversarr.github.io/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统综合课程设计</title>
    <link href="http://adversarr.github.io/2022/11/23/study/ComputerScience/fragments/cse/"/>
    <id>http://adversarr.github.io/2022/11/23/study/ComputerScience/fragments/cse/</id>
    <published>2022-11-22T16:00:00.000Z</published>
    <updated>2023-02-24T04:27:44.158Z</updated>
    
    <content type="html"><![CDATA[<p>SEU 19 综合课设</p><span id="more"></span><p>Project: <a href="https://github.com/adversarr/reborn">reborn</a></p><div class="story post-story"><h2 id="general-idea">General Idea</h2><img src="/2022/11/23/study/ComputerScience/fragments/cse/cpu-pipeline-graph.png" class="lazyload" data-srcset="/2022/11/23/study/ComputerScience/fragments/cse/cpu-pipeline-graph.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="cpu-pipeline-graph"><blockquote><p>Reference: <ahref="https://github.com/Evensgn/RISC-V-CPU">RISC-V-CPU</a></p></blockquote><h3 id="基本定义">基本定义</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一字节宽度</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> WordRange 31:0</span></span><br><span class="line"><span class="comment">// 高电平有效</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> Enable 1&#x27;b1</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> Disable 1&#x27;b0</span></span><br></pre></td></tr></table></figure><h3 id="cpu-顶层设计">CPU 顶层设计</h3><p>首先是考虑cpu顶层如何设计（见<code>cpu.v</code>）。考虑到一些基本的信号输入输出，并根据实验要求添加一些输入输出线：</p><ol type="1"><li>基本输入输出信号<ol type="1"><li><code>input wire clk</code>：CPU 时钟</li><li><code>input wire rst</code>：复位信号，高电平复位（输入时需要考虑UART串口）</li><li><code>input wire [5:0] interrupt_in</code>：中断输入信号，总共6-bit</li></ol></li><li>Instruction Memory 输入：<ol type="1"><li><code>input wire [31:0] instr_memory_in</code>：代表从MiniSys实验板，从InstructionMemory输入</li><li><code>output wire [31:0] instr_addr_out</code>：读InstructionMemory的指令地址</li></ol></li><li>总线相关：<ol type="1"><li><code>input wire [31:0] bus_data_in</code>：总线输入，包括IO和DataMemory（主存）</li><li><code>output wire [31:0] bus_addr_out</code>: 写入总线的地址</li><li><code>output wire bus_enable_out</code>：总线读写使能，高电平表示<strong>读写</strong>有效</li><li><code>output wire bus_write_enable_out</code>：总线写使能，高电平表示<strong>写</strong>有效</li><li><code>output wire [3:0] bus_byte_sel_out</code>：控制总线选择</li></ol></li></ol><p>对于CPU内部，分别考虑五个stage之间的关系。</p><h4 id="stageif">Stage：IF</h4><p>IF的功能是确定下一条指令地址，即PC，并能从InstructionMemory取出，其输入输出如下（实现：<code>stage_if.v</code>）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> clk, <span class="comment">// 时钟</span></span><br><span class="line"><span class="keyword">input</span> rst, <span class="comment">// 同步复位信号</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] if_pc, <span class="comment">// 当前PC，输出到Instr Mem</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span>[`WordRange] if_instr, <span class="comment">// Stage IF的指令</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span>[`WordRange] instr_memory_in, <span class="comment">// Instr Mem 返回的instruction</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> pause, <span class="comment">// 流水暂停</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> branch_enable_in, <span class="comment">// branch 使能</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span>[`WordRange] branch_addr_in, <span class="comment">// branch 目标地址</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> interrupt_enable_in,  <span class="comment">// 异常使能</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span>[`WordRange] interrupt_pc <span class="comment">// 异常处理程序跳转地址</span></span><br></pre></td></tr></table></figure><p>在没有考虑 Instr Cache 的情况下，基本只有 PC在其中需要实现，且实现逻辑上也较为简单，分情况分析即可。</p><p>从IF到ID需要传递的信号如下（实现：<code>tran_if_id.v</code>）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span>[`WordRange] if_pc, <span class="comment">// IF级PC</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span>[`WordRange] if_ins, <span class="comment">// IF级指令</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] id_pc, <span class="comment">// ID级PC</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] id_ins, <span class="comment">// ID级指令</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> pause, <span class="comment">// 流水线暂停信号</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> interrupt_enable_in    <span class="comment">// 异常处理</span></span><br></pre></td></tr></table></figure><h4 id="stageid">Stage：ID</h4><p>指令译码模块的功能是对指令进行译码，输出包括：源操作数1、源操作数2、写入的目的寄存器的运算类型（逻辑、移位、算术）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> rst,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> pc_in,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [`WordRange] ins_in,</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register IO:</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [`WordRange] reg1_data_in,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [`WordRange] reg2_data_in,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> reg1_read_enable_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> reg2_read_enable_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [`WordRange] reg1_read_addr_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [`WordRange] reg2_read_addr_out,</span><br><span class="line"><span class="comment">// ALU:</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [`ALUOpRange] alu_op_out,</span><br><span class="line"><span class="comment">// Source Operands</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [`WordRange] data1_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [`WordRange] data2_out,</span><br><span class="line"><span class="comment">// Writes to reg?</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> reg_write_enable_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [`RegRangeLog2] reg_write_addr_out,</span><br><span class="line"><span class="comment">// Data Correlated =&gt; From EX</span></span><br><span class="line"><span class="keyword">input</span> ex_write_reg_enable_in,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [`WordRange] ex_write_reg_data_in,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [`RegRangeLog2] ex_write_reg_addr_in,</span><br><span class="line"><span class="comment">// Data Correlated =&gt; From MEM</span></span><br><span class="line"><span class="keyword">input</span> mem_write_reg_enable_in,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [`WordRange] mem_write_reg_data_in,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [`RegRangeLog2] mem_write_reg_addr_in,</span><br><span class="line"><span class="comment">// Pipeline Stall Req Signal:</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> pause_out,</span><br><span class="line"><span class="comment">// delay-slot: Reference pdf Page206</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> is_in_delayslot_in,  <span class="comment">// current instr is in slot.</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> is_in_delayslot_out, <span class="comment">// current instr is in slot.</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> next_is_in_delayslot_out,  <span class="comment">// next instr is in slot.</span></span><br><span class="line"><span class="comment">// Branch:</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> branch_enable_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] branch_addr_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] link_addr_out,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] ins_out,</span><br><span class="line"><span class="comment">// Interruption</span></span><br><span class="line"><span class="comment">// abnormal_type_out</span></span><br><span class="line"><span class="comment">// 31...12 预留</span></span><br><span class="line"><span class="comment">// 11 eret</span></span><br><span class="line"><span class="comment">// 10 systemcall</span></span><br><span class="line"><span class="comment">// 9...8 abnormal info</span></span><br><span class="line"><span class="comment">// 7...0 interrupt info</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] abnormal_type_out,     <span class="comment">// information about instr</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>[`WordRange] current_id_pc_addr_out</span><br></pre></td></tr></table></figure><p>所有指令类型根据《自己动手实现CPU》实现。</p><h4 id="idex">ID→EX</h4><p>从译码到执行过程中需要传递的信号（及其解释如下）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ALU 功能选择</span></span><br><span class="line">ex_aluop &lt;= id_aluop;</span><br><span class="line"><span class="comment">// ALU 数据</span></span><br><span class="line">ex_data1 &lt;= id_data1;</span><br><span class="line">ex_data2 &lt;= id_data2;</span><br><span class="line"><span class="comment">// （传到WB阶段）写使能</span></span><br><span class="line">ex_write_reg_enable &lt;= id_write_reg_enable;</span><br><span class="line">ex_write_reg_addr &lt;= id_write_reg_addr;</span><br><span class="line"><span class="comment">// 跳转地址</span></span><br><span class="line">ex_link_addr &lt;= id_link_addr;</span><br><span class="line"><span class="comment">// 延迟槽</span></span><br><span class="line">ex_is_in_delayslot &lt;= id_is_in_delayslot;</span><br><span class="line">ex_next_is_in_delayslot &lt;= id_next_is_in_delayslot;</span><br><span class="line"><span class="comment">// 指令</span></span><br><span class="line">ex_instr &lt;= id_instr;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">ex_current_pc_addr &lt;= id_current_pc_addr;</span><br><span class="line">ex_abnormal_type &lt;= id_abnormal_type;</span><br></pre></td></tr></table></figure><h4 id="stage-ex">Stage EX</h4></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SEU 19 综合课设&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="http://adversarr.github.io/categories/Computer-Science/"/>
    
    
  </entry>
  
  <entry>
    <title>Todo List - 挖坑</title>
    <link href="http://adversarr.github.io/2022/11/19/talk-chat/todolist/"/>
    <id>http://adversarr.github.io/2022/11/19/talk-chat/todolist/</id>
    <published>2022-11-18T16:00:00.000Z</published>
    <updated>2023-02-24T04:32:07.379Z</updated>
    
    <content type="html"><![CDATA[<p>一个长期的TodoList。</p><span id="more"></span><div class="story post-story"><h2 id="section">2022-11-19</h2><p>The 10 Algorithms with the Greatest Influence on the Development andPractice of Science and Engineering in the 20th Century (Computing inScience &amp; Engineering)</p><ol type="1"><li>Metropolis Algorithm for Monte Carlo</li><li>Simplex Method for Linear Programming</li><li>Krylov Subspace Iteration Methods</li><li>The Decompositional Approach to Matrix Computations</li><li>The Fortran Optimizing Compiler</li><li>QR Algorithm for Computing Eigenvalues</li><li>Quicksort Algorithm for Sorting</li><li>Fast Fourier Transform</li><li>Integer Relation Detection</li><li>Fast Multipole Method</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个长期的TodoList。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读：Elasto Monolith</title>
    <link href="http://adversarr.github.io/2022/11/13/CG/SortByCato/Unified/ElastoMonolith/"/>
    <id>http://adversarr.github.io/2022/11/13/CG/SortByCato/Unified/ElastoMonolith/</id>
    <published>2022-11-12T16:00:00.000Z</published>
    <updated>2023-02-24T04:27:50.056Z</updated>
    
    <content type="html"><![CDATA[<p>ElastoMonolith: A Monolithic Optimization-based Liquid Solver forContact-Aware Elastic-Solid Coupling</p><span id="more"></span><div class="story post-story"><h2 id="elasto-monolith-overview">Elasto Monolith Overview</h2><p>使用基于优化的时间积分器，来实现流固动力学计算及其耦合。</p><ol type="1"><li>流体动力学：使用APIC，网格上全隐式的求解</li><li>变形体动力学：Position-level Optimization</li><li>刚体动力学：Velocity-level Friction contact handling(ref: Siggraph2022 course)</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Algorithm EM:</span><br><span class="line"><span class="bullet">1.</span> map fluid velocity (P-&gt;G)</span><br><span class="line"><span class="bullet">2.</span> add Explicit External Force</span><br><span class="line"><span class="bullet">3.</span> solve the system</span><br><span class="line"><span class="bullet">4.</span> advect particles and update rigid body positions.</span><br></pre></td></tr></table></figure><p>该最小化问题集成了：</p><ol type="1"><li>粘性、无粘性液体 + Incompressibility</li><li>刚体、弹性体 + Friction</li></ol><p>消除了可见的错误：</p><ol type="1"><li>体积流失</li><li>穿透</li><li>流固耦合上的能量损失</li></ol><p><span class="math display">\[\mathbf{u}, \mathbf{x}_e \mathbf{v}_r = \arg\min_{d\in \mathcal{D}, h\in \mathcal{H}} E(u, x, r)\]</span></p><p>其中，<span class="math inline">\(E\)</span>由三部分组成：</p><p><span class="math display">\[E = E_{f} + E_{e} + E_{r}\]</span></p><p>分别是流体项、弹性体项、刚体项</p><blockquote><p>相当的朴实无华...</p></blockquote><h3 id="rigid-body-simulation">Rigid body Simulation</h3><p>Contact handling of rigid bodies =&gt; Energy Minimization.</p><p>Object for rigid bodies can be written as the kinematic energy-normof difference between before and after.</p><p><span class="math display">\[E_r(v_r) = \frac{1}{2} \| v_r - v_{r}^{*} \|_{\alpha M_r}\]</span> 其中：<span class="math inline">\(v_r^*\)</span> 和 <spanclass="math inline">\(v_r\)</span> 是 before 和 after 的刚体速度，<spanclass="math inline">\(M_r\)</span> 为质量矩阵</p><p><span class="math display">\[v_r = v_{r}^{*} + \Delta t (\alpha M_r)^{-1} (F_{r s} s + F_{r p} p +\alpha J_r^Tc)\]</span></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;ElastoMonolith: A Monolithic Optimization-based Liquid Solver for
Contact-Aware Elastic-Solid Coupling&lt;/p&gt;</summary>
    
    
    
    <category term="Physical Simlation" scheme="http://adversarr.github.io/categories/Physical-Simlation/"/>
    
    
    <category term="Computer Graphics" scheme="http://adversarr.github.io/tags/Computer-Graphics/"/>
    
    <category term="Paper Reading" scheme="http://adversarr.github.io/tags/Paper-Reading/"/>
    
    <category term="Rigid-Fluid Coupling" scheme="http://adversarr.github.io/tags/Rigid-Fluid-Coupling/"/>
    
  </entry>
  
  <entry>
    <title>Digital Geometry Processing</title>
    <link href="http://adversarr.github.io/2022/11/04/CG/DGP/lec1/"/>
    <id>http://adversarr.github.io/2022/11/04/CG/DGP/lec1/</id>
    <published>2022-11-04T04:14:06.796Z</published>
    <updated>2022-11-05T01:34:39.274Z</updated>
    
    <content type="html"><![CDATA[<p>GCL-F-DGP1</p><span id="more"></span><div class="story post-story"><h2 id="representations">Representations</h2><p>How to represent geometry data in computer.</p><h3 id="point-cloud">Point cloud</h3><p><span class="math display">\[P = \{ p _ 1, \dots , p _ n\}\]</span></p><p>A set of data points in some coord-system.</p><p>Applications: scanners</p><h3 id="signed-distance-function-sdf">Signed Distance Function(SDF)</h3><p>Give the distance of a given point x from the boundary of <spanclass="math inline">\(\Omega\)</span></p><ol type="1"><li>inside -&gt; neg</li><li>outside -&gt; pos</li></ol><blockquote><p>Truncated SDF(TSDF)</p></blockquote><h3 id="implicit-function">Implicit Function</h3><p><span class="math display">\[F(x, y, z) = 0\]</span></p><p>SDF is some kind of IF.</p><h3 id="grid">Grid</h3><h4 id="pixel-voxel">Pixel, Voxel</h4><ol type="1"><li><p>Adaptive: Grid-Hierarchical Oct-Tree</p></li><li><p>Patch-based quadtree.</p><p>Ref: Adaptive O-CNN</p></li></ol><h3 id="triangle-mesh">Triangle Mesh</h3><p>A collection of triangles. without any mathematical structure.</p><p>Geometry component:</p><ul><li>Vertices: <span class="math inline">\(v _ 1 ... v _ N\)</span></li></ul><p>Topological component:</p><ul><li>Triangle: <span class="math inline">\(T\)</span></li><li>Edge: <span class="math inline">\(E\)</span></li></ul><blockquote><p>Topology describes the connectivity.</p></blockquote><h4 id="quad-mesh">Quad Mesh</h4><p>不一定是共面的！</p><blockquote><p><strong>Homework 1</strong>: Shortest Path, Minimal Spaning Tree</p></blockquote><h4 id="manifold">2-manifold</h4><p>Euler Formula <span class="math display">\[N_V -N_E+ N_F= 2(1-g)\]</span></p><ul><li><span class="math inline">\(g\)</span>为亏格数量</li></ul><h4 id="data-structure---requirements">Data Structure -requirements</h4><ol type="1"><li>Given <span class="math inline">\(f_j\)</span>, find its containingvertices in order</li><li>Given <span class="math inline">\(v_i\)</span>, find its one-ringfacets in order</li><li>Given <span class="math inline">\(v_i\)</span>, find adjacentvertices/outgoing edges</li><li>Given <span class="math inline">\(e_k\)</span>, find its connectedtwo facets</li><li>Given <span class="math inline">\(f_j\)</span> and <spanclass="math inline">\(e_k\)</span>, find another facet which connects<span class="math inline">\(e_k\)</span></li><li>…</li></ol><p>Half edge Data structure!</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GCL-F-DGP1&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读：SPH Introduction</title>
    <link href="http://adversarr.github.io/2022/10/27/CG/SortByCato/SPH/1106paper/"/>
    <id>http://adversarr.github.io/2022/10/27/CG/SortByCato/SPH/1106paper/</id>
    <published>2022-10-26T16:00:00.000Z</published>
    <updated>2023-02-24T04:25:47.981Z</updated>
    
    <content type="html"><![CDATA[<p>1106 论文汇报</p><p>SPH Fluids in computer graphic</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><h3 id="governing-equations">Governing Equations</h3><p>Consider fluid that consists of a set of small moving fluidelements(i.e. particles), and for each particle, it carriesattributes:</p><ol type="1"><li>Density <span class="math inline">\(\rho _ i\)</span></li><li>Pressure <span class="math inline">\(p _ i\)</span></li><li>volume <span class="math inline">\(v _ i\)</span></li></ol><p>From Newton's second law:</p><p><span class="math display">\[\frac{\mathrm d x _ i} {\mathrm d t} = v _ i\]</span></p><p>We use particles to describe the fluid flow, the time rate of changeof the velocity is governed by the <strong>Lagrange</strong> view of NSEquation.</p><p><span class="math display">\[\dot v _ i = -\frac 1 {\rho _ i} \nabla p _ i + v \nabla ^ 2 v _ i +\frac{F _ {ext}} {m _ i}\]</span></p><ol type="1"><li>Pressure</li><li>Friction force. <span class="math inline">\(v\)</span> -&gt;kinematic viscosity.</li><li>External force, such as gravity.</li></ol><h3 id="sph">SPH</h3><p>Idea: Interpolate the fluid quantities at arbitary positions and toapproximate the spatial derivatives, <strong>using a set of samplepositions, i.e. adjacent particles</strong></p><p><em>Interpolation</em>: A quantity <span class="math inline">\(A _i\)</span> at <span class="math inline">\(x _ i\)</span> is approximatedusing a weighted sum of neighbour particles:</p><p><span class="math display">\[A _ i = \sum _ {j \in \mathcal N _ i} \frac{m _ j} { \rho _ j } A _ j W_ {ij}\]</span></p><p><span class="math inline">\(W _ {ij}\)</span> should be close to aGaussian, amd can be implemented as:</p><ol type="1"><li>Bell function</li><li>Quintic Spline -- <span class="math inline">\(C^1\)</span>continuity</li><li>Cubic Spline -- <span class="math inline">\(C ^ 2\)</span>continuity</li></ol><p><em>Spatial Derivatives</em>: Spatial derivatives can be derived:</p><p><span class="math display">\[\begin{aligned}\nabla A_i = \rho_i + \sum_{j} m_j  \left ( \frac { A _ i} { \rho _ i  ^2} + \frac{A _ j} {\rho _ j ^ 2}\right) \nabla W_ { i j }\\\nabla \cdot \mathbf{A}_i = - \frac 1 { \rho _ i} \sum _ j m _ j \mathbfA _ {ij} \cdot \nabla W _ {ij} \\\nabla ^ 2 A _ i = 2 \sum _ { j } \frac { m _ j} { \rho _ j} A _ {ij}\frac {\mathbf x _ {ij} \cdot \nabla W _ { ij }}{\mathbf x _ {ij} \cdot\mathbf x _ {ij} + 0.01 h ^ 2}\end{aligned}\]</span></p><p>Here, <span class="math inline">\(\rho\)</span> is computedusing:</p><p><span class="math display">\[\rho_i  = \sum_j m_j W_{ij}\]</span></p><blockquote><p>we always use <span class="math inline">\(m / \rho\)</span>, and themeaning of <span class="math inline">\(\rho\)</span> here does notmatter.</p></blockquote><h3 id="the-solver">The solver</h3><p>Three basic steps:</p><ol type="1"><li>Neighbourhood search</li><li>Pressure Computation</li><li>Time Integrations</li></ol><p>Neighbourhood search can be solved using VDB or SpatialOrdering/Hashing methods. We focus on 2 and 3.</p><p>A typical choice is:</p><p>For <em>Pressure Computation</em>:</p><p><span class="math display">\[p_i = k \left( \left ( \frac{\rho_i}{\rho_0}\right) ^ 7 - 1 \right)\]</span></p><p>where:</p><ul><li><span class="math inline">\(\rho_0\)</span> is the restdensity.</li><li><span class="math inline">\(k\)</span> is the stiffness.</li></ul><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foreach Particle P:</span><br><span class="line">  find neighbours.</span><br><span class="line">foreach Particle P:</span><br><span class="line">  compute density.</span><br><span class="line">  compute pressure.</span><br><span class="line">foreach Particle P:</span><br><span class="line">  compute pressure force.</span><br><span class="line">  compute viscosity force</span><br><span class="line">  compute <span class="keyword">external</span> force</span><br><span class="line">  merge <span class="built_in">all</span> the forces.</span><br><span class="line"></span><br><span class="line">foreach Particle P:</span><br><span class="line">  update velocity, position.</span><br></pre></td></tr></table></figure><blockquote><p><strong>CFL Condition</strong> should be considered carefully whenusing this method.</p></blockquote><p><span class="math display">\[\Delta t \le \lambda \frac{ h } { \| v _ {\max} \| }, \qquad\mathrm{with}~~\lambda \approx 0.4\]</span></p><h3 id="neightbourhood-search">Neightbourhood Search</h3><p><em>Time</em>: 1. Grids: <span class="math inline">\(O(n)\)</span>build, <span class="math inline">\(O(1)\)</span> access 2. Hierarchy:<span class="math inline">\(O(n log n)\)</span> build, <spanclass="math inline">\(O(log n)\)</span> access.</p><p><em>Memory</em>: Hierarchy &lt; Grid.</p><ol type="1"><li><em>Iterative</em>: Reuse the structure frequently, and we can storethe neighborhood set, and rebuild it from time to time.</li><li><em>Non-Iterative</em>:</li></ol><h4 id="uniform-grid">Uniform Grid</h4><ol type="1"><li>Index Sort -&gt; See GPU Gems 3</li><li>Z-index Sort -&gt; latency, cache hit rate</li></ol><h4 id="hashing">Hashing</h4><ol type="1"><li>hashing,</li><li>compact hasihing.</li></ol><blockquote><p>To reduce the memory consumption of plain grid storaging method.</p><p>but it reduce the <em>cache-hit-rate</em></p></blockquote><h3 id="gpus">GPUs</h3></div><div class="story post-story"><h2 id="incompressibility">Incompressibility</h2><h3 id="non-iterative-eos-solver">Non Iterative EOS Solver</h3><p><strong>EOS</strong>: Describe the relation between <spanclass="math inline">\(\rho\)</span>, <spanclass="math inline">\(p\)</span>, and <spanclass="math inline">\(T\)</span>(temperature).</p><p>Original:</p><p><span class="math display">\[p = p (\rho , T) = \frac{\mu}{R} \rho T\]</span></p><p>Typically, for water:</p><p><span class="math display">\[\rho = \rho _ 0\]</span></p><p>Pressure penals the violation of the condition.</p><h3 id="non-iterative-eos-solvers-with-splitting">Non Iterative EOSSolvers with Splitting</h3><p>Split the:</p><ol type="1"><li>Pressure Force</li><li>Non-Pressure Force</li></ol><p>because:</p><p><span class="math display">\[\frac { 1 } {\Delta t} (v(t + \Delta t) - v^ * (t) ) = - (1 / \rho ^ * _i) \nabla p _ i\]</span></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> P: <span class="built_in">find</span> neighbours</span><br><span class="line"><span class="keyword">foreach</span> P: compute Non-Pressure forces  -&gt; Advection</span><br><span class="line"><span class="keyword">foreach</span> P: compute Pressure forces.     -&gt; Projection, use data <span class="keyword">from</span> Advection</span><br><span class="line"><span class="keyword">foreach</span> P: update <span class="built_in">velocity</span> &amp; <span class="built_in">position</span></span><br></pre></td></tr></table></figure><h3 id="iterative-eos-solvers-with-splitting">Iterative EOS Solvers withSplitting</h3><p>Alternatively, <em>strong-incompressibility</em>.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foreach</span> P: <span class="built_in">find</span> neighbours</span><br><span class="line"><span class="built_in">foreach</span> P: compute Non-Pressure part.       -&gt; Advection</span><br><span class="line"><span class="keyword">repeat</span> <span class="keyword">until</span> convergence:                   -&gt; Projection(weak)</span><br><span class="line">  <span class="built_in">foreach</span> P: compute density <span class="keyword">and</span> pressure</span><br><span class="line">  <span class="built_in">foreach</span> P: update velocity <span class="keyword">and</span> positions</span><br></pre></td></tr></table></figure><p>e.g.:</p><ol type="1"><li>PCISPH</li><li>LPSPH</li></ol><h3 id="pressure-projection">Pressure Projection</h3><p>Solve a pressure poisson equation(PPE).</p><p><span class="math display">\[\nabla ^ 2 p _ i = \frac {\rho _ 0} {\Delta t} \nabla \cdot v_i\]</span></p><ol type="1"><li>IISPH</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foreach P: find neighbours</span><br><span class="line">foreach P: <span class="built_in">compute</span> Non-Pressure part.       -&gt; Advection</span><br><span class="line">foreach P: <span class="built_in">compute</span> rho*</span><br><span class="line"><span class="built_in">solve</span> PPE                                   -&gt; Projection</span><br><span class="line"><span class="built_in">compute</span> Pressure Force</span><br><span class="line">update v, x</span><br></pre></td></tr></table></figure><blockquote><p>As the overall computation time of all solvers largely depends on theobtained incompressibility, average or maximum density errors areconsidered to specify the simulation quality.</p></blockquote></div><div class="story post-story"><h2 id="incompressibility----extra">Incompressibility -- Extra</h2><p>In (EG 2022): There are only two categories:</p><ol type="1"><li>weak-incompressible: incompressible is not enforced, only a<em>trend</em> is formulated. Pressure indicates incompressible.</li></ol><ul><li>Local Pressure Solver</li></ul><ol start="2" type="1"><li>strong-incompressible: incompressible PPE is solved.</li></ol><ul><li>Global Pressure Solver</li></ul><p>In this sense: target of PCISPH = IISPH = PBF.</p><h3 id="iisph">IISPH</h3><p><span class="math display">\[\Delta t^2 \nabla^2 p_i = \rho^0 - (\rho_i - \Delta t \rho_i\nabla \cdotv_i^{*})\]</span> step 1: compute the pressure accelerations:</p><p><span class="math display">\[(a_i^P)^l = - \frac{1}{\rho_i} \nabla p_i^l\]</span> step 2: compute density change <span class="math display">\[\Delta \rho = \Delta t \sum_j m_j\Delta t(a_i^p - a_j^p)\Delta W_{ij}\]</span> ## Boundary Handling</p><p>Most methods: Extend the field attributes to the boundary.</p><h3 id="particle-based-methods">Particle-based Methods</h3><p>Also sample the particle points on rigid/deformable bodies, computethe penalty force based on distance.</p><blockquote><p>The boundary particles serve as additional sampling points andtypically have the same radius as the fluid particles.</p></blockquote><p><span class="math display">\[\rho_i = \rho_{\mathcal{F}} + \rho_{\mathcal{B}} \approx \sum_j m_jW_{ij} + \sum_k \tilde{m}_k W_{ik}\]</span> when computing the pressure and force, these particles shouldbe considered as well.</p><p><strong>How-to-Sample</strong>:</p><ol type="1"><li>uniform / non-uniform</li><li>single-layer/multi-layer</li></ol><p><strong>Pros</strong>:</p><ol type="1"><li>simplicity: generate, integration, computation</li></ol><p><strong>Cons</strong>:</p><ol type="1"><li>result in small time-steps for weak-incompressible fluids. (pressurevariety is large)</li><li>even simple geometry shape need large amount of particles.</li><li><em>bumpy representation</em>: reduce the accuracy of pressurecomputation, introduce artificial friction. -&gt; Implicit boundaryrepresentation.</li></ol><h3 id="implicit-method">Implicit Method</h3><p>Signed Distance Function.</p><h3 id="computing-the-boundary-pressure">Computing the boundarypressure</h3><p>Original, without boundary:</p><p><span class="math display">\[(a_i^P)^l = - \frac{1}{\rho_i} \nabla p_i^l = - \sum_j m \left(p_i^l/\rho_i^2 + p_j^l/\rho_j^2 \right)\Delta W_{ij}\]</span></p><p>With boundary:</p><p><span class="math display">\[(a_i^P)^l = - \sum_j m_j \left( p_i^l/\rho_i^2 + p_j^l/\rho_j^2\right)\Delta W_{ij} - \sum_k m_k \left( p_i^l/\rho_i^2 + p_k^l/\rho_k^2\right)\Delta W_{ik}\]</span></p><p>To define <span class="math inline">\(p_k\)</span>:</p><ol type="1"><li>Pressure Mirroring: <span class="math inline">\(p_k =p_i\)</span></li><li>Pressure Extrapolation:</li></ol><p><span class="math display">\[p_k = \frac{\sum_l p_lW_{kl}+ \mathbf{g} \cdot \sum_j \rho_l(x_k -x_l)W_{kl}}{\sum_l W_{kl}}\]</span></p><h3 id="penalty-based-methods">Penalty based Methods</h3><p><strong>Cons</strong>: hard to control the stiffness, and have smalltime steps.</p></div><div class="story post-story"><h2 id="other-techniques">Other Techniques</h2><ol type="1"><li>Adaptive time-step</li><li>Data-Driven.</li></ol><h3 id="cnns">CNNs</h3><p>Target: enforce incompressibility</p><p>Steps:</p><ol type="1"><li>Rasterize to Grid.</li><li>use cnn on grid to compute the velocity correction.</li></ol></div><div class="story post-story"><h2 id="future-work">Future work</h2><ol type="1"><li>Approximate Quality:<ol type="1"><li>particle count is low =&gt; degradation of approximation</li><li>lack of practical and sufficient solution: because negative pressureare clamped to 0, only projective Jacobi or GS Iteration is allowed.Conj-Grad is not available currently.</li></ol></li><li>Unified Solver &amp; Ultimate Coupling:<ol type="1"><li>Unified Coupling solver.</li><li>Suitable for multiple particle-resolution.</li></ol></li><li>Artist Control</li><li>Data Driven</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;1106 论文汇报&lt;/p&gt;
&lt;p&gt;SPH Fluids in computer graphic&lt;/p&gt;</summary>
    
    
    
    <category term="Physical Simlation" scheme="http://adversarr.github.io/categories/Physical-Simlation/"/>
    
    
    <category term="Computer Graphics" scheme="http://adversarr.github.io/tags/Computer-Graphics/"/>
    
    <category term="Paper Reading" scheme="http://adversarr.github.io/tags/Paper-Reading/"/>
    
    <category term="Fluid Simulation" scheme="http://adversarr.github.io/tags/Fluid-Simulation/"/>
    
    <category term="SPH" scheme="http://adversarr.github.io/tags/SPH/"/>
    
  </entry>
  
  <entry>
    <title>Games 301</title>
    <link href="http://adversarr.github.io/2022/10/07/CG/GAMES/games301/lec1/"/>
    <id>http://adversarr.github.io/2022/10/07/CG/GAMES/games301/lec1/</id>
    <published>2022-10-07T02:26:33.747Z</published>
    <updated>2022-12-03T07:55:20.576Z</updated>
    
    <content type="html"><![CDATA[<p>Games 301-01</p><span id="more"></span><div class="story post-story"><h2 id="曲面参数化">曲面参数化</h2><h3 id="引入">引入</h3><ul><li>几何直观：从三维曲面展开成2d曲面</li><li>数学本质：三维曲面在二维平面的嵌入/映射<ul><li>构建曲面到平面的一一对应</li><li>3d曲面的本质是2d的：2d流形（拓扑同胚）</li></ul></li></ul><h4 id="应用曲面贴图">应用：曲面贴图</h4><ol type="1"><li>纹理、法相、偏置、颜色、材质……</li><li>工业界：uv图</li></ol><h4 id="应用纹理地图texture-atalas">应用：纹理地图（TextureAtalas）</h4><ol type="1"><li>Segmentation &amp; Packing</li></ol><h4 id="应用曲面拟合">应用：曲面拟合</h4><ol type="1"><li>曲线：B样条</li><li>曲面：T样条、NURBS</li></ol><h4 id="应用曲面渲染">应用：曲面渲染</h4><ol type="1"><li>虚拟纹理</li><li>虚拟几何</li><li>mipmap</li><li>LOD</li></ol><p>……</p><h3 id="表达方法">表达方法</h3><ol type="1"><li>基函数 -- 连续函数</li><li>分片映射方法<ol type="1"><li>三角网格</li><li>线性映射拼接</li></ol></li></ol><h4id="参数化的度量什么是最优的参数化">参数化的度量：什么是“最优”的参数化？</h4><p>不同的范数（或度量）下，最优是不同的。</p><h4 id="jacobian-的几何意义">Jacobian 的几何意义</h4><p><span class="math display">\[Jf(\mathbf x)\]</span></p><p>定义了局部的形变量。</p><p>行列式表明面积的变化</p><h4 id="保持xx的映射">保持xx的映射</h4><ol type="1"><li>保角映射 - conformal （共形）</li><li>保面积 - authalic（等积）</li><li>等距</li></ol><p>Theorem： 共形映射总是存在的。</p><p>共形映射</p><ul><li>对数共形因子</li><li>Yamabe 方程 （内蕴高斯曲率）</li></ul><p>等距映射：保持任意两点的测地曲率。</p><ul><li>可展曲面：高斯曲率处处为0<ul><li>只有三种：柱面、锥面、切线面</li></ul></li></ul><h3 id="几何形变-distortion">几何形变 distortion</h3><p>svd on <span class="math inline">\(J\)</span>：</p><ul><li>保角：<span class="math inline">\(\sigma _1 = \sigma_2\)</span></li><li>等积：<span class="math inline">\(\sigma _ 1 \sigma _ 2 =1\)</span></li><li>等距：<span class="math inline">\(\sigma _ 1 = \sigma _ 2 =1\)</span></li></ul><h4 id="locally-bijactive-injective">Locally bijactive = Injective</h4><p>The sufficient condition:</p><p><span class="math display">\[det Jf &gt; 0\quad\forall x\]</span></p><h4 id="global-bijective-v.s.-locally-bijective.">Global Bijective v.s.Locally Bijective.</h4><img src="/2022/10/07/CG/GAMES/games301/lec1/16651115265131.jpg" class="lazyload" data-srcset="/2022/10/07/CG/GAMES/games301/lec1/16651115265131.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><h4 id="distortion-metric">Distortion Metric</h4><ol type="1"><li>Conformal (2003): <span class="math inline">\(\sigma_2 / \sigma _1\)</span></li><li>MIPS: <span class="math inline">\(\sigma _ 1 / \sigma _ 2 + \sigma _2 / \sigma _1\)</span></li><li>Symm Dirichlet: <span class="math inline">\(\sigma_1^2 + \frac 1{\sigma_1 ^ 2} + \sigma_2 ^ 2 + \frac 1 {\sigma_2 ^ 2}\)</span></li></ol><h3 id="广义参数化和数据降维">广义参数化和数据降维</h3><p>相容性网格：构建曲面的映射（双）</p><p>体参数化(Volumetric Parameterization).</p><p>都属于<strong>几何映射</strong>：Inversion free Geometric mappingconstruction: A Survey (Fu 2021 CVM)</p><p>参数化表达：何为参数？</p><ol type="1"><li>本征维度</li><li>维度估计：高维数据可能存在低维结构。</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Games 301-01&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Implement Autodiff using Meta Programming in C++</title>
    <link href="http://adversarr.github.io/2022/10/05/study/bachelor_final/meta_intro/"/>
    <id>http://adversarr.github.io/2022/10/05/study/bachelor_final/meta_intro/</id>
    <published>2022-10-04T16:00:00.000Z</published>
    <updated>2022-12-03T07:56:47.799Z</updated>
    
    <content type="html"><![CDATA[<p>本来是想发在知乎的，但想了想还是先首发在自己的blog上。</p><span id="more"></span><blockquote><p>Template metaprogramming is a family of techniques to create newtypes and compute values at compile time. C++ templates are Turingcomplete if there are no limits to the amount of recursiveinstantiations and the number of allowed state variables. Erwin Unruhwas the first to demonstrate template metaprogramming at a committeemeeting by instructing the compiler to print out prime numbers in errormessages. The standard recommends an implementation support at least1024 levels of recursive instantiation, and infinite recursion intemplate instantiations is undefined behavior.</p></blockquote><h2id="为什么我们需要自动求导为什么是编译期自动求导">为什么我们需要自动求导，为什么是编译期自动求导</h2><p>首先回答第一个问题：在我看来自动求导能够避免不必要的错误、方便想法的快速实现。例如在物理仿真领域的计算中，大都需要“能量函数”（特别是弹性能量）的梯度、Hessian，以支持牛顿迭代法进行快速求解。而大多数的能量形式都十分复杂，直接手推公式十分容易出错，并且写出的表达式也不利于机器进行优化（例如Eigen的LazyEvaluation），因此自动求导是十分有必要的。<ahref="https://zhuanlan.zhihu.com/p/413934057">Ref</a></p><p>再回答另一个问题，为什么是编译期的自动求导，主要是原因：</p><ol type="1"><li>物理仿真中的导数形式相对固定，没有必要多次进行计算图的构建；</li><li>计算图模型的每一个节点都进行了数据的存储，不利于Eigen等数学库的LazyEvaluation优化，也不利于SIMD指令的优化（例如<spanclass="math inline">\(ax+b\)</span>，会被拆分为乘法、加法两个节点）但静态的编译期自动求导则可以利用到，这些编译期优化。</li></ol><img src="/2022/10/05/study/bachelor_final/meta_intro/16691019900751.jpg" class="lazyload" data-srcset="/2022/10/05/study/bachelor_final/meta_intro/16691019900751.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><p>这篇文章大致分为三个模块</p><ol type="1"><li>模版元、自动求导的算法与数学基础</li><li>一个基本的自动求导实现</li><li>性能优化与展望</li></ol><div class="story post-story"><h2 id="引言模版元和自动求导的基础">引言：模版元和自动求导的基础</h2><h3id="模版元编程到底做了什么为什么需要模版元编程">模版元编程到底做了什么、为什么需要模版元编程</h3><p>实际上我感觉模版元编程在大学本科阶段中介绍的并不多，而真正使用过模版元编程的同学也少之又少，我觉得原因主要是：</p><ol type="1"><li>课堂中教授的有关泛型的内容，并不是一个后续解决问题时的核心手段：对于大一并没有专业方向的同学而言，后续的发展的多样性非常高，而泛型只是个别语言中的核心特性，且具有和C++相类似的模版推导能力的语言并不多；</li><li>模版元编程并不是最主流的设计，也不是最经济的设计方法：总体上模版元还是一个较为新颖的方法，一来一些机器上无法通过编译（C++11/17），模版元并不是一个“稳定”的解决方案，相比面向对象等已经广泛应用的方法而言，其应用上还是具有一定的局限；二来在算法的设计、coding本身的复杂度上都相较于原有的面向对象方法提升了不止一个档次，入门门槛变高；</li><li>模版元编程解决的并不是原本（指泛型）不能解决的问题，而是提升算法运行时效率/提升抽象程度的一个手段</li></ol><p>其实还有一些原因，但受限于我的开发经验并不多，而且本文的主要目的是介绍模版元编程，就仅仅在此提一嘴。</p><p>回到正题，抛开模版本身的复杂程度，在实际应用上的价值是很大的：</p><h4 id="c11">～C++11</h4><p>对于原本（指C++11前）的模版而言，其主要起到的功能是作为类型构造器存在，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这也是STL中的大多数<strong>容器</strong>起到的功能，通过设置模版参数，能够简化并封装对于数组<code>vector/array</code>、关联容器<code>map/unordered_map</code>、链表<code>list/deque</code>等的封装。</p><p>以及也有容器适配器，例如<code>stack</code>类模版，其本身并不是一个容器模版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = deque&lt;T&gt;&gt; <span class="keyword">class</span> stack;</span><br></pre></td></tr></table></figure><p>其依赖于 <code>Container</code>来表明底层实际使用的容器，再通过自身封装的接口为用户提供栈这种数据结构的功能。</p><p>总结一下，C++11之前，模版的功能还是相对单一，模版主要提供一个类型/函数构造的方法，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Array</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>Array</code>本身<strong>并不是类型</strong>，只有<code>Array&lt;int&gt;</code>才是类型。这也是为什么模版类/模版函数的实现一定要放在头文件里面的原因，因为从概念上讲，template标记的东西并不直接生成机器二进制代码，而只有你尝试将其变为类型，也就是你使用模版的时候才进行二进制代码生成。</p><p>在C++11之前，模版已经引入了特化的功能，最经典的例子是<code>std::vector&lt;bool&gt;</code>：如果没有特化的功能，在使用这个类的时候，有多少个<code>bool</code>就会开辟多少空间，这样是很浪费的，就算一个<code>bool</code>只有一字节（最少也是），也会为此浪费8倍的存储空间。具体的实现大家可以去各大平台逛一逛，大多数还是讲的很清楚的，这里就暂时略过。总之，模版特化是一种为特定的模版参数进行“定制”的方法，在使用的时候，c++会优先使用特化的模版，而非原本没有特化的模版（PartialOrdering）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Array</span> &#123;<span class="comment">/* impl */</span>&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">bool</span>&gt; &#123;<span class="comment">/* spec impl */</span>&#125;</span><br><span class="line">Array&lt;<span class="type">bool</span>&gt; <span class="comment">// 使用 spec impl 而非 impl</span></span><br></pre></td></tr></table></figure><p>特化的一个重要功能是，能够在编译期给出一个类型的某些特性，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="c11c17">C++11～C++17</h4><p>主要的功能是添加了SFINAE，即替换失败并不是错误，举个比较教科书的例子好了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ref: https://en.cppreference.com/w/cpp/language/sfinae</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::B*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">int</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> i = <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>); <span class="comment">// uses second overload</span></span><br></pre></td></tr></table></figure><p>其能够通过<code>int</code>没有成员<code>int::B</code>来判断应该使用哪一个模版，即使这两个模版是同名的。</p><p>其最经典的例子则是<code>enable_if</code> 和 一系列<code>is_xxx</code> 的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> B, <span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">void</span>&gt; <span class="keyword">struct</span> enable_if &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, T&gt; &#123; <span class="keyword">typedef</span> T type; &#125;;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> enable_if&lt;is_floating_point&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type <span class="title">func</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// floating impl.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> enable_if&lt;! is_floating_point&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type <span class="title">func</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// other impl.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有SFINAE，那么在调用<code>func&lt;int&gt;(1)</code>的时候，会检查各个模版，当检查到第一个模版的时候，由于<code>enable_if&lt;false, T&gt;</code>中并没有成员<code>type</code>，则会产生一个错误（E）。但拥有SFINAE后则不会报错，编译器会尝试使用所有的可能情况，选择最合适的模版使用，如果没有模版能够成功替换才会报错。</p><p>在C++11中另一个大升级是可变参数模版，即<code>parameter-pack</code>，简而言之，就是现在模版可以和函数一样，接受任意多个参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...T&gt; <span class="keyword">class</span> <span class="title class_">Tuple</span>;</span><br><span class="line">Tuple&lt;&gt; tp1;</span><br><span class="line">Tuple&lt;<span class="type">int</span>&gt; tp2;</span><br><span class="line">Tuple&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">long</span>&gt; tp3;</span><br></pre></td></tr></table></figure><p>其可以用于构造这样的类型表，并且给出表中的元素个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt; <span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> length = <span class="keyword">sizeof</span>...(T);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此我们已经能够隐约知道模版的一些基本功能，并且由于SFINAE的存在，我们甚至可以来写一些简单的类型推导：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// H, T... =&gt; H</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">Front</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">Front</span>&lt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = Empty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> H, <span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">Front</span>&lt;H, T...&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = H;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// H..., T =&gt; T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">Back</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">Back</span>&lt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = Empty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Back</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> H, <span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">Back</span>&lt;H, T...&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> Back&lt;T...&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里实现的是取出类型参数表的头和尾的操作。我们可以扩展这个操作，即获得一个类型的<code>List</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="comment">// 本身</span></span><br><span class="line">  <span class="keyword">using</span> type = List&lt;T...&gt;;</span><br><span class="line">  <span class="comment">// 长度</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> acg::<span class="type">size_t</span> size_ = <span class="keyword">sizeof</span>...(T);</span><br><span class="line">  <span class="comment">// 转换，例如: List&lt;int, float, char&gt;::cast&lt;std::tuple&gt; =&gt; std::tuple&lt;int, float, char&gt;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="keyword">typename</span> C&gt; <span class="keyword">using</span> cast = C&lt;T...&gt;;</span><br><span class="line">  <span class="comment">// 尾部扩展</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ts&gt; <span class="keyword">using</span> append = List&lt;T..., Ts&gt;;</span><br><span class="line">  <span class="comment">// 头上扩展</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ts&gt; <span class="keyword">using</span> prepend = List&lt;Ts, T...&gt;;</span><br><span class="line">  <span class="keyword">using</span> front = <span class="keyword">typename</span> Front&lt;T...&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> back = <span class="keyword">typename</span> Back&lt;T...&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了偏特化我们可以做啥呢：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Car: [h, t...] =&gt; h</span></span><br><span class="line"><span class="comment">//      [h] =&gt; h</span></span><br><span class="line"><span class="comment">//      [] =&gt; Empty</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Car</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">Car</span>&lt;List&lt;T...&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> List&lt;T...&gt;::front;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cdr: [h, t...] =&gt; [t...]</span></span><br><span class="line"><span class="comment">//      [h] =&gt; []</span></span><br><span class="line"><span class="comment">//      [] =&gt; Empty</span></span><br><span class="line"><span class="comment">//      ?  =&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Cdr</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> H, <span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">Cdr</span>&lt;List&lt;H, T...&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = List&lt;T...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> H&gt; <span class="keyword">struct</span> <span class="title class_">Cdr</span>&lt;List&lt;H&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = List&lt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是不是有函数式编程那味了？我们继续：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetElem</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> x, <span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">GetElem</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetElem x [] =&gt; Empty</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> x&gt; <span class="keyword">struct</span> <span class="title class_">GetElem</span>&lt;x, List&lt;&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = Empty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetElem 0 [H T ...] =&gt; H</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> H, <span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">GetElem</span>&lt;<span class="number">0</span>, List&lt;H, T...&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = H;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetElem x [H T ...] =&gt; GetElem (x - 1) [T ...]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> x, <span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> <span class="title class_">GetElem</span>&lt;x, List&lt;T...&gt;&gt;</span><br><span class="line">    : <span class="keyword">public</span> GetElem&lt;x - <span class="number">1</span>, <span class="keyword">typename</span> Cdr&lt;List&lt;T...&gt;&gt;::type&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concat</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt; <span class="keyword">struct</span> <span class="title class_">Concat</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concat [L...] [R...] =&gt; [L... R...]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... LT, <span class="keyword">typename</span>... RT&gt; <span class="keyword">struct</span> <span class="title class_">Concat</span>&lt;List&lt;LT...&gt;, List&lt;RT...&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = List&lt;LT..., RT...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上了解过Haskell的童鞋已经发现了，它和Haskell的风格真的很像！通过偏特化和SFINAE，我们实现了类似于函数式里的模式匹配功能。以及在模版替换过程中，实际上是有一定的LazyEvaluation的存在的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">GetType</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Inner</span> &#123; <span class="keyword">using</span> type = <span class="keyword">typename</span> T::type; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  GetType&lt;Empty&gt; x; <span class="comment">// No Error! because GetType&lt;Empty&gt;::Inner is not instantiated!</span></span><br><span class="line">  <span class="comment">// GetType&lt;Empty&gt;::Inner x; -&gt; Error!</span></span><br><span class="line">  <span class="comment">// error: no type named &#x27;type&#x27; in &#x27;Empty&#x27;</span></span><br><span class="line">  <span class="comment">//  ... in instantiation of member class &#x27;GetType&lt;Empty&gt;::Inner&#x27; requested here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c17">C++17～</h4><p>这里主要就是针对之前的一些痛点做出的优化，比如CTAD这些，能够更方便的帮你实现一些骚操作，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair <span class="title">p</span><span class="params">(<span class="number">2</span>, <span class="number">4.5</span>)</span></span>;     <span class="comment">// deduces to std::pair&lt;int, double&gt; p(2, 4.5);</span></span><br><span class="line"><span class="function">std::tuple <span class="title">t</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2.5</span>)</span></span>; <span class="comment">// same as auto t = std::make_tuple(4, 3, 2.5);</span></span><br><span class="line">std::less l;             <span class="comment">// same as std::less&lt;void&gt; l;</span></span><br></pre></td></tr></table></figure><p>这里原本是需要给出模版参数的，但由于CTAD的存在，其可以通过构造函数来自动推断出你需要的类型。</p><figure><img src="./meta_intro.assets/image-20221122143024020.png"alt="image-20221122143024020" /><figcaption aria-hidden="true">image-20221122143024020</figcaption></figure><h3id="那么模版到底有什么更实际的作用呢">那么模版到底有什么更实际的作用呢？</h3><p>首先，可以用这样的类型数据结构来实现编译时算法，例如 TaskFlow的这个PR：<ahref="Add%20TaskBuild%20DSL%20to%20describe%20a%20graph!%20by%20netcan%20·%20Pull%20Request%20#222%20·%20taskflow/taskflowgithub.com/taskflow/taskflow/pull/222">NewFeature</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">def_task</span>((A), &#123; std::cout &lt;&lt; <span class="string">&quot;TaskA\n&quot;</span>; &#125;;);</span><br><span class="line"><span class="built_in">def_task</span>((B), &#123; std::cout &lt;&lt; <span class="string">&quot;TaskB\n&quot;</span>; &#125;;);</span><br><span class="line"><span class="built_in">def_task</span>((C), &#123; std::cout &lt;&lt; <span class="string">&quot;TaskC\n&quot;</span>; &#125;;);</span><br><span class="line"><span class="built_in">def_task</span>((D), &#123; std::cout &lt;&lt; <span class="string">&quot;TaskD\n&quot;</span>; &#125;;);</span><br><span class="line"><span class="built_in">def_task</span>((E), &#123; std::cout &lt;&lt; <span class="string">&quot;TaskE\n&quot;</span>; &#125;;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tasks = <span class="built_in">taskbuild</span>(</span><br><span class="line">  <span class="built_in">task</span>(A)</span><br><span class="line">    -&gt; fork(B, C)</span><br><span class="line">    -&gt; <span class="built_in">task</span>(D),</span><br><span class="line">  <span class="built_in">merge</span>(A, B)</span><br><span class="line">    -&gt; <span class="built_in">task</span>(E)</span><br><span class="line">)(taskflow);</span><br></pre></td></tr></table></figure><p>通过这样简单的语法就能够快速且准确地描述任务之间的拓扑连接关系。这和我们的终极目标——AutoDiff很像！AutoDiff大多需要通过计算图模型来进行梯度计算，例如<ahref="https://pytorch.org/tutorials/beginner/blitz/autograd_tutorial.html#computational-graphpytorch.org/tutorials/beginner/blitz/autograd_tutorial.html#computational-graph">PyTorch</a></p><p>Taskflow中，描述Task之间关系的图也是有向无环的，而计算图模型也是有向无环的。TaskFlow利用模版元编程实现了进行静态的任务调度，即通过对于图节点进行拓扑排序，在编译期利用模版自动推导、并确定任务执行顺序，在运行时直接按照该顺序执行，即可省去原来在运行时计算拓扑排序：</p><p><ahref="netcan.github.io/2020/08/15/%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8FDSL/">设计并实现一个拓扑排序DSL</a></p><p>我们的Autodiff中，何处使用了类似的思想呢，我们来仔细讲讲</p><h3 id="meta-autodiff">Meta AutoDiff</h3><p>这里我们初步构思一下AutoDiff实现的大致方案和思路。</p><blockquote><p>P.S.由于高阶导数是导数的导数，因此我们（如果有解析表达式的情况下）只需要考虑一阶导数如何进行计算。</p></blockquote><h4 id="方向导数计算的数学基础">方向导数计算的数学基础</h4><blockquote><p>P.S. 在这里先考虑函数光滑。</p></blockquote><p>首先是，一阶导数到底是如何求出的？这里我们选择使用求方向导数的方法。现有的AutoDiff库，以及ceres都使用了这类方法</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/248865580">reference</a></p></blockquote><p>我们进行一个简单的推导，先考虑光滑的一元函数函数 <spanclass="math inline">\(f,g,h:\mathbb R\rightarrow \mathbb R\)</span>的情况（表述上可能不是很严谨）：</p><p>链式法则告诉我们：若 <span class="math inline">\(f = g\circh\)</span>，且<span class="math inline">\(f(x) = g(h(x))\)</span>，<spanclass="math inline">\(\frac{\mathrm d f}{\mathrm d x}(x) = \frac{\mathrmd g}{\mathrm d h} (x)\frac{\mathrm d h}{\mathrm d x}(x)\)</span>，举个例子：</p><p><span class="math display">\[\begin{aligned} &amp;f(x) = \cos x^2, g(x) = \cos(x), h(x) = x^2\\\implies&amp; \frac{\mathrm d f}{\mathrm d x} (x)= \frac{\mathrm dg}{\mathrm d h} (x)\frac{\mathrm d h}{\mathrm d x} (x)= -\sin(x^2) \cdot2x\\ \implies &amp;\mathrm{d}f = - 2x \cdot \sin(x^2)\mathrm{d}x\end{aligned}\]</span></p><p>由于一元函数/标量的标量值函数并没有方向的概念（始终认为 dx 就是沿着 x正向走的一个小量），我们来第二个例子，来分析其中的导数是如何进行传递的，假设我们有一个二元函数<spanclass="math inline">\(f(x, y): (x, y)\rightarrowtail xy, \mathbb R\times\mathbb R \rightarrow \mathbb R\)</span></p><p>我们想知道的是，关于 <span class="math inline">\(x,y\)</span>的偏导数的解析式，我们可以尝试对 <span class="math inline">\(f\)</span>进行<strong>全微分</strong>：</p><p><span class="math display">\[\mathrm df = x \mathrm dy + y\mathrm dx\]</span></p><p>考虑到实际上全微分描述的是函数在一点的线性近似，改写为：</p><p><span class="math display">\[f + \delta f = xy +x \delta y + y\delta x\]</span></p><p>实际上，我们只需要线性近似，因此我们可以认为二阶小量为0，即</p><p><span class="math display">\[f+\delta f = (x+\delta x)(y+\delta y) \approx xy + x\delta y+y\delta x\]</span></p><p>在这个意义下，我们直接取 <span class="math inline">\(\delta x, \deltay\)</span> 的系数，就能得到关于 <span class="math inline">\(x,y\)</span>的<strong>偏导数</strong>的解析表达！实际上 <spanclass="math inline">\(f\)</span> 看作一个向量函数情况下，即<spanclass="math inline">\(f:\mathbb R^2\rightarrow \mathbb R\)</span>，那么之前提到的 <span class="math inline">\(\delta x\)</span>前的系数实际上是它的方向导数，方向是 <spanclass="math inline">\(x\)</span> 正方向。</p><p>另一方面，根据方向导数的定义其描述的是自变量沿着某一个方向走出一小步（<spanclass="math inline">\(\delta x =:e\)</span>），对于最终函数的影响有多大（ <spanclass="math inline">\(\delta f\)</span> ）：例如在上式中，我们只沿着<span class="math inline">\(x\)</span> 走一步 <spanclass="math inline">\(e\)</span> ，即 <span class="math inline">\(\deltax =e, \delta y = 0\)</span> ，那么</p><p><span class="math display">\[f + \delta f = xy + y \cdot e\]</span></p><p>取出这个系数即可得到 <span class="math inline">\(f_x\)</span> 。</p><blockquote><p>P.S. 为啥不一起求 <span class="math inline">\(f_x,f_y\)</span>的表达式，实际上是为了让这个问题变得简单，因为必须区分 <spanclass="math inline">\(x,y\)</span> 对于 <spanclass="math inline">\(f\)</span> 的贡献，从而就会引入两个类似于 e的变元，在后续实现上较为复杂。另一方面，由于所有表达式都是在编译期推导的，运行时仅仅进行表达式计算，因此不会因此带来额外的运行时消耗。</p></blockquote><p>我们一般意义上说的梯度，实际上是一个标量值函数，对于其输入向量的各个维度的导数，即：</p><p><span class="math display">\[f:\mathbb R^n \rightarrow \mathbb R\implies (\nabla f)^T = \left(\frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2},\cdots,\frac{\partial f}{\partial x_n} \right)\]</span></p><p>那么我们在计算第一个偏导数的时候，设定 <span class="math inline">\(e= (1, 0, \cdots, 0)\)</span>，最终就能求出得到的<spanclass="math inline">\(\frac{\partial f}{\partial x_1}\)</span>。</p><p>这个方法的推导过程中，表达式常常被称为Dual，因为整个表达式由两部分组成，一部分是原本的表达式，另一部分是表达式关于某个方向的方向导数值，记作<spanclass="math inline">\(f(x) + e\cdot g(x)\)</span>。由于<spanclass="math inline">\(e\)</span>实际上是代表选定方向的一个一阶无穷小量，并且我们也只需要一阶无穷小量，因此关于<spanclass="math inline">\(e\)</span>定义</p><p><span class="math display">\[e^2 = 0\]</span></p><p>其他的四则运算则与原本一致。这里给出一些例子（仅对于<spanclass="math inline">\(x\)</span>求偏导，也就是x正方向的方向导数）：</p><p><span class="math display">\[\begin{aligned}f(x) = x^2 &amp;\implies f + \delta f = (x + e) ^2 = x^2 + e\cdot 2x\\f(x, y) = xy &amp; \implies f + \delta f = (x + e)y = xy + e \cdot y\\f(x, y) = x+y &amp; \implies f + \delta f = (x + e)+y = x+y + e \cdot1\end{aligned}\]</span></p><p>另外，如果是向量函数，我们也可以求出其关于第1个维度的方向导数，例如设<spanclass="math inline">\(x, y\in \mathbb R^3\)</span>，下列函数关于<spanclass="math inline">\(\delta x = e (1, 0,0)^T\)</span>的方向导数可以用相类似的方法进行推导</p><p><span class="math display">\[\begin{aligned}f(x) = x^Tx = \| x\|^2 &amp;\implies f + \delta f = (x + \delta x)^T(x+\delta x) = x^Tx + 2x\cdot \delta x= x^Tx + e\cdot (2x \cdot (1, 0, 0)^T) \\f(x, y) = x^Ty &amp; \implies f + \delta f = (x + \delta x)y = xy + e(1,0, 0)^T\cdot y\\f(x, y) = x+y &amp; \implies f + \delta f = (x + e)+y = x+y + e (1, 0,0)^T\end{aligned}\]</span></p><p>从第三个例子我们可以看出，使用方向导数我们不仅仅能够获得对于标量值函数的方向导数，我们还能够得到对于向量值函数的方向导数。</p><p>另外我们需要注意的是，如果是多元函数，在应用链式法则的时候需要注意求出每一个输入的导数，再组合出最终结果：</p><p><span class="math display">\[f(x) = g(h_1(x), h_2(x), \cdots, h_n(x)) \implies\frac{\partial f}{\partial x} = \sum _{ i = 1}^n \frac{\partialg}{\partial h _ i} \frac{\partial h _ i}{\partial x}\]</span></p><h3 id="如何将公式变为代码-基于类型的符号计算">如何将公式变为代码 —基于类型的符号计算</h3><p>如何进行符号计算，特别是编译期的符号计算。区别于AutoDiff的实现：</p><p><ahref="https://github.com/autodiff/autodiff/blob/main/autodiff/reverse/var/var.hpp">Autodiff/reverse/var</a></p><p>该实现的原理是在每一次发生计算的时，依赖于运算符重载自动生成计算图。对于计算图的生成在本质上是在编译时的，但对于导数的计算是运行时的，即其并没有得到导数的解析表达式，而是通过运行时来计算得到的。例如对于Hessian 的计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Return the Hessian matrix of variable y with respect to variables x.</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X, <span class="keyword">typename</span> GradientVec&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">hessian</span><span class="params">(<span class="type">const</span> Variable&lt;T&gt;&amp; y, Eigen::DenseBase&lt;X&gt;&amp; x, GradientVec&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> U = VariableValueType&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ScalarX = <span class="keyword">typename</span> X::Scalar;</span><br><span class="line">    <span class="built_in">static_assert</span>(isVariable&lt;ScalarX&gt;, <span class="string">&quot;Argument x is not a vector with Variable&lt;T&gt; (aka var) objects.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ScalarG = <span class="keyword">typename</span> GradientVec::Scalar;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;U, ScalarG&gt;, <span class="string">&quot;Argument g does not have the same arithmetic type as y.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> Rows = X::RowsAtCompileTime;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> MaxRows = X::MaxRowsAtCompileTime;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> n = x.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form a vector containing gradient expressions for each variable</span></span><br><span class="line">    <span class="keyword">using</span> ExpressionGradient = Vec&lt;ScalarX, Rows, MaxRows&gt;;</span><br><span class="line">    <span class="function">ExpressionGradient <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        x[k].expr-&gt;<span class="built_in">bind_expr</span>(&amp;<span class="built_in">G</span>(k).expr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build a full gradient expression in DFS tree traversal, updating</span></span><br><span class="line"><span class="comment">     * gradient expressions when encountering variables</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    y.expr-&gt;<span class="built_in">propagatex</span>(<span class="built_in">constant</span>&lt;T&gt;(<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">      x[k].expr-&gt;<span class="built_in">bind_expr</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the gradient value from gradient expressions&#x27; cached values</span></span><br><span class="line">    g.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        g[i] = <span class="built_in">val</span>(G[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form a numeric hessian using the gradient expressions</span></span><br><span class="line">    <span class="keyword">using</span> Hessian = Mat&lt;U, Rows, Rows, MaxRows, MaxRows&gt;;</span><br><span class="line">    Hessian H = Hessian::<span class="built_in">Zero</span>(n, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">            x[k].expr-&gt;<span class="built_in">bind_value</span>(&amp;<span class="built_in">H</span>(i, k));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate a second derivative value calculation down the gradient expression tree for variable i</span></span><br><span class="line">        G[i].expr-&gt;<span class="built_in">propagate</span>(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">            x[k].expr-&gt;<span class="built_in">bind_value</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其不仅仅可能产生多次重复的计算结果，而且中间在计算上大量使用了<code>shared_ptr</code>导致了计算效率低下的问题。</p><p>我们的目标是在<strong>编译期</strong>产生解析的<strong>方向导数</strong>（也就是这个方向导数的解析表达式），因此我们的（数学上的）输入变量一定不是（编程中的）变量！</p><p>在C++中，变量是运行时的一个概念，通常认为能够对应到一个物理存在的内存块，能够参与运行时的计算。而类型才是C++中编译时的概念，在没有RAII的情况下，绝大多数程序并不能直接得到某个物理内存块上存储的变量所对应的类型。因此，如果我们需要产生尽量少的运行时开销，那么我们用来推导导数所使用的一定只能是基于类型，而非变量。</p><p>更形象化来说，通常可能你认为的Add类是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span>: <span class="keyword">public</span> Expr <span class="comment">/* 表示一个计算图节点 */</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Add</span>(Node* lhs, Node* rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Node* lhs, rhs; <span class="comment">// Runtime Consumption</span></span><br><span class="line">  ValueType val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span>: <span class="keyword">public</span> Expr &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(ValueType )</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ValueType val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上我们想要的是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt; <span class="keyword">struct</span> <span class="title class_">Add</span>: <span class="keyword">public</span> Expr &#123; </span><br><span class="line">  <span class="keyword">using</span> type = Add&lt;L, R&gt;; </span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_leaf = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Input</span>: <span class="keyword">public</span> Expr&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_leaf = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们生成的一个表达式可能是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>: <span class="keyword">public</span> Input&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span>: <span class="keyword">public</span> Input&#123;&#125;;</span><br><span class="line"><span class="keyword">using</span> Result = Mult&lt;Add&lt;X, Y&gt;, Y&gt;;</span><br></pre></td></tr></table></figure><p>这样，<code>X</code>和<code>Y</code>不再是运行时的变量，而是一个类型，便于我们后续进行推导。</p></div><div class="story post-story"><h2 id="一个初步的实现">一个初步的实现</h2><h3 id="基础表达式的设计">基础表达式的设计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... E&gt; <span class="keyword">struct</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">  <span class="comment">// 记录该函数输入表达式，Add&lt;L, R&gt;::InputExpr =&gt; List&lt;L, R&gt;</span></span><br><span class="line">  <span class="keyword">using</span> InputExpr = List&lt;E...&gt;;</span><br><span class="line">  <span class="comment">// 记录该表达式的所有输入例如 Add&lt;X, Ones&lt;float&gt;&gt;::InputNodes == List&lt;X&gt;;</span></span><br><span class="line">  <span class="keyword">using</span> InputNodes = Unique_t&lt;Reduce_t&lt;Concat, List&lt;List&lt;&gt;, <span class="keyword">typename</span> E::InputNodes...&gt;&gt;&gt;;</span><br><span class="line">  <span class="comment">// 表示真实计算时的数据类型</span></span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">  <span class="comment">// 表示所有其依赖的子表达式</span></span><br><span class="line">  <span class="keyword">using</span> SubNodes = Unique_t&lt;Reduce_t&lt;Concat, List&lt;List&lt;E...&gt;, <span class="keyword">typename</span> E::SubNodes...&gt;&gt;&gt;;</span><br><span class="line">  <span class="comment">// 是否是常数</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_constant = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 是否是输入节点（自变量）</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_input = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式法则，求出 F，F 的输入为 I（一个表达式表），关于 X， 方向为 D 的导数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> I, <span class="keyword">typename</span> X, <span class="keyword">typename</span> D&gt; <span class="keyword">struct</span> <span class="title class_">Chain</span>;</span><br><span class="line"><span class="comment">// 方向导数，对于Y，求关于X，方向为 D 的导数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y, <span class="keyword">typename</span> X, <span class="keyword">typename</span> D&gt; <span class="keyword">struct</span> <span class="title class_">DirectionalDiff</span> &#123;</span><br><span class="line">  <span class="comment">// 根据多元函数链式法则，就是对于各个输入节点的导数。</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> Chain&lt;Y, <span class="keyword">typename</span> Y::InputExpr, X, D&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果是空列表，那么返回0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> X, <span class="keyword">typename</span> D&gt; <span class="keyword">struct</span> <span class="title class_">Chain</span>&lt;F, List&lt;&gt;, X, D&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = Zeros&lt;<span class="keyword">typename</span> F::type&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果输入只有一个，即f是一个一元函数（不一定是标量），直接用一元函数链式法则。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> I, <span class="keyword">typename</span> X, <span class="keyword">typename</span> D&gt; <span class="keyword">struct</span> <span class="title class_">Chain</span>&lt;F, List&lt;I&gt;, X, D&gt; &#123;</span><br><span class="line">  <span class="comment">// 先得到 dI，即I对X方向为D的导数表达式。</span></span><br><span class="line">  <span class="keyword">using</span> ix = <span class="keyword">typename</span> DirectionalDiff&lt;I, X, D&gt;::type;</span><br><span class="line">  <span class="comment">// 然后算 dF Grad_t描述了表达式 F，对于输入I，已知I对X的D方向导数为ix情况下的方向导数。</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> F::<span class="keyword">template</span> Grad_t&lt;I, ix&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果输入有多个，那么先取出第一个输入，应用链式法则得到 fhx，然后对剩下输入进行递归，得到剩下的部分导数表达式，加起来得到最终结果。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> X, <span class="keyword">typename</span> D, <span class="keyword">typename</span> IH, <span class="keyword">typename</span>... IT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chain</span>&lt;F, List&lt;IH, IT...&gt;, X, D&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> hx = <span class="keyword">typename</span> DirectionalDiff&lt;IH, X, D&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> fhx = <span class="keyword">typename</span> F::<span class="keyword">template</span> Grad_t&lt;IH, dual_hx&gt;;</span><br><span class="line">  <span class="keyword">using</span> type = Add&lt;fhx, <span class="keyword">typename</span> Chain&lt;F, List&lt;IT...&gt;, X, D&gt;::type&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 递归终点：如果是 X 对 X 求方向D的导数，那么结果就是D</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> D&gt; <span class="keyword">struct</span> <span class="title class_">DirectionalDiff</span>&lt;X, X, D&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = D;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以加法为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add Operation, L::type should equals to R::type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt; <span class="keyword">struct</span> <span class="title class_">Add</span> : <span class="keyword">public</span> Expr&lt;<span class="keyword">typename</span> L::type, L, R&gt; &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">typename</span> L::type, <span class="keyword">typename</span> R::type&gt;,</span><br><span class="line">                <span class="string">&quot;L::type should be same as R::type.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Li, <span class="keyword">typename</span> Ri&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">operator</span><span class="params">()</span><span class="params">(Li&amp;&amp; l, Ri&amp;&amp; r)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l + r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> G&gt; <span class="keyword">using</span> Grad_t = G;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Add对应的数学函数是：<span class="math inline">\(f(x_1, x_2) = x_1 +x_2\)</span>，注意到，<code>Grad_t</code>是一个模版，第一个参数<code>X</code>用于表明是对哪一个位置求偏导，第二个参数<code>G</code>表示的是Dual计算是的<spanclass="math inline">\(e\)</span>项的系数，例如：</p><p><span class="math display">\[f(F(x), y) \implies f+\delta f=f(F(x)+Ae, y) = (F(x)+y) + e \cdot 1\]</span></p><p>对应了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add&lt;F, Y&gt;::Grad_t&lt;F, A&gt; =&gt; A</span><br></pre></td></tr></table></figure><p>其中 <code>A</code> 存储了计算到 <code>F</code> 对于 <code>X</code>的某一方向导数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mul</span>&lt;L, R&gt; : <span class="keyword">public</span> Expr&lt;<span class="keyword">typename</span> L::type, L, R&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Li, <span class="keyword">typename</span> Ri&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">operator</span><span class="params">()</span><span class="params">(Li&amp;&amp; l, Ri&amp;&amp; r)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l * r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> G&gt; <span class="keyword">using</span> Grad_t</span><br><span class="line">      = std::<span class="type">conditional_t</span>&lt;std::is_same_v&lt;X, R&gt;, Mul&lt;L, G&gt;, Mul&lt;G, R&gt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于乘法，若是关于<spanclass="math inline">\(x_1\)</span>的方向导数：</p><p><span class="math display">\[f(x_1, x_2) = x_1 x_2\implies f(x_1 + e, x_2) = f+ \delta f = x_1x_2 x_2e\]</span></p><p>对 <span class="math inline">\(x_2\)</span> 亦然。</p><p>至此我们已经能够得到一些初步的结果：</p><img src="/2022/10/05/study/bachelor_final/meta_intro/16691052850385.jpg" class="lazyload" data-srcset="/2022/10/05/study/bachelor_final/meta_intro/16691052850385.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"><p>未完待续……</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来是想发在知乎的，但想了想还是先首发在自己的blog上。&lt;/p&gt;</summary>
    
    
    
    <category term="Programming" scheme="http://adversarr.github.io/categories/Programming/"/>
    
    
    <category term="Programming" scheme="http://adversarr.github.io/tags/Programming/"/>
    
    <category term="C/C++" scheme="http://adversarr.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Useful Links for programming</title>
    <link href="http://adversarr.github.io/2022/10/05/study/ComputerScience/cpp/useful-links/"/>
    <id>http://adversarr.github.io/2022/10/05/study/ComputerScience/cpp/useful-links/</id>
    <published>2022-10-04T16:00:00.000Z</published>
    <updated>2022-11-06T00:39:53.449Z</updated>
    
    <content type="html"><![CDATA[<div class="story post-story"><h2 id="cpp">Cpp</h2><h3 id="c-rvalue-references-explained">C++ Rvalue ReferencesExplained</h3><p><ahref="http://thbecker.net/articles/rvalue_references/section_01.html">http://thbecker.net/articles/rvalue_references/section_01.html</a></p><h3 id="abseil">Abseil</h3><blockquote><p>Abseil provides a number of containers as alternatives to STLcontainers. These containers generally adhere to the properties of STLcontainers, though there are often some associated API differencesand/or implementation details which differ from the standardlibrary.</p></blockquote><ul><li><a href="https://abseil.io/docs/cpp/">Document</a></li><li></li></ul><h3 id="folly">Folly</h3><blockquote><p>Folly (acronymed loosely after Facebook Open Source Library) is alibrary of C++14 components designed with practicality and efficiency inmind. Folly contains a variety of core library components usedextensively at Facebook. In particular, it's often a dependency ofFacebook's other open source C++ efforts and place where those projectscan share code.</p></blockquote><ul><li><a href="https://github.com/facebook/folly">Github</a></li></ul><h3 id="coost">Coost</h3><blockquote><p>coost 是一个兼具性能与易用性的跨平台 C++基础库，其目标是打造一把地表最好用的 C++ 开发神器，让 C++编程变得简单、轻松、愉快。</p><p>coost 原名为 co，后改为cocoyaxi，前者过短，后者过长，取中庸之道，又改为 coost。它曾被称为小型boost 库，与 boost 相比，coost 小而精美，在 linux 与 mac上编译出来的静态库仅 1M 左右大小，却包含了不少强大的功能：</p></blockquote><ul><li><a href="https://coostdocs.github.io/cn/about/co/">Document</a></li><li><a href="https://github.com/idealvin/coost">Github</a></li></ul><h3 id="thrust">Thrust</h3><p>Cuda Algorithm library.</p><h3 id="taskflow.">Taskflow.</h3><p>Alter to oneTBB.</p><ul><li><a href="https://github.com/taskflow/taskflow">link</a></li></ul><h3 id="awesome-parallel-computing">Awesome Parallel Computing</h3><ul><li><ahref="https://github.com/taskflow/awesome-parallel-computing">link</a></li></ul><h3 id="assimp">ASSIMP</h3><p>The official Open-Asset-Importer-Library Repository. Loads 40+3D-file-formats into one unified and clean data structure. (byassimp)</p></div><div class="story post-story"><h2 id="求解器线性代数等">求解器、线性代数等</h2><h3 id="spectra">Spectra</h3><p>Spectra stands for Sparse Eigenvalue Computation Toolkit as aRedesigned ARPACK. It is a C++ library for large scale eigenvalueproblems, built on top of Eigen, an open source linear algebralibrary.</p><p>Spectra is implemented as a header-only C++ library, whose onlydependency, Eigen, is also header-only. Hence Spectra can be easilyembedded in C++ projects that require calculating eigenvalues of largematrices.</p><p>https://github.com/yixuan/spectra/</p></div><div class="story post-story"><h2 id="vulkan">Vulkan</h2><h3 id="vkbootstrap">VkBootstrap</h3><p>As Vulkan is a very explicit API that gives very “direct” control,you need to initialize it to do things such as load extensions, selectwhich GPU (or multiple!) you are going to use, and create the initialVkInstance and VkDevice structures that you then use with Vulkancommands.</p><p>https://github.com/charles-lunarg/vk-bootstrap</p></div><div class="story post-story"><h2 id="pages">Pages</h2><blockquote><p>📚经典技术书籍 PDF文件，涵盖：编程语言、计算机系统、网络协议、数据库、代码艺术、设计模式、算法与数据结构、系统架构、微服务、测试、程序员职业修炼等相关书籍。</p></blockquote><p><a href="https://awesome-programming-books.github.io">link</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;story post-story&quot;&gt;&lt;h2 id=&quot;cpp&quot;&gt;Cpp&lt;/h2&gt;
&lt;h3 id=&quot;c-rvalue-references-explained&quot;&gt;C++ Rvalue References
Explained&lt;/h3&gt;
&lt;p&gt;&lt;a
href=&quot;</summary>
      
    
    
    
    <category term="Programming" scheme="http://adversarr.github.io/categories/Programming/"/>
    
    
    <category term="Programming" scheme="http://adversarr.github.io/tags/Programming/"/>
    
    <category term="C/C++" scheme="http://adversarr.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>105-1-Introduction to Computer Animation 3d.</title>
    <link href="http://adversarr.github.io/2022/10/01/CG/GAMES/games105/lec1/"/>
    <id>http://adversarr.github.io/2022/10/01/CG/GAMES/games105/lec1/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2023-02-24T04:29:58.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction-to-computer-animation----in-3d.">Introduction toComputer Animation -- in 3D.</h2><h3 id="what-is-character-animation">What is character animation</h3><ol type="1"><li>Animate Movie</li><li>Virtual Idle... Digital Human...</li></ol><p><strong>Compare with CG</strong>:</p><ul><li>... -&gt; Geometry -&gt; Animation -&gt; Rendering -&gt; ...</li><li>simulation: <strong>Phenomenon</strong></li><li>character animation: <strong>Behaviour</strong></li></ul><p><em>Simulation + Control = Character Animation</em></p><h3 id="why-study-c.a.">Why study C.A.</h3><ol type="1"><li>A character typically has 20+ joints, 50-100+ parameters.<ol type="1"><li>传统：手调参数</li></ol></li><li>角色动画<ol type="1"><li>Understanding the mechanism behind the motions and behaviors</li><li>"Compute Intensive"</li></ol></li></ol><p>A Pipeline :</p><ol type="1"><li>Rigging &amp; skining:绑定、蒙皮</li><li>Skeletal Animation：骨骼动画</li><li>1 + 2 = Animated Character</li></ol><h3 id="where-does-motion-come-frome">where does motion come frome</h3><ol type="1"><li>brain</li><li>muscle</li><li>force</li><li>physics</li><li>body <strong>pose</strong></li></ol><p>Two approach:</p><ol type="1"><li>Key Frame-Based / Kinematic Approach: Ignore the idea, update posedirectly.(Simple)</li><li>Physics-based /dynamic Approach: merge 123, simplified control &amp;physics.</li></ol><p>Two target:</p><ol type="1"><li>Low-Level Control: More details.</li><li>High-Level Goals: focus on target. (e.g. lift up the box)</li></ol><blockquote><p>Disney's 12 priciples.</p></blockquote><div class="story post-story"><h2 id="key-frame-based.">key frame based.</h2><h3 id="two-key-techniques">Two key techniques</h3><p>(Keyframe Animation)</p><ol type="1"><li>forward Kinematics: Given rotations of every joints, computerotations of every joints.</li><li>Inverse Kinematics</li></ol><p>other solution:</p><ol type="1"><li>Motion Capture.</li><li>Motion Retargeting.</li></ol><h3 id="motion-graphs-state-machines-in-game">Motion Graphs / Statemachines (in game)</h3><blockquote><p>2002: Motion Graph</p></blockquote><p>... Motion Matching ...</p><p>在游戏中阻力较大：新技术，区别于状态机。</p><h3 id="learning-based.">Learning Based.</h3><p>Generative Model.</p><ol type="1"><li>Input: Control Signal + Current Pose</li><li>Output: Next Pose</li></ol><p>Iterative.</p><p>e.g. Character Controllers using Motion VAEs.</p></div><div class="story post-story"><h2 id="physics-based">Physics based</h2><ol type="1"><li>force, torque -&gt; simulation</li><li>PD(Proportional Derivative)</li></ol><p>Approaches</p><ol type="1"><li>Keyframe Control</li><li>Spacetime/Trajectory Optimization.</li><li>Abstract Models</li><li>Reinforcement Learning.</li><li>Generative Control Policies.</li></ol><img src="/2022/10/01/CG/GAMES/games105/lec1/16655417660523.jpg" class="lazyload" data-srcset="/2022/10/01/CG/GAMES/games105/lec1/16655417660523.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;introduction-to-computer-animation----in-3d.&quot;&gt;Introduction to
Computer Animation -- in 3D.&lt;/h2&gt;
&lt;h3 id=&quot;what-is-character-animation&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Real-Time Cloth Simulation</title>
    <link href="http://adversarr.github.io/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/"/>
    <id>http://adversarr.github.io/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/</id>
    <published>2022-09-30T01:16:33.203Z</published>
    <updated>2023-02-24T04:25:47.997Z</updated>
    
    <content type="html"><![CDATA[<p>Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>Dynamic Solver：</p><ul><li>High resolution</li><li>High nonlinearity</li><li>High stiffness — 多次迭代、计算量</li></ul><p>Collision:</p><ul><li>Collision detection</li><li>Collision Response.</li></ul><h3 id="problem-definitions">Problem Definitions</h3><h4 id="terms">Terms</h4><p>Position Vector: <span class="math display">\[\mathbf x = [\mathbf x_0 \mathbf x_1 \cdots \mathbf x_N]&#39;\]</span> Velocity: <span class="math display">\[\mathbf v = \dot {\mathbf x}\quad \mathbf M = diag(m_0, \dots, m_N)\]</span> Energy – Holonomic(Position only): <spanclass="math display">\[E(\mathbf x)\]</span> 例如：</p><ol type="1"><li>重力势能</li><li>弹簧能量</li><li>Fixing Energy — <span class="math inline">\(\frac{\sigma}2 (\mathbfx_i -\mathbf y_i)^2\)</span></li></ol><h4 id="time-integration">Time Integration</h4><p>常用：隐式欧拉法</p><p>求解方法：</p><ol type="1"><li>消去 <span class="math inline">\(\mathbf v^{t + \Deltat}\)</span></li><li>转化为非线性优化问题</li></ol><p>从而，整个问题都变为： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x)\]</span> 其中 <span class="math inline">\(F\)</span>由动能和势能组成。</p><h4 id="碰撞">碰撞</h4><p>作为约束项出现： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad \mathbf x^{t + \Delta t} \in \Omega\]</span> <img src="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414210701587.png" class="lazyload" data-srcset="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414210701587.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="image-20220414210701587"></p><p>上式存在隧穿问题(Tunnel)。故采用CCD。 <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad s \mathbf x^t + (1-s)  \mathbf x^{t + \Delta t} \in \Omega\forall s\in [0,1]\]</span></p></div><div class="story post-story"><h2 id="dynamics">Dynamics</h2><p>非线性优化通常有如下的形式： <span class="math display">\[\mathbf x ^{k+1} = \mathbf x^k - \alpha^{k + 1}\left(A^{k+1}\right)^{-1} \mathrm{grad}\]</span></p><h3 id="newton-法">Newton 法</h3><p>优点</p><ul><li>2 阶方法</li><li>Hessian Matrix</li></ul><p>问题</p><ul><li>如何求解 <span class="math inline">\(A^{-1}f\)</span> —计算量大</li><li>不一定收敛<ul><li>减小 <span class="math inline">\(\alpha\)</span></li><li>要求 Hessian 正定</li></ul></li></ul><h3 id="梯度下降">梯度下降</h3><p><span class="math display">\[A = \mathrm{id}\]</span></p><p>优点</p><ul><li>GPU++</li><li>简单</li></ul><p>缺点</p><ul><li>1阶收敛 – 慢</li><li>没有任何实时模拟器使用</li></ul><h3 id="projective-dynamics">Projective Dynamics</h3><p>用常矩阵代替 <span class="math inline">\(A\)</span></p><p>优点：</p><ul><li>CPU++，（C 可以被预分解）</li><li>收敛快 — smoother</li></ul><p>缺点</p><ul><li>GPU不友好</li><li>1阶收敛速度（总体上很慢）</li></ul><h3 id="diagonal-hessian">Diagonal Hessian</h3><p><span class="math display">\[\mathbf A^{k+1} = \mathrm{diag\ grad}\]</span></p><p>优点</p><ul><li>收敛快于GD</li><li>GPU++</li></ul><p>缺点</p><ul><li>速度仍然差于牛顿</li></ul><h3 id="lower-hessian">Lower Hessian</h3><p>使用hessian的下三角</p><p>优缺点同 Diag Hess</p><img src="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414212056199.png" class="lazyload" data-srcset="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414212056199.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="总结对比"><h3 id="acceleration">Acceleration</h3><ul><li>Chebyshev — GPU Firendly</li><li>Multiscale Acceleration</li></ul><h3 id="conclusion">Conclusion</h3><p>CPU：Projective Dynamics + Newton-Raphson</p><p>GPU：Chebyshev + Diagonal Hessian / Newton + PCG</p><h3 id="more">More</h3><h4 id="pbd-position-based-dynamics">PBD — Position-Based Dynamics</h4><p><strong>NVCLOTH</strong></p><h4 id="regular-grid-mesh">Regular Grid Mesh</h4><ul><li>Avoid Topology info</li><li>mem access</li><li>more suitable for high resolution</li></ul></div><div class="story post-story"><h2 id="碰撞-1">碰撞</h2><p>两部分：碰撞检测 + 碰撞响应 具体看综述</p><h3 id="检测">检测</h3><p>mesh -&gt; pair -&gt; collision</p><h3 id="response">Response</h3><ol type="1"><li>Iterative Position-Based Repulsion</li><li>Impact Zone Method</li><li>Untangling</li></ol></div><div class="story post-story"><h2 id="other-topics">Other Topics</h2><ul><li>Friction</li><li>Nonelastic</li><li>Locking</li><li>Physical model and measurement</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021&lt;/p&gt;</summary>
    
    
    
    <category term="Physical Simlation" scheme="http://adversarr.github.io/categories/Physical-Simlation/"/>
    
    
    <category term="Geometry" scheme="http://adversarr.github.io/tags/Geometry/"/>
    
    <category term="Computer Graphics" scheme="http://adversarr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读：Affine Particle-In-Cell Method</title>
    <link href="http://adversarr.github.io/2022/09/30/CG/SortByCato/MPM/apic/"/>
    <id>http://adversarr.github.io/2022/09/30/CG/SortByCato/MPM/apic/</id>
    <published>2022-09-29T16:00:00.000Z</published>
    <updated>2023-02-24T04:25:47.968Z</updated>
    
    <content type="html"><![CDATA[<p>Paper Reading: The Affine Particle In Cell.</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>相比于之前的方法</p><ol type="1"><li>保留了 PIC 的稳定性，但解决了耗散/误差问题</li><li>保留了 FLIP 的动量、角动量守恒特性，但解决了不稳定的问题</li></ol><p>主要思想：用一个仿射变换来代替原本的简单插值，从而解决p-&gt;g阶段的数据丢失。</p><h3 id="mpm">MPM</h3><ol type="1"><li>欧拉网格<ol type="1"><li>求力简单：均匀网格上的拉普拉斯算子容易计算</li><li>求运动困难</li></ol></li><li>拉格朗日粒子<ol type="1"><li>求运动简单</li><li>容易让物理量守恒</li><li>求力困难：难以离散化、邻居查找较为困难</li></ol></li></ol><p>建立从Euler Grid到LagrangeParticle的信息传递，来描述一个连续体介质。</p><p>问题出现在信息传递过程中：存在信息丢失的情况（维数不同，会产生降维的情况）</p><h3 id="pic">PIC</h3><p>P→G：</p><ol type="1"><li>mass: <span class="math inline">\(m_i^n = \sum_p w_{ip}^nm_p\)</span></li><li>velocity/linear momentum: <span class="math inline">\(m_i^n \mathbfv_i ^ n = \sum_p w_{ip}^n m_p \mathbf v_p^n\)</span></li></ol><p>G update: use NS-equation and backward-euler.</p><ol type="1"><li>velocity: <span class="math inline">\(\mathbf v_i ^n \rightarrow\mathbf v_i ^{n+1}\)</span></li></ol><p>G→P:</p><ol type="1"><li>velocity: <span class="math inline">\(\mathbf v_p^{n+1} = \sum_iw_{ip}^n \mathbf v_i ^ {n+1}\)</span></li></ol><p>P update: newton equations:</p><ol type="1"><li>position: <span class="math inline">\(\mathbf x = \mathbf x +\mathbf v \Delta t\)</span></li></ol><p>P→G保角动量，但G→P只传递动量，角动量不保持。</p><h3 id="flip">FLIP</h3></div><div class="story post-story"><h2 id="apic">APIC</h2><h3 id="rpic">RPIC</h3><p>在每一个particle上添加角动量<span class="math inline">\(L _ p ^n\)</span>，并用动量相同的方法执行P→G</p><p>P→G:</p><ol type="1"><li>Angular Momentum: <span class="math inline">\(m_i^n \mathbf v_i ^ n= \sum _ p w_{ip}^n m _ p (\mathbf v_p ^ n + ((\mathbfK_p^n)^{-1}\mathbf L _ p ^ n)\times (\mathbf x_i^n - \mathbf x _ p ^n))\)</span></li></ol><blockquote><p>其中 <span class="math inline">\(\mathbf K\)</span>是转动惯量张量，且<span class="math inline">\(\mathbf \omega = (\mathbfK)^{-1} \mathbf L\)</span></p></blockquote><p>G→P:</p><ol type="1"><li>Angular Momentum: <span class="math inline">\(L_p^{n+1}= \sum_i w_{ip} ^ n (\mathbf x_i^n - \mathbf x _ p ^n)\times m_p \mathbf v_{i}^{n+1}\)</span></li></ol><p>简单粗暴的保持角动量的方法。</p><p>至此，转动动能保持、平动动能保持。对于刚体运动，其能量能够保持，信息无损失。</p><p>但考虑到流体不具有刚性，从而还需要保持shearing mode下的运动。</p><h3 id="affine-pic">Affine PIC</h3><p>核心：粒子的速度场是分片仿射的。</p><p>解决RPIC中无法进行shearing的问题。</p><p><span class="math display">\[P\rightarrow G: \mathbf v_i^n = \sum_p w_{ip}^n \mathbf (v_p^n +C_p^n(\mathbf x_i - \mathbf x_p))\]</span></p><p>Problem: How to define <span class="math inline">\(C\)</span>efficiently. see <ahref="https://www.math.ucla.edu/~cffjiang/research/apic/tech-doc.pdf">tech-doc</a>.</p><p>P→G:</p><ol type="1"><li>mass</li><li>momentum: <span class="math inline">\(m_i\mathbf v_i ^n = \sum_pw_{ip}^n m_p(\mathbf v_p^n +B_p ^n(D_p^n)^{-1}(\mathbf x_i^n - \mathbfx_i^p))\)</span></li></ol><p>G→P:</p><ol type="1"><li>update: <span class="math inline">\(B _ p ^{n+1} = \sum _ iw_{ip}^{n}\mathbf v_i^{n+1}(\mathbf x_i^n - \mathbfx_p^n)^T\)</span></li><li>velocity.</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Paper Reading: The Affine Particle In Cell.&lt;/p&gt;</summary>
    
    
    
    <category term="Physical Simlation" scheme="http://adversarr.github.io/categories/Physical-Simlation/"/>
    
    
    <category term="Computer Graphics" scheme="http://adversarr.github.io/tags/Computer-Graphics/"/>
    
    <category term="Paper Reading" scheme="http://adversarr.github.io/tags/Paper-Reading/"/>
    
    <category term="Fluid Simulation" scheme="http://adversarr.github.io/tags/Fluid-Simulation/"/>
    
    <category term="MPM" scheme="http://adversarr.github.io/tags/MPM/"/>
    
  </entry>
  
  <entry>
    <title>离散微分几何 - 1 - Introduction</title>
    <link href="http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c1/"/>
    <id>http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c1/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2023-02-05T06:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>离散微分几何 - 1 - Introduction</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>Application:</p><ul><li>Geometry Processing: Up-sample / Down-sample — 3d-surface</li><li>Shape Analysis</li><li>Machine Learning.</li><li>Numerical Simu</li></ul></div><div class="story post-story"><h2 id="what-will-we-learn-wont">What will we learn / Won't</h2><ol type="1"><li>Diff Geometry</li><li>Geo Processing</li><li>Central — Link These two perspectives</li></ol><p>Won't</p><ol type="1"><li>view points on diff geometry</li><li>huge number of algorithms</li></ol></div><div class="story post-story"><h2 id="what-is-diff-geo">What is Diff Geo</h2><h3 id="diff-geo">Diff Geo</h3><ol type="1"><li>Talk about local properties of shape</li><li>and thier connection to global properties of shape</li><li>Lang of geometry physics</li></ol><h3 id="discrete-diff-geo">Discrete Diff Geo</h3><ol type="1"><li>infinity no longer allowed</li><li>expressed in terms of lenghs, angles</li><li>Loss is littow: captures many fundamental ideas</li></ol><blockquote><p>Translate continuous to discrete</p></blockquote><h3 id="how-to">How to</h3><p>DDG — obtain discrete definitions</p><ol type="1"><li>write down several equivalent definitions in the smooth setting</li><li>apply each smooth definition to an object in discrete</li><li>Determine which properties are captured by each resultinginequivalent discrete definition</li></ol></div><div class="story post-story"><h2 id="example-discrete-curvature">Example: Discrete Curvature</h2><h3 id="curves-in-the-plane">Curves in the Plane</h3><p>in 2D, a <strong>parameterized curve</strong> is a map taking eachpoint in an interval <span class="math inline">\([0, L]\)</span>.</p><p>Discrete Curves in the Plane:</p><ul><li><p>piecewise linear parameterized curve, vertices connected bystraight line segments</p></li><li><p>view as a interval <spanclass="math inline">\(\rightarrow\)</span> Segments</p></li></ul><h3 id="tangentnormalcurvature">Tangent/Normal/Curvature</h3><p>unit tangent: <span class="math display">\[T(s) := \frac{d}{ds} \gamma(s) / |\frac{d}{ds}\gamma(s)|\]</span> unit Normal: <span class="math display">\[N(s) = \mathcal JT(s)\]</span></p><ul><li><span class="math inline">\(\mathcal J\)</span>表示顺时针旋转</li></ul><p>curvature can be expressed as the rate of change in the tangent.<span class="math display">\[\kappa(s):=\langle N, \frac{d}{ds} T\rangle\]</span></p><ul><li>Key idea 1 — curvature is a second devirative.</li><li>Key idea 2 — curvature can have sign.</li></ul><h3 id="to-discrete">To Discrete</h3><p>in continuous:</p><ol type="1"><li>Turning angle</li><li>length variation</li><li>steiner formula</li><li>osculating curve</li></ol><h3 id="integrated-curvature">Integrated Curvature</h3><p><span class="math display">\[\int _ b ^ a \kappa(s) \mathrm ds = \varphi(b) - \varphi(a)\]</span></p><p>consider <span class="math inline">\(\gamma_{i - 1}\)</span>, <spanclass="math inline">\(\gamma_{i}\)</span>,<spanclass="math inline">\(\gamma_{i + 1}\)</span> <spanclass="math display">\[\theta _ i =: \kappa_i ^A\quad (\text{turning angle})\]</span></p><ul><li>integrated rather than pointwise values</li><li>total change in angle, not derivative.</li></ul><h3 id="length-variation">Length Variation</h3><blockquote><p>The fastest way to descrease the length of a curve is to move it inthe normal direction, with speed proportioonal to curvature</p></blockquote><p>Intuition — in flat rigions, normal motions doesn't change curvelength.</p><p>变分： <span class="math display">\[\eta(0) = \eta(L) = 0\]</span> Gradient of Length for a line segment</p><p><span class="math display">\[l:= \| b - a \|\]</span></p><p>Gradient of Length for a Discrete Curve</p><ul><li>Sumup the gradients above.</li></ul><h3 id="discrete-curvature">Discrete Curvature</h3></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;离散微分几何 - 1 - Introduction&lt;/p&gt;</summary>
    
    
    
    <category term="Mathematics" scheme="http://adversarr.github.io/categories/Mathematics/"/>
    
    
    <category term="Discrete Geomeotry" scheme="http://adversarr.github.io/tags/Discrete-Geomeotry/"/>
    
    <category term="Geometry" scheme="http://adversarr.github.io/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>离散微分几何 - 1 - Introduction</title>
    <link href="http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c2a/"/>
    <id>http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c2a/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2023-02-05T06:19:51.261Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="combinatorial-surfaces-mesh">Combinatorial Surfaces（Mesh）</h2><h3 id="what-is-a-mesh">What is a mesh?</h3><ol type="1"><li>simplical complex<ol type="1"><li>Abstract/geometric</li><li>Oriented, manifold simplical complex.</li></ol></li><li>Cell complex</li><li>Data structures.</li></ol><h3 id="connection-to-dg">Connection to DG?</h3><ol type="1"><li>Topological space. &lt;-&gt; Abstract simplical complex</li></ol><div class="story post-story"><h2 id="convex-set">Convex Set</h2><ol type="1"><li>Definition.</li><li>Convex Hull</li></ol><h3 id="simplex">Simplex</h3><ol type="1"><li>Definition: Linear Independence</li><li>Definition: Affine Independence(<span class="math inline">\(v_i =p_i - p_0\)</span> are linear indenpendent)</li></ol><p>Definition: a k-simplex is the convex hull of <spanclass="math inline">\(k+1\)</span> affine-independent points, which wecall its vertices.</p><h3 id="barycentric-coordinates">Barycentric Coordinates</h3><ul><li>we can describe a simplex more explicitly usingbarycentric-coord.</li></ul><p>any point <span class="math inline">\(p\)</span> inside simplex canbe expressed as a weighted combination of the vertices.</p><p><span class="math display">\[\sigma = \left \{\sum _{i = 0} ^ k t _ i p _ i : \sum _{i = 0} ^ k t_i = 1, t_i \ge 0\right\}\]</span></p><p>Definition: <strong>standard</strong> n-simplex(select <spanclass="math inline">\(p_i = \epsilon _ i\)</span>)</p><h3 id="simplicial-complex">Simplicial Complex</h3><blockquote><p>a bunch of simplicies.</p></blockquote><dl><dt>face</dt><dd>a face of a simplex is any simplex whose vertices are a subset of thevertices of <span class="math inline">\(\sigma\)</span></dd><dt>Simplicial Complex</dt><dd>a collection of simplicies where: 1. the intersection of any twosimplicies is a simplex. 2. every face of every simplex in the complexis also in the complex</dd></dl></div>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;combinatorial-surfaces-mesh&quot;&gt;Combinatorial Surfaces
（Mesh）&lt;/h2&gt;
&lt;h3 id=&quot;what-is-a-mesh&quot;&gt;What is a mesh?&lt;/h3&gt;</summary>
      
    
    
    
    <category term="Mathematics" scheme="http://adversarr.github.io/categories/Mathematics/"/>
    
    
    <category term="Discrete Geomeotry" scheme="http://adversarr.github.io/tags/Discrete-Geomeotry/"/>
    
    <category term="Geometry" scheme="http://adversarr.github.io/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>201-06-线性弹性有限元、拓扑优化</title>
    <link href="http://adversarr.github.io/2022/08/05/CG/GAMES/games201/g201-06/"/>
    <id>http://adversarr.github.io/2022/08/05/CG/GAMES/games201/g201-06/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-02-24T04:24:19.061Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 201 - 06 - 线性弹性有限元、拓扑优化</p><span id="more"></span><div class="story post-story"><h2 id="fem-overview">FEM Overview</h2><blockquote><p>Galerkin 方法的一种。将连续的PDE，转换为离散的线性系统</p><p>类似的还有物质点法（MPM）。（FEM是一种无元素的Galerkin方法）</p></blockquote><ol type="1"><li>将Strong-Form PDE转换为<strong>Weak-Form</strong>: 利用 testfunction <span class="math inline">\(w\)</span></li><li>分部积分，简化方程</li><li>散度定理</li><li>离散化</li><li>求解</li></ol><h3 id="d-泊松方程">2d-泊松方程</h3><p><span class="math display">\[\nabla \cdot \nabla u = 0\]</span></p><p>以及四个边界：</p><ol type="1"><li>三个Dirichlet边界：<span class="math inline">\(u(x) = f(x), x\in\partial \Omega\)</span></li><li>一个Neumann边界：<span class="math inline">\(\nabla u(x) \cdot n =g(x)\)</span></li></ol><h4 id="weak-formulation">Weak-Formulation</h4><p>任取的2d-test function<span class="math inline">\(w\)</span>：</p><p><span class="math display">\[\nabla \cdot \nabla u = 0 \iff \forall w, \iint _ \Omega w (\nabla \cdot\nabla u) \mathrm d A = 0\]</span></p><h4 id="分部积分去除二阶导数">分部积分去除二阶导数</h4><p><span class="math display">\[w\nabla \cdot \nabla u + \nabla w\cdot \nabla u = \nabla (w \nabla u)\implies\nabla w\cdot \nabla u = \nabla (w \nabla u)\]</span></p><h4 id="利用散度定理rhs">利用散度定理(RHS)</h4><p><span class="math display">\[\iint _ \Omega \nabla w \cdot \nabla u \mathrm dA = \oint _{\partial\Omega} w \nabla u \cdot \mathrm d\mathbf n\]</span></p></div><div class="story post-story"><h2 id="离散泊松方程">离散泊松方程</h2><p>取定基函数，表示<span class="math inline">\(u\)</span></p><p><span class="math display">\[u(x) = \sum_j u _ j \phi _ j (x)\]</span></p><blockquote><p>comsol - multiphysics - fem.</p></blockquote><p>并且直接用 <span class="math inline">\(\phi\)</span> 替换 <spanclass="math inline">\(w\)</span></p><p><span class="math display">\[\forall i, \quad \sum _ j (\iint \nabla \phi _ i \cdot \nabla \phi _ j\mathrm dA) u_j =\oint _ {\partial \Omega} \phi _ j \nabla u \cdot \mathrm dn\]</span></p><p>即</p><p><span class="math display">\[Ku = f\]</span></p><ul><li><span class="math inline">\(K\)</span>: stiffness matrix</li><li><span class="math inline">\(u\)</span>: solution vector</li><li><span class="math inline">\(f\)</span>: load vector</li></ul><p><span class="math display">\[K_{ij} = \iint _{\Omega} \nabla \phi_i \cdot \nabla \phi _ j \mathrm dA\]</span></p><p>右端：</p><ol type="1"><li>Dirichlet 边界条件：<span class="math inline">\(u(x) = f(x)\impliesu_i = f(x_i)\)</span></li><li>Neumann 边界条件：<span class="math inline">\(\nabla u (x) \cdot n =g(x)\)</span>: 将 <span class="math inline">\(g\)</span>插入方程右端，作为 <span class="math inline">\(f\)</span>的非零项。</li></ol></div><div class="story post-story"><h2 id="线性弹性有限元">线性弹性有限元</h2><p>柯西动量方程：</p><p><span class="math display">\[\frac{Dv}{Dt} = \frac 1 \rho \nabla \cdot \sigma + g\]</span></p><p>准静态（<span class="math inline">\(v = 0\)</span>,常密度，无重力）情况下：</p><p><span class="math display">\[\nabla \cdot \sigma = 0\]</span></p><h3 id="index-notation参考微分几何-爱因斯坦记号">IndexNotation（参考微分几何-爱因斯坦记号）</h3><p>用 <span class="math inline">\(\alpha,\beta, \gamma\)</span>表示。</p><p><span class="math display">\[\frac{Dv}{Dt} = \frac 1 \rho \nabla \cdot \sigma + g \iff\frac{Dv_\alpha}{Dt} = \frac 1 \rho \sum _ \beta\frac{\partial\sigma_{\alpha \beta}}{\partial x _ \beta} + g_\alpha\]</span></p></div><div class="story post-story"><h2 id="拓扑优化">拓扑优化</h2><p>Minimal Compliance Topology Optimization</p><p><span class="math display">\[\begin{aligned}\min L(\rho) = u^TK(\rho) u\\s.t. Ku = f\\\sum_e \rho_ e \le cV\\\rho _ e \in [\rho_\min, 1]\end{aligned}\]</span></p><ol type="1"><li><span class="math inline">\(L\)</span>：描述物质形变大小</li><li><span class="math inline">\(c\)</span>：体积系数</li><li><span class="math inline">\(\rho_e\)</span>：0表示空，1表示填充</li><li><span class="math inline">\(V\)</span>：总体积</li></ol><blockquote><ol type="1"><li>SIMP</li><li>OC</li></ol></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 201 - 06 - 线性弹性有限元、拓扑优化&lt;/p&gt;</summary>
    
    
    
    <category term="Physical Simulation" scheme="http://adversarr.github.io/categories/Physical-Simulation/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>201-05-多体问题和涡方法</title>
    <link href="http://adversarr.github.io/2022/08/04/CG/GAMES/games201/g201-05/"/>
    <id>http://adversarr.github.io/2022/08/04/CG/GAMES/games201/g201-05/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2023-02-24T04:24:18.651Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES201-5-多体问题和涡方法</p><span id="more"></span><h2 id="多体问题---introduction-to-fast-simulation">多体问题 -Introduction to Fast Simulation</h2><p>例如：万有引力</p><p><span class="math display">\[f(x) = \nabla \phi\]</span></p><blockquote><p>使用快速多级展开 -- 线性时间内求解<spanclass="math inline">\(n^2\)</span>的问题</p></blockquote><h3 id="d-泊松方程">2d-泊松方程</h3><p>考察给定原点，和在<spanclass="math inline">\(z\)</span>处的势能，使用泰勒（洛朗）展开</p><p>多极点的情况下：</p><p><span class="math display">\[\phi(z) = \sum q_j \log (z - z_j)= (\sum q_j \log z) - \sum_{k = 1}^p\frac {\sum _ j q_j z_j ^ k}{z^k}\quadQ_k = - \sum _ j \frac{q_j z_j^k}{k}\]</span></p><h3 id="tree-code">Tree Code</h3><p>类似于图像金字塔，网格划分。</p><h3 id="快速多级展开">快速多级展开</h3><p>思路：从一个Multipole到另一个Multipole直接计算，即在已经计算过的点处进行展开：</p><p><span class="math display">\[\begin{aligned}\phi(z) = Q\log(z - z_2) + \sum_{k = 1} ^ p \frac {b_k}{z^k} =Q\log z +  \sum_{k = 1} ^ p \frac {Q_k}{z^k}\end{aligned}\]</span></p><p>其中的 <span class="math inline">\(b_k\)</span> 是对于 <spanclass="math inline">\(Q_k\)</span> 的泛化 （M2M变换）</p><p><span class="math display">\[b_k = - \frac{Q (z_1 - z_2) ^ k}{k} + \sum_{i = 1} ^ k Q_i(z_1-z_2)^{k-i} C^{k-1}_{i-1}\]</span></p><blockquote><p>M2M Transform, M2L Transform ......</p></blockquote><!--TODO...-->]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES201-5-多体问题和涡方法&lt;/p&gt;</summary>
    
    
    
    <category term="Physical Simulation" scheme="http://adversarr.github.io/categories/Physical-Simulation/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的微分几何整理</title>
    <link href="http://adversarr.github.io/2022/07/15/study/Math/SummerCamp/DiffGeometry/"/>
    <id>http://adversarr.github.io/2022/07/15/study/Math/SummerCamp/DiffGeometry/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2023-02-24T04:36:12.616Z</updated>
    
    <content type="html"><![CDATA[<p>微分几何，主要是局部的性质。（不再更新）</p><span id="more"></span><div class="story post-story"><h2 id="欧氏空间">欧氏空间</h2><h3 id="向量空间">向量空间</h3><h4 id="向量空间的基本概念">向量空间的基本概念</h4><p>首先是相关概念。</p><ol type="1"><li>定义了内积的有限维向量空间是欧氏向量空间</li><li>经过 Schmidt 正交化可以得到标准正交基</li><li>可以定义外积运算</li></ol><dl><dt>外积的性质</dt><dd>设<span class="math inline">\(\mathbf v_{1} ..\mathbfv_{4}\)</span>是向量，则： 1. <span class="math inline">\(\mathbf v_1\wedge (\mathbf v_2 \wedge \mathbf v_3) = \langle\mathbf v_1 , \mathbfv_3\rangle - \langle \mathbf v_1,\mathbf v_2\rangle \mathbf v_3\)</span>2. 拉格朗日恒等式 3. 混合积循环不变</dd></dl><h4 id="向量分析">向量分析</h4><p>考虑向量值/数量值-向量/数量函数的微分：</p><ol type="1"><li><span class="math inline">\(\frac{d}{dt}(\lambda \mathbf a ) =\frac{d\lambda}{dt} a + \lambda \frac{d\mathbf a}{dt}\)</span></li><li>外积也满足上述公式</li><li>混合积也满足上述公式</li><li>多变量时，可以进行偏导和微分，也满足上述公式</li></ol><p>引入 <strong>梯度</strong> 场 和 Nabla算子： <spanclass="math display">\[\mathbf {grad} f = \nabla f\]</span></p><p>引入散度和旋度场： <span class="math display">\[\mathrm{div} \mathbf F\quad \mathbf{rot} \mathbf F\]</span></p><h3 id="欧氏空间-1">欧氏空间</h3><h4 id="向量运算">向量运算</h4><p>注意外积的运算： 1. 反交换律 2. 分配律</p><h4 id="坐标变换">坐标变换</h4><p>注意欧氏空间的定向：</p><dl><dt>定向</dt><dd>两个标架之间的正交变换<spanclass="math inline">\(T\)</span>的行列式为<spanclass="math inline">\(1\)</span>时，称之为定向相同。</dd></dl><h4 id="合同变换">合同变换</h4><dl><dt>Theo</dt><dd>设<span class="math inline">\(\mathcal T\)</span>是合同变换，则存在<spanclass="math inline">\(\mathbf T\in O(3)\)</span>以及<spanclass="math inline">\(P \in E^3\)</span>，使得： <spanclass="math display">\[\mathcal T(X) = X\mathbf T + P,\quad \forall X = (x^1,x^2, x^3)\in E^3\]</span> 即合同变换是正交变换和平移的复合</dd></dl><p>不难验证：合同变换的全体是一个群，称为三维合同变换群，当<spanclass="math inline">\(\det =1\)</span>是，对应的合同变换是刚体运动（也是一个群），反之称为反向刚体运动。</p><h4 id="正交标架和合同变换群">正交标架和合同变换群</h4><p><span class="math inline">\(E^3\)</span>的标架全体<spanclass="math inline">\(\mathcal F\)</span>与<spanclass="math inline">\(E^3\)</span>的欧式变换群之间有一一对应。</p><blockquote><p>即<spanclass="math inline">\(E^3\)</span>的所有元素的稳定化子只有<spanclass="math inline">\(\mathbf{id}\)</span>，并且<spanclass="math inline">\(E^3\)</span>中只有一个轨道。</p></blockquote></div><div class="story post-story"><h2 id="曲线">曲线</h2><h3 id="曲线的概念">曲线的概念</h3><p>在这里我们只考虑如下定义的正则曲线</p><dl><dt>正则曲线</dt><dd>如果曲线满足，每一个分量都是<spanclass="math inline">\(C^\infty\)</span>且 <spanclass="math inline">\(|dr/dt| &gt; 0\)</span>，对于所有<spanclass="math inline">\(t\)</span>，则称该曲线是正则曲线。</dd></dl><blockquote><p>平面上连续可微的参数曲线不一定是正规的</p></blockquote><p><span class="math display">\[\mathbf r(t) = (t^3 , t ^ 2)\]</span></p><h3 id="曲线的弧长">曲线的弧长</h3><p>假设有参数方程<span class="math inline">\(\mathbf r = \mathbfr(t)\)</span>，那么： <span class="math display">\[s= \int _ a ^ b \| \mathbf r&#39;(t)\| \mathrm dt\]</span> 是其弧长，是曲线的一个<strong>不变量</strong></p><h3 id="曲率frenet-标架">曲率、Frenet 标架</h3><dl><dt>Theo</dt><dd></dd></dl></div><div class="story post-story"><h2 id="测地曲率和测地线">测地曲率和测地线</h2><p>根据 Gauss 绝妙定理，<span class="math inline">\(K\)</span>只决定于曲面的第一基本形式，在保长对应下不变，是曲面的内蕴性质。在这里继续研究曲面内蕴几何的主要研究对象。</p><h3 id="测地曲率和测地线-1">测地曲率和测地线</h3><p>我们考虑正则曲面<span class="math inline">\(S:\mathbf r = \mathbfr(u^1, u^2)\)</span>，设有曲线<span class="math inline">\(u^\alpha =u^\alpha (s)\)</span> 是一条弧长参数曲线。其作为空间中的曲线参数方程为：<span class="math display">\[\mathbf r = \mathbf r(s) = \mathbf r (u^1, u^2)\]</span> 建立新的正交标架： <span class="math display">\[\begin{aligned}\mathbf e_1  &amp;= \frac {d\mathbf r(s)}{ds} = \alpha(s)\\\mathbf e_2 &amp;= \mathbf n(s)\times \alpha(s) \\\mathbf  e_3 &amp;= \mathbf n(s)\end{aligned}\]</span> 对于该曲线来考察原曲面的性质： <span class="math display">\[\begin{cases}\frac{d\mathbf r}{ds} &amp;= \mathbf e_1&amp;\\\frac{d\mathbf e_1}{ds} &amp;= &amp; +\kappa _g\mathbf e_2 &amp; +\kappa_n\mathbf e_3\\\frac{d\mathbf e_2}{ds} &amp;= -\kappa_g\mathbf e_1 &amp;&amp;+\tau_g\mathbf e_3 \\\frac{d\mathbf e_3}{ds} &amp;= -\kappa_n \mathbf e_1 &amp; +\tau_g\mathbf e_2\\\end{cases}\]</span> 显然，式中的：</p><ul><li><span class="math inline">\(\kappa_n\)</span> 就是曲面<spanclass="math inline">\(S\)</span>沿着曲线<spanclass="math inline">\(C\)</span>的切方向的法曲率；</li></ul><p>而也可以求解出其他的参数： <span class="math display">\[\kappa_g = \left( \mathbf n, \mathbf r&#39;, \mathbf r&#39;&#39; \right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地曲率</strong>； <span class="math display">\[\tau_g = \left( \mathbf n, \mathbf n&#39;,\mathbf r&#39;\right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地挠率</strong>。</p><p>下面的定理描述了测地曲率和测地挠率的几何意义：</p><dl><dt><strong>Theo</strong></dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条正则曲线，其在 <spanclass="math inline">\(p\)</span>处的测地曲率等于将其投影到切平面上的曲线的相对曲率，其平面的正向由曲面<span class="math inline">\(S\)</span> 在点 <spanclass="math inline">\(p\)</span> 的法向量给出。</dd><dt><strong>Theo</strong></dt><dd>曲面<span class="math inline">\(S\)</span>上任一条曲线<spanclass="math inline">\(C\)</span>的测地曲率是保长对应的不变量，即：<strong>测地曲率是内蕴量</strong>。</dd></dl><p>在取正交参数系的情况下，计算测地曲率有如下的<strong>Liouville公式</strong>：</p><dl><dt><strong>Theo</strong></dt><dd>设<span class="math inline">\((u,v)\)</span>是<spanclass="math inline">\(S\)</span>上的正交参数系，从而<spanclass="math inline">\(S\)</span>的第一基本形式为 <spanclass="math display">\[I = E(du)^2 + G(dv)^2\]</span> 假设<span class="math inline">\(C\)</span>与<spanclass="math inline">\(u\)</span>曲线的夹角为<spanclass="math inline">\(\theta\)</span>，那么其测地曲率是 <spanclass="math display">\[\kappa_g = \frac{d\theta}{ds} - \frac{1}{2\sqrt G} \frac{\partial \logE}{\partial v} \cos \theta + \frac{1}{2\sqrt E} \frac{\partial \logG}{\partial u}\sin \theta\]</span></dd></dl><p>最后我们讨论测地挠率，从自然标架的运动公式可以得出： <spanclass="math display">\[\tau _ g = \frac{1} {\sqrt g}\begin{vmatrix}&amp;\left(\frac{du^2}{ds} \right)^2 &amp; - \frac{du^1du^2}{dsds} &amp;\left(\frac{du^1}{ds} \right)^2 \\&amp;g_{11} &amp;g_{12} &amp; g_{22}\\&amp;b_{11} &amp;b_{22} &amp; b_{22}\end{vmatrix}\]</span> 故测地挠率和测地曲率一样，是<spanclass="math inline">\(S\)</span>上切方向的函数，反映的是曲面<spanclass="math inline">\(S\)</span>本身的性质，但其不是内蕴量。</p><p>对比主方向的方程，主方向恰好是测地挠率为 0的切方向。同时也有如下定理成立：</p><dl><dt>Theo</dt><dd>在曲面上非直线的渐进曲线<span class="math inline">\(C\)</span>的挠率是<span class="math inline">\(S\)</span>沿着曲面<spanclass="math inline">\(C\)</span>的切方向的测地挠率。</dd></dl><h3 id="测地线">测地线</h3><p>观察到测地曲率是内蕴量，从而要观察曲面上测地曲率为 0的曲线（测地线）</p><dl><dt>Theo</dt><dd>曲面上曲线<spanclass="math inline">\(C\)</span>是测地线，当且仅当，它或是一条直线，或者其主法向量处处是曲面的法向量</dd></dl><blockquote><p>例如：</p><ol type="1"><li>旋转面上的经线是测地线</li><li>若曲面上运动的质点 <span class="math inline">\(p\)</span>只受到将它约束在曲面上的力的作用，而不受到任何其他外力作用，则<spanclass="math inline">\(p\)</span>的轨迹是测地线</li></ol></blockquote><dl><dt>Theo</dt><dd>对于曲面上任意一点<span class="math inline">\(p\)</span>和曲面在<spanclass="math inline">\(p\)</span>的任意单位切向量<spanclass="math inline">\(v\)</span>，在曲面上存在唯一的一条弧长参数测地线通过<spanclass="math inline">\(p\)</span>且以<spanclass="math inline">\(v\)</span>为切向量</dd></dl><blockquote><p>平面 – 直线</p><p>曲面 – 测地线</p></blockquote><dl><dt>Theo</dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条曲线，则<spanclass="math inline">\(C\)</span>的弧长在任意一个有固定端点的变分<spanclass="math inline">\(C_t\)</span>中达到临界值的充分必要条件是<spanclass="math inline">\(C\)</span>是<spanclass="math inline">\(S\)</span>的测地线。</dd></dl><p>从而我们有：若曲线<span class="math inline">\(C\)</span>是连接<spanclass="math inline">\(p,q\)</span>的最短线，则<spanclass="math inline">\(C\)</span>是测地线。</p><h3 id="测地坐标系和法坐标系">测地坐标系和法坐标系</h3><h4 id="测地线族">测地线族</h4><p>在研究了测地线的性质后，我们研究测地线族的性质。</p><dl><dt>Theo</dt><dd>设<span class="math inline">\(\Sigma\)</span>是曲面<spanclass="math inline">\(S\)</span>上覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族，<spanclass="math inline">\(\Sigma_1\)</span>是由在区域<spanclass="math inline">\(D\)</span>内与<spanclass="math inline">\(\Sigma\)</span>中的曲线正交的轨线构成的曲线组，则其中任意两条曲线在<spanclass="math inline">\(\Sigma\)</span>中各条测地线上截出的曲线段长度相等。</dd></dl><blockquote><p>也就是说，测地线族的任意两条正交轨线之间的距离是处处相等的。</p><p>即：测地线族的任意两条正交轨线是<strong>测地平行</strong>的</p></blockquote><dl><dt>Theo</dt><dd>设<span class="math inline">\(C\)</span>是曲面<spanclass="math inline">\(S\)</span>上连接了<spanclass="math inline">\(p,q\)</span>两点的一条测地线，若曲线<spanclass="math inline">\(C\)</span>能够潜入到覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族<spanclass="math inline">\(\Sigma\)</span>中，且<spanclass="math inline">\(p,q\in D\)</span>，则其是区域内连接两点的最短线</dd></dl><h4 id="测地平行坐标系">测地平行坐标系</h4><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点<spanclass="math inline">\(p\)</span>的一个充分小的邻域内必定存在参数系<spanclass="math inline">\((u,v)\)</span>使得<spanclass="math inline">\(p\rightarrow (0,0)\)</span>，而第一基本形式可以写作 <span class="math display">\[I = (du)^2 + G(u,v) (dv)^2\]</span> 函数 <span class="math inline">\(G\)</span> 满足：$G(0, v)=1<span class="math inline">\(，\)</span>(0, v) =0<spanclass="math inline">\(，参数系\)</span>(u,v)$是<strong>测地平行坐标系</strong></dd></dl><h4 id="测地极坐标系">测地极坐标系</h4><p>定义指数映射： <span class="math display">\[\exp_p : T_pS \rightarrow S\quad \mathbf v\rightarrowtail\gamma(|\mathbf v|, \mathbf v_0)\]</span> <span class="math inline">\(\gamma\)</span>对于点<spanclass="math inline">\(p\)</span>处的单位切向量<spanclass="math inline">\(\mathbfv_0\)</span>，映射为弧长参数测地线上的参数为<spanclass="math inline">\(s\)</span>的位置。</p><p>显然指数映射 <span class="math inline">\(\exp_p\)</span>是连续可微的。于是有 <strong>法坐标系</strong>： <spanclass="math display">\[u^\alpha = u ^ \alpha(\exp_p(\mathbf v)) = u ^ \alpha(v^1, v^2)\]</span> 从而有<strong>测地圆</strong>（以<spanclass="math inline">\(p\)</span>为中心，<spanclass="math inline">\(s_0\)</span>为半径）</p><dl><dt>Theo 高斯引理</dt><dd>从<span class="math inline">\(p\)</span>出发的测地线与以点<spanclass="math inline">\(p\)</span>为中心的测地圆是彼此正交的。（即曲线族<spanclass="math inline">\(\Sigma_1\)</span>中的每一条曲线都是测地线族<spanclass="math inline">\(\Sigma\)</span>的正交轨线。</dd></dl><p>由此可以推导出测地极坐标系 <spanclass="math inline">\(（s,\theta)\)</span></p><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点的<spanclass="math inline">\(p\)</span>邻域内，出去从点<spanclass="math inline">\(p\)</span>出发的一条测地线外，也存在测地极坐标系，使得曲面第一形式为<span class="math display">\[I = (ds)^2 + G(d\theta)^2\quad \begin{cases}\lim _{s\rightarrow 0} \sqrt G = 0\\\lim_{s\rightarrow 0} \frac{\partial }{\partial S} \sqrt{G(s,\theta)} =1\end{cases}\]</span> 对应了平面上的极坐标系</dd></dl><h3 id="常曲率曲面">常曲率曲面</h3><p>高斯曲率为常数的曲面为<strong>常曲率曲面</strong>。</p><p>由于高斯曲率为内蕴量，我们不难考虑如下的定理：</p><dl><dt>Theo</dt><dd>有相同高斯曲率的任意两块常曲率曲面在局部上有保长对应。</dd></dl><blockquote><p>从现在的观点来看：</p><ol type="1"><li>常曲率曲面的第一基本形式是由其高斯曲率完全决定的</li><li>非欧几何学：将平面几何学推广到常曲率曲面</li></ol></blockquote><h3 id="平行移动">平行移动</h3><blockquote><p>考虑切向量场的协变微分和平行移动</p></blockquote><h3 id="gauss-bonnet公式">Gauss-Bonnet公式</h3><p>假定曲线是邮箱曲面上的一条分段光滑简单闭曲线，其包围的区域是曲面<span class="math inline">\(S\)</span> 的一个单连通区域，则 <spanclass="math display">\[\oint _C. \kappa _ g \mathrm d s + \iint _D K \mathrm d \sigma = 2 \pi -\sum _ {i = 1} ^ n \alpha _ i\]</span></p><ul><li><span class="math inline">\(\kappa_g\)</span>是曲线的测地曲率，</li><li><span class="math inline">\(K\)</span> 是曲面的高斯曲率</li><li>$_ i $ 表示曲线在角点<spanclass="math inline">\(i\)</span>的外角</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;微分几何，主要是局部的性质。（不再更新）&lt;/p&gt;</summary>
    
    
    
    <category term="Mathematics" scheme="http://adversarr.github.io/categories/Mathematics/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="微分几何" scheme="http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>理论力学C</title>
    <link href="http://adversarr.github.io/2022/06/18/study/Physics/TheoMechanics/"/>
    <id>http://adversarr.github.io/2022/06/18/study/Physics/TheoMechanics/</id>
    <published>2022-06-17T16:00:00.000Z</published>
    <updated>2023-02-05T06:21:34.007Z</updated>
    
    <content type="html"><![CDATA[<p>理论力学复习笔记</p><span id="more"></span><hr /><p>静力学</p><div class="story post-story"><h2 id="静力学公理和受力分析">静力学公理和受力分析</h2><h3 id="静力学公理">静力学公理</h3><ol type="1"><li><strong>二力平衡原理</strong>：受靓丽作用的刚体，平衡的充要条件时两个力大小相等、方向相反、作用在同一直线；<ol type="1"><li>二力构件</li></ol></li><li><strong>加减平衡力系原理</strong>：在作用域刚体的任何一个力系上，加上/减去任意多个平衡利息，不改变原力系对于刚体的效应<ol type="1"><li>不适合变形体</li><li>推论 – <strong>力的可传性</strong>：力可以沿着作用线任意移动</li></ol></li><li><strong>平行四边形法则</strong><ol type="1"><li>推论 – <strong>三力平衡汇交定理</strong>：三力平衡时，如果其中两个力的作用线相交于一点，则三力必须共面且共点</li></ol></li><li><strong>作用和反作用定律</strong>（牛三）</li><li><strong>刚化原理</strong>：变形体在力系作用下处于平衡状态时，可以假象变形体是刚体，在原力系作用下保持平衡</li></ol><h3 id="约束和约束力">约束和约束力</h3><ol type="1"><li><strong>自由体</strong>：空间中运动不受限制的物体</li><li><strong>约束</strong>：限制物体运动的条件<ol type="1"><li>约束反应 = 约束力</li></ol></li></ol><h4 id="柔性索">柔性索</h4><p>不及自重，不可伸长，只能承受拉力 – 力只沿着柔索</p><h4 id="光滑接触面">光滑接触面</h4><p>约束力：沿接触点的公法线，指向被约束的物体。</p><p>例如：齿轮传动</p><h4 id="光滑圆柱铰链">光滑圆柱铰链</h4><ol type="1"><li>圆柱铰链 – 约束力xy正交分解</li><li>固定铰链 – xy正交分解</li><li>滚动铰链 – 垂直于接触面</li></ol><h4 id="光滑球铰链">光滑球铰链</h4><p>约束力过球心 – xyz正交分解</p><h4 id="轴承">轴承</h4><ol type="1"><li>向心轴承 – xy正交分解</li><li>止推轴承 – xyz正交分解</li></ol><h4 id="必考链杆-二力杆"><code>必考</code>链杆 – 二力杆</h4><h3 id="受力分析受力图">受力分析、受力图</h3><ol type="1"><li>确定研究对象</li><li>分析力作用</li><li>分析相互作用力</li></ol><p>说明：</p><ol type="1"><li>字母标注</li><li>尽可能画在力的作用点上</li><li>不能用合力代替分布载荷</li><li>受力图上不用画出内力</li></ol></div><div class="story post-story"><h2 id="平面汇交力系和平面力偶系">平面汇交力系和平面力偶系</h2><h3 id="平面汇交力系">平面汇交力系</h3><p>– 力的作用线共面且汇交于一点</p><h4 id="几何法">几何法</h4><p>首尾相连</p><h4 id="几何条件">几何条件</h4><p>力多边形自行封闭</p><h3id="平面汇交力系合成平衡的解析法">平面汇交力系合成、平衡的解析法</h3><h4 id="力在坐标轴上的投影">力在坐标轴上的投影</h4><h4 id="汇交力系合成的解析法">汇交力系合成的解析法</h4><p>合力投影定理：在任意轴上的投影等于分力在同一轴上投影的代数和。</p><h4 id="平面汇交力系平衡方程">平面汇交力系平衡方程</h4><p>平衡的充要条件是力系的合力为0</p><h3 id="平面内力对于点的矩">平面内力对于点的矩</h3><h4 id="平面内力对点的矩">平面内力对点的矩</h4><p>合理矩定理：合力对任力系中各力对该点之矩矢的矢量和。 <spanclass="math display">\[M_O(F_R) = \sum M_O(F_i)\]</span> 适用于有合力的任意力系</p><h4 id="平面力偶系">平面力偶系</h4><dl><dt>力偶</dt><dd><p>大小相等，方向相反，不共线的两个力组成的力系<spanclass="math inline">\((F, F&#39;)\)</span></p></dd></dl><ol type="1"><li>力偶作用面、力偶臂</li><li>力偶效应：改变刚体的转动状态<ol type="1"><li>是力学中的<strong>基本量</strong></li></ol></li></ol><dl><dt>力偶矩</dt><dd>度量力偶对物体转动效应的量 – <span class="math inline">\(M= \pm d \cdotF\)</span></dd></dl><p>力偶是滑动矢量 – 与矩心的位置无关</p><h5 id="力偶的性质">力偶的性质</h5><ol type="1"><li>力偶无合力 – <span class="math inline">\(F_R &#39; = \sum F_i =0\)</span></li><li>力偶的效应<strong>只和</strong>力偶矩有关</li><li>力偶只与力偶矩相等的另一力偶等效</li><li>力偶对其作用面上任何一点的矩等于力偶矩</li></ol><blockquote><p>静止时，力偶不能与任一力平衡</p></blockquote><h5 id="平面力偶系合成">平面力偶系合成</h5><p>合成的结果为： <span class="math display">\[M = \sum _ i M_i\]</span> 即一个合力偶，力偶矩等于原力偶系中所有力偶矩的代数和</p><p>平面力偶系的平衡方程为： <span class="math display">\[\sum _i M_i = 0 \quad(i.e. \sum M = 0)\]</span></p></div><div class="story post-story"><h2 id="平面任意力系">平面任意力系</h2><h3 id="力系简化">力系简化</h3><h4 id="力的平移定理">力的平移定理</h4><dl><dt>力的平移定理</dt><dd>可以把刚体上一点的力向任意点平移，但要附加一个力偶，其力偶矩等于原来力对移动点（新点）的矩。</dd></dl><blockquote><p>相当于在目标点作一个力，然后设法使之等效。</p></blockquote><h4 id="平面力系向面内一点简化">平面力系向面内一点简化</h4><p>简化结果是：</p><ol type="1"><li>力系主矢 <span class="math inline">\(F_R&#39;= \sum_{i=1}^nF_i\)</span></li><li>力系主矩 <span class="math inline">\(M_O=\sum_{i = 1} ^ nM_O(F_i)\)</span></li></ol><p>其中 <span class="math inline">\(O\)</span> 是简化中心：</p><ol type="1"><li>力系主矢与<span class="math inline">\(O\)</span>无关</li><li>力系主矩<strong>一般</strong>和<spanclass="math inline">\(O\)</span>有关 –注意可能最终是一个合力偶的情况</li></ol><h5 id="简化结果的情况">简化结果的情况</h5><ol type="1"><li>力偶 – <span class="math inline">\(F_R&#39; = 0, M_O \ne0\)</span></li><li>平衡 – <span class="math inline">\(F&#39;_R = 0, M_O =0\)</span></li><li>合力 – 其他的情况</li></ol><h4 id="合理矩定理">合理矩定理</h4><dl><dt>合理矩定理</dt><dd>平面任意力系的合力对作用面任一点的矩等于力系中各力对同一点的矩的代数和<span class="math display">\[M_O(F_R) = \sum M_O(F_i)\]</span></dd></dl><h3 id="平衡方程和平衡条件">平衡方程和平衡条件</h3><h4 id="平衡的充要条件">平衡的充要条件</h4><p>充要条件是主矢和主矩都为0. <span class="math display">\[\begin{cases}F_R&#39; = 0\\M_O = 0\end{cases}\]</span> 则最简单的平衡方程为（一矩式） <span class="math display">\[\begin{cases}\sum F_x = 0\\\sum F_y = 0\\\sum M_O(F) = 0\end{cases}\]</span> 三个独立方程 – 三个未知量</p><h4 id="平衡方程的三种形式">平衡方程的三种形式</h4><p>两矩式 <span class="math display">\[\begin{cases}\sum F_x = 0\\\sum M_A(F) = 0\\\sum M_B(F) = 0\end{cases}\]</span></p><blockquote><p>要求<span class="math inline">\(AB\)</span>不垂直于<spanclass="math inline">\(x\)</span>轴</p></blockquote><p>三矩式 <span class="math display">\[\begin{cases}\sum M_A(F) = 0\\\sum M_B(F) = 0\\\sum M_C(F) = 0\end{cases}\]</span></p><blockquote><p>要求<span class="math inline">\(ABC\)</span>不共线</p></blockquote><h3 id="平衡问题">平衡问题</h3><p>特殊情况下，平衡方程可以解的位置量减少：</p><ol type="1"><li>汇交力系 — 两个独立方程</li><li>平行力系 — 两个独立方程</li><li>力偶系 — 一个独立方程</li></ol><blockquote><p>其中<span class="math inline">\(x, y\)</span>方向选择具有一定的任意性– 线性无关</p></blockquote><h4 id="静定问题和静不定问题">静定问题和静不定问题</h4><ol type="1"><li>静定问题 – 平衡方程可以求解所有未知数</li><li>静不定问题 – 平衡方程无法求出所有未知数</li></ol><p>确定方法：</p><ol type="1"><li>未知数和方程数比较</li><li>几何分析</li><li>计算自由度</li></ol><h3 id="桁架">桁架</h3><h4 id="分类">分类</h4><ol type="1"><li>平面桁架</li><li>空间桁架</li></ol><h4 id="工程实例与理想桁架">工程实例与理想桁架</h4><ol type="1"><li>无余杆 – 去掉任意一根，形状可变</li><li>有余杆</li></ol><h4 id="内力计算方法">内力计算方法</h4><p>节点法</p><ol type="1"><li>以节点为研究对象</li><li>平面汇交力系平衡方程 – <span class="math inline">\(F_x = 0\quad F_y= 0\)</span></li></ol><p>截面法</p><ol type="1"><li>假象截面截开桁架</li><li>局部桁架平衡，直接求内力</li></ol><p>考试题、关键点：找零力杆</p><ol type="1"><li>截面单杆 –截面法中如果被切断的二力杆除了一根外，其余都交于一点或互相平行，此根杆为单杆。</li><li>节点单杆 – 节点法中列平衡方程可以求出内力的杆</li></ol></div><div class="story post-story"><h2 id="摩擦">摩擦</h2><h3 id="滑动摩擦">滑动摩擦</h3><dl><dt>滑动摩擦</dt><dd>力 –两个粗糙表面的物体，接触面之间有相对滑动趋势/相对滑动时，彼此作用，阻碍相对滑动的阻力。方向– 与相对滑动相反</dd></dl><p>最大静摩擦 <span class="math display">\[F = f_s F_N\]</span></p><h3 id="摩擦角和自锁">摩擦角和自锁</h3><p>全约束反力： <span class="math display">\[F_R = F_N + F_S\]</span></p><blockquote><p>注意力的作用点需要按照其他力的作用线来判断</p></blockquote><p>摩擦角： <span class="math display">\[\tan \varphi _ m = f_s\]</span> 自锁 : 摩擦角范围内，不论主动力多大，物体都会保持平衡。</p><h3 id="摩擦平衡">摩擦平衡</h3><p>临界滑动</p><p>翻倒</p><h3 id="滚动摩阻">滚动摩阻</h3></div><div class="story post-story"><h2 id="点的运动学">点的运动学</h2><h3 id="矢量法">矢量法</h3><h4 id="运动方程">运动方程</h4><p><span class="math display">\[r=r(t)\]</span></p><h4 id="速度">速度</h4><p><span class="math display">\[v = \dot r\]</span></p><h4 id="加速度">加速度</h4><p><span class="math display">\[a = \dot v = \ddot r\]</span></p><h3 id="直角坐标法">直角坐标法</h3><h3 id="自然坐标法">自然坐标法</h3><p>考虑空间曲线的运动方程： <span class="math display">\[S ::= f(t)\]</span> 写出标架： <span class="math display">\[\begin{matrix}\vec t\\\vec n\\\vec b\end{matrix}\]</span> 则：速度为 <span class="math display">\[v = v_\tau \vec t = \frac{ds}{dt} \vec t\]</span> 加速度为： <span class="math display">\[a = a_\tau + a_n = a _ \tau \vec t + a_n \vec n\]</span></p></div><div class="story post-story"><h2 id="刚体运动学">刚体运动学</h2><h3 id="刚体平移">刚体平移</h3><dl><dt>平移</dt><dd>刚体运动过程中，其上任意直线始终平行于这一支线的初始位置</dd></dl><p>特点：</p><ol type="1"><li>刚体上的各点有形状相同的运动轨迹</li><li>各点在瞬时有相同的速度和加速度</li><li>可以简化为其上<strong>任意一点</strong>的运动分析</li></ol><h3 id="定轴转动">定轴转动</h3><dl><dt>定轴转动</dt><dd>刚体运动过程中，有一直线始终保持不动</dd></dl><h4 id="特征描述">特征描述</h4><ol type="1"><li>转角：通过转轴的</li><li>转动方程 ： <span class="math inline">\(\varphi = f(t)\)</span></li><li>角速度<span class="math inline">\(\omega\)</span>：<spanclass="math inline">\(\omega = \frac{d\varphi}{dt} = \dot\varphi\)</span></li><li>角加速度 <span class="math inline">\(\alpha=\ddot\varphi\)</span></li></ol><h4 id="各点运动分析">各点运动分析</h4><p>任意一点的速度： <span class="math display">\[v_P = \omega r\]</span> 加速度：</p><ol type="1"><li>法向加速度 <span class="math inline">\(a_P^n = r\alpha\)</span></li><li>切向加速度 <span class="math inline">\(a_P^\tau = r\alpha\)</span></li></ol><h4 id="传动比">传动比</h4><p>利用边缘处速度相等： <span class="math display">\[v = r_1 \omega _ 1 = r_2 \omega _ 2\implies \frac{\omega _ 1}{\omega _2} = \frac{r_2}{r_1}= \frac{z_2}{z_1}\]</span></p><h4 id="角速度矢量角加速度矢量">角速度矢量、角加速度矢量</h4><p>方向：右手法则</p><p>模长：<span class="math inline">\(\omega\)</span></p><p>从而： <span class="math display">\[v = \omega \times\vec r\]</span> 角加速度矢量 – 与角加速度矢量平行</p></div><div class="story post-story"><h2 id="点的合成运动">点的合成运动</h2><h3 id="绝对运动相对运动牵连运动">绝对运动、相对运动、牵连运动</h3><h4 id="静系-动系">静系-动系</h4><ol type="1"><li>静系 – 固定于地球、相对地球静止的坐标系</li><li>动系 – 固定在相对地球运动的物体上的坐标系</li></ol><h4 id="运动">运动</h4><ol type="1"><li><strong>绝对运动</strong>：动点相对静系</li><li><strong>相对运动</strong>：动点相对动系</li><li><strong>牵连运动</strong>：动系相对静系</li></ol><h4 id="速度-1">速度</h4><ol type="1"><li>绝对速度 <span class="math inline">\(v_a\)</span> –动点在绝对运动中的速度</li><li>相对速度 <span class="math inline">\(v_r\)</span> –动点在相对运动中的速度<br /></li><li>牵连速度 <span class="math inline">\(v_e\)</span> –牵连点相对于静系的速度</li></ol><p><strong>牵连点</strong>：动系上和动点重合的点</p><h4 id="加速度-1">加速度</h4><ol type="1"><li>绝对加速度</li><li>相对加速度</li><li>牵连加速度</li></ol><h3 id="速度合成定理">速度合成定理</h3><dl><dt>速度合成定理</dt><dd>速度合成就是矢量相加 <span class="math display">\[v_a = v_r + v_e\]</span></dd></dl><h3 id="加速度合成定理">加速度合成定理</h3><p>牵连运动是平移时： <span class="math display">\[a_a = a_e + a_r\]</span> 牵连运动不是平移： <span class="math display">\[a_a = a_e + a _ r + a _ C\]</span></p><h4 id="相对导数绝对导数">相对导数、绝对导数</h4><p><span class="math display">\[\frac {d A}{dt} = \frac{\tilde d A} {dt} + \omega \times A\]</span></p><p>因此： <span class="math display">\[a_a = a_e + a_ r + a_C\\a_C = 2 \omega \times v_r\]</span></p></div><div class="story post-story"><h2 id="刚体的平面运动">刚体的平面运动</h2><h3 id="概念">概念</h3><dl><dt>刚体的平面运动</dt><dd>运动时，其上同一平面内各点到一固定平面的距离不变。</dd></dl><blockquote><p>可以简化为平面图形 – 不同平面上对应点具有相同的轨迹、速度、加速度</p></blockquote><h4 id="平面运动方程">平面运动方程</h4><p>– 自由度 = 3 <span class="math display">\[\begin{cases}x_A\\y_A\\\varphi\end{cases}\]</span> 其中 <span class="math inline">\(A\)</span> 称为基点</p><h4 id="平面运动分解">平面运动分解</h4><p>可以分解为：</p><ol type="1"><li>平移：速度和加速度都和基点选取有关</li><li>定轴转动：角速度和基点选取无关</li></ol><h3 id="基点法">基点法</h3><ol type="1"><li>平面图形 – S</li><li>定系 – <span class="math inline">\(Oxy\)</span></li><li>基点 – <span class="math inline">\(A\)</span></li><li>平移系 – <span class="math inline">\(Axy\)</span></li><li>角速度 – <span class="math inline">\(\omega\)</span></li><li>基点速度 – <span class="math inline">\(v_A\)</span></li></ol><p>故：<span class="math inline">\(v_B = v_A + v_{BA}, v_{BA} = \omegar_B\)</span></p><h4 id="投影法">投影法</h4><dl><dt>速度投影定理</dt><dd>平面图形任意两点的速度在两点的连线上投影相等</dd></dl><h3 id="瞬心法">瞬心法</h3><p>速度瞬心 – 速度为 0 的点</p><ol type="1"><li>瞬时性</li><li>唯一性</li><li>瞬时转动</li></ol><h4 id="确定方法">确定方法</h4><ol type="1"><li><p>特殊情况：已知只滚动不滑动</p></li><li><p>已知两点速度矢量方向且互不平行</p></li><li><p>已知两点速度方向相互平行</p><ol type="1"><li><p>连线与速度垂直，</p><ol type="1"><li>大小不等 – 可以找到瞬心</li><li>大小相等 – 瞬时平移</li></ol></li><li><p>连线与速度不垂直</p><p>必然大小相等（投影），且为瞬时平移</p></li></ol></li></ol><h3 id="加速度分析-基点法">加速度分析 – 基点法</h3><p>已知一点 <span class="math inline">\(A\)</span> 的加速度，和 <spanclass="math inline">\(B\)</span>相对 <spanclass="math inline">\(A\)</span>的加速度，则 <spanclass="math display">\[a_a = a_e + a_r = a_A + a_{BA} = a_B\]</span> 进一步的： <span class="math display">\[a_B = a_A + a_{BA}^t + a_{BA} ^ n\]</span></p></div><div class="story post-story"><h2 id="动能定理">动能定理</h2><h3 id="力的功">力的功</h3><ol type="1"><li><p>重力的功</p></li><li><p>弹性力的功</p></li><li><p>定轴转动刚体上作用力的功</p></li><li><p>力偶的功：<span class="math inline">\(W = M\varphi\)</span></p></li><li><p>平面运动刚体： <span class="math display">\[W_{12} = \int_{\varphi_1} ^{\varphi _ 2} M_c d\varphi + \int _{C_1}^{C_2} Fd r_c\]</span></p><blockquote><p>作用在某处的力，对于刚体的功等于：</p><ol type="1"><li>力等效移动到质心得到的力偶和</li><li>力对质心做功</li></ol><p>的和</p></blockquote></li><li><p>内力的功</p></li><li><p>纯滚动时 – 滑动摩擦力不做功</p></li></ol><h3 id="质点质点系的动能">质点、质点系的动能</h3><ol type="1"><li>质点的动能 – <span class="math inline">\(T = \frac 1 2 m v ^2\)</span></li><li>质点系的动能 — <span class="math inline">\(T = \sum _ i \frac 1 2 m_i v _ i ^ 2\)</span></li><li>柯尼希定理 — <span class="math inline">\(T = \frac 1 2 M v_c^2 + T_r= T_e + T_r\)</span></li></ol><h4 id="各种形式下刚体的动能">各种形式下刚体的动能</h4><ol type="1"><li>平移 – <span class="math inline">\(T = \frac 1 2mv_C^2\)</span></li><li>定轴转动刚体的动能 – <span class="math inline">\(T = \frac 1 2 J_z\omega ^ 2\)</span></li><li>平面运动 – <span class="math inline">\(T = \frac 1 2 m v_C^2 + \frac1 2 J_C\omega^2 = \frac 1 2 J_P\omega ^ 2\)</span></li></ol><h3 id="动能定理-1">动能定理</h3><h4 id="质点动能定理">质点动能定理</h4><p>两种形式 <span class="math display">\[dT = \delta W\quad T_2 - T_1 = W_{12}\]</span> 求加速度先考虑微分、求速度先考虑积分。</p><h4 id="质点系动能定理">质点系动能定理</h4><p>直接求和即可</p><h3 id="功率功率方程">功率、功率方程</h3><p>力的功率 – 力做的功对时间的变化率 <span class="math display">\[P= \frac {\delta W}{dt} = F \cdot v\]</span> 力矩和力偶矩的功率 — <span class="math display">\[P = M \cdot \omega\]</span></p></div><div class="story post-story"><h2 id="动量定理">动量定理</h2><h3 id="动量和冲量">动量和冲量</h3><p>质点系的动量和冲量分别为： <span class="math display">\[p = mv\\p = \sum_i m_i v_i = M v_C\]</span></p><h4 id="冲量">冲量</h4><p><span class="math display">\[I = \int F\cdot d t\]</span></p><h3 id="动量定理-1">动量定理</h3><h4 id="质点的动量定理">质点的动量定理</h4><p><span class="math display">\[\mathrm d (mv) = F \mathrm dt\]</span></p><p>积分形式为 <span class="math display">\[mv_2 - mv_1=\int F \mathrm dt = I\]</span></p><h4 id="质点系的动量定理">质点系的动量定理</h4><p><span class="math display">\[\frac{dp}{dt} = \sum F_i\]</span></p><blockquote><p>质点系的动量矢对时间的一阶导数 = 作用在质点系上的外力主矢</p></blockquote><p>积分为： <span class="math display">\[p - p_0 =I\]</span></p><h4 id="质点系的动量守恒">质点系的动量守恒</h4><p>外力主矢 = 0</p><h3 id="质心运动定理">质心运动定理</h3><p><span class="math display">\[ma_C = \sum F_i ^ e\]</span></p><blockquote><p>质点系总质量与质心加速度的积 = 作用在质点系上的外力主矢</p></blockquote><p>即外力主矢确定了质点系质心运动状态变化。</p></div><div class="story post-story"><h2 id="动量矩定理">动量矩定理</h2><h3 id="质点质点动量矩">质点、质点动量矩</h3><h4 id="质点的动量矩">质点的动量矩</h4><p><span class="math display">\[M_O(mv) = r \times mv\]</span></p><p>动量矩是定位矢量 – 与 <span class="math inline">\(O\)</span>有关。</p><h4 id="质点系的动量矩">质点系的动量矩</h4><p><span class="math display">\[M_O(m _ i v _ i) = r_i \times m_i v_i \quadL_O = \sum _{i = 1} ^ n M_O(m _ i v _ i)\]</span></p><h4 id="对轴的动量矩">对轴的动量矩</h4><p>质点： <span class="math display">\[M_z ( mv ) = \left[M_O(mv)\right]_z\]</span> 质点系：</p><ol type="1"><li>平移 – 按照质量集中在质心的质点计算。</li><li>定轴转动 – <span class="math inline">\(L_z = J_z\omega\)</span></li></ol><p>常见转动惯量（按质心算）</p><ol type="1"><li>圆盘：<span class="math inline">\(J_O = \frac 1 2 mR^2\)</span></li><li>杆：<span class="math inline">\(J_C = \frac{1}{12} ml ^2\)</span></li><li>球：<span class="math inline">\(J_z = \frac 2 5 mR^2\)</span></li></ol><dl><dt>平行移轴定理</dt><dd><span class="math inline">\(J_z = J_{z_C} + md^2\)</span></dd><dt>回转半径</dt><dd><p>满足 <span class="math inline">\(J_z = m \rho^2_z\)</span></p></dd></dl><h3 id="相对于定点的动量矩定理">相对于定点的动量矩定理</h3><blockquote><p>注意要相对定点/定轴！</p></blockquote><h4 id="质点的动量矩定理">质点的动量矩定理</h4><p><span class="math display">\[\frac{d L _ O}{dt} = M_O(F)\]</span></p><p>动量矩的变化率 = 作用在质点上的力</p><h4 id="质点系的动量矩定理">质点系的动量矩定理</h4><p><span class="math display">\[\frac{d L _ O}{dt} = \sum M_O(F)\]</span></p><p>质点系对定点的动量矩的变化率 = 所有外力对同一点的主矩。</p><h4 id="动量矩守恒">动量矩守恒</h4><p>若外力系对于定点的主矩为0，则质点系对这一点的动量矩守恒。</p><h3 id="定轴转动的微分方程">定轴转动的微分方程</h3><p><span class="math display">\[J_z \alpha = \sum M_z (F)\]</span></p><h3 id="质点系对质心的动量矩定理">质点系对质心的动量矩定理</h3><p><span class="math display">\[\frac{dL_C}{dt} = \sum M_C^e\]</span></p><p>其中： <span class="math display">\[L_C = \sum _{i} r _ i &#39; \times m_i v_{ir}\]</span></p><h3 id="刚体平面运动微分方程">刚体平面运动微分方程</h3><p>利用： <span class="math display">\[L_C = J_C \omega\]</span></p><p><span class="math display">\[m \ddot x_C = \sum F_x ^ e \\m \ddot y_C = \sum F_y ^ e \\J_C \ddot \phi = \sum M_C(F^e)\]</span></p></div><div class="story post-story"><h2 id="达朗贝尔原理">达朗贝尔原理</h2><h3 id="惯性力动静法">惯性力、动静法</h3><p><span class="math display">\[\sum F+ F_I = 0\quad F_I = - m a\]</span></p><h3 id="质点系的达朗贝尔原理">质点系的达朗贝尔原理</h3><p><span class="math display">\[\sum F_i^e + \sum F_{Ii} = 0\quad \sum M_O(F_i^e) + \sum M_O(F_{Ii}) = 0\]</span></p><h3 id="惯性力系简化">惯性力系简化</h3><ol type="1"><li>平移时 – 主矢大小为<span class="math inline">\(ma_C\)</span>主矩为0</li><li>定轴转动时 – 主矢为 0，主矩为<span class="math inline">\(J_O\alpha\)</span></li><li>平面运动 –<ol type="1"><li>主矢 <span class="math inline">\(ma_C\)</span></li><li>主矩 <span class="math inline">\(J_C\alpha\)</span></li></ol></li></ol><blockquote><p>方向都与 <span class="math inline">\(a_C,\alpha\)</span> 相反。</p></blockquote><hr /></div><div class="story post-story"><h2 id="作业和复习课">作业和复习课</h2><h3 id="静力学">静力学</h3><p><code>受力图</code></p><ol type="1"><li>隔离法各个物体单独画</li></ol><p>列方程： <span class="math display">\[\begin{aligned}\sum F_x = 0 &amp;\quad ... + ... + ... =0\\\sum F_y = 0 &amp;\quad ... + ... + ... =0\\\sum M_f = 0 &amp;\quad ... + ... + ... =0\end{aligned}\]</span> <strong>固定端</strong>必考 – 这次必考（作业题2）</p><ul><li>注意约束力偶矩 – 受力图！</li></ul><p>这甜蜜和近代物理老师送分没啥区别。</p><p>二力构件和二力杆 – 填空题、作图题（画受力图 – 3题） –只要受到两个力而平衡，就是二力构件。</p><p>三力汇交必考</p><h3 id="运动学">运动学</h3><p>点的合成运动</p><p>8-22 明确写出以谁为动点、以谁为动系 – 3+3分</p><ul><li><span class="math inline">\(v_a\)</span> – 绝对</li><li><span class="math inline">\(v_e\)</span> – 牵连</li><li><span class="math inline">\(v_r\)</span> – 相对</li></ul><p>加速度同理，<span class="math inline">\(a_c\)</span></p><p>8-29 只是求<span class="math inline">\(a_c\)</span> – 相对速度 +角速度</p><p>9-</p><h3 id="考试">考试</h3><p>选择、填空（计算）、判断</p><p>做图</p><p>计算题</p><blockquote><p>u1s1-不如报答案</p></blockquote><p>判断</p><ul><li>2个-牵连运动、牵连速度！是否和定义一致？</li><li>质心运动定理一定要理解<span class="math inline">\(m a_c = \sum \vecF\)</span> ，包括主动力、约束力都要考虑！</li><li>达朗贝尔原理、惯性力系简化（平移、惯性力偶矩、合力？）<ul><li>平移和瞬时平移（平面运动的一个特例）是不同的！</li></ul></li></ul><p>单选填空作图</p><ul><li>作图：受力图 – 明确方向！<ul><li>能够看出二力杆：受拉力还是压力？</li></ul></li><li>参考 书本P83图4-13</li><li>空间力系-求对轴的矩？力和轴平行时为0</li><li>重心<ul><li>组合法</li><li>负面积法</li></ul></li><li>速度顺心 – 平面运动 – 作图题</li><li>选择填空：<ul><li><span class="math inline">\(J_c \alpha = \sum M_c (\vec F)\)</span>–对比一下选答案 （所有外力）</li><li>平面运动的动能 <span class="math inline">\(T = \frac 1 2 m v_c ^ 2 +\frac 1 2 J_c \omega^2\)</span></li><li>13-5 动量动能动量矩</li><li>p270 – 11-4 串并联、固有频率、求解方法</li></ul></li></ul><p>计算</p><ul><li><p>静力学：有固定端（约束力偶矩），谁是固定端，其他很简单</p><ul><li>要分开画受力图</li><li>协调性原则 – 方向（牛3）、标注（<span class="math inline">\(F\rightarrow F&#39;\)</span>）</li></ul></li><li><p>桁架：零力杆（要写理由）截面法、节点法 – 送分</p></li><li><p>动力学：P184图8-16、速度合成定理、刚体的平面运动（动点动系记得要写-3分）</p><ul><li>基点法、投影定理、瞬心 – 求加速度只能用基点法</li><li>判断加速度方向</li><li>速度瞬心法 – 如果是又滚又滑</li></ul></li><li><p>动力学：P413 16-24题：</p></li><li><p>达朗贝尔原理 或者用：<span class="math inline">\(J_c \alpha =\sum M_c (\vec F)\)</span> （对单个物体成立）和<spanclass="math inline">\(Ma_c = \sum F\)</span></p><ul><li>建立坐标系 – 放在正半轴的一般位置？</li></ul></li></ul><p>复习个xxxxx</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;理论力学复习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="http://adversarr.github.io/categories/Course/"/>
    
    
    <category term="物理" scheme="http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
</feed>
