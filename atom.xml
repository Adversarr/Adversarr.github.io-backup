<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逆版本战士の部落格</title>
  
  
  <link href="http://adversarr.github.io/atom.xml" rel="self"/>
  
  <link href="http://adversarr.github.io/"/>
  <updated>2022-11-05T01:34:39.274Z</updated>
  <id>http://adversarr.github.io/</id>
  
  <author>
    <name>Adversarr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Digital Geometry Processing</title>
    <link href="http://adversarr.github.io/2022/11/04/CG/DGP/lec1/"/>
    <id>http://adversarr.github.io/2022/11/04/CG/DGP/lec1/</id>
    <published>2022-11-04T04:14:06.796Z</published>
    <updated>2022-11-05T01:34:39.274Z</updated>
    
    <content type="html"><![CDATA[<p>GCL-F-DGP1</p><span id="more"></span><div class="story post-story"><h2 id="representations">Representations</h2><p>How to represent geometry data in computer.</p><h3 id="point-cloud">Point cloud</h3><p><span class="math display">\[P = \{ p _ 1, \dots , p _ n\}\]</span></p><p>A set of data points in some coord-system.</p><p>Applications: scanners</p><h3 id="signed-distance-function-sdf">Signed Distance Function(SDF)</h3><p>Give the distance of a given point x from the boundary of <spanclass="math inline">\(\Omega\)</span></p><ol type="1"><li>inside -&gt; neg</li><li>outside -&gt; pos</li></ol><blockquote><p>Truncated SDF(TSDF)</p></blockquote><h3 id="implicit-function">Implicit Function</h3><p><span class="math display">\[F(x, y, z) = 0\]</span></p><p>SDF is some kind of IF.</p><h3 id="grid">Grid</h3><h4 id="pixel-voxel">Pixel, Voxel</h4><ol type="1"><li><p>Adaptive: Grid-Hierarchical Oct-Tree</p></li><li><p>Patch-based quadtree.</p><p>Ref: Adaptive O-CNN</p></li></ol><h3 id="triangle-mesh">Triangle Mesh</h3><p>A collection of triangles. without any mathematical structure.</p><p>Geometry component:</p><ul><li>Vertices: <span class="math inline">\(v _ 1 ... v _ N\)</span></li></ul><p>Topological component:</p><ul><li>Triangle: <span class="math inline">\(T\)</span></li><li>Edge: <span class="math inline">\(E\)</span></li></ul><blockquote><p>Topology describes the connectivity.</p></blockquote><h4 id="quad-mesh">Quad Mesh</h4><p>不一定是共面的！</p><blockquote><p><strong>Homework 1</strong>: Shortest Path, Minimal Spaning Tree</p></blockquote><h4 id="manifold">2-manifold</h4><p>Euler Formula <span class="math display">\[N_V -N_E+ N_F= 2(1-g)\]</span></p><ul><li><span class="math inline">\(g\)</span>为亏格数量</li></ul><h4 id="data-structure---requirements">Data Structure -requirements</h4><ol type="1"><li>Given <span class="math inline">\(f_j\)</span>, find its containingvertices in order</li><li>Given <span class="math inline">\(v_i\)</span>, find its one-ringfacets in order</li><li>Given <span class="math inline">\(v_i\)</span>, find adjacentvertices/outgoing edges</li><li>Given <span class="math inline">\(e_k\)</span>, find its connectedtwo facets</li><li>Given <span class="math inline">\(f_j\)</span> and <spanclass="math inline">\(e_k\)</span>, find another facet which connects<span class="math inline">\(e_k\)</span></li><li>…</li></ol><p>Half edge Data structure!</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GCL-F-DGP1&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SPH Introduction</title>
    <link href="http://adversarr.github.io/2022/10/27/CG/SortByCato/SPH/1106paper/"/>
    <id>http://adversarr.github.io/2022/10/27/CG/SortByCato/SPH/1106paper/</id>
    <published>2022-10-26T16:00:00.000Z</published>
    <updated>2022-11-05T08:16:01.583Z</updated>
    
    <content type="html"><![CDATA[<p>1106 论文汇报</p><p>SPH Fluids in computer graphic</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><h3 id="governing-equations">Governing Equations</h3><p>Consider fluid that consists of a set of small moving fluidelements(i.e. particles), and for each particle, it carriesattributes:</p><ol type="1"><li>Density <span class="math inline">\(\rho _ i\)</span></li><li>Pressure <span class="math inline">\(p _ i\)</span></li><li>volume <span class="math inline">\(v _ i\)</span></li></ol><p>From Newton's second law:</p><p><span class="math display">\[\frac{\mathrm d x _ i} {\mathrm d t} = v _ i\]</span></p><p>We use particles to describe the fluid flow, the time rate of changeof the velocity is governed by the <strong>Lagrange</strong> view of NSEquation.</p><p><span class="math display">\[\dot v _ i = -\frac 1 {\rho _ i} \nabla p _ i + v \nabla ^ 2 v _ i +\frac{F _ {ext}} {m _ i}\]</span></p><ol type="1"><li>Pressure</li><li>Friction force. <span class="math inline">\(v\)</span> -&gt;kinematic viscosity.</li><li>External force, such as gravity.</li></ol><h3 id="sph">SPH</h3><p>Idea: Interpolate the fluid quantities at arbitary positions and toapproximate the spatial derivatives, <strong>using a set of samplepositions, i.e. adjacent particles</strong></p><p><em>Interpolation</em>: A quantity <span class="math inline">\(A _i\)</span> at <span class="math inline">\(x _ i\)</span> is approximatedusing a weighted sum of neighbour particles:</p><p><span class="math display">\[A _ i = \sum _ {j \in \mathcal N _ i} \frac{m _ j} { \rho _ j } A _ j W_ {ij}\]</span></p><p><span class="math inline">\(W _ {ij}\)</span> should be close to aGaussian, amd can be implemented as:</p><ol type="1"><li>Bell function</li><li>Quintic Spline -- <span class="math inline">\(C^1\)</span>continuity</li><li>Cubic Spline -- <span class="math inline">\(C ^ 2\)</span>continuity</li></ol><p><em>Spatial Derivatives</em>: Spatial derivatives can be derived:</p><p><span class="math display">\[\begin{aligned}\nabla A_i = \rho_i + \sum_{j} m_j  \left ( \frac { A _ i} { \rho _ i  ^2} + \frac{A _ j} {\rho _ j ^ 2}\right) \nabla W_ { i j }\\\nabla \cdot \mathbf{A}_i = - \frac 1 { \rho _ i} \sum _ j m _ j \mathbfA _ {ij} \cdot \nabla W _ {ij} \\\nabla ^ 2 A _ i = 2 \sum _ { j } \frac { m _ j} { \rho _ j} A _ {ij}\frac {\mathbf x _ {ij} \cdot \nabla W _ { ij }}{\mathbf x _ {ij} \cdot\mathbf x _ {ij} + 0.01 h ^ 2}\end{aligned}\]</span></p><p>Here, <span class="math inline">\(\rho\)</span> is computedusing:</p><p><span class="math display">\[\rho_i  = \sum_j m_j W_{ij}\]</span></p><blockquote><p>we always use <span class="math inline">\(m / \rho\)</span>, and themeaning of <span class="math inline">\(\rho\)</span> here does notmatter.</p></blockquote><h3 id="the-solver">The solver</h3><p>Three basic steps:</p><ol type="1"><li>Neighbourhood search</li><li>Pressure Computation</li><li>Time Integrations</li></ol><p>Neighbourhood search can be solved using VDB or SpatialOrdering/Hashing methods. We focus on 2 and 3.</p><p>A typical choice is:</p><p>For <em>Pressure Computation</em>:</p><p><span class="math display">\[p_i = k \left( \left ( \frac{\rho_i}{\rho_0}\right) ^ 7 - 1 \right)\]</span></p><p>where:</p><ul><li><span class="math inline">\(\rho_0\)</span> is the restdensity.</li><li><span class="math inline">\(k\)</span> is the stiffness.</li></ul><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foreach Particle P:</span><br><span class="line">  find neighbours.</span><br><span class="line">foreach Particle P:</span><br><span class="line">  compute density.</span><br><span class="line">  compute pressure.</span><br><span class="line">foreach Particle P:</span><br><span class="line">  compute pressure force.</span><br><span class="line">  compute viscosity force</span><br><span class="line">  compute <span class="keyword">external</span> force</span><br><span class="line">  merge <span class="built_in">all</span> the forces.</span><br><span class="line"></span><br><span class="line">foreach Particle P:</span><br><span class="line">  update velocity, position.</span><br></pre></td></tr></table></figure><blockquote><p><strong>CFL Condition</strong> should be considered carefully whenusing this method.</p></blockquote><p><span class="math display">\[\Delta t \le \lambda \frac{ h } { \| v _ {\max} \| }, \qquad\mathrm{with}~~\lambda \approx 0.4\]</span></p><h3 id="neightbourhood-search">Neightbourhood Search</h3><p><em>Time</em>: 1. Grids: <span class="math inline">\(O(n)\)</span>build, <span class="math inline">\(O(1)\)</span> access 2. Hierarchy:<span class="math inline">\(O(n log n)\)</span> build, <spanclass="math inline">\(O(log n)\)</span> access.</p><p><em>Memory</em>: Hierarchy &lt; Grid.</p><ol type="1"><li><em>Iterative</em>: Reuse the structure frequently, and we can storethe neighborhood set, and rebuild it from time to time.</li><li><em>Non-Iterative</em>:</li></ol><h4 id="uniform-grid">Uniform Grid</h4><ol type="1"><li>Index Sort -&gt; See GPU Gems 3</li><li>Z-index Sort -&gt; latency, cache hit rate</li></ol><h4 id="hashing">Hashing</h4><ol type="1"><li>hashing,</li><li>compact hasihing.</li></ol><blockquote><p>To reduce the memory consumption of plain grid storaging method.</p><p>but it reduce the <em>cache-hit-rate</em></p></blockquote><h3 id="gpus">GPUs</h3></div><div class="story post-story"><h2 id="incompressibility">Incompressibility</h2><h3 id="non-iterative-eos-solver">Non Iterative EOS Solver</h3><p><strong>EOS</strong>: Describe the relation between <spanclass="math inline">\(\rho\)</span>, <spanclass="math inline">\(p\)</span>, and <spanclass="math inline">\(T\)</span>(temperature).</p><p>Original:</p><p><span class="math display">\[p = p (\rho , T) = \frac{\mu}{R} \rho T\]</span></p><p>Typically, for water:</p><p><span class="math display">\[\rho = \rho _ 0\]</span></p><p>Pressure penals the violation of the condition.</p><h3 id="non-iterative-eos-solvers-with-splitting">Non Iterative EOSSolvers with Splitting</h3><p>Split the:</p><ol type="1"><li>Pressure Force</li><li>Non-Pressure Force</li></ol><p>because:</p><p><span class="math display">\[\frac { 1 } {\Delta t} (v(t + \Delta t) - v^ * (t) ) = - (1 / \rho ^ * _i) \nabla p _ i\]</span></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> P: <span class="built_in">find</span> neighbours</span><br><span class="line"><span class="keyword">foreach</span> P: compute Non-Pressure forces  -&gt; Advection</span><br><span class="line"><span class="keyword">foreach</span> P: compute Pressure forces.     -&gt; Projection, use data <span class="keyword">from</span> Advection</span><br><span class="line"><span class="keyword">foreach</span> P: update <span class="built_in">velocity</span> &amp; <span class="built_in">position</span></span><br></pre></td></tr></table></figure><h3 id="iterative-eos-solvers-with-splitting">Iterative EOS Solvers withSplitting</h3><p>Alternatively, <em>strong-incompressibility</em>.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foreach</span> P: <span class="built_in">find</span> neighbours</span><br><span class="line"><span class="built_in">foreach</span> P: compute Non-Pressure part.       -&gt; Advection</span><br><span class="line"><span class="keyword">repeat</span> <span class="keyword">until</span> convergence:                   -&gt; Projection(weak)</span><br><span class="line">  <span class="built_in">foreach</span> P: compute density <span class="keyword">and</span> pressure</span><br><span class="line">  <span class="built_in">foreach</span> P: update velocity <span class="keyword">and</span> positions</span><br></pre></td></tr></table></figure><p>e.g.:</p><ol type="1"><li>PCISPH</li><li>LPSPH</li></ol><h3 id="pressure-projection">Pressure Projection</h3><p>Solve a pressure poisson equation(PPE).</p><p><span class="math display">\[\nabla ^ 2 p _ i = \frac {\rho _ 0} {\Delta t} \nabla \cdot v_i\]</span></p><ol type="1"><li>IISPH</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foreach P: find neighbours</span><br><span class="line">foreach P: <span class="built_in">compute</span> Non-Pressure part.       -&gt; Advection</span><br><span class="line">foreach P: <span class="built_in">compute</span> rho*</span><br><span class="line"><span class="built_in">solve</span> PPE                                   -&gt; Projection</span><br><span class="line"><span class="built_in">compute</span> Pressure Force</span><br><span class="line">update v, x</span><br></pre></td></tr></table></figure><blockquote><p>As the overall computation time of all solvers largely depends on theobtained incompressibility, average or maximum density errors areconsidered to specify the simulation quality.</p></blockquote></div><div class="story post-story"><h2 id="incompressibility----extra">Incompressibility -- Extra</h2><p>In (EG 2022): There are only two categories:</p><ol type="1"><li>weak-incompressible: incompressible is not enforced, only a<em>trend</em> is formulated. Pressure indicates incompressible.</li></ol><ul><li>Local Pressure Solver</li></ul><ol start="2" type="1"><li>strong-incompressible: incompressible PPE is solved.</li></ol><ul><li>Global Pressure Solver</li></ul><p>In this sense: target of PCISPH = IISPH = PBF.</p><h3 id="iisph">IISPH</h3><p><span class="math display">\[\Delta t^2 \nabla^2 p_i = \rho^0 - (\rho_i - \Delta t \rho_i\nabla \cdotv_i^{*})\]</span> step 1: compute the pressure accelerations:</p><p><span class="math display">\[(a_i^P)^l = - \frac{1}{\rho_i} \nabla p_i^l\]</span> step 2: compute density change <span class="math display">\[\Delta \rho = \Delta t \sum_j m_j\Delta t(a_i^p - a_j^p)\Delta W_{ij}\]</span> ## Boundary Handling</p><p>Most methods: Extend the field attributes to the boundary.</p><h3 id="particle-based-methods">Particle-based Methods</h3><p>Also sample the particle points on rigid/deformable bodies, computethe penalty force based on distance.</p><blockquote><p>The boundary particles serve as additional sampling points andtypically have the same radius as the fluid particles.</p></blockquote><p><span class="math display">\[\rho_i = \rho_{\mathcal{F}} + \rho_{\mathcal{B}} \approx \sum_j m_jW_{ij} + \sum_k \tilde{m}_k W_{ik}\]</span> when computing the pressure and force, these particles shouldbe considered as well.</p><p><strong>How-to-Sample</strong>:</p><ol type="1"><li>uniform / non-uniform</li><li>single-layer/multi-layer</li></ol><p><strong>Pros</strong>:</p><ol type="1"><li>simplicity: generate, integration, computation</li></ol><p><strong>Cons</strong>:</p><ol type="1"><li>result in small time-steps for weak-incompressible fluids. (pressurevariety is large)</li><li>even simple geometry shape need large amount of particles.</li><li><em>bumpy representation</em>: reduce the accuracy of pressurecomputation, introduce artificial friction. -&gt; Implicit boundaryrepresentation.</li></ol><h3 id="implicit-method">Implicit Method</h3><p>Signed Distance Function.</p><h3 id="computing-the-boundary-pressure">Computing the boundarypressure</h3><p>Original, without boundary:</p><p><span class="math display">\[(a_i^P)^l = - \frac{1}{\rho_i} \nabla p_i^l = - \sum_j m \left(p_i^l/\rho_i^2 + p_j^l/\rho_j^2 \right)\Delta W_{ij}\]</span></p><p>With boundary:</p><p><span class="math display">\[(a_i^P)^l = - \sum_j m_j \left( p_i^l/\rho_i^2 + p_j^l/\rho_j^2\right)\Delta W_{ij} - \sum_k m_k \left( p_i^l/\rho_i^2 + p_k^l/\rho_k^2\right)\Delta W_{ik}\]</span></p><p>To define <span class="math inline">\(p_k\)</span>:</p><ol type="1"><li>Pressure Mirroring: <span class="math inline">\(p_k =p_i\)</span></li><li>Pressure Extrapolation:</li></ol><p><span class="math display">\[p_k = \frac{\sum_l p_lW_{kl}+ \mathbf{g} \cdot \sum_j \rho_l(x_k -x_l)W_{kl}}{\sum_l W_{kl}}\]</span></p><h3 id="penalty-based-methods">Penalty based Methods</h3><p><strong>Cons</strong>: hard to control the stiffness, and have smalltime steps.</p></div><div class="story post-story"><h2 id="other-techniques">Other Techniques</h2><ol type="1"><li>Adaptive time-step</li><li>Data-Driven.</li></ol><h3 id="cnns">CNNs</h3><p>Target: enforce incompressibility</p><p>Steps:</p><ol type="1"><li>Rasterize to Grid.</li><li>use cnn on grid to compute the velocity correction.</li></ol></div><div class="story post-story"><h2 id="future-work">Future work</h2><ol type="1"><li>Approximate Quality:<ol type="1"><li>particle count is low =&gt; degradation of approximation</li><li>lack of practical and sufficient solution: because negative pressureare clamped to 0, only projective Jacobi or GS Iteration is allowed.Conj-Grad is not available currently.</li></ol></li><li>Unified Solver &amp; Ultimate Coupling:<ol type="1"><li>Unified Coupling solver.</li><li>Suitable for multiple particle-resolution.</li></ol></li><li>Artist Control</li><li>Data Driven</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;1106 论文汇报&lt;/p&gt;
&lt;p&gt;SPH Fluids in computer graphic&lt;/p&gt;</summary>
    
    
    
    <category term="Anything" scheme="http://adversarr.github.io/categories/Anything/"/>
    
    
    <category term="Anything" scheme="http://adversarr.github.io/tags/Anything/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Computer Animation 3d.</title>
    <link href="http://adversarr.github.io/2022/10/12/CG/GAMES/games105/lec1/"/>
    <id>http://adversarr.github.io/2022/10/12/CG/GAMES/games105/lec1/</id>
    <published>2022-10-12T01:41:27.011Z</published>
    <updated>2022-11-05T01:25:11.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction-to-computer-animation----in-3d.">Introduction toComputer Animation -- in 3D.</h2><h3 id="what-is-character-animation">What is character animation</h3><ol type="1"><li>Animate Movie</li><li>Virtual Idle... Digital Human...</li></ol><p><strong>Compare with CG</strong>:</p><ul><li>... -&gt; Geometry -&gt; Animation -&gt; Rendering -&gt; ...</li><li>simulation: <strong>Phenomenon</strong></li><li>character animation: <strong>Behaviour</strong></li></ul><p><em>Simulation + Control = Character Animation</em></p><h3 id="why-study-c.a.">Why study C.A.</h3><ol type="1"><li>A character typically has 20+ joints, 50-100+ parameters.<ol type="1"><li>传统：手调参数</li></ol></li><li>角色动画<ol type="1"><li>Understanding the mechanism behind the motions and behaviors</li><li>"Compute Intensive"</li></ol></li></ol><p>A Pipeline :</p><ol type="1"><li>Rigging &amp; skining:绑定、蒙皮</li><li>Skeletal Animation：骨骼动画</li><li>1 + 2 = Animated Character</li></ol><h3 id="where-does-motion-come-frome">where does motion come frome</h3><ol type="1"><li>brain</li><li>muscle</li><li>force</li><li>physics</li><li>body <strong>pose</strong></li></ol><p>Two approach:</p><ol type="1"><li>Key Frame-Based / Kinematic Approach: Ignore the idea, update posedirectly.(Simple)</li><li>Physics-based /dynamic Approach: merge 123, simplified control &amp;physics.</li></ol><p>Two target:</p><ol type="1"><li>Low-Level Control: More details.</li><li>High-Level Goals: focus on target. (e.g. lift up the box)</li></ol><blockquote><p>Disney's 12 priciples.</p></blockquote><div class="story post-story"><h2 id="key-frame-based.">key frame based.</h2><h3 id="two-key-techniques">Two key techniques</h3><p>(Keyframe Animation)</p><ol type="1"><li>forward Kinematics: Given rotations of every joints, computerotations of every joints.</li><li>Inverse Kinematics</li></ol><p>other solution:</p><ol type="1"><li>Motion Capture.</li><li>Motion Retargeting.</li></ol><h3 id="motion-graphs-state-machines-in-game">Motion Graphs / Statemachines (in game)</h3><blockquote><p>2002: Motion Graph</p></blockquote><p>... Motion Matching ...</p><p>在游戏中阻力较大：新技术，区别于状态机。</p><h3 id="learning-based.">Learning Based.</h3><p>Generative Model.</p><ol type="1"><li>Input: Control Signal + Current Pose</li><li>Output: Next Pose</li></ol><p>Iterative.</p><p>e.g. Character Controllers using Motion VAEs.</p></div><div class="story post-story"><h2 id="physics-based">Physics based</h2><ol type="1"><li>force, torque -&gt; simulation</li><li>PD(Proportional Derivative)</li></ol><p>Approaches</p><ol type="1"><li>Keyframe Control</li><li>Spacetime/Trajectory Optimization.</li><li>Abstract Models</li><li>Reinforcement Learning.</li><li>Generative Control Policies.</li></ol></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;introduction-to-computer-animation----in-3d.&quot;&gt;Introduction to
Computer Animation -- in 3D.&lt;/h2&gt;
&lt;h3 id=&quot;what-is-character-animation&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Games 301</title>
    <link href="http://adversarr.github.io/2022/10/07/CG/GAMES/games301/lec1/"/>
    <id>http://adversarr.github.io/2022/10/07/CG/GAMES/games301/lec1/</id>
    <published>2022-10-07T02:26:33.747Z</published>
    <updated>2022-11-05T01:24:04.709Z</updated>
    
    <content type="html"><![CDATA[<p>Games 301-01</p><span id="more"></span><div class="story post-story"><h2 id="曲面参数化">曲面参数化</h2><h3 id="引入">引入</h3><ul><li>几何直观：从三维曲面展开成2d曲面</li><li>数学本质：三维曲面在二维平面的嵌入/映射<ul><li>构建曲面到平面的一一对应</li><li>3d曲面的本质是2d的：2d流形（拓扑同胚）</li></ul></li></ul><h4 id="应用曲面贴图">应用：曲面贴图</h4><ol type="1"><li>纹理、法相、偏置、颜色、材质……</li><li>工业界：uv图</li></ol><h4 id="应用纹理地图texture-atalas">应用：纹理地图（TextureAtalas）</h4><ol type="1"><li>Segmentation &amp; Packing</li></ol><h4 id="应用曲面拟合">应用：曲面拟合</h4><ol type="1"><li>曲线：B样条</li><li>曲面：T样条、NURBS</li></ol><h4 id="应用曲面渲染">应用：曲面渲染</h4><ol type="1"><li>虚拟纹理</li><li>虚拟几何</li><li>mipmap</li><li>LOD</li></ol><p>……</p><h3 id="表达方法">表达方法</h3><ol type="1"><li>基函数 -- 连续函数</li><li>分片映射方法<ol type="1"><li>三角网格</li><li>线性映射拼接</li></ol></li></ol><h4id="参数化的度量什么是最优的参数化">参数化的度量：什么是“最优”的参数化？</h4><p>不同的范数（或度量）下，最优是不同的。</p><h4 id="jacobian-的几何意义">Jacobian 的几何意义</h4><p><span class="math display">\[Jf(\mathbf x)\]</span></p><p>定义了局部的形变量。</p><p>行列式表明面积的变化</p><h4 id="保持xx的映射">保持xx的映射</h4><ol type="1"><li>保角映射 - conformal （共形）</li><li>保面积 - authalic（等积）</li><li>等距</li></ol><p>Theorem： 共形映射总是存在的。</p><p>共形映射</p><ul><li>对数共形因子</li><li>Yamabe 方程 （内蕴高斯曲率）</li></ul><p>等距映射：保持任意两点的测地曲率。</p><ul><li>可展曲面：高斯曲率处处为0<ul><li>只有三种：柱面、锥面、切线面</li></ul></li></ul><h3 id="几何形变-distortion">几何形变 distortion</h3><p>svd on <span class="math inline">\(J\)</span>：</p><ul><li>保角：<span class="math inline">\(\sigma _1 = \sigma_2\)</span></li><li>等积：<span class="math inline">\(\sigma _ 1 \sigma _ 2 =1\)</span></li><li>等距：<span class="math inline">\(\sigma _ 1 = \sigma _ 2 =1\)</span></li></ul><h4 id="locally-bijactive-injective">Locally bijactive = Injective</h4><p>The sufficient condition:</p><p><span class="math display">\[det Jf &gt; 0\quad\forall x\]</span></p><h4 id="global-bijective-v.s.-locally-bijective.">Global Bijective v.s.Locally Bijective.</h4><h4 id="distortion-metric">Distortion Metric</h4><ol type="1"><li>Conformal (2003): <span class="math inline">\(\sigma_2 / \sigma _1\)</span></li><li>MIPS: <span class="math inline">\(\sigma _ 1 / \sigma _ 2 + \sigma _2 / \sigma _1\)</span></li><li>Symm Dirichlet: <span class="math inline">\(\sigma_1^2 + \frac 1{\sigma_1 ^ 2} + \sigma_2 ^ 2 + \frac 1 {\sigma_2 ^ 2}\)</span></li></ol><h3 id="广义参数化和数据降维">广义参数化和数据降维</h3><p>相容性网格：构建曲面的映射（双）</p><p>体参数化(Volumetric Parameterization).</p><p>都属于<strong>几何映射</strong>：Inversion free Geometric mappingconstruction: A Survey (Fu 2021 CVM)</p><p>参数化表达：何为参数？</p><ol type="1"><li>本征维度</li><li>维度估计：高维数据可能存在低维结构。</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Games 301-01&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Useful Links for programming</title>
    <link href="http://adversarr.github.io/2022/10/05/study/ComputerScience/cpp/useful-links/"/>
    <id>http://adversarr.github.io/2022/10/05/study/ComputerScience/cpp/useful-links/</id>
    <published>2022-10-04T16:00:00.000Z</published>
    <updated>2022-11-05T01:25:46.459Z</updated>
    
    <content type="html"><![CDATA[<div class="story post-story"><h2 id="cpp">Cpp</h2><h3 id="c-rvalue-references-explained">C++ Rvalue ReferencesExplained</h3><p><ahref="http://thbecker.net/articles/rvalue_references/section_01.html">http://thbecker.net/articles/rvalue_references/section_01.html</a></p><h3 id="abseil">Abseil</h3><blockquote><p>Abseil provides a number of containers as alternatives to STLcontainers. These containers generally adhere to the properties of STLcontainers, though there are often some associated API differencesand/or implementation details which differ from the standardlibrary.</p></blockquote><ul><li><a href="https://abseil.io/docs/cpp/">Document</a></li><li></li></ul><h3 id="folly">Folly</h3><blockquote><p>Folly (acronymed loosely after Facebook Open Source Library) is alibrary of C++14 components designed with practicality and efficiency inmind. Folly contains a variety of core library components usedextensively at Facebook. In particular, it's often a dependency ofFacebook's other open source C++ efforts and place where those projectscan share code.</p></blockquote><ul><li><a href="https://github.com/facebook/folly">Github</a></li></ul><h3 id="coost">Coost</h3><blockquote><p>coost 是一个兼具性能与易用性的跨平台 C++基础库，其目标是打造一把地表最好用的 C++ 开发神器，让 C++编程变得简单、轻松、愉快。</p><p>coost 原名为 co，后改为cocoyaxi，前者过短，后者过长，取中庸之道，又改为 coost。它曾被称为小型boost 库，与 boost 相比，coost 小而精美，在 linux 与 mac上编译出来的静态库仅 1M 左右大小，却包含了不少强大的功能：</p></blockquote><ul><li><a href="https://coostdocs.github.io/cn/about/co/">Document</a></li><li><a href="https://github.com/idealvin/coost">Github</a></li></ul><h3 id="thrust">Thrust</h3><p>Cuda Algorithm library.</p><h3 id="taskflow.">Taskflow.</h3><p>Alter to oneTBB.</p><ul><li><a href="https://github.com/taskflow/taskflow">link</a></li></ul><h3 id="awesome-parallel-computing">Awesome Parallel Computing</h3><ul><li><ahref="https://github.com/taskflow/awesome-parallel-computing">link</a></li></ul><h3 id="assimp">ASSIMP</h3><p>The official Open-Asset-Importer-Library Repository. Loads 40+3D-file-formats into one unified and clean data structure. (byassimp)</p></div><div class="story post-story"><h2 id="求解器线性代数等">求解器、线性代数等</h2><h3 id="spectra">Spectra</h3><p>Spectra stands for Sparse Eigenvalue Computation Toolkit as aRedesigned ARPACK. It is a C++ library for large scale eigenvalueproblems, built on top of Eigen, an open source linear algebralibrary.</p><p>Spectra is implemented as a header-only C++ library, whose onlydependency, Eigen, is also header-only. Hence Spectra can be easilyembedded in C++ projects that require calculating eigenvalues of largematrices.</p><p>https://github.com/yixuan/spectra/</p></div><div class="story post-story"><h2 id="vulkan">Vulkan</h2><h3 id="vkbootstrap">VkBootstrap</h3><p>As Vulkan is a very explicit API that gives very “direct” control,you need to initialize it to do things such as load extensions, selectwhich GPU (or multiple!) you are going to use, and create the initialVkInstance and VkDevice structures that you then use with Vulkancommands.</p><p>https://github.com/charles-lunarg/vk-bootstrap</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;story post-story&quot;&gt;&lt;h2 id=&quot;cpp&quot;&gt;Cpp&lt;/h2&gt;
&lt;h3 id=&quot;c-rvalue-references-explained&quot;&gt;C++ Rvalue References
Explained&lt;/h3&gt;
&lt;p&gt;&lt;a
href=&quot;</summary>
      
    
    
    
    <category term="Programming" scheme="http://adversarr.github.io/categories/Programming/"/>
    
    
    <category term="C/C++" scheme="http://adversarr.github.io/tags/C-C/"/>
    
    <category term="Programming" scheme="http://adversarr.github.io/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Sig16-Course-The Material Point Method for Simulating Continuum Materials</title>
    <link href="http://adversarr.github.io/2022/10/04/CG/siggraph-courses/siggraph2016-mpm/"/>
    <id>http://adversarr.github.io/2022/10/04/CG/siggraph-courses/siggraph2016-mpm/</id>
    <published>2022-10-03T16:00:00.000Z</published>
    <updated>2022-10-04T05:34:47.574Z</updated>
    
    <content type="html"><![CDATA[<p>orz</p><span id="more"></span><h2id="the-material-point-method-for-simulating-continuum-materials">TheMaterial Point Method for Simulating Continuum Materials</h2><p>Siggraph 2016 Course, by Chenfanfu Jiang.</p><h3 id="introduction">Introduction</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;orz&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graphics" scheme="http://adversarr.github.io/categories/Computer-Graphics/"/>
    
    
    <category term="SIGGRAPH Course" scheme="http://adversarr.github.io/tags/SIGGRAPH-Course/"/>
    
    <category term="MPM" scheme="http://adversarr.github.io/tags/MPM/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-引言</title>
    <link href="http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter-1-Introduction/"/>
    <id>http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter-1-Introduction/</id>
    <published>2022-09-30T01:16:33.354Z</published>
    <updated>2022-09-30T01:43:27.206Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 ch 1 - 引言</p><span id="more"></span><h1 id="chapter-1-introduction">Chapter-1-Introduction</h1><ol type="1"><li><p>绪论</p></li><li><p>非线性方程求根</p></li><li><p>线性方程组的数值解</p></li><li><p>插值和逼近</p></li><li><p>数值积分和数值微分</p></li><li><p>常微分方程的数值解</p></li><li><p>偏微分方程的数值解</p></li></ol><h1 id="绪论">绪论</h1><p>主要内容：</p><ol type="1"><li><p><strong>科学计算的内容</strong>：科学模拟的过程、一般策略</p></li><li><p><strong>误差的概念</strong>：绝对误差、相对误差、向前/向后误差、有效数字及它们之间的关系</p></li><li><p><strong>数据误差对函数值的影响</strong>：讨论函数的误差与自变量误差之间的关系</p></li><li><p><strong>算法的数值稳定性</strong>：讨论初始数据的误差对计算结果的影响</p></li><li><p><strong>实际计算中应该注意的问题</strong></p></li></ol><div class="story post-story"><h2 id="科学计算">科学计算</h2><h3 id="计算模拟解决问题的过程">计算模拟解决问题的过程</h3><ol type="1"><li><p>建立数学模型</p></li><li><p>给出数值算法</p></li><li><p>计算机软件实现算法</p></li><li><p>运行、进行数值模拟</p></li><li><p>表示计算结果</p></li><li><p>解释计算结果</p></li></ol><h3 id="一般策略">一般策略</h3><ol type="1"><li><p>有限维空间代替无限维空间</p></li><li><p>用有限过程代替无限过程</p></li><li><p>用线性方程代替微分方程</p></li><li><p>用低阶方程组代替高阶方程组</p></li><li><p>用简单函数代替复杂函数</p></li><li><p>用简单结构矩阵代替一般矩阵</p></li></ol></div><div class="story post-story"><h2 id="机器数系">机器数系</h2><ol type="1"><li>计算机中的实数（浮点数）<span class="math inline">\(x = \pm \beta^p\times (0.\alpha _ 1\alpha _ 2\cdots)\)</span></li><li>特点：<ol type="1"><li>有限的离散集</li><li>有最大、（非零非负）最小数</li><li>溢出错误（<span class="math inline">\(\infty\)</span> 和 <spanclass="math inline">\(0\)</span>）</li></ol></li><li>计算机对于数的接收</li></ol></div><div class="story post-story"><h2 id="误差的基本概念">误差的基本概念</h2><h3 id="误差的来源">误差的来源</h3><ol type="1"><li><p><strong>模型误差</strong>：对实际情况的简化和近似</p></li><li><p><strong>观测误差</strong>：测量误差等等</p></li><li><p><strong>截断误差</strong>：计算中的无限过程，使用了有限的近似，例如级数求和</p></li><li><p><strong>舍入误差</strong>：四舍五入</p></li></ol><p>例1：<span class="math inline">\(A=4\pi r^2\)</span>中，包含了各种误差</p><p>例2：Taylor 展开：<span class="math inline">\(e^{-x} = 1-x+\frac 12{x^2} -\frac{1}{6}x^3+E_r(x)\)</span> ，其中略去 <spanclass="math inline">\(E_r\)</span> 项，产生了截断误差</p><h3 id="绝对误差">绝对误差</h3><ul><li><strong>绝对误差</strong>：设<spanclass="math inline">\(x^*\)</span>是准确值，<spanclass="math inline">\(x\)</span>是近似值，则：</li></ul><p><span class="math display">\[e(x)=x^*-x\]</span></p><p>为近似值<spanclass="math inline">\(x\)</span>的<strong>绝对误差</strong>，简称<strong>误差</strong>。在实际计算中，绝对误差无法求出，但只需要知道误差的一个范围，从而有<strong>绝对误差限</strong><span class="math inline">\(\varepsilon\)</span>：</p><p><span class="math display">\[|e(x)|\le \varepsilon\]</span></p><h3 id="相对误差">相对误差</h3><p><span class="math display">\[e_r(x)=\frac{x^*-x}{x^*}\]</span></p><p>若 <span class="math inline">\(x^*\)</span> 无法确定，也用：</p><p><span class="math display">\[e_r(x)=\frac{x^*-x}{x}\]</span></p><p>相应的，有相对误差限：</p><p><span class="math display">\[|e_r(x)|\le \varepsilon\]</span></p><h3 id="有效数">有效数</h3><p>若 <span class="math inline">\(x\)</span> 为 <spanclass="math inline">\(x^*\)</span> 的近似值，若 <spanclass="math inline">\(|e(x)|\)</span>是其某个数位的半个单位，从左起第一个非零数到这一位有 n 位，则称 n个数字为其有效数字。</p><p>在实际情况中：n 位有效数字通常表示为：</p><p><span class="math display">\[x = \pm 0.\alpha_1\alpha_2\alpha_3....\times10^{m}\]</span></p><p>则其误差（的绝对值）为：<spanclass="math inline">\(|e(x)|\le\displaystyle \frac 1 2 \times10^{m-n}\)</span>，误差限为：</p><p><span class="math display">\[\varepsilon = \frac 1 2 \times 10^{m-n}\]</span></p><p>例如：<span class="math inline">\(\pi=3.14159.....\)</span>，3.14有3位有效数字，3.1416有5位有效数字，3.1415只有4位有效数字。</p><blockquote><p>对应作业部分：<ahref="https://www.wolai.com/vSwxZPkgTHNmW7WT1uygWa">Week1</a></p></blockquote><h3 id="数据误差和计算误差">数据误差和计算误差</h3><p>→ <span class="math inline">\(x\)</span>表示输入的真值，<spanclass="math inline">\(f(x)\)</span>为所求的真实结果，假设所用的输入值不是精确值，即为<spanclass="math inline">\(\hat x\)</span>，得到的近似值为<spanclass="math inline">\(\hat f\)</span>则：</p><p><span class="math display">\[总误差=(\hat f(\hat x) -f(\hat x)) + (f(\hatx)-f(x))=计算误差+数据传播误差\]</span></p><p>例如：</p><ul><li><span class="math inline">\(\sin x\approx x-\frac 1{3!}x^3\Rightarrow f\approx \hat x\)</span>l</li></ul><h3 id="向前误差和向后误差">向前误差和向后误差</h3><p><span class="math inline">\(x,f\)</span>表示输入值和函数，<spanclass="math inline">\(\hat f\)</span>表示实际计算的函数，<spanclass="math inline">\(x\)</span>表示能精确地得出计算值的输入，则：<spanclass="math inline">\(\hat f(x)=f(\hat x)\)</span></p><p>则：</p><ul><li><p>绝对向前误差：<span class="math inline">\(|\hatf(x)-f(x)|\)</span></p></li><li><p>绝对向后误差：<span class="math inline">\(|\hatx-x|\)</span></p></li></ul><p>条件数：<span class="math inline">\(\displaystyle\frac {|(f(\hat x) -f(x))/f(x)|} { |(\hat x-x)/x|}\)</span>→ 相对误差的放大倍数</p></div><div class="story post-story"><h2 id="数据误差对函数值的影响">数据误差对函数值的影响</h2><p>对于单变量函数而言：</p><p><span class="math display">\[y=f(x)\rightarrow e(y)=y^*-y=f(x^*)-f(x)\]</span></p><p>若使用Taylor展开<span class="math inline">\(e(y)\approxf&#39;(x)(x^*-x)=f&#39;(x)e(x),\quade_r(y)=\frac{xf&#39;(x)}{f(x)}e_r(x)\)</span></p><p>对于多变量函数而言：</p><p><span class="math display">\[\begin{aligned}e(y)&amp;=f(x_1^*,x_2^*)-f(x_1,x_2)\\&amp;\approx \frac{\partial f(x_1,x_2)}{\partialx_1}e(x_1)+\frac{\partial f(x_1,x_2)}{\partial x_2}e(x_2)\\e_r(y)&amp;=e(y)/y\\&amp;\approx\frac{\partial f(x_1,x_2)}{\partialx_1}\frac{x_1}{f(x_1,x_2)}e_r(x_1)+\frac{\partial f(x_1,x_2)}{\partialx_2}\frac{x_2}{f(x_1,x_2)}e(x_2)\end{aligned}\]</span></p><p>和差积商的误差计算方法：</p><ol type="1"><li><p><span class="math inline">\(e(x_1\pm x_2)=e(x_1)\pme(x_2)\)</span></p></li><li><p><span class="math inline">\(e(x_1x_2)=x_2e(x_1)+x_1e(x_2)\)</span></p></li><li><p><span class="math inline">\(e(x_1/x_2)\approx\displaystyle\frac{1}{x_2}e(x_1)-\frac{x_1}{x_2^2}e(x_2)\)</span></p></li></ol></div><div class="story post-story"><h2 id="算法的数值稳定性">算法的数值稳定性</h2><h3 id="数值稳定性">数值稳定性</h3><blockquote><p>对于某一种算法，如果初始数据有很小的误差，仅仅使结果产生很小的误差，则称这个算法时（数值）稳定的，否则称为（数值）不稳定的。</p></blockquote><p>例如：<span class="math inline">\(I_n=\int_0^1\frac {x^n}{x+5}\mathrmdx\)</span></p><ul><li><p><span class="math inline">\(I_n=\frac 1 n -5I_{n-1}\)</span>→<span class="math inline">\(|e_n|=5^n|e_0|\)</span>（误差传播）→不稳定</p></li><li><p><span class="math inline">\(I_{n-1}=\frac 1 5(1/n -I_n)\)</span>利用 <span class="math inline">\(I_{10}\)</span>推算</p></li></ul><h3 id="病态问题ill-posed">病态问题（ill-posed）</h3><blockquote><p>多项式求根时一个病态问题！</p></blockquote></div><div class="story post-story"><h2 id="实际问题中应该注意的问题">实际问题中应该注意的问题</h2><ol type="1"><li><p>避免除数远小于被除数</p></li><li><p>避免两个相近的数详见</p></li><li><p>防止大数“吃”小数</p></li><li><p>简化计算次数，减少计算次数：例如：快速幂算法，多项式计算的秦九韶算法</p></li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 ch 1 - 引言&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-非线性方程求解</title>
    <link href="http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%202%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
    <id>http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%202%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%B1%82%E8%A7%A3/</id>
    <published>2022-09-30T01:16:33.353Z</published>
    <updated>2022-09-30T01:16:33.353Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 ch 2 - 非线性方程求解</p><span id="more"></span><h1 id="chapter-2-非线性方程的求解">Chapter 2 非线性方程的求解</h1><ol type="1"><li><p>一个自变量的非线性方程： <span class="math inline">\(f(x)=0,\quadx\in R&#39;\)</span></p></li><li><p>[NO] 多个自变量的非线性方程组： <span class="math inline">\(\vecF (\vec x) =\vec 0,\quad \vec x\in R^n,\vec F(\vec x)\inR^m\)</span></p></li></ol><hr /><p>Content：</p><ol type="1"><li><p>二分法</p></li><li><p>简单迭代法</p></li><li><p>Newton迭代法</p></li></ol><p>Idea：</p><p><span class="math display">\[线性：f(x)=0\iff x=\varphi(x)\rightarrow x_{n+1}=\varphi(x_n)\\非线性：x=\psi (x)\Rightarrow x_{n+1}:=\psi(x_n),x_n\rightarrow x^*\]</span></p><p>重数：<span class="math inline">\(f(x) =(x-x^*)^mg(x),g(x^*)\ne0\)</span> 则m称为重数</p><p>一般分为如下2步：</p><ol type="1"><li>搜索根，分析方程存在多少个实根，每个根存在的区间</li></ol><p>图解法、近似方程法、解析法、定步长搜索法</p><ol start="2" type="1"><li>精确化：求满足给定精度的根的近似值</li></ol><p>从2项迭代导致的2阶方法。</p><div class="story post-story"><h2 id="二分法">二分法</h2></div><div class="story post-story"><h2 id="简单迭代法">简单迭代法</h2><ol type="1"><li><p>局部收敛（<spanclass="math inline">\(x_0\)</span>与精确解靠近）</p></li><li><p>全局收敛（<spanclass="math inline">\(x_0\)</span>未必与精确解靠近）</p></li></ol><h3 id="迭代格式的构造">迭代格式的构造</h3><p>通过方程 <span class="math inline">\(f(x)=0\)</span> 得到的等价形式：<span class="math inline">\(x=\varphi(x)\)</span>，得到递推公式。</p><p>若根据 <span class="math inline">\(x=\varphi(x)\)</span>得到的序列收敛， <spanclass="math inline">\(\lim_{k\rightarrow\infty}x_k=x^*\)</span>。（当<spanclass="math inline">\(x^*=\varphi(x^*)\)</span>时，称为不动点，上述方法称为不动点迭代法）</p><p>序列是否收敛，由 <span class="math inline">\(\varphi\)</span>和 <spanclass="math inline">\(x_0\)</span>确定。</p><h3 id="迭代的收敛性">迭代的收敛性</h3><p><strong>Thm</strong>若 <spanclass="math inline">\(\varphi(x)\)</span>在 <spanclass="math inline">\((a,b)\)</span>内有一阶连续导数，且满足，</p><ol type="1"><li><p><span class="math inline">\(x\in [a,b]\)</span>时， <spanclass="math inline">\(\varphi(x)\in [a,b]\)</span></p></li><li><p>存在正常数 <span class="math inline">\(L&lt;1\)</span>使得当<span class="math inline">\(x\in[a,b]\)</span>， <spanclass="math inline">\(|\varphi&#39;(x)|\le L &lt;1\)</span></p></li></ol><p>则：</p><ol type="1"><li><p><span class="math inline">\(x=\varphi(x)\)</span>在 <spanclass="math inline">\([a,b]\)</span>上有实根 <spanclass="math inline">\(x^*\)</span></p></li><li><p>对于任意初值 <span class="math inline">\(x_0\in[a,b]\)</span>，迭代收敛→<strong>全局收敛</strong></p></li></ol><p>同时满足：</p><p><span class="math inline">\(|x^*-x_k|\le \frac {L^k}{1-L}|x_1-x_0|\)</span></p><p><strong>Thm</strong> 方程在区间 <spanclass="math inline">\([a,b]\)</span>上有根，且当 <spanclass="math inline">\(x\in [a,b]\)</span>时， <spanclass="math inline">\(|\varphi&#39;(x)|\ge 1\)</span>则对于任意 <spanclass="math inline">\(x_0\)</span>迭代发散。</p><p><strong>Def</strong>（<strong>局部收敛</strong>）方程 <spanclass="math inline">\(x=\varphi(x)\)</span>，若在 <spanclass="math inline">\(x^*\)</span> 的某个邻域内，对于任意初值 <spanclass="math inline">\(x_0\in S\)</span>，迭代都收敛，则称迭代法在 <spanclass="math inline">\(x^*\)</span>附近局部收敛。</p><p><strong>Thm</strong>：若方程 <spanclass="math inline">\(x=\varphi(x)\)</span>有根 <spanclass="math inline">\(x^*\)</span>，在某个邻域内一阶连续可导：</p><ol type="1"><li><p><span class="math inline">\(|\varphi&#39;(x^*)|&lt;1\)</span>→局部收敛</p></li><li><p><spanclass="math inline">\(|\varphi&#39;(x)|&gt;1\)</span>→发散</p></li></ol></div><div class="story post-story"><h2 id="newton-迭代法">Newton 迭代法</h2><h3 id="迭代格式">迭代格式</h3><blockquote><p>基于 <span class="math inline">\(f(x)=0\)</span> 的近似形式</p></blockquote><p><span class="math display">\[x_{k+1}=x_k-\frac{f(x_k)}{f&#39;(x_k)}=\psi(x_k)\]</span></p><p>如果需要计算二重根，Newton迭代法常常不能满足</p><h3 id="newton-迭代法的收敛性">Newton 迭代法的收敛性</h3><p><strong>Thm</strong> 设函数 <spanclass="math inline">\(f\)</span>在区间 <spanclass="math inline">\([a,b]\)</span>内二阶连续可导，且：</p><ol type="1"><li><p><span class="math inline">\(f(a)f(b)&lt;0\)</span></p></li><li><p>当<span class="math inline">\(x\in[a,b]\)</span>时， <spanclass="math inline">\(f&#39;(x)\ne0\)</span></p></li><li><p>当<span class="math inline">\(x\in (a,b)\)</span>时， <spanclass="math inline">\(f&#39;&#39;(x)\)</span>保号</p></li><li><p><span class="math inline">\(a-\frac{f(a)}{f&#39;(a)}\leb,b-\frac{f(b)}{f&#39;(b)}\ge a\)</span></p></li></ol><p>则其Newton迭代格式收敛到 <spanclass="math inline">\([a,b]\)</span>内的唯一实根。</p><h3 id="重根的处理">重根的处理</h3><p>若其是<span class="math inline">\(m\)</span>重根，则修正为：</p><p><span class="math display">\[x_{k+1}=x_k-m\frac{f(x_k)}{f&#39;(x_k)}\]</span></p><h3 id="newton迭代的变形">Newton迭代的变形</h3><ol type="1"><li>Newton下山法：</li></ol><p><spanclass="math inline">\(x_{k+1}=x_k-\lambda\frac{f(x_k)}{f&#39;(x_k)}\)</span></p><ol start="2" type="1"><li>割线法：</li></ol><p><span class="math inline">\(x_{k+1} =x_k-\frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1})\)</span></p><p>......ch2: 5 6 11 12</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 ch 2 - 非线性方程求解&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-线性方程组的数值解</title>
    <link href="http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%203%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3/"/>
    <id>http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%203%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3/</id>
    <published>2022-09-30T01:16:33.353Z</published>
    <updated>2022-09-30T01:16:33.353Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 ch 3 - 线性方程组的数值解</p><span id="more"></span><h1 id="chapter-3-线性方程组的数值解">Chapter 3 线性方程组的数值解</h1><p>Content：</p><ol type="1"><li><p>Gauss 消去法，Gauss列主元消去法</p></li><li><p>向量和矩阵的范数、方程组性态和误差估计</p></li><li><p>Jacobi迭代，Gauss-Seidel迭代格式，收敛性的判别</p></li><li><p>幂法和反幂法</p></li></ol><hr /><p>迭代解法描述：</p><p><span class="math display">\[\begin{aligned}A\vec x=\vec b\iff\vec x&amp;=B\vec x+\vec c\\\vecx_{n+1}&amp;=B\vec x_n+\vec c\\if~x_n~converge,~\vec x_n&amp;\rightarrow \vec x^*\end{aligned}\]</span></p><p>Today's outline:</p><ol type="1"><li><p>解线性方程组的可操作的解法</p></li><li><p>直接法：不考虑舍入误差，通过有限步运算一定能得到<strong>精确解</strong></p></li></ol><p>例如：Kramer's law</p><pre><code>- $A=(\vec a_1, \vec a_2,\cdots)$$A_i = (\vec a_1,\cdots,\vec a_&#123;i-1&#125;,\vec b,\vec a_&#123;i+1&#125;,\cdots,\vec a_n)$$x_i = |A_i|/|A|$</code></pre><ol start="2" type="1"><li><p>消元法：Gauss</p></li><li><p>间接法：通过有限次运算得到近似解→如何刻画</p></li><li><p>矩阵/向量的范数 误差估计</p></li><li><p>迭代法求解（近似解）</p></li><li><p>恒等变形：</p></li></ol><p><span class="math display">\[Ax=b\iff x = Bx+f\]</span></p><ol start="2" type="1"><li>构造迭代序列：（由 <span class="math inline">\(B\)</span>和 <spanclass="math inline">\(x_0\)</span>完全决定）</li></ol><p><span class="math display">\[x_{k+1}=Bx_k+f\]</span></p><ol start="3" type="1"><li>如果序列收敛，则：</li></ol><p><span class="math display">\[x^*=Bx^*+f\]</span></p><ol start="4" type="1"><li><p>对于充分大的<span class="math inline">\(k\)</span>，有 <spanclass="math inline">\(x_k\approx x^*\)</span></p></li><li><p>计算矩阵A的最大（小）特征值</p></li></ol><div class="story post-story"><h2 id="gauss-消元法">Gauss 消元法</h2><blockquote><p>思想：利用线性代数中学过的初等行变换，将方程组化为等价的三角形方程组</p></blockquote><h3 id="三角形方程组的回代法">三角形方程组的回代法</h3><p><span class="math display">\[\begin{aligned}u_{11}x_1+\cdots +u_{1n}x_n=y_1&amp;\\\cdots&amp;\\u_{nn}x_n=y_n&amp;\end{aligned}\]</span></p><p><span class="math display">\[\begin{cases}x_n=y_n/u _{nn}\\x_i = (y_{n-1}-\sum _{j=i+1}^n u_{ij}x_j)/u_{ii}\end{cases}\]</span></p><h3 id="gauss-消去法">Gauss 消去法</h3><ol type="1"><li>将 <span class="math inline">\(Ax=b\)</span>化为增广矩阵：<spanclass="math inline">\(\overline A^{(1)}\)</span></li></ol><blockquote><p>同解变换：非零数乘一个方程两边，互换位置，一个方程乘常数+另一个方程</p></blockquote><ol start="2" type="1"><li>下面用n-1步消元，将<span class="math inline">\(\overlineA^{(1)}\)</span>转化为上三角矩阵</li></ol><p><span class="math inline">\(\bar A^{(1)}\rightarrow \barA^{(2)}\rightarrow\cdots\rightarrow \bar A^{(n)}\)</span></p><ol start="3" type="1"><li>三角形方程组回代</li></ol><p>→<span class="math inline">\(O(n^3)\)</span></p><p><strong>Thm</strong>：（充分条件）若 A的各阶顺序主子式非零，则Gauss消去法中各<strong>主元</strong><spanclass="math inline">\(a_{kk}^{(k)}\)</span>均非零。</p><h3 id="三对角方程组的追赶法">三对角方程组的追赶法</h3><p><span class="math display">\[\left[\begin{matrix}b_1&amp;c_1\\a_2&amp;b_2&amp;c_2\\&amp;a_3&amp;b_3&amp;c_3\\&amp;&amp;&amp;\cdots\end{matrix}\right]x = d\]</span></p><p>且对角占优：<spanclass="math inline">\(|b_i|&gt;|a_i|+|c_i|\)</span></p><p>消元过程如下：</p><p><span class="math inline">\(\beta_1=b_1,y_1=d_1,l_i=\frac {a_i}{\beta _{i-1}},\beta_i=b_i-l_ic_{i-1},y_i=d_i-l_iy_{i-1}\)</span></p><h3 id="列主元gauss消元">列主元Gauss消元</h3><p>→ <span class="math inline">\(|a_{tk}^{(k)}|=\max_{k\le i\len}|a_{ik}^{(k)}|\)</span></p><h3 id="lu分解法">LU分解法</h3><p>Gauss消元→行变换L→<spanclass="math inline">\(L=(L_k^{-1}L_{k-1}^{-1}\cdotsL_1^{-1})\)</span>→<span class="math inline">\(LUx=b\)</span>→<spanclass="math inline">\(Ly=b,Ux=y\)</span></p><p><strong>Thm</strong>A的各阶顺序主子式均不为0，则对A可做唯一的LU分解</p><p><strong>Thm</strong>若A是对称矩阵，且各阶顺序主子式不为0，则A可以做LU分解，且</p><p><span class="math display">\[l_{ik}=\frac {u_{ki}}{u_{kk}}\]</span></p><h2 id="方程组的性态和误差分析-important">方程组的性态和误差分析#IMPORTANT</h2><p>如何刻画一个矩阵A的性态→矩阵的条件数（与矩阵的模有关）</p><h3 id="向量范数">向量范数</h3><p><strong>Def</strong>（范数）一个函数，满足：非负性、齐次性、三角不等式</p><ul><li><p>常用的：</p><ol type="1"><li><p>1-范数</p></li><li><p>∞-范数</p></li><li><p>2-范数←内积</p></li></ol></li></ul><p><strong>Thm</strong>：<strong>有限维空间所有的模都是</strong>等价<strong>的</strong>（<spanclass="math inline">\(\exists c_1,c_2\forall x\in R^n,c_1||x||_p\le||x||_q\le c_2||x||_p\)</span>)</p><blockquote><p>定性描述为：两个范数等价是指在一个范数顶一下的向量，在另一个范数下也小</p></blockquote><p>借助这样的理论：我们研究 两个向量之间的绝对误差和相对误差：</p><blockquote><p>设<span class="math inline">\(x^*\)</span>和<spanclass="math inline">\(\tilde x\)</span>是方程组<spanclass="math inline">\(Ax=b\)</span>的精确解和近似解，则<spanclass="math inline">\(||x^*-\tilde x||, ||x^*-\tilde x||/||\tildex||\)</span>可以表示其误差</p></blockquote><h3 id="矩阵范数">矩阵范数</h3><p>借助向量模定义矩阵模</p><p><strong>Def</strong>（矩阵范数）一个函数，满足</p><ol type="1"><li><p>非负性<span class="math inline">\(||A||\ge0 且||A||=0\iffA=0\)</span></p></li><li><p>齐次性<span class="math inline">\(||\alphaA||=|\alpha|||A||\)</span></p></li><li><p>三角不等式<span class="math inline">\(||A+B||\le||A||+||B||\)</span></p></li><li><p><span class="math inline">\(||AB||\le||A||~||B||\)</span></p></li><li><p>相容性<span class="math inline">\(||Ax||\le||A||~||x||\)</span></p></li></ol><blockquote><p>矩阵的行列式<strong>不可以</strong>作为范数</p></blockquote><p><strong>Def</strong>（向量范数导出的算子范数） 设 <spanclass="math inline">\(||\cdot||\)</span>是一个范数，称<spanclass="math inline">\(\max_{x\in R^n} \frac{||Ax||}{||x||}=\max_{x\inR^n,||x||=1}||Ax||\)</span>为A的向量范数导出的算子范数<spanclass="math inline">\(|||A|||\)</span></p><p><strong>Def</strong>（谱Spectrum半径）设<spanclass="math inline">\(B\in R^{n\times n}\)</span>，<spanclass="math inline">\(\lambda_1,...,\lambda_n\)</span>为特征值，谱半径为：</p><p><span class="math display">\[\rho(B)=\max \{\lambda_i\}\]</span></p><p><strong>Thm</strong>：常用矩阵范数计算</p><ol type="1"><li><p><span class="math inline">\(||A||_1=\max_{1\le j\len}\sum_{i=1}^n\)</span>=最大列绝对值和</p></li><li><p><spanclass="math inline">\(||A||_\infty\)</span>=最大行绝对值和</p></li><li><p><spanclass="math inline">\(||A||_2=\sqrt{\rho(A^TA)}\)</span></p></li><li><p><spanclass="math inline">\(||A|_F=\sqrt{\sum_{i,j=1}^na_{ij}^2}\)</span>→注意！不是算子范数！例如 <span class="math inline">\(||I||\ne1\)</span></p></li></ol><p><strong>Thm</strong>：对于对称矩阵，<spanclass="math inline">\(\rho(A)=||A||_2\)</span></p><p><strong>Thm</strong>：对于<strong>任意</strong>范数<spanclass="math inline">\(\rho(A)\le ||A||\)</span></p><blockquote><p>可用于证明迭代法收敛！</p></blockquote><p><strong>Thm</strong>： <span class="math inline">\(R^{n\timesn}\)</span> 中的任意两个矩阵范数是等价的</p><blockquote><p>【推广】有限维空间中的两个范数是等价的。</p></blockquote><p><strong>Thm</strong>：对于两个矩阵范数，存在常数<spanclass="math inline">\(d_1\)</span>和<spanclass="math inline">\(d_2\)</span>满足：</p><p><span class="math display">\[d_1||A||_p\le ||A||_q\le d_2||A||_p\]</span></p><p><strong>Def</strong>（矩阵之间的距离）<spanclass="math inline">\(||A-B||\)</span></p><p><strong>Def</strong>（矩阵收敛）<spanclass="math inline">\(\lim_{k\rightarrow \infty} ||A^{(k)}-A||=0\iff\lim_{k\rightarrow \infty} A^{(k)}=A\)</span></p><p><strong>Thm</strong>：<span class="math inline">\(\lim_{k\rightarrow\infty} B^k=0\iff \rho(B)&lt;1\)</span></p><p>例如：</p><p><span class="math display">\[\begin{aligned}\frac 1{1-q}&amp;=1+q+q^2+\cdots\\(I-A)^{-1}&amp;=I+A+A^2+\cdots\end{aligned}\]</span></p><h3 id="方程组的性态和条件数">方程组的性态和条件数</h3><blockquote><p>矩阵的行列式可以一定程度上的表示误差大小，而用条件数进行精确刻画。</p></blockquote><ol type="1"><li><p>设<span class="math inline">\(b\)</span>有一个小的扰动<spanclass="math inline">\(\delta b\)</span>，此时解变为<spanclass="math inline">\(x^*+\delta^*\)</span></p></li><li><p>则有<span class="math inline">\(A\delta x^*=\deltab\)</span>，也就是<span class="math inline">\(\delta x^*=A^{-1}\deltab\)</span></p></li><li><p>取范数：</p></li></ol><p><span class="math display">\[\frac{||\delta x^*||}{||x^*||}\le ||A^{-1}||~||A||\frac{||\deltab||}{||b||}\]</span></p><ol type="1"><li><p>设<span class="math inline">\(A\)</span>有微小变化<spanclass="math inline">\(\delta A\)</span></p></li><li><p>则<span class="math inline">\(\delta x^*=-A^{-1} \deltaA(x^*+\delta x^*)\)</span></p></li><li><p>取范数：</p></li></ol><p><span class="math display">\[\frac{||\delta x^*||}{||x^*+\delta x^*||}\le ||A^{-1}||~||A||~\frac{||\delta A||}{||A||}\]</span></p><p><strong>Def</strong>（条件数<span class="math inline">\(\mathrm{cond}A\)</span>）<spanclass="math inline">\(A\)</span>为非奇异矩阵，则称 <spanclass="math inline">\(||A^{-1}||~||A||\)</span>为条件数</p><p><strong>Def</strong>（好的方程组）对于Ax=b而言，若</p><ol type="1"><li><p>A的条件数很大，则为<strong>病态方程组</strong>（误差不一定大）</p></li><li><p>A的条件数很小，则为<strong>良态方程组</strong>（误差一定小）</p></li></ol><p>常用的判断方法：</p><ol type="1"><li><p>列主元Gauss消去法出现绝对值很小的pivot</p></li><li><p>系数矩阵中，某些行（列）近似线性相关</p></li><li><p>系数矩阵元素间，数量级差距很大，且没有一定的规律</p></li></ol><p>一般的解决方案：</p><ol type="1"><li><p>提高计算精度</p></li><li><p><strong>预处理</strong>：选择合理的非奇异矩阵<spanclass="math inline">\(D,C\)</span>，将方程组化为等价的方程组，<spanclass="math inline">\(DAC[C^{-1}]=Db\)</span>且使得<spanclass="math inline">\(\mathrm{cond} DAC\)</span>较小</p></li></ol><p>例如：正则化方法：<span class="math inline">\(Ax=b,|A|\approx0\)</span>→<span class="math inline">\(x=(\alphaI+A^TA)^{-1}A^Tb\)</span></p><h2id="迭代法jacobi迭代gauss-seidel迭代">迭代法（Jacobi迭代，Gauss-Seidel迭代）</h2><h3 id="迭代格式的构造">迭代格式的构造</h3><p>将方程组改写为等价的方程：</p><p><span class="math display">\[x=Bx+f\]</span></p><p>通过该格式进行迭代，若迭代格式对于任意初始向量产生的迭代序列 <spanclass="math inline">\(\{x^{(k)}\}\)</span>都收敛，则<strong>迭代收敛</strong></p><blockquote><p>对于线性方程组而言，迭代收敛只与<spanclass="math inline">\(B\)</span>有关；对于非线性方程组而言，和 <spanclass="math inline">\(B,x\)</span> 都有关。</p></blockquote><h3 id="三种常用的迭代格式">三种常用的迭代格式</h3><h4 id="jacobi迭代法">Jacobi迭代法</h4><p>假设对角线元素都非零，则可以通过该公式得到：</p><p><span class="math display">\[\begin{aligned}x_1 = (b_1-a_{12}x_2-\cdots - a_{1n}x_n)/a_{11}\\\cdots\\x_n = (b_n - a _ {n1} x_1 - \cdots - a_{n,n-1}x_{n-1})/a_{nn}\end{aligned}\]</span></p><p>若将原矩阵进行重写：</p><p>$$ A=L+D+U</p><p>$$</p><ul><li><p><span class="math inline">\(J = -D^{-1}(L+U)\)</span></p></li><li><p><span class="math inline">\(f_J=D^{-1}b\)</span></p></li></ul><h4 id="gauss-seidel迭代">Gauss-Seidel迭代</h4><p>我们用已经求出的 <spanclass="math inline">\(x^{(k)}_{i}\)</span>代入后续所有计算，即为Gauss-Seidel格式：</p><p><span class="math display">\[x^{(k+1)}=D^{-1}(b-Lx^{(k+1)}-Ux^{(k)})\]</span></p><p>最终的迭代格式为：</p><p><span class="math display">\[x^{(k+1)}=Gx^{(k)}+f_G\]</span></p><ul><li><p><span class="math inline">\(G=-(D+L)^{-1}U\)</span></p></li><li><p><span class="math inline">\(f_G=(D+L)^{-1}b\)</span></p></li></ul><h4 id="sor逐次超松弛迭代格式">SOR（逐次超松弛）迭代格式</h4><p><span class="math display">\[x^{(k+1)}=(1-\omega )x^{(k)}+\omega D^{-1}(b-Lx^{(k+1)}-Ux^{(k)})\]</span></p><p><span class="math inline">\(\omega\)</span>称为松弛因子，当 <spanclass="math inline">\(\omega =1\)</span>时，即为Gauss-Seidel迭代。</p><p>最终格式为：</p><p><span class="math display">\[x^{(k+1)}=S_\omega x^{(k)}+f_\omega\]</span></p><ul><li><p><span class="math inline">\(S_\omega =(D+\omegaL)^{-1}[(1-\omega)D-\omega U]\)</span></p></li><li><p><span class="math inline">\(f_\omega =\omega (D+\omegaL)^{-1}b\)</span></p></li></ul><h3 id="迭代格式的收敛性">迭代格式的收敛性</h3><h4 id="迭代法基本定理">迭代法基本定理</h4><p><strong>Thm</strong>：迭代格式 <spanclass="math inline">\(x^{(k+1)}=Bx^{(k)}+f\)</span>收敛的充分必要条件是<span class="math inline">\(\rho(B)&lt;1\)</span></p><p><strong>Thm</strong>：若迭代格式 <spanclass="math inline">\(||B||&lt;1\)</span>，则<spanclass="math inline">\(x^{(k+1)}=Bx^{(k)}+f\)</span>收敛。「<ahref="https://www.wolai.com/4bZTUKfKuKiHhhaEUmhhDC">Thm：对于任意范数(A)||A||</a>」同时：（误差的先验估计和后验估计）</p><ol type="1"><li><p><span class="math inline">\(||x^*-x^{(k+1)}||\le||B||~||x^*-x^{(k)}||\)</span></p></li><li><p><span class="math inline">\(||x^*-x^{(k)}||\le \frac{||B||}{1-||B||} ||x^{(k)} - x^{(k-1)}||\)</span></p></li><li><p><span class="math inline">\(||x^*-x^{(k)}||\le \frac{||B||^k}{1-||B||} ||x^{(1)} - x^{(0)}||\)</span></p></li></ol><h4id="jacobi迭代和gauss-seidel迭代的收敛性">Jacobi迭代和Gauss-Seidel迭代的收敛性</h4><ol type="1"><li><p>Jacobi迭代法收敛<spanclass="math inline">\(\iff\rho(J)&lt;1\)</span></p></li><li><p>Gauss-Seidel迭代法收敛<span class="math inline">\(\iff\rho(G)&lt;1\)</span></p></li></ol><blockquote><p>严格行对角占优： <span class="math inline">\(|a_{ii}|\ge\sum_{j,i\nej}|a_{ij}|\)</span></p></blockquote><blockquote><p>严格列对角占优：<span class="math inline">\(|a_{jj}|\ge\sum_{i,i\nej}|a_{ij}|\)</span></p></blockquote><p><strong>引理</strong> 若A是严格对角占优的，则 <spanclass="math inline">\(|A|\ne0\)</span></p><p><strong>Thm</strong> 如果对于矩阵 <spanclass="math inline">\(Ax=b\)</span>是严格对角占优的，则Jacobi迭代和Gauss-Seidel迭代收敛。</p><h4 id="sor迭代法的收敛性">SOR迭代法的收敛性</h4><p><strong>Thm</strong> SOR迭代收敛的必要条件是 <spanclass="math inline">\(0&lt;\omega&lt;2\)</span></p><p><strong>Thm</strong> 若A对称正定，且 <spanclass="math inline">\(0&lt;\omega&lt;2\)</span>则SOR迭代法收敛</p><blockquote><p><strong>Thm</strong> 若A对称正定，则Gauss-Seidel迭代法收敛</p></blockquote><blockquote><p>Homework ：P124:28 30 32(1,2) 34</p></blockquote></div><div class="story post-story"><h2 id="幂法和反幂法">幂法和反幂法</h2><h3 id="求主特征值的方法">求主特征值的方法</h3><p><strong>Def</strong>（主特征值）若将<spanclass="math inline">\(A\)</span>线性无关的特征向量对应的特征值<spanclass="math inline">\(\lambda_j\)</span>按模大小排列，有<spanclass="math inline">\(\max{|\lambda_j|}=|\lambda_1|\)</span>为主特征值。</p><p><strong>Thm</strong> 幂法：</p><p><span class="math display">\[\begin{cases} u_0=v_0\\v_k=Au_{k-1}\\m_k=\max(v_k)\\u_k=v_k/m_k\end{cases}\]</span></p><p><strong>Thm</strong> 若满足<spanclass="math inline">\(|\lambda_1|&gt;|\lambda_2|\ge\cdots\)</span>，则通过幂法得到的序列有如下极限：</p><p><span class="math display">\[\begin{cases} m_k\rightarrow \lambda_1\\u_k\rightarrow \frac{x_1}{\maxx_1} \end{cases}\]</span></p><h3 id="反幂法">反幂法</h3><p>求最小特征值：用<span class="math inline">\(A^{-1}\)</span>代替<spanclass="math inline">\(A\)</span>计算</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 ch 3 - 线性方程组的数值解&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-数值积分和数值微分</title>
    <link href="http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%205%20%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E5%92%8C%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/"/>
    <id>http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%205%20%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E5%92%8C%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/</id>
    <published>2022-09-30T01:16:33.353Z</published>
    <updated>2022-09-30T01:16:33.353Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 ch 5 - 数值积分和数值微分</p><span id="more"></span><h1 id="chapter-5-数值积分和数值微分">Chapter 5 数值积分和数值微分</h1><ol type="1"><li><p>插值型求积公式</p></li><li><p>复化求积公式</p></li><li><p>Romberg求积法</p></li><li><p>Gauss求积公式</p></li><li><p>数值微分</p></li></ol><hr /><div class="story post-story"><h2 id="数值积分的基本概念">数值积分的基本概念</h2><p><span class="math display">\[\int_{a}^bf(x) \mathrm dx\approx \sum_{k=0}^n A_k f(x_k\]</span></p><p>其中：</p><ol type="1"><li><p><span class="math inline">\(x_k\)</span>称为插值节点</p></li><li><p><span class="math inline">\(A_k\)</span>为求积系数</p></li></ol></div><div class="story post-story"><h2 id="插值型求积公式">插值型求积公式</h2><p>记 <span class="math inline">\(I(f) = \int_a^bf(x)\mathrmdx\)</span>，则<span class="math inline">\(f\)</span>的一个插值多项式为<span class="math inline">\(L_n(x)\)</span>，其中 <spanclass="math inline">\(l_k(x)\)</span> 是插值基函数。则用 <spanclass="math inline">\(L_n(x)\)</span> 替代被积函数，一个求积公式为：</p><p><span class="math display">\[I_n(f) = \sum_k A_kf(x_k)\\A_k = \int _a^b l_k(x)\mathrm dx\]</span></p><h3 id="插值型求积公式-1">插值型求积公式</h3><dl><dt>插值型求积公式</dt><dd>设有计算<span class="math inline">\(I(f)\)</span>的求积公式</dd></dl><p><span class="math display">\[I _ n(f)=\sum _ {k=0}^nA _ k f(x _ k)\]</span></p><p>若其求积系数<span class="math inline">\(A _ k=\int _ a ^ bl _ k(x)\mathrm dx\)</span>，则称该求积公式为插值型求积公式。</p><p>截断误差为：</p><p><span class="math display">\[R(f) = \int_a^b \frac{f^{(n+1)}(x_0)}{(n+1)!} \prod_k(x-x_k)\mathrm dx\]</span></p><dl><dt>Newton-Cotes公式</dt><dd>若求积节点是等间距的，即 <span class="math inline">\(x_k =a+kh\)</span>，则该插值型求积公式称为 Newton-Cotes 公式。</dd></dl><p>记： <span class="math display">\[C_{n,k} = \frac{(-1)^{n-k} h}{k!(n-k)!} \int _ {0} ^ n\prod _ {j=0\\j\nek}^n(t-j)\mathrm dt\]</span> N-C公式可转化为： <span class="math display">\[I _ n(f) = \sum _ {k=0} ^ n C _{n, k} f(x_k)\]</span> 常用的三种插值求积公式：</p><ol type="1"><li>梯形公式：<span class="math inline">\(T(f) = \frac{b-a} 2 [f(a) +f(b)]\)</span></li><li>Simpson公式：<span class="math inline">\(S(f) =\frac{b-a}{6}[f(a)+4f(\frac{a+b} 2)] + f(b)]\)</span></li><li>Cotes公式：<span class="math inline">\(C(f) = \frac{b-a}{90} [7f(a)+32f(\frac{3a+b} 4) + 12 f(\frac{a+b} 2) +32f(\frac{a+3b}4)+7f(b)]\)</span></li></ol><h3 id="代数精度">代数精度</h3><p>当<span class="math inline">\(f(x)\)</span>为多项式时，考虑截断误差：<span class="math display">\[R(f) = \int _ a ^ b \frac{f^{(n+1)}(\xi)}{(n+1)!} \prod _ {k=0} ^ n (x-x_ k) \mathrm dx = 0\]</span> 则 <span class="math inline">\(I _ n(f) =I(f)\)</span>，求积公式是精确的</p><dl><dt>代数精度</dt><dd>计算 <span class="math inline">\(I_n(f)\)</span>的求积公式，若对于所有<spanclass="math inline">\(m\)</span>次多项式是精确的，但至少对一个<spanclass="math inline">\((m+1)\)</span>次数的多项式是不精确的，则称该求积公式具有<spanclass="math inline">\(m\)</span>次代数精度。</dd></dl><p class='p blue'>Theorem</p><p>求积公式 <span class="math inline">\(I_n(f)\)</span> 至少有<spanclass="math inline">\(n\)</span>次代数精度的充分必要条件是该公式是插值型的。</p><p class='p blue'>Theorem</p><p>求积公式 <span class="math inline">\(I_n(f)\)</span> 至少有<spanclass="math inline">\(m\)</span>次代数精度的充分必要条件是该公式对<spanclass="math inline">\(f(x)=x^i,~i=0, 1,...,m\)</span>都精确成立，但对<spanclass="math inline">\(f(x)=x^{m+1}\)</span>不精确成立</p><p>常用三种插值求积公式的代数精度：</p><ol type="1"><li>梯形公式：截断误差为<span class="math inline">\(-\frac{(b-a)^3}{12}f&#39;&#39;(\eta)\)</span>，代数精度为 1</li><li>Simpson公式：截断误差为<spanclass="math inline">\(-\frac{(b-a)^5}{2880}f^{(4)}(\eta)\)</span>，代数精度为3</li><li>Cotes公式：代数精度为5</li></ol><h3id="梯形公式simpson公式和cotes公式的截断误差">梯形公式、Simpson公式和Cotes公式的截断误差</h3><p><span class="math display">\[R_T(f) = -\frac{(b-a)^3}{12}f&#39;&#39;(\eta),\quad \eta\in (a,b)\]</span></p><p><span class="math display">\[R_S(f) = -\frac{(b-a)^4}{2880}f^{(4)}(\eta),\quad\eta\in (a,b)\]</span></p><p><span class="math display">\[R_C(f) = -\frac{2(b-a)}{945}(\frac{(b-a)}4)^6f^{(6)}(\eta),\quad\eta\in(a,b)\]</span></p></div><div class="story post-story"><h2 id="复化求积公式">复化求积公式</h2><h3 id="复化梯形求积公式">复化梯形求积公式</h3><p>对每个小区间上的积分 <span class="math inline">\(\int _ {x _ k} ^{x _{k+1} }f(x)\mathrm dx\)</span> 都应用梯形公式： <spanclass="math display">\[T _ n(f) = \sum _ {k=0}^{n-1} \frac h 2 [f(x _ k) + f(x _ { k + 1 })]\]</span> 截断误差为： <span class="math display">\[I(f) - T_n (f) = - \frac {h^3} {12} \sum _ {k = 0} ^{ n - 1}f&#39;&#39;(\eta _ k )\]</span> 其<strong>先验误差估计</strong>为： <spanclass="math display">\[I(f) - T _ n (f) = \frac{b - a} {12} h^ 2|f&#39;&#39;(\eta) | \le\frac{b - a} {12} M_2 h^2\le \varepsilon\\M_2=\max_{a\le x \le b} |f&#39;&#39;(x)||\]</span> 其<strong>后验误差估计</strong>为： <spanclass="math display">\[|I(f) - T _ {2n} (f) | \approx \frac 1 3 |T _ {2n} - T _ n (f)|&lt;\varepsilon\]</span></p><h3 id="复化simpson公式">复化Simpson公式</h3><p>对每个小区间上的积分 <span class="math inline">\(\int _ {x _ k} ^{x _{k+1} }f(x)\mathrm dx\)</span> 都应用Simpson公式： <spanclass="math display">\[S _ n(f) = \sum _ {h=0} ^ { n - 1} \frac h 6 [f(x _ k) + 4 f(x _ {k +1/2}) + f( x _ {k+1})]\\x _ {k + 1/ 2} = \frac 1 2(x_k + x _ { k + 1})\]</span> 其截断误差为：<spanclass="math inline">\(-\frac{b-a}{180}(\frac{h}2)^4\sum_{k = 0} ^ {n-1}f^{(4)}(\eta_k)\)</span></p><p>先验误差估计为：</p><p><span class="math display">\[I(f) - S_n(f) = - \frac{b-a}{180}\left( \frac h 2 \right)^4f^{(4)}(\eta)\\|I(f) - S_n (f)| \le \varepsilon\]</span></p><p>后验误差估计为：</p><p><span class="math display">\[I(f) - S_{2n}(f) \approx \frac 1 {15} (S_{2n}(f) - S_n (f))\\|I(f) - S _ {2n} (f)|\approx \frac 1 {15} |S_{2n}(f) - S_j(f)|\]</span></p><h3 id="复化-cotes-公式">复化 Cotes 公式</h3><p>记</p><p><span class="math display">\[x_{k+\frac14} = x_k +\frac14 h,\quad  x_{k+\frac12}= x_k + \frac 12h,\quad \cdots\]</span></p><p>对于积分<span class="math inline">\(\int_{x_k} ^{x_{k+1}}f(x)\mathrmdx\)</span>应用Cotes公式，得到复化Cotes公式</p><p><span class="math display">\[C_n(f) = \sum_{k=0}^{n-1} \frac h{90}[7f(x_k) + 32 f(x_{k+\frac 14}) +12 f(x_{k+\frac12}) + 32 f(x_{k+\frac34}) + 7f(x_{k+1})]\]</span></p><p>其截断误差为</p><p><span class="math display">\[I(f) - C_n(f) = -\frac{2(b-a)}{945}\left( \frac h2\right)^6f^{(6)}(\eta), \quad \eta\in (a,b)\]</span></p><p>后验误差估计为：</p><p><span class="math display">\[I(f) - C_{2n}(f)\approx \frac1{63} [C_{2n}(f) - C_n(f)]\]</span></p><h3 id="求积公式的阶数">求积公式的阶数</h3><dl><dt>求积公式的阶数</dt><dd>如果计算积分<span class="math inline">\(I(f)\)</span>的复化求积公式<spanclass="math inline">\(I_n(f)\)</span>，存在正整数<spanclass="math inline">\(p\)</span>和非零常数<spanclass="math inline">\(C\)</span>使得： <span class="math display">\[\lim_{h\rightarrow 0} \frac{I(f)-I_n(f)}{h^p} = C\]</span> 则称公式<span class="math inline">\(I_n(f)\)</span>是<spanclass="math inline">\(p\)</span>阶的。</dd></dl><p class='p blue'>Theorem 复化公式的阶数</p><ol type="1"><li>复化梯形公式 —— 2阶</li><li>复化Simpson公式 —— 4阶</li><li>复化Cotes公式 —— 6阶</li></ol></div><div class="story post-story"><h2 id="romberg-积分法">Romberg 积分法</h2><p>注意到：</p><p><span class="math display">\[I(f) \approx \frac 43 T_{2n}(f) - \frac13 T_n(f)\]</span></p><p>实际上：</p><p><span class="math display">\[S_n(f) = \frac43 T_{2n}(f) - \frac13 T_n(f)\]</span></p><p><span class="math display">\[C_n(f) = \frac{16}{15} S_{2n}(f) - \frac 1{15} S_n(f)\]</span></p><p>则：</p><dl><dt>Romberg公式</dt><dd>称</dd></dl><p><span class="math display">\[R_n(f) = \frac{64}{63} C_{2n}(f) - \frac{1}{63}C_n(f)\]</span></p><p>为Romberg公式，且其具有7次代数精度。</p><p>Romberg求积法可以通过列表计算</p><table><thead><tr class="header"><th>n</th><th>T</th><th>S</th><th>C</th><th>R</th></tr></thead><tbody><tr class="odd"><td>1</td><td><span class="math inline">\(T_1\)</span></td><td><span class="math inline">\(S_1\)</span></td><td><span class="math inline">\(C_1\)</span></td><td><span class="math inline">\(R_1\)</span></td></tr><tr class="even"><td>2</td><td><span class="math inline">\(T_2\)</span></td><td><span class="math inline">\(S_2\)</span></td><td><span class="math inline">\(C_2\)</span></td><td><span class="math inline">\(R_2\)</span></td></tr><tr class="odd"><td>4</td><td><span class="math inline">\(T_4\)</span></td><td><span class="math inline">\(S_4\)</span></td><td><span class="math inline">\(C_4\)</span></td><td><span class="math inline">\(R_4\)</span></td></tr><tr class="even"><td>8</td><td><span class="math inline">\(T_8\)</span></td><td><span class="math inline">\(S_8\)</span></td><td><span class="math inline">\(C_8\)</span></td><td><span class="math inline">\(R_8\)</span></td></tr><tr class="odd"><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table><p>每一次选择一个n，向右上方计算。</p></div><div class="story post-story"><h2 id="gauss求积公式">Gauss求积公式</h2><dl><dt>Gauss-Legendre 公式</dt><dd>设 <span class="math inline">\(I_n(f)\)</span> 是求积分<spanclass="math inline">\(I(f)\)</span>的求积公式，其代数精度为<spanclass="math inline">\((2n+1)\)</span>则称其为 <strong>Gauss-Legendre公式</strong>，对应的节点为<strong>Gauss点</strong>。</dd></dl><p class='p blue'>Theorem</p><p>若有插值型求积公式 <span class="math inline">\(I_n(f)\)</span>，<spanclass="math inline">\(I_n(f)\)</span>是Gauss求积公式 当且仅当 <spanclass="math inline">\(W_{n+1}(x)\)</span> 和让任何一个次数不超过 <spanclass="math inline">\(n\)</span> 的多项式正交。</p><h3 id="正交多项式">正交多项式</h3><dl><dt>正交多项式序列</dt><dd>设 <span class="math inline">\(g_n(x) = a_{n,0} x^n +a_{n,1}x^{n-1}+\cdots + a_{n,n}\)</span> 对于任意 <spanclass="math inline">\(i,j\)</span> 有 <span class="math inline">\((g_i,g_j)=0\)</span> 则称 <span class="math inline">\(\{g_ k(x)\}_{k=0}^\infty\)</span> 是<spanclass="math inline">\([a,b]\)</span>上的<strong>正交多项式序列</strong>。</dd></dl><p class='p blue'>Theorem</p><p>正交多项式序列是线性无关的</p><p class='p blue'>Theorem</p><p>正交多项式序列中<span class="math inline">\(g_n(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上有<spanclass="math inline">\(n\)</span>个零点</p><dl><dt>n次Legendre多项式</dt><dd>称</dd></dl><p><span class="math display">\[P_n(t) = \frac 1 {2^nn!} \frac{\mathrm d^n(t^2-1)^n}{\mathrm dt^n},\quadn = 0,1,2,\cdots\]</span></p><p>为Legendre多项式</p><p class='p blue'>Theorem Lerandre多项式</p><p><span class="math inline">\(\{P_k(t)\}\)</span> 在 <spanclass="math inline">\([-1,1]\)</span> 上正交。</p><h3 id="区间--1-1-上的gauss公式">区间 [-1, 1] 上的Gauss公式</h3><p><span class="math inline">\(n+1\)</span> 次Legendre多项式的零点就是Gauss公式的节点，求积系数为：</p><p><span class="math display">\[\tilde A_k = \int _{-1} ^1 \prod_{j=0,j\ne k} ^n\frac{t-t_j}{t_k-t_j}\mathrm dt\]</span></p><h3 id="区间-a-b-上的gauss公式">区间 [a, b] 上的Gauss公式</h3><p>转化为 <span class="math inline">\([-1,1]\)</span>的Gauss公式求解。</p><h3 id="gauss-公式的截断误差">Gauss 公式的截断误差</h3><p>截断误差为：</p><p><span class="math display">\[R(f) = \frac{f^{(2n+2)}(\xi)}{(2n+2)!}\int_a^b W_{n+1}^2(x)\mathrm dx\]</span></p><h3 id="gauss-公式的稳定性和收敛性">Gauss 公式的稳定性和收敛性</h3><p class='p blue'>Theorem</p><p>Gauss公式的求积系数都是正的</p><dl><dt>求积公式的稳定性</dt><dd>若对于任意 <span class="math inline">\(\varepsilon&gt;0\)</span> 存在<span class="math inline">\(\delta &gt; 0\)</span> 当 <spanclass="math inline">\(\max_{0\le k \le n}|f(x_k) - \tilde f_k| &lt;\delta\)</span> 时， 有<span class="math inline">\(|I_n(f) -I_n(\tilde{f})|&lt;\varepsilon\)</span> 则该公式是稳定的。</dd></dl><p class='p blue'>Theorem</p><p>Gauss公式是稳定的</p><dl><dt>求积公式的收敛性</dt><dd>若对于任意 <span class="math inline">\(\varepsilon&gt;0\)</span>存在<span class="math inline">\(N\)</span>，当<spanclass="math inline">\(n&gt;N\)</span>时，有<spanclass="math inline">\(|I(f) -I_n(f)|&lt;\varepsilon\)</span>则称该求积公式收敛。</dd></dl><p class='p blue'>Theorem Gauss公式的收敛性</p><p>若 <span class="math inline">\(f\in C[a,b]\)</span> 则Gauss公式收敛。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 ch 5 - 数值积分和数值微分&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-多项式插值和函数最佳逼近</title>
    <link href="http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%204%20%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%80%E4%BD%B3%E9%80%BC%E8%BF%91/"/>
    <id>http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%204%20%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%80%E4%BD%B3%E9%80%BC%E8%BF%91/</id>
    <published>2022-09-30T01:16:33.353Z</published>
    <updated>2022-09-30T01:16:33.353Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 ch 4 多项式插值和函数最佳逼近</p><span id="more"></span><h1 id="chapter-4-多项式插值和函数最佳逼近">Chapter 4多项式插值和函数最佳逼近</h1><ol type="1"><li>给定一个函数： <spanclass="math inline">\(f(x)\in[a,b]\)</span></li></ol><p>在离散点处的值，能否给出一个近似？</p><div class="story post-story"><h2 id="函数近似和函数逼近">函数近似和函数逼近</h2><h3 id="函数近似表示可能性">函数近似表示：可能性</h3><p><strong>Def</strong>（插值函数）设函数 <spanclass="math inline">\(y=f(x)\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上有定义，且已知在<spanclass="math inline">\(a\le x_0&lt;\cdots&lt;x_n\leb\)</span>上的值，若存在一个简单函数<spanclass="math inline">\(P(x)\)</span>使</p><p><span class="math display">\[P(x_i)=f(x_i)\quad (i=0,1,\dots,n)\]</span></p><p>成立，则称<span class="math inline">\(P(x)\)</span>为<spanclass="math inline">\(f(x)\)</span>的<strong>插值函数</strong>，上式称为<strong>插值条件</strong>，点<spanclass="math inline">\(x_0,x_1,\dots,x_n\)</span>称为插值节点，<spanclass="math inline">\([a,b]\)</span>称为<strong>插值区间</strong>。求<spanclass="math inline">\(P(x)\)</span>的方法称为差值法。</p><p><strong>Thm</strong>（存在n次多项式插值）满足插值条件的n次多项式<spanclass="math inline">\(p_n(x)\)</span>存在且唯一。</p><blockquote><p>存在性：可以构造出Lagrange表示 唯一性：代数基本定理</p></blockquote><p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存在性：</span><br><span class="line"><span class="bullet">-</span> 构造范德蒙矩阵</span><br><span class="line"><span class="bullet">-</span> 范德蒙矩阵的行列式 |X| ≠ 0</span><br></pre></td></tr></table></figure></p><p>范德蒙行列式：</p><p><span class="math display">\[|X| = \prod_{0\le i&lt;j\le n} (x_i-x_j)\]</span></p><h3 id="基本插值多项式">基本插值<strong>多项式</strong></h3><p>求n次多项<span class="math inline">\(l_k(x)\)</span>满足：</p><p><span class="math display">\[l_k(x_j)= \mathbb 1_{j=k}\]</span></p><p>由条件4知道<spanclass="math inline">\(x_0,x_1...,x_{k-1},x_{k+1},...,x_n\)</span>是<spanclass="math inline">\(l_k(x)\)</span>的零点。所以<spanclass="math inline">\(l_k(x)\)</span>有n个因子：<spanclass="math inline">\(x-x_0,...x-x_{k-1},...,x_{k+1},...,x-x_n\)</span>，所以</p><p><span class="math display">\[l_k=A_k \prod _{i\ne k} (x-x_i)\]</span></p><p>其中：</p><p><span class="math display">\[A_k=\cfrac{1}{\prod_{i\ne k}(x_i-x_k)}\]</span></p><p>则<span class="math inline">\(l_k(x)\)</span>称为n次（第<spanclass="math inline">\(k\)</span>个）<strong>基本插值多项式</strong>（也就是<strong>Lagrange插值基函数</strong>）</p><h3 id="lagrange插值多项式">Lagrange插值多项式</h3><p><strong>Thm</strong>：设<span class="math inline">\(x_0, x_1,\cdots,x_n\)</span>是互异节点，则存在唯一的次数不超过<spanclass="math inline">\(n\)</span>次的多项式<spanclass="math inline">\(L_n(x)\)</span>，使得<spanclass="math inline">\(L_n(x_i)=f(x_i)\)</span></p><p>用Lagrange（选择<spanclass="math inline">\(l_k(x)\)</span>为基函数），组合后的系数即为<spanclass="math inline">\(f(x_i)\)</span>：</p><p><span class="math display">\[L_n(x)=\sum_{k=0}^nf(x_k)l_k(x)=\sum _{k=0} ^ nf(x_k)\prod_{i\nek,i=0}\frac{x-x_i}{x_k-x_i}\]</span></p><p>称为<strong>n次Lagrange插值多项式</strong></p><h3 id="插值余项和误差估计">插值余项和误差估计</h3><p><strong>Def</strong>（余项）<spanclass="math inline">\(R_n(x)=f(x)-L_n(x)\)</span>为插值多项式的<strong>余项</strong>（一般的为<spanclass="math inline">\(R_n(x)=f(x)-p_n(x)\)</span>）</p><p><strong>Thm</strong>：设<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\((a,b)\)</span>内有<spanclass="math inline">\(f^{(n+1)}(x)\)</span>存在，<spanclass="math inline">\(L_n(x)\)</span>为Lagrange插值多项式，则对于任意<spanclass="math inline">\(x\in [a,b]\)</span>，<spanclass="math inline">\(\exists \xi\in (a,b),s.t.R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}W_{n+1}(x)\)</span>，其中<spanclass="math inline">\(W_{n+1} (x) = \prod_{i=0}^n(x-x_i)\)</span></p><p>注：</p><ol type="1"><li><p><span class="math inline">\(\xi\)</span>依赖于<spanclass="math inline">\(x\)</span></p></li><li><p>一般不能求出，只能估计误差</p></li></ol></div><div class="story post-story"><h2 id="差商和牛顿插值">差商和牛顿插值</h2><p>Lagrange插值的缺点：节点增加或减少时，所有插值基函数的系数都可能变化（计算不变）</p><p>设<span class="math inline">\(L_{k}(x)\)</span>时以<spanclass="math inline">\(x_0,x_1,...,x_{k}\)</span>为插值节点的多项式，考察<spanclass="math inline">\(L_k\)</span>和<spanclass="math inline">\(L_{k-1}\)</span>的关系：</p><p><span class="math display">\[let\quad g(x)=L_k(x) - L_{k-1} (x)\]</span></p><p>从而：<span class="math inline">\(g\)</span>时一个次数不超过<spanclass="math inline">\(k\)</span>的多项式，也就是说，<spanclass="math inline">\(L\)</span>可以写成</p><p><span class="math display">\[L_k(x) = a_0+a_1(x-x_0) + \cdots + a_k(x-x_0)(x-x_1)\cdots(x-x_{k-1})\]</span></p><p>求出 <span class="math inline">\(a_k\)</span>：</p><p><span class="math display">\[a_k = \sum_{m=0}^k\frac{f(x_m)}{\prod\limits_{i\ne m,i=0}^k(x-x_i)}\]</span></p><h3 id="差商和newton插值公式">差商和Newton插值公式</h3><p><strong>Def</strong>：设已知函数<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(n+1\)</span>个互异节点上的值为<spanclass="math inline">\(f(x_0),...,f(x_n)\)</span>称：</p><p><span class="math display">\[f[x_i,x_j] =\frac{f(x_j)-f(x_i)}{x_j-x_i}\]</span></p><p>为节点<spanclass="math inline">\(x_i,x_j\)</span>的一阶差商，其一阶差商的差商：</p><p><span class="math display">\[f[x_i,x_j,x_k]=\frac{f[x_j,x_k] - f[x_i,x_j]}{x_k-x_i}\]</span></p><p>为二阶差商，以此类推。约定零阶差商为函数值。</p><p><strong>Thm</strong>：k阶差商可以表示成<spanclass="math inline">\(f(x_0),f(x_1),...,f(x_k)\)</span>的线性组合。</p><p><span class="math display">\[f[x_0,x_1,\cdots,x_k] = \sum_{m=0}^k \frac{f(x_m)}{\prod_{i=0,i\nem}^k(x_m-x_i)} =a_k\]</span></p><p>则：</p><p><span class="math display">\[L_n(x) = f(x_0) + f[x_0,x_1](x-x_0) +...+f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1})\]</span></p><p><strong>Thm</strong>：k阶差商与节点的次序无关。</p><p><strong>Thm</strong>：k阶差商和k阶导数有如下关系<spanclass="math inline">\(f[x_0,...,x_k]=\frac{f^{(k)}(\eta)}{k!}\quad \eta\in (\min\{x_0,...,x_k\}, \max\{x_0,...,x_k\} )\)</span></p><h3id="差分和等距节点的newton插值多项式">差分和等距节点的Newton插值多项式</h3><p><strong>Def</strong>：若已知函数<spanclass="math inline">\(f(x)\)</span>在等距节点<spanclass="math inline">\(x_i\)</span>上的函数值为<spanclass="math inline">\(f(x_i) = f_i(i = 0, 1, ...,n)\)</span>则称 <spanclass="math inline">\(f_{i+1} - f_i\)</span>为<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_i\)</span>处以<spanclass="math inline">\(h\)</span>为步长的1阶<strong>向前</strong>差分<spanclass="math inline">\(\Delta f_i\)</span>。<spanclass="math inline">\(\Delta^k f_i = \Delta^{k-1} f_{i+1} -\Delta^{k-1}f_{i}\)</span>为k阶差分。</p><p>可以证明，差分和差商有如下关系 ：</p><p><span class="math display">\[f[x_i,x_{i+1},\cdots,x_{i+k}]=\frac{\Delta^k f_i}{k!h^k}\]</span></p><p>从而可以得到Newton插值多项式：</p>$$<span class="math display">\[\begin{aligned}N_n(x)&amp;=\sum_{k=0}^n f[x_0, x_1,\cdots,x_k]\prod_{j=0}^{k-1}(x-x_j)\\N_n(x_0+th)&amp;=\sum_{k=0}^n \frac{\Delta^kf_0}{k!} \prod_{j=0}^{k-1}(t-j)\end{aligned}\]</span><p>$$</p><p>第二个式子称为n次Newton前插公式。</p></div><div class="story post-story"><h2 id="高次插值的缺点分段低次插值">高次插值的缺点、分段低次插值</h2><h3 id="埃尔米特插值hermite">埃尔米特插值(Hermite)</h3><p><strong>Def</strong>：给定<spanclass="math inline">\([a,b]\)</span>中的<spanclass="math inline">\(n+1\)</span>个互异的节点及其函数值和直到<spanclass="math inline">\(m_i\)</span>阶导数<spanclass="math inline">\(f(x_i),f&#39;(x_i),...,f^{(m_i)}(x_i)\)</span>，令<spanclass="math inline">\(m=\sum_{i=0}^n(m_i+1)-1\)</span>若存在一个次数不超过<spanclass="math inline">\(m\)</span>次的多项式<spanclass="math inline">\(H_m(x)\)</span>，满足所有条件，则称<spanclass="math inline">\(H_m(x)\)</span>为<spanclass="math inline">\(f(x)\)</span>的<spanclass="math inline">\(m\)</span>次Hermite插值多项式。</p><p><strong>Thm</strong>：满足该插值条件的<spanclass="math inline">\(m\)</span>次多项式<spanclass="math inline">\(H_m(x)\)</span>是存在且唯一的。</p><p><strong>Thm</strong>：设<spanclass="math inline">\(H_m(x)\)</span>是满足条件的m次插值多项式，<spanclass="math inline">\(f(x)\)</span>在包含<spanclass="math inline">\(n+1\)</span>个互异节点<spanclass="math inline">\(x_0,x_1,\dots,x_n\)</span>的区间<spanclass="math inline">\([a,b]\)</span>上有m阶连续导数，且在<spanclass="math inline">\((a,b)\)</span>上有<spanclass="math inline">\(m+1\)</span>阶导数，则对于其中每一个点，一定存在<spanclass="math inline">\(\xi\)</span>使得：</p><p><span class="math display">\[R_m(x) = \frac{f^{(m+1)}(\xi)}{(m+1)!}\prod _{i=0}^n (x-x_i)^{m_i+1}\]</span></p><p><strong>Thm</strong>：（Hermite-Gennochi）若 <spanclass="math inline">\(f\in C^n[a,b],x_i\in [a,b],i = 0, 1,...,n\)</span>且互异，则：</p><p><span class="math display">\[f[x_0,\dots,x_n]=\int\mathop\cdots\limits_{\tau_n}\int f^{(n)}(t_0x_0+t_1x_1+\cdots + t_nx_n)\mathrm dt_1\cdots\mathrm dt_n\]</span></p><p>其中 <span class="math inline">\(\\tau _ n = \left\{ { (t _ 1,\dots,t_ n) |t_i\ge 0, \sum t _ i \le 1 }\right\}\)</span>为n维单纯形，而<spanclass="math inline">\(t _ 0 = 1- \sum_{i=1} ^n t _ i\)</span> .</p><p>扩展差商的定义（<strong>重节点插值</strong>）：</p><p><span class="math display">\[f[x_0,x_0] = \lim _{x\rightarrow x_0} f[x_0, x] =f&#39;(x_0)\\f[x_0,...,x_0] = \frac{f^{(k)}(x_0) }{k!}\]</span></p><p>从而：</p><p><span class="math display">\[\begin{aligned}H_m(x) = &amp;f(x_0) + f[x_0,x_0](x-x0) + \cdots + f[x_0,\cdots,x_0](x-x_0)^{m_0}\\&amp;+f[x_0,\cdots,x_0,x_1] (x-x_0)^{m_0+1} + \cdots +\\&amp;f[x_0,\cdots, x_0, x_1\cdots x_1](x-x_0)^{m_0+1}(x-x_1)^{m_1}+\cdots\\&amp;+f[x_0,\cdots,x_n](x-x_0)^{m_0+1}\cdots(x-x_{n-1})^{m_{n-1}+1}(x-x_n)^{m_n}\end{aligned}\]</span></p><p>插值余项为：</p><p><span class="math display">\[f(x)-H_m(x)=\frac{f^{(m+1)}(\xi)}{(m+1)!}\prod_{i=0}^n(x-x_i)^{m_i+1}\]</span></p></div><div class="story post-story"><h2 id="高次插值的缺点和分段线性插值">高次插值的缺点和分段线性插值</h2><p>常见的问题：个数多→误差大</p><blockquote><p>在<ahref="https://www.wanweibaike.com/wiki-数值分析">数值分析</a>领域中，<strong>龙格现象</strong>是在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。它是由<ahref="https://www.wanweibaike.com/wiki-卡爾·龍格">卡尔·龙格</a>（Runge）在探索使用多项式插值逼近某些函数时的错误行为时发现的。<ahref="https://www.wanweibaike.com/wiki-龙格现象#cite_note-1">[1]</a>这一发现非常重要，因为它表明使用高次多项式插值并不总能提高准确性。该现象与傅里叶级数近似中的吉布斯现象相似。——Wikipedia</p></blockquote><h3 id="分段线性插值">分段线性插值</h3><blockquote><p>在<ahref="https://www.wanweibaike.com/wiki-数值分析">数值分析</a>这个数学分支中，<strong>样条插值</strong>是使用一种名为<ahref="https://www.wanweibaike.com/wiki-样条">样条</a>的特殊<ahref="https://www.wanweibaike.com/wiki-分段">分段</a><ahref="https://www.wanweibaike.com/wiki-多项式">多项式</a>进行插值的形式。</p></blockquote><p>在<a href="https://www.wanweibaike.com/wiki-数学">数学</a>学科<ahref="https://www.wanweibaike.com/wiki-数值分析">数值分析</a>中，<strong>样条</strong>（Spline）是一种特殊的<ahref="https://www.wanweibaike.com/wiki-函数">函数</a>，由<ahref="https://www.wanweibaike.com/wiki-多项式">多项式</a>分段定义。</p><p>若给出<spanclass="math inline">\(f(x)\)</span>在n+1个节点上的数据表，则线性插值：</p><p><span class="math display">\[L_{1,i} (x) = f(x_i) + f[x_i, x_{i+1}](x-x_i)\\\tilde L_1(x) = \begin{cases}L_{1,0}(x),&amp;x\in[x_0,x_1)\\L_{1,1}(x),&amp;x\in[x_1,x_2)\\\vdots\\L_{1,n-1}(x),&amp;x\in [x_{n-1},x_n]\end{cases}\]</span></p><p>其插值误差为：</p><p><span class="math display">\[\max_{a\le x\le b}|f(x) - \tilde L_1(x)| \le \frac 1 8 h^2 \max_{a\lex\le b}|f&#39;&#39;(x)|\]</span></p><p>→产生了<strong>尖点</strong>（不光滑）</p><p>需要的：</p><ol type="1"><li><p>小区间上是多项式</p></li><li><p>两个相邻区间内光滑连接</p></li></ol><p>→ 三次样条插值</p></div><div class="story post-story"><h2 id="三次样条插值">三次样条插值</h2><p><strong>Def</strong>：设在区间<spanclass="math inline">\([a,b]\)</span>上的n+1个插值节点</p><p><span class="math display">\[a=x_0&lt;x_1&lt;\cdots&lt;x_n=b\]</span></p><p>及其函数在节点上的值<spanclass="math inline">\(y_i\)</span>，若存在函数<spanclass="math inline">\(S(x)\)</span>满足：</p><ol type="1"><li><p><span class="math inline">\(S(x_j)=y_j\)</span></p></li><li><p><spanclass="math inline">\(S(x)\)</span>在每个小区间上都是三次多项式</p></li><li><p><span class="math inline">\(S\in C^2[a,b]\)</span></p></li></ol><p>则称为三次样条插值函数</p><p>由于在边界上缺少边界条件，通常在端点上2个附加条件（<strong>边界条件</strong>）：</p><ol type="1"><li><p>（第一型）已知一阶导数</p></li><li><p>（第二型）已知二阶导数</p></li><li><p>（第三型）周期边界条件</p></li></ol><h3 id="三次样条插值函数的求法">三次样条插值函数的求法</h3><p>从二阶导数入手：</p><p><span class="math display">\[S&#39;&#39;(x_j)=M_j, S&#39;&#39;(x_{j+1})=M_{j+1}\]</span></p><p>令<span class="math inline">\(h_j = x_{j+1}-x_j\)</span>则：</p><p><span class="math display">\[S(x) =y_j+c_j(x-x_j)+\frac 1 2 M_j(x-x_j)^2+ \frac 1 {6h_j}(M_{j+1} -M_j)(x-x_j)^3,x\in [x_j,x_{j+1}]\]</span></p><p>代入一次导数连续：</p><p><span class="math display">\[S&#39;(x_j)=S&#39;(x_{j+1})\]</span></p><p>则</p><p><span class="math display">\[\mu_j M_{j-1} +2M_j+\lambda _jM_{j+1}=d_j\\\mu_j = \frac{h_{j-1}}{h_{j-1}+h_j},\quad\lambda_j = 1 - \mu_j,\quadd_j=6f[x_{j-1}, x_j,x_{j+1}]\]</span></p><p>即可构造出三对角矩阵，若给出第一型条件<span class="math inline">\(d_0= 6f[x_0,x_0,x_1]\)</span>, <span class="math inline">\(d_1 =6f[x_{n-1}, x_n,x_n]\)</span>：</p><p><span class="math display">\[\left[\begin{matrix}2&amp;1\\\mu_1&amp;2&amp;\lambda_1\\&amp;\mu_2&amp;2&amp;\lambda_2\\&amp;&amp;\ddots&amp;\ddots&amp;\ddots\\&amp;&amp;&amp;\mu_{n-1}&amp; 2&amp; \lambda_{n-1}\\&amp;&amp;&amp;&amp;1 &amp;2\end{matrix}\right]\left[\begin{matrix}M_0\\M_1\\M_2\\\vdots\\M_{n-1}\\M_n\end{matrix}\right] =\left[\begin{matrix}d_0\\d_1\\d_2\\\vdots\\d_{n-1}\\d_n\end{matrix}\right]  \]</span></p><h3 id="三次样条插值函数的收敛性">三次样条插值函数的收敛性</h3><p><strong>Thm</strong>：设被插值函数四阶连续，则在插值区间上有</p><p><span class="math display">\[||f^{(k)}-S^{(k)}||_\infty \le c_kh^{4-k}||f^{(4)}||_\infty,\quad k = 0,1, 2\\h = \max_{0\le j\le n-1}h_j,c_0 = 1/16, c_1=c_2=1/2\]</span></p></div><div class="story post-story"><h2 id="最佳一致逼近">最佳一致逼近</h2><h3 id="线性赋范空间">线性赋范空间</h3><p><strong>Def</strong>（线性空间）若<span class="math inline">\(\forallx,y\in X, \lambda x\in R,\lambda x\in X, x+y\in X\)</span>则称<spanclass="math inline">\(X\)</span>为线性空间。</p><p><strong>Def</strong>（线性赋范空间）对应的空间称线性赋范空间</p><p><strong>Def</strong>（距离）<spanclass="math inline">\(X\)</span>是线性赋范空间，<spanclass="math inline">\(x,y\in X\)</span>则称<spanclass="math inline">\(||x-y||\)</span>为<spanclass="math inline">\(x\)</span><spanclass="math inline">\(y\)</span>之间的距离</p><p><strong>Def</strong>（最佳逼近元）<spanclass="math inline">\(X\)</span>是线性赋范空间，<spanclass="math inline">\(M\sube X\)</span>若存在<spanclass="math inline">\(\varphi \in M\)</span>使得<spanclass="math inline">\(\forall \psi\in M\)</span>有</p><p><span class="math display">\[||f-\varphi||\le ||f-\psi||\]</span></p><p>则称<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(M\)</span>中的最佳逼近元</p><h3 id="最佳一致逼近多项式">最佳一致逼近多项式</h3><p><strong>Def</strong>（最佳一致逼近多项式）若<spanclass="math inline">\(\exist p_n\in M_n\)</span>使得<spanclass="math inline">\(\forall q_n\in M_n\)</span></p><p><span class="math display">\[||f-p_n||_\infty \le ||f-q_n||_\infty\]</span></p><p><strong>Thm</strong>：n次最佳一致逼近多项式是存在且唯一的</p><p><strong>Def</strong>（偏差点）<spanclass="math inline">\(|g(x_0)|=||g||_\infty = \max_{a\le x\leb}|g(x)|\)</span>（又分正偏差点、负偏差点）</p><p><strong>引理1</strong>：对于最佳一致逼近多项式，<spanclass="math inline">\(f-p_n\)</span>必存在正负误差点。</p><p><strong>Thm</strong>：设<span class="math inline">\(f\inC[a,b]\)</span>，<spanclass="math inline">\(p_n(x)\)</span>是n次多项式，则<spanclass="math inline">\(p_n(x)\)</span>是<spanclass="math inline">\(f(x)\)</span>的<spanclass="math inline">\(n\)</span>次最佳一致逼近多项式<spanclass="math inline">\(\iff\)</span><spanclass="math inline">\(f(x)-p_n(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上至少有n+2个交错偏差点。<spanclass="math inline">\(a\le x_0 &lt; x_1 &lt; \cdots &lt; x_{n + 1} \leb\)</span></p><p><span class="math display">\[f(x_i)-p_n(x_i)=(-1)^i\sigma ||f-p_n || _\infty\]</span></p><p><strong>推论1</strong>：若$f^{(n+1)} <spanclass="math inline">\(在\)</span>(a,b)<spanclass="math inline">\(上存在且保号，则\)</span>f(x)-p_n(x)<spanclass="math inline">\(在\)</span>[a,b]<spanclass="math inline">\(内恰好有\)</span>n+2$个交错偏差点，且两端点都是偏差点。</p><p><strong>推论2</strong>：<spanclass="math inline">\(p_n(x)\)</span>是<spanclass="math inline">\(f(x)\)</span>的某一个n次插值多项式</p></div><div class="story post-story"><h2 id="最佳平方逼近">最佳平方逼近</h2><h3 id="内积空间">内积空间</h3><p><strong>Def</strong>（内积空间和内积）：若<spanclass="math inline">\(X\)</span>是一个线性空间，若<spanclass="math inline">\(\forall x,y\)</span>有实数与之对应<spanclass="math inline">\((x,y)\)</span>，且</p><ol type="1"><li><p><span class="math inline">\(\forall x,y \inX,~(x,y)=(y,x)\)</span></p></li><li><p><span class="math inline">\(\forall x,y \in X,\lambda\inR,~(\lambda x,y)=\lambda(x,y)\)</span></p></li><li><p><span class="math inline">\(\forall x,y,z\inX,(x,y+z)=(x,y)+(y,z)\)</span></p></li><li><p><span class="math inline">\(\forall x\in X, (x,x)\ge 0,(x,x)=0\iff x=0\)</span></p></li></ol><p><strong>Def</strong>（正交）：<spanclass="math inline">\((x,y)=0\)</span></p><p><strong>Thm</strong>：柯西-施瓦茨不等式</p><h3 id="最佳平方逼近-1">最佳平方逼近</h3><p>设<span class="math inline">\(X\)</span>是内积空间，<spanclass="math inline">\((\cdot,\cdot)\)</span>是内积，M是X的有限维子空间，<spanclass="math inline">\(\varphi_0,...,\varphi_m\)</span>是M的一组基。求<spanclass="math inline">\(\varphi\in M\)</span>使得：<spanclass="math inline">\(\varphi = \arg\min_{\psi\in M}||f-\psi||\)</span>，则称<spanclass="math inline">\(\varphi\)</span>为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(M\)</span>中的最佳平方逼近元</p><p>记：<span class="math inline">\(\varphi = \sum c_i \varphi_i,\quad\psi = \sum a_i\varphi _i\)</span>，问题变为求解<spanclass="math inline">\(c\)</span></p><p><span class="math display">\[\left[(\varphi_i, \varphi_j)\right][c_0,c_1,...,c_m]^T = [(f, \varphi_0),(f,\varphi_1),...,(f,\varphi_m)]\]</span></p><p>上述方程组称为正规方程组。</p><p><strong>引理</strong>：正规方程组是对称正定的。</p><p><strong>Thm</strong>：正规方程组存在唯一解，且为<spanclass="math inline">\(||f-\sum a_i\varphi_i||^2\)</span>的最小点。</p><h3 id="超定线性方程组的最小二乘解">超定线性方程组的最小二乘解</h3><p><span class="math display">\[\left[a_{i,j}\right] [x_1,x_2,\dots,x_n]^T = [b_1,b_2,\dots,b_m]^T\]</span></p><p>其中：<span class="math inline">\(m&gt;n\)</span></p><p><span class="math display">\[A^TAx=A^Tb\]</span></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 ch 4 多项式插值和函数最佳逼近&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-常微分方程的数值解</title>
    <link href="http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%206%20%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/"/>
    <id>http://adversarr.github.io/2022/09/30/study/Math/NumericRecipies/Chapter%206%20%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/</id>
    <published>2022-09-30T01:16:33.353Z</published>
    <updated>2022-09-30T01:16:33.354Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 Chapter 6 常微分方程的数值解</p><span id="more"></span><p>主要内容：</p><ol type="1"><li>Euler公式、后向Euler公式、梯形公式、改进的Euler公式、局部截断误差和阶数</li><li>R-K方法</li><li>单步的收敛性和稳定性</li><li>线性多步法（Adams显式、隐式公式，基于Taylor展开的线性多步法的构造）</li></ol><p>主要讨论一阶常微分方程初值问题的数值解：</p><p><span class="math display">\[\begin{cases}    y&#39; = f(x,y),&amp; a\le x \le b\\    y(a) = \eta.\end{cases}\]</span></p><p>假设其存在唯一解，且充分光滑，在解的邻域内 <spanclass="math inline">\(f(x, y)\)</span> 和 <spanclass="math inline">\(\displaystyle \frac{\partial f(x,y)}{\partialy}\)</span> 连续。</p><p>将<span class="math inline">\([a,b]\)</span>作<spanclass="math inline">\(n\)</span>等分，作<spanclass="math inline">\(h=(b-a)/n\)</span>和<spanclass="math inline">\(x_i=a+ih\)</span></p><p>在计算<span class="math inline">\(y_i\)</span>时，</p><ol type="1"><li>如果只用到前一步的值<spanclass="math inline">\(y_{i-1}\)</span>：<strong>单步法</strong></li><li>如果用到前<span class="math inline">\(r\)</span>步的值：<spanclass="math inline">\(r\)</span>步方法。</li></ol><hr /><div class="story post-story"><h2 id="euler方法">Euler方法</h2><h3 id="euler公式的构造">Euler公式的构造</h3><p>将两边积分： <span class="math display">\[\int_{x_i}^{x_{i+1}} y&#39;(x) \mathrm dx = \int _{x_i} ^{x_{i+1}} f(x,y(x))\mathrm dx\\\Rightarrow y(x_{i+1}) = y(x_i)+\int _{x_i} ^{x_{i+1}} f(x, y(x))\mathrm dx\]</span> 从而应用<strong>左矩形公式</strong>做近似： <spanclass="math display">\[y(x_{i+1}) = y(x_i) +h\cdot f(x_i, y (x _ i)) +R_{i+1}^{(1)}\]</span> 其中： <span class="math display">\[R_{i+1}^{(1)}=\frac 1 2 y&#39;&#39;(\xi_i) h ^ 2,\quad \xi _i \in (x_i,x_{i+1})\]</span> 如果忽略<spanclass="math inline">\(R_{i+1}^{(1)}\)</span>可以得到Euler公式。</p><dl><dt>Euler 公式</dt><dd>称下公式为求解初值问题的Euler方法 <span class="math display">\[\begin{cases}y_0 = \eta \\y_{i+1} = y_{i} + h f(x_i, y_i)\end{cases}\]</span></dd></dl><p>Euler公式在计算式只用到了前一步的值来计算，另外，Euler公式给出了<spanclass="math inline">\(y_{i+1}\)</span>和<spanclass="math inline">\(y_i\)</span>的显式依赖关系，直接代入即可得到<spanclass="math inline">\(y_{i+1}\)</span>。因而称为<strong>单步显式公式</strong></p><dl><dt>单步显式公式</dt><dd>一般形式为，其中<spanclass="math inline">\(\varphi(x,y,h)\)</span>称为<strong>增量函数</strong><span class="math display">\[\begin{cases}y_{i+1} = y_i + h\varphi(x_i, y_i, h)\\y_0 = \eta\end{cases}\]</span></dd><dt>单步显式公式的局部截断误差</dt><dd>一个单步显示公式在<spanclass="math inline">\(x_{i+1}\)</span>处的局部截断误差为 <spanclass="math display">\[R_{i+1} = y(x_{i+1}) - [y(x_i) + h\varphi(x_i,y(x_i), h)]\]</span></dd></dl><h3 id="后退euler公式">后退Euler公式</h3><dl><dt>单步隐式公式</dt><dd>一般形式如下，其中<spanclass="math inline">\(\psi\)</span>为增量函数，后退Euler公式的增量函数为<spanclass="math inline">\(\psi(x_i, y_i, y_{i+1}, h)=f(x_i+h,y_{i+1})\)</span> <span class="math display">\[\begin{cases}  y_{i+1} = y_i + h \psi(x_i, y_i, y_{i+1}, h)\\  y_0 = \eta\end{cases}\]</span></dd><dt>单步隐式公式的局部截断误差</dt><dd>后退Euler公式的局部截断误差为</dd></dl><p><span class="math display">\[R_{i+1} = -\frac12 y&#39;&#39;(\xi_i)h^2\]</span></p><h3 id="梯形公式">梯形公式</h3><p>应用梯形公式近似：</p><p><span class="math display">\[y(x_{i+1})=y(x_i) +\frac h2\left[ f(x_i, y_i) +f(x_{i+1},y_{i+1})\right]+R_{i+1}^{(3)}\]</span></p><p>其中：</p><p><span class="math display">\[R_{i+1}^{(3)} = - \frac{1}{12} y&#39;&#39;&#39;(\xi_i) h^3\]</span></p><h3id="预测校正系统和改进的euler公式">预测校正系统和改进的Euler公式</h3><dl><dt>预测校正公式</dt><dd>称侠士为改进的Euler公式，为单步显式公式</dd></dl><p><span class="math display">\[\begin{cases}  y_{i+1}^{(p)}=y_i+hf(x_i, y_i) &amp;预测公式\\  y_{i+1} = y_i + \frac{h}{2}[f(x_i, y_i) + f(x_{i+1}, y_{i+1}^{(p)})]&amp; 校正公式\end{cases}\]</span></p><p>也可以改写为：</p><p><span class="math display">\[\begin{cases}  y_{i+1}^{(p)} = y_i + h f(x_i , y_i)\\  y_{i+1}^{(c)} = y_i + hf(x_{i+1}, y_{i+1}^{(p)})\\  y_{i+1} = (y_{i+1}^{(p)}+ y_{i+1}^{(c)})/2\end{cases}\]</span></p><p>局部截断误差为：</p><p><span class="math display">\[R_{i+1} = y(x_{i+1}) - \left\{ y(x_i) + \frac h2 [f(x_i, y(x_i)) +f(x_{i+1}, y(x_i) + hf(x_i, y(x_i)))] \right\}\]</span></p><dl><dt>求解公式的阶数</dt><dd>如果一个求解公式的局部截断误差为<spanclass="math inline">\(R_{i+1}=O(h^{p+1})\)</span>则称该求解公式是<spanclass="math inline">\(p\)</span>阶的。</dd></dl></div><div class="story post-story"><h2 id="r-k方法">R-K方法</h2><h3 id="r-k方法的基本思想">R-K方法的基本思想</h3><p>利用积分中值定理：</p><p><span class="math display">\[y(x_{i+1}) = y(x_i) + hf(x_i+\theta h, y(x_i + \theta h))\]</span></p><p>称<span class="math inline">\(f(x_i+\theta h, y(x_i + \thetah))\)</span>为平均斜率</p><p>记：</p><p><span class="math display">\[\begin{aligned}  &amp;k_1 = f(x_i, y_i)\\  &amp;k_2 = f(x_{i+1}, y_i + hk_1)\end{aligned}\]</span></p><p>若用<span class="math inline">\(k_1\)</span>近似<spanclass="math inline">\(k^*\)</span>，则得到一阶Euler公式，若用<spanclass="math inline">\(\frac{k_1+k_2}{2}\)</span>来近似<spanclass="math inline">\(k^*\)</span>，则得到二阶改进的Euler公式。</p><dl><dt>R-K方法</dt><dd>一般的显式r-级Runge-Kutta方法为</dd></dl><p><span class="math display">\[\begin{cases}   y_{i+1} = y_i + h\sum_{j=1}^r \alpha_j k_j\\   k_1=f(x_i , y_i)\\   k_j = f(x_i + \lambda_j h, h_i + h\sum_{l=1}^{j-1} \mu_{jl}k_l),&amp;j=2,3,...,r\end{cases}\]</span></p><p>例如：<span class="math inline">\(r=\alpha_1=1\)</span>可得Euler方法。</p><h3 id="阶r-k公式">2阶R-K公式</h3><p><span class="math display">\[\begin{cases}  y_{i+1} = y_i + h(\alpha_1k_1+\alpha_2k_2)\\  k_1 = f(x_i, y_i)\\  k_2 = f(x_i + \lambda_2h, y_i + h\mu_{21}k_1)\end{cases}\]</span></p><p>要使得其具有二阶精度，iff参数 <spanclass="math inline">\(\alpha_1,\alpha_2,\lambda_2\)</span> 和 <spanclass="math inline">\(\mu_{21}\)</span>满足：</p><p><span class="math display">\[\begin{cases}1-\alpha_1 - \alpha_2 =0\\\frac 12 - \alpha_2\lambda_2 = 0\\\frac{1}{2}-\alpha_2\mu_{21} = 0\end{cases}\]</span></p><p>若取 <span class="math inline">\(\alpha_2=1/2\)</span>则得到<strong>二阶改进的Euler公式</strong>。</p><p>若取 <span class="math inline">\(\alpha_2=1\)</span>则得到<strong>变形的Euler公式</strong></p></div><div class="story post-story"><h2 id="单步法的收敛性和稳定性">单步法的收敛性和稳定性</h2><h3 id="收敛性">收敛性</h3><dl><dt>整体截断误差</dt><dd>设 <span class="math inline">\(\{y(x_i)\}\)</span> 是微分方程的解，<spanclass="math inline">\(\{y_i^{[h]}\}\)</span>是通过某个数值方法近似解。则称 <span class="math inline">\(E(h) =\max|y(x_i) -y_i^{[h]}|\)</span> 为该方法的整体截断误差，若</dd></dl><p><span class="math display">\[\lim_{h\rightarrow 0} E(h) = 0\]</span></p><p>则称该方法收敛。</p><p class='p blue'>Theorem</p><p>若<span class="math inline">\(y(x)\)</span>是微分方程的解，<spanclass="math inline">\(\{y_i\}\)</span>是单步显式公式的解，如果存在：</p><ol type="1"><li><span class="math inline">\(c_0&gt;0\)</span> 使得 <spanclass="math inline">\(|R_{i+1}|\le c_0h^{p+1}\)</span></li><li><span class="math inline">\(h_0&gt;0,L&gt;0\)</span> 使得 <spanclass="math inline">\(\max|\frac{\partial\varphi}{\partial y}|\leL\)</span></li></ol><p>则当 <span class="math inline">\(h&lt;\min\{h_0,(\delta/c)^{1/p}\}\)</span> 有：</p><p><span class="math display">\[E(h) \le ch^p\]</span></p><h3 id="稳定性">稳定性</h3><p>对于初值问题<spanclass="math inline">\(\{y_i\}_{i=0}^n\)</span>是由单步法到的的近似解,<span class="math inline">\(\{z_i\}_{i=0}^n\)</span>是扰动后的解,即满足</p><p><span class="math display">\[\left\{\begin{array}{l}z_{i+1}=z_i+h[\varphi(x_i,z_i,h)+\delta_{i+1}],\quad i=0,1,\cdotsn-1,\\  z_0=\eta+\delta_0,\end{array}\right.\]</span></p><p>如果存在正常数 <span class="math inline">\(C, \varepsilon_0,h_0\)</span>, 使得对所有 <spanclass="math inline">\(\varepsilon\in(0,\varepsilon_0]\)</span>, <spanclass="math inline">\(h\in(0,h_0]\)</span>, 当 <spanclass="math inline">\(\max\limits_{0\le i\len}|\delta_i|\le\varepsilon\)</span> 时, 有</p><p><span class="math display">\[\max_{0\le i\le n}|y_i-z_i|\le C\varepsilon,\]</span></p><p>则称单步法稳定.</p><p class='p blue'>Theorem 在定理1的条件下，单步公式是稳定的</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 Chapter 6 常微分方程的数值解&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    <category term="常微分方程" scheme="http://adversarr.github.io/tags/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 编程规范</title>
    <link href="http://adversarr.github.io/2022/09/30/study/ComputerScience/fragments/Google_C_programming_specification/"/>
    <id>http://adversarr.github.io/2022/09/30/study/ComputerScience/fragments/Google_C_programming_specification/</id>
    <published>2022-09-30T01:16:33.301Z</published>
    <updated>2022-09-30T01:16:33.301Z</updated>
    
    <content type="html"><![CDATA[<p>Google C/C++ 规范文档。</p><span id="more"></span><h1 id="c编程规范">c++编程规范</h1><div class="story post-story"><h2 id="扉页">0. 扉页</h2><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>版本:</th><th>4.45</th></tr></thead><tbody><tr class="odd"><td>原作者:</td><td>Benjy WeinbergerCraig SilversteinGregory EitzmannMarkMentovaiTashana Landray</td></tr><tr class="even"><td>翻译:</td><td><a href="http://www.yulefox.com/">YuleFox</a><ahref="https://github.com/yangyubo">Yang.Y</a><ahref="http://acgtyrant.com/">acgtyrant</a><ahref="http://github.com/lilinsanity">lilinsanity</a></td></tr><tr class="odd"><td>项目主页:</td><td><a href="http://google-styleguide.googlecode.com/">Google StyleGuide</a><ahref="http://github.com/zh-google-styleguide/zh-google-styleguide">Google开源项目风格指南 - 中文版</a></td></tr></tbody></table><h3 id="译者前言">0.1 译者前言</h3><p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码.但是如果代码贡献者的编程风格与 Google 的不一致,会给代码阅读者和其他代码提交者造成不小的困扰. Google因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google的编程风格.</p><p>翻译初衷:</p><blockquote><p>规则的作用就是避免混乱. 但规则本身一定要权威, 有说服力, 并且是理性的.我们所见过的大部分编程规范, 其内容或不够严谨, 或阐述过于简单,或带有一定的武断性.</p><p>Google 保持其一贯的严谨精神, 5 万汉字的指南涉及广泛, 论证严密.我们翻译该系列指南的主因也正是其严谨性.严谨意味着指南的价值不仅仅局限于它罗列出的规范,更具参考意义的是它为了列出规范而做的谨慎权衡过程.</p><p>指南不仅列出你要怎么做, 还告诉你为什么要这么做,哪些情况下可以不这么做, 以及如何权衡其利弊.其他团队未必要完全遵照指南亦步亦趋, 如前面所说, 这份指南是 Google根据自身实际情况打造的, 适用于其主导的开源项目. 其他团队可以参照该指南,或从中汲取灵感, 建立适合自身实际情况的规范.</p><p>我们在翻译的过程中, 收获颇多.希望本系列指南中文版对你同样能有所帮助.</p></blockquote><p>我们翻译时也是尽力保持严谨, 但水平所限, bug 在所难免.有任何意见或建议, 可与我们取得联系.</p><p>中文版和英文版一样, 使用 <code>Artistic License/GPL</code>开源许可.</p><p>中文版修订历史:</p><blockquote><ul><li><p>2015-08 : 热心的清华大学同学 <span class="citation"data-cites="lilinsanity">@lilinsanity</span>完善了「类」章节以及其它一些小章节。至此，对 Google CPP Style Guide 4.45的翻译正式竣工。</p></li><li><p>2015-07 4.45 : acgtyrant 为了学习 C++ 的规范，顺便重新翻译了本C++ 风格指南，特别是 C++11的全新内容。排版大幅度优化，翻译措辞更地道，添加了新译者笔记。Google总部 C++ 工程师 innocentim,清华大学不愿意透露姓名的唐马儒先生，大阪大学大学院情报科学研究科计算机科学专攻博士farseerfc 和其它 Arch Linux 中文社区众帮了译者不少忙，谢谢他们。因为 C++Primer 尚未完全入门，暂时没有翻译「类」章节和其它一些小章节。</p></li><li><p>2009-06 3.133 : YuleFox 的 1.0 版已经相当完善,但原版在近一年的时间里, 其规范也发生了一些变化.</p></li></ul><blockquote><p>Yang.Y 与 YuleFox 一拍即合, 以项目的形式来延续中文版 : <ahref="http://github.com/yangyubo/zh-google-styleguide">Google开源项目风格指南 - 中文版项目</a>.</p><p>主要变化是同步到 3.133 最新英文版本,做部分勘误和改善可读性方面的修改, 并改进排版效果. Yang.Y 重新翻修,YuleFox 做后续评审.</p></blockquote><ul><li>2008-07 1.0 : 出自 <a href="http://www.yulefox.com/?p=207">YuleFox的 Blog</a>, 很多地方摘录的也是该版本.</li></ul></blockquote><h3 id="背景">0.2 背景</h3><p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++程序员都知道的, C++ 有很多强大的特性,但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug,难以阅读和维护.</p><p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性.这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p><p><em>风格</em>, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语"风格" 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p><p>使代码易于管理的方法之一是加强代码一致性.让任何程序员都可以快速读懂你的代码这点非常重要.保持统一编程风格并遵守约定意味着可以很容易根据 "模式匹配"规则来推断各种标识符的含义. 创建通用,必需的习惯用语和模式可以使代码更容易理解.在一些情况下可能有充分的理由改变某些编程风格,但我们还是应该遵循一致性原则，尽量不这么做.</p><p>本指南的另一个观点是 C++ 特性的臃肿. C++是一门包含大量高级特性的庞大语言. 某些情况下,我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽,避免这些特性可能导致的各种问题. 指南中列举了这类特性,并解释为什么这些特性被限制使用.</p><p>Google 主导的开源项目均符合本指南的规定.</p><p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p></div><div class="story post-story"><h2 id="头文件">1. 头文件</h2><p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件.也有一些常见例外, 如单元测试代码和只包含 <code>main()</code> 函数的<code>.cc</code> 文件.</p><p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p><p>下面的规则将引导你规避使用头文件时的各种陷阱.</p><h3 id="self-contained-头文件">1.1. Self-contained 头文件</h3><p>Tip</p><p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以<code>.h</code>结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以<code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code>头文件的做法.</p><p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">1.2.##define 保护</a>，统统包含它所需要的其它头文件，也不要求定义任何特别symbols.</p><p>不过有一个例外，即一个文件并不是 self-contained的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用<code>.inc</code> 文件扩展名。</p><p>如果 <code>.h</code>文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的<code>.cc</code>文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的<code>-inl.h</code> 文件里（译者注：过去该规范曾提倡把定义放到 -inl.h里过）。</p><p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的<code>.cc</code> 文件里。</p><h3 id="define-保护">1.2. ##define 保护</h3><blockquote><p>[!TIP]</p><p>1</p></blockquote><p>所有头文件都应该使用 <code>##define</code> 来防止头文件被多重包含,命名格式当是: <code>___H_</code> .</p><p>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如,项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code>可按如下方式保护:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></table></figure><h3 id="前置声明">1.3. 前置声明</h3><p>尽可能地避免使用前置声明。使用 <code>#include</code>包含需要的头文件即可。</p><p><strong>定义：</strong></p><blockquote><p>所谓「前置声明」（forwarddeclaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p></blockquote><p><strong>优点：</strong></p><blockquote><ul><li>前置声明能够节省编译时间，多余的 <code>#include</code>会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code>使代码因为头文件中无关的改动而被重新编译多次。</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li><p>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</p></li><li><p>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</p></li><li><p>前置声明来自命名空间 <code>std::</code> 的 symbol时，其行为未定义。</p></li><li><p>很难判断什么时候该用前置声明，什么时候该用 <code>#include</code>。极端情况下，用前置声明代替 <code>includes</code>甚至都会暗暗地改变代码的含义：</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; <span class="built_in">f</span>(x); &#125;  <span class="comment">// calls f(B*)</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>如果 <code>#include</code> 被 <code>B</code> 和 <code>D</code>的前置声明替代， <code>test()</code> 就会调用 <code>f(void*)</code>.</p></blockquote><ul><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的<code>include</code> 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li></ul></blockquote><p><strong>结论：</strong></p><blockquote><ul><li>尽量避免前置声明那些定义在其他项目中的实体.</li><li>函数：总是使用 <code>#include</code>.</li><li>类模板：优先使用 <code>#include</code>.</li></ul></blockquote><p>至于什么时候包含头文件，参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##name-and-order-of-includes">1.5.<code>#include</code> 的路径及顺序</a> 。</p><h3 id="内联函数">1.4. 内联函数</h3><p>Tip</p><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p><p><strong>定义:</strong></p><blockquote><p>当函数被声明为内联函数之后, 编译器会将其内联展开,而不是按通常的函数调用机制进行调用.</p></blockquote><p><strong>优点:</strong></p><blockquote><p>只要内联的函数体较小, 内联该函数可以令目标代码更加高效.对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减,这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小,但内联一个相当大的函数将戏剧性的增加代码大小.现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p></blockquote><p><strong>结论:</strong></p><blockquote><p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数,析构函数往往比其表面看起来要更长,因为有隐含的成员和基类析构函数被调用!</p><p>另一个实用的经验准则: 内联那些包含循环或 <code>switch</code>语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或<code>switch</code> 语句从不被执行).</p><p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要;比如虚函数和递归函数就不会被正常内联. 通常,递归函数不应该声明成内联函数.（YuleFox 注:递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的,大多数编译器都不支持内联递归函数).虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便,抑或是当作文档描述其行为, 比如精短的存取函数.</p></blockquote><h3 id="include-的路径及顺序">1.5. <code>#include</code>的路径及顺序</h3><p>Tip</p><p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库,C++ 库, 其他库的 .h, 本项目内的 .h.</p><p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录).例如, <code>google-awesome-project/src/base/logging.h</code>应该按如下方式包含:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/logging.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>又如, <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code>的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能,<code>foo.cc</code> 中包含头文件的次序如下:</p><blockquote><ol type="1"><li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 <code>.h</code> 文件</li><li>本项目内 <code>.h</code> 文件</li></ol></blockquote><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code>遗漏某些必要的库时， <code>dir/foo.cc</code> 或<code>dir/foo_test.cc</code>的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code>通常位于同一目录下 (如 <code>base/basictypes_unittest.cc</code> 和<code>base/basictypes.h</code>), 但也可以放在不同目录下.</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p><p>您所依赖的符号 (symbols)被哪些头文件所定义，您就应该包含（include）哪些头文件，<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##forward-declarations">前置声明</a>(forward declarations) 情况除外。比如您要用到 <code>bar.h</code>中的某个符号, 哪怕您所包含的 <code>foo.h</code> 已经包含了<code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非<code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的symbol. 不过，凡是 cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code>就够了，不用再管后者所包含的其它内容。</p><p>举例来说,<code>google-awesome-project/src/foo/internal/fooserver.cc</code>的包含次序如下:</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/fooserver.h&quot;</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/basictypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/commandlineflags.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/bar.h&quot;</span></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>例外：</strong></p><p>有时，平台特定（system-specific）代码需要条件编译（conditionalincludes），这些代码可以放到其它 includes之后。当然，您的平台特定代码也要够简练且独立，比如：</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/fooserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/port.h&quot;</span>  <span class="comment">// For LANG_CXX11.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LANG_CXX11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// LANG_CXX11</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="译者-yulefox-笔记">译者 (YuleFox) 笔记</h3><ol type="1"><li>避免多重包含是学编程时最基本的要求;</li><li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li><li>内联函数的合理使用可提高代码执行效率;</li><li><code>-inl.h</code> 可提高代码可读性 (一般用不到吧:D);</li><li>标准化函数参数顺序可以提高可读性和易维护性(对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li><li>包含文件的名称使用 <code>.</code> 和 <code>..</code>虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理,包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在“最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后,这样出错先是项目内的文件, 头文件都放在对应源文件的最前面,这一点足以保证内部错误的及时发现了.</li></ol><h3 id="译者acgtyrant笔记">译者（acgtyrant）笔记</h3><ol type="1"><li>原来还真有项目用 <code>##includes</code> 来插入文本，且其文件扩展名<code>.inc</code> 看上去也很科学。</li><li>Google 已经不再提倡 <code>-inl.h</code> 用法。</li><li>注意，前置声明的类是不完全类型（incompletetype），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li><li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的<code>.cc</code>文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li><li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库,其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li></ol></div><div class="story post-story"><h2 id="作用域">2. 作用域</h2><h3 id="命名空间">2.1. 命名空间</h3><p>Tip</p><p>鼓励在 <code>.cc</code> 文件内使用匿名命名空间或 <code>static</code>声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p><p><strong>定义:</strong></p><blockquote><p>命名空间将全局作用域细分为独立的, 具名的作用域,可有效防止全局作用域的命名冲突.</p></blockquote><p><strong>优点:</strong></p><blockquote><p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注:将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.</p><p>举例来说, 两个不同项目的全局作用域都有一个类 <code>Foo</code>,这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中,<code>project1::Foo</code> 和 <code>project2::Foo</code>作为不同符号自然不会冲突.</p><p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace Y</span></span><br><span class="line">&#125;  <span class="comment">// namespace X</span></span><br></pre></td></tr></table></figure><p><code>X::Y::foo()</code> 与 <code>X::foo()</code>彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>命名空间具有迷惑性,因为它们使得区分两个相同命名所指代的定义更加困难。</p><p>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p><p>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</p><p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One DefinitionRule (ODR)).</p></blockquote><p><strong>结论:</strong></p><blockquote><p>根据下文将要提到的策略合理使用命名空间.</p><ul><li><p>遵守 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/naming.html##namespace-names">命名空间命名</a>中的规则。</p></li><li><p>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</p></li><li><p>用命名空间把文件包含, <ahref="https://gflags.github.io/gflags/">gflags</a> 的声明/定义,以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><p>更复杂的 <code>.cc</code> 文件包含更多, 更复杂的细节, 比如 gflags 或using 声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="built_in">DEFINE_FLAG</span>(<span class="type">bool</span>, someflag, <span class="literal">false</span>, <span class="string">&quot;dummy flag&quot;</span>);</span><br><span class="line"><span class="keyword">namespace</span> a &#123;</span><br><span class="line"></span><br><span class="line">...code <span class="keyword">for</span> a...                <span class="comment">// 左对齐</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace a</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>不要在命名空间 <code>std</code> 内声明任何东西,包括标准库的类前置声明. 在 <code>std</code>命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体,需要包含对应的头文件.</p></li><li><p>不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止 —— 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>不要在头文件中使用 <em>命名空间别名</em>除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 .cc 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 .h 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> librarian &#123;</span><br><span class="line"><span class="keyword">namespace</span> impl &#123;  <span class="comment">// 仅限内部使用</span></span><br><span class="line"><span class="keyword">namespace</span> sidetable = ::pipeline_diagnostics::sidetable;</span><br><span class="line">&#125;  <span class="comment">// namespace impl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 限制在一个函数中的命名空间别名</span></span><br><span class="line">  <span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace librarian</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>禁止用内联命名空间</p></li></ul></blockquote><h3 id="匿名命名空间和静态变量">2.2. 匿名命名空间和静态变量</h3><p>Tip</p><p>在 <code>.cc</code>文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为<code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p><p><strong>定义:</strong></p><blockquote><p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为<code>static</code>拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p></blockquote><p><strong>结论:</strong></p><blockquote><p>推荐、鼓励在 <code>.cc</code>中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在<code>.h</code> 中使用。</p><p>匿名命名空间的声明和具名的格式相同，在最后注释上<code>namespace</code> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="非成员函数静态成员函数和全局函数">2.3.非成员函数、静态成员函数和全局函数</h3><p>Tip</p><p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数.将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p><p><strong>优点:</strong></p><blockquote><p>某些情况下, 非成员函数和静态成员函数是非常有用的,将非成员函数放在命名空间内可避免污染全局作用域.</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>将非成员函数和静态成员函数作为新类的成员或许更有意义,当它们需要访问外部资源或具有重要的依赖关系时更是如此.</p></blockquote><p><strong>结论:</strong></p><blockquote><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的.这样的函数可以被定义成静态成员, 或是非成员函数.非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内.相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">2.1.命名空间</a> 。举例而言，对于头文件 <code>myproject/foo_bar.h</code> ,应当使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p>而非</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p>定义在同一编译单元的函数,被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖;静态成员函数对此尤其敏感. 可以考虑提取到新类中,或者将函数置于独立库的命名空间内.</p><p>如果你必须定义非成员函数, 又只是在 <code>.cc</code> 文件中使用它,可使用匿名 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">2.1.命名空间</a> 或 <code>static</code> 链接关键字 (如<code>static int Foo() &#123;...&#125;</code>) 限定其作用域.</p></blockquote><h3 id="局部变量">2.4. 局部变量</h3><p>Tip</p><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p><p>C++ 允许在函数的任何位置声明变量.我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好.这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值.特别是，应使用初始化的方式替代声明再赋值, 比如:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 好——初始化时声明</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 好——v 一开始就初始化</span></span><br></pre></td></tr></table></figure></blockquote><p>属于 <code>if</code>, <code>while</code> 和 <code>for</code>语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></blockquote><p>Warning</p><p>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数,每次退出作用域都要调用其析构函数. 这会导致效率降低.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环作用域外面声明这类变量要高效的多:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态和全局变量">2.5. 静态和全局变量</h3><p>Tip</p><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p><p>禁止使用类的 <ahref="http://zh.cppreference.com/w/cpp/language/storage_duration##.E5.AD.98.E5.82.A8.E6.9C.9F">静态储存周期</a>变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug。不过 <code>constexpr</code>变量除外，毕竟它们又不涉及动态初始化或析构。</p><p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型(POD : Plain Old Data): 即 int, char 和 float, 以及 POD类型的指针、数组和结构体。</p><p>静态变量的构造函数、析构函数和初始化的顺序在 C++中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug.所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD变量，除非该函数（比如 <code>getenv()</code> 或 <code>getpid()</code>）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p><p>Note</p><p>Xris 译注:</p><p>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为(unspecified behaviour)。</p><p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从<code>main()</code> 返回还是对 <code>exit()</code>的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p><p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替<code>exit()</code>并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行<code>atexit()</code> 所绑定的任何 handlers. 如果您想在执行<code>quick_exit()</code> 来中断时执行某 handler（比如刷新log），您可以把它绑定到 <code>_at_quick_exit()</code>. 如果您想在<code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler,都绑定上去。</p><p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用<code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用<code>const char []</code>)。</p><p>如果您确实需要一个 <code>class</code>类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或<code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p><p>Note</p><p>Yang.Y 译注:</p><p>上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量,静态类成员变量, 以及函数静态变量.</p><h3 id="译者-yulefox-笔记-1">译者 (YuleFox) 笔记</h3><ol type="1"><li><code>cc</code> 中的匿名命名空间可避免命名冲突, 限定作用域,避免直接使用 <code>using</code> 关键字污染命名空间;</li><li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要<code>public</code>;</li><li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制,尽量单独形成编译单元;</li><li>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型(含 STL 容器), 避免不明确行为导致的 bug.</li><li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合,提高编译/执行效率.</li></ol><h3 id="译者acgtyrant笔记-1">译者（acgtyrant）笔记</h3><ol type="1"><li>注意「using 指示（using-directive）」和「using声明（using-declaration）」的区别。</li><li>匿名命名空间说白了就是文件作用域，就像 C static声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li><li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li><li>注意别在循环犯大量构造和析构的低级错误。</li></ol></div><div class="story post-story"><h2 id="类">3. 类</h2><p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用.本节列举了在写一个类时的主要注意事项.</p><h3 id="构造函数的职责">3.1. 构造函数的职责</h3><p><strong>总述</strong></p><p>不要在构造函数中调用虚函数,也不要在无法报出错误时进行可能失败的初始化.</p><p><strong>定义</strong></p><p>在构造函数中可以进行各种初始化操作.</p><p><strong>优点</strong></p><ul><li>无需考虑类是否被初始化.</li><li>经过构造函数完全初始化后的对象可以为 <code>const</code> 类型,也能更方便地被标准容器或算法使用.</li></ul><p><strong>缺点</strong></p><ul><li>如果在构造函数内调用了自身的虚函数,这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现,将来仍是隐患.</li><li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常(因为已经被 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##exceptions">禁用</a>了) 等方法的条件下, 构造函数很难上报错误</li><li>如果执行失败, 会得到一个初始化失败的对象,这个对象有可能进入不正常的状态, 必须使用 <code>bool IsValid()</code>或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.</li><li>构造函数的地址是无法被取得的, 因此, 举例来说,由构造函数完成的工作是无法以简单的方式交给其他线程的.</li></ul><p><strong>结论</strong></p><p>构造函数不允许调用虚函数. 如果代码允许,直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 <code>Init()</code>方法或工厂函数.</p><p>构造函数不得调用虚函数, 或尝试报告一个非致命错误.如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init()方法或使用工厂模式. Avoid <code>Init()</code> methods on objects with noother states that affect which public methods may be called(此类形式的半构造对象有时无法正确工作).</p><h3 id="隐式类型转换">3.2. 隐式类型转换</h3><p><strong>总述</strong></p><p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用<code>explicit</code> 关键字.</p><p><strong>定义</strong></p><p>隐式类型转换允许一个某种类型 (称作 <em>源类型</em>)的对象被用于需要另一种类型 (称作 <em>目的类型</em>) 的位置, 例如, 将一个<code>int</code> 类型的参数传递给需要 <code>double</code>类型的函数.</p><p>除了语言所定义的隐式类型转换,用户还可以通过在类定义中添加合适的成员定义自己需要的转换.在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如<code>operator bool()</code>). 在目的类型中定义隐式类型转换,则通过以源类型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现.</p><p><code>explicit</code> 关键字可以用于构造函数或 (在 C++11 引入)类型转换运算符,以保证只有当目的类型在调用点被显式写明时才能进行类型转换, 例如使用<code>cast</code>. 这不仅作用于隐式类型转换, 还能作用于 C++11的列表初始化语法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Foo f)</span></span>;</span><br></pre></td></tr></table></figure><p>此时下面的代码是不允许的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Func</span>(&#123;<span class="number">42</span>, <span class="number">3.14</span>&#125;);  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是<code>explicit</code> 应当限制的行为.</p><p><strong>优点</strong></p><ul><li>有时目的类型名是一目了然的, 通过避免显式地写出类型名,隐式类型转换可以让一个类型的可用性和表达性更强.</li><li>隐式类型转换可以简单地取代函数重载.</li><li>在初始化对象时, 列表初始化语法是一种简洁明了的写法.</li></ul><p><strong>缺点</strong></p><ul><li>隐式类型转换会隐藏类型不匹配的错误. 有时,目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li><li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候,因为这时很难判断到底是哪个函数被调用.</li><li>单参数构造函数有可能会被无意地用作隐式类型转换.</li><li>如果单参数构造函数没有加上 <code>explicit</code> 关键字,读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上<code>explicit</code> 标记.</li><li>并没有明确的方法用来判断哪个类应该提供类型转换,这会使得代码变得含糊不清.</li><li>如果目的类型是隐式指定的,那么列表初始化会出现和隐式类型转换一样的问题,尤其是在列表中只有一个元素的时候.</li></ul><p><strong>结论</strong></p><p>在类型定义中, 类型转换运算符和单参数构造函数都应当用<code>explicit</code> 进行标记. 一个例外是,拷贝和移动构造函数不应当被标记为 <code>explicit</code>,因为它们并不执行类型转换.对于设计目的就是用于对其他类型进行透明包装的类来说,隐式类型转换有时是必要且合适的. 这时应当联系项目组长并说明特殊情况.</p><p>不能以一个参数进行调用的构造函数不应当加上 <code>explicit</code>.接受一个 <code>std::initializer_list</code> 作为参数的构造函数也应当省略<code>explicit</code>, 以便支持拷贝初始化 (例如<code>MyType m = &#123;1, 2&#125;;)</code> .</p><h3 id="可拷贝类型和可移动类型">3.3. 可拷贝类型和可移动类型</h3><p><strong>总述</strong></p><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则,就把隐式产生的拷贝和移动函数禁用.</p><p><strong>定义</strong></p><p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值,或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值.对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义.<code>string</code> 类型就是一个可拷贝类型的例子.</p><p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值,或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的).<code>std::unique_ptr</code> 就是一个可移动但不可复制的对象的例子.对于用户定义的类型,移动操作一般是通过移动构造函数和移动赋值操作符实现的.</p><p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如,通过传值的方式传递对象.</p><p><strong>优点</strong></p><p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得API 更简单, 更安全也更通用. 与传指针和引用不同,这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱,也就没必要在协议中予以明确.这同时也防止了客户端与实现在非作用域内的交互,使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API一起使用, 例如大多数容器.</p><p>拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如<code>Clone()</code>, <code>CopyFrom()</code> or <code>Swap()</code>,更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过<code>= default</code>. 这种方式很简洁, 也保证所有数据成员都会被复制.拷贝与移动构造函数一般也更高效,因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 <ahref="http://en.cppreference.com/w/cpp/language/copy_elision">省略不必要的拷贝</a>这样的优化它们也更加合适.</p><p>移动操作允许隐式且高效地将源数据转移出右值对象.这有时能让代码风格更加清晰.</p><p><strong>缺点</strong></p><p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑,也显得荒谬而不合理. 单件类型 (<code>Registerer</code>),与特定的作用域相关的类型 (<code>Cleanup</code>),与其他对象实体紧耦合的类型 (<code>Mutex</code>)从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的,因为在使用它们时会造成 <ahref="https://en.wikipedia.org/wiki/Object_slicing">对象切割</a> .默认的或者随意的拷贝操作实现可能是不正确的,这往往导致令人困惑并且难以诊断出的错误.</p><p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略.这会让人迷惑,尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时,这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.</p><p><strong>结论</strong></p><p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则,如果对于你的用户来说这个拷贝操作不是一眼就能看出来的,那就不要把类型设置为可拷贝. 如果让类型可拷贝,一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝,同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作(移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝,但是移动操作的正确性对用户显然可见,那么把这个类型设置为只可移动并定义移动的两个操作.</p><p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的.记得时刻检查默认操作的正确性,并且在文档中说明类是可拷贝的且/或可移动的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>(Foo&amp;&amp; other) : <span class="built_in">field_</span>(other.field) &#123;&#125;</span><br><span class="line">  <span class="comment">// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Field field_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于存在对象切割的风险,不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数(当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性,请提供一个 <code>public virtual Clone()</code> 和一个<code>protected</code> 的拷贝构造函数以供派生类实现.</p><p>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code>public</code>域中使用 <code>= delete</code> 或其他手段禁用之.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp;) = delee;</span><br></pre></td></tr></table></figure><h3 id="结构体-vs.-类">3.4. 结构体 VS. 类</h3><p><strong>总述</strong></p><p>仅当只有数据成员时使用 <code>struct</code>, 其它一概使用<code>class</code>.</p><p><strong>说明</strong></p><p>在 C++ 中 <code>struct</code> 和 <code>class</code>关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解,以便为定义的数据类型选择合适的关键字.</p><p><code>struct</code> 用来定义包含数据的被动式对象,也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能.并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数,<code>Initialize()</code>, <code>Reset()</code>, <code>Validate()</code>等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.</p><p>如果需要更多的函数功能, <code>class</code> 更适合. 如果拿不准, 就用<code>class</code>.</p><p>为了和 STL 保持一致, 对于仿函数等特性可以不用 <code>class</code>而是使用 <code>struct</code>.</p><p>注意: 类和结构体的成员变量使用不同的 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##variable-names">命名规则</a>.</p><h3 id="继承">3.5. 继承</h3><p><strong>总述</strong></p><p>使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;<Design Patterns>&gt;里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为<code>public</code> 继承.</p><p><strong>定义</strong></p><p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中,继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">接口继承</a>,子类仅继承父类的方法名称.</p><p><strong>优点</strong></p><p>实现继承通过原封不动的复用基类代码减少了代码量.由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误.从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API中某个必须的方法时, 编译器同样会发现并报告错误.</p><p><strong>缺点</strong></p><p>对于实现继承, 由于子类的实现代码散布在父类和子类间之间,要理解其实现变得更加困难. 子类不能重写父类的非虚函数,当然也就不能修改其实现. 基类也可能定义了一些数据成员,因此还必须区分基类的实际布局.</p><p><strong>结论</strong></p><p>所有继承必须是 <code>public</code> 的. 如果你想使用私有继承,你应该替换成把基类的实例作为成员对象的方式.</p><p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个”(“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承:如果 <code>Bar</code> 的确 “是一种” <code>Foo</code>, <code>Bar</code>才能继承 <code>Foo</code>.</p><p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数,则析构函数也应该为虚函数.</p><p>对于可能被子类访问的成员函数, 不要过度使用 <code>protected</code>关键字. 注意, 数据成员都必须是 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##access-control">私有的</a>.</p><p>对于重载的虚函数或虚析构函数, 使用 <code>override</code>, 或(较不常用的) <code>final</code> 关键字显式地进行标记. 较早 (早于 C++11)的代码可能会使用 <code>virtual</code> 关键字作为不得已的选项. 因此,在声明重载时, 请使用 <code>override</code>, <code>final</code> 或<code>virtual</code> 的其中之一进行标记. 标记为 <code>override</code> 或<code>final</code> 的析构函数如果不是对基类虚函数的重载的话, 编译会报错,这有助于捕获常见的错误. 这些标记起到了文档的作用,因为如果省略这些关键字, 代码阅读者不得不检查所有父类,以判断该函数是否是虚函数.</p><h3 id="多重继承">3.6. 多重继承</h3><p><strong>总述</strong></p><p>真正需要用到多重实现继承的情况少之又少.只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类;其它基类都是以 <code>Interface</code> 为后缀的 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">纯接口类</a>.</p><p><strong>定义</strong></p><p>多重继承允许子类拥有多个基类. 要将作为 <em>纯接口</em> 的基类和具有<em>实现</em> 的基类区别开来.</p><p><strong>优点</strong></p><p>相比单继承 (见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##inheritance">继承</a>),多重实现继承可以复用更多的代码.</p><p><strong>缺点</strong></p><p>真正需要用到多重 <em>实现</em> 继承的情况少之又少.有时多重实现继承看上去是不错的解决方案,但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.</p><p><strong>结论</strong></p><p>只有当所有父类除第一个外都是 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">纯接口类</a>时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以<code>Interface</code> 为后缀.</p><p><strong>注意</strong></p><p>关于该规则, Windows 下有个 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/exceptions/##windows-code">特例</a>.</p><h3 id="接口">3.7. 接口</h3><p><strong>总述</strong></p><p>接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀(不强制).</p><p><strong>定义</strong></p><p>当一个类满足以下要求时, 称之为纯接口:</p><ul><li>只有纯虚函数 (“<code>=0</code>”) 和静态函数(除了下文提到的析构函数).</li><li>没有非静态数据成员.</li><li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为<code>protected</code>.</li><li>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code>为后缀的类继承.</li></ul><p>接口类不能被直接实例化, 因为它声明了纯虚函数.为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的<em>The C++ Programming Language, 3rd edition</em> 第 12.4 节.</p><p><strong>优点</strong></p><p>以 <code>Interface</code>为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员.这一点对于 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##multiple-inheritance">多重继承</a>尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p><p><strong>缺点</strong></p><p><code>Interface</code> 后缀增加了类名长度, 为阅读和理解带来不便.同时, 接口属性作为实现细节不应暴露给用户.</p><p><strong>结论</strong></p><p>只有在满足上述条件时, 类才以 <code>Interface</code> 结尾, 但反过来,满足上述需要的类未必一定以 <code>Interface</code> 结尾.</p><h3 id="运算符重载">3.8. 运算符重载</h3><p><strong>总述</strong></p><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p><p><strong>定义</strong></p><p>C++ 允许用户通过使用 <code>operator</code> 关键字 <ahref="http://en.cppreference.com/w/cpp/language/operators">对内建运算符进行重载定义</a>, 只要其中一个参数是用户定义的类型. <code>operator</code>关键字还允许用户使用 <code>operator""</code> 定义新的字面运算符,并且定义类型转换函数, 例如 <code>operator bool()</code>.</p><p><strong>优点</strong></p><p>重载运算符可以让代码更简洁易懂,也使得用户定义的类型和内建类型拥有相似的行为.重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如<code>==</code>, <code>&lt;</code>, <code>=</code>,<code>&lt;&lt;</code>), 遵循这些语言约定可以让用户定义的类型更易读,也能更好地和需要这些重载运算符的函数库进行交互操作.</p><p>对于创建用户定义的类型的对象来说,用户定义字面量是一种非常简洁的标记.</p><p><strong>缺点</strong></p><ul><li>要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力,而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.</li><li>过度使用运算符会带来难以理解的代码,尤其是在重载的操作符的语义与通常的约定不符合时.</li><li>函数重载有多少弊端, 运算符重载就至少有多少.</li><li>运算符重载会混淆视听,让你误以为一些耗时的操作和操作内建类型一样轻巧.</li><li>对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了,这时需要能够理解 C++ 语法的搜索工具.</li><li>如果重载运算符的参数写错,此时得到的可能是一个完全不同的重载而非编译错误. 例如:<code>foo &lt; bar</code> 执行的是一个行为, 而<code>&amp;foo &lt; &amp;bar</code>执行的就是完全不同的另一个行为了.</li><li>重载某些运算符本身就是有害的. 例如, 重载一元运算符<code>&amp;</code> 会导致同样的代码有完全不同的含义,这取决于重载的声明对某段代码而言是否是可见的. 重载诸如<code>&amp;&amp;</code>, <code>||</code> 和 <code>,</code>会导致运算顺序和内建运算的顺序不一致.</li><li>运算符从通常定义在类的外部, 所以对于同一运算,可能出现不同的文件引入了不同的定义的风险.如果两种定义都链接到同一二进制文件, 就会导致未定义的行为,有可能表现为难以发现的运行时错误.</li><li>用户定义字面量所创建的语义形式对于某些有经验的 C++程序员来说都是很陌生的.</li></ul><p><strong>结论</strong></p><p>只有在意义明显,不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符.例如, <code>|</code> 要作为位或或逻辑或来使用, 而不是作为 shell中的管道.</p><p>只有对用户自己定义的类型重载运算符. 更准确地说,将它们和它们所操作的类型定义在同一个头文件中, <code>.cc</code>中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符,并且最大程度上避免了多重定义的风险. 如果可能的话,请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用.如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义,并且保证这些定义的语义是一致的. 例如, 如果你重载了 <code>&lt;</code>,那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数,<code>&lt;</code> 和 <code>&gt;</code> 不会同时返回<code>true</code>.</p><p>建议不要将不进行修改的二元运算符定义为成员函数.如果一个二元运算符被定义为类成员,这时隐式转换会作用域右侧的参数却不会作用于左侧. 这时会出现<code>a &lt; b</code> 能够通过编译而 <code>b &lt; a</code> 不能的情况,这是很让人迷惑的.</p><p>不要为了避免重载操作符而走极端. 比如说, 应当定义 <code>==</code>,<code>=</code>, 和 <code>&lt;&lt;</code> 而不是 <code>Equals()</code>,<code>CopyFrom()</code> 和 <code>PrintTo()</code>. 反过来说,不要只是为了满足函数库需要而去定义运算符重载. 比如说,如果你的类型没有自然顺序, 而你要将它们存入 <code>std::set</code> 中,最好还是定义一个自定义的比较运算符而不是重载 <code>&lt;</code>.</p><p>不要重载 <code>&amp;&amp;</code>, <code>||</code>, <code>,</code>或一元运算符 <code>&amp;</code>. 不要重载 <code>operator""</code>,也就是说, 不要引入用户定义字面量.</p><p>类型转换运算符在 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##implicit-conversions">隐式类型转换</a>一节有提及. <code>=</code> 运算符在 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##copyable-and-movable-types">可拷贝类型和可移动类型</a>一节有提及. 运算符 <code>&lt;&lt;</code> 在 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##streams">流</a>一节有提及. 同时请参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">函数重载</a>一节, 其中提到的的规则对运算符重载同样适用.</p><h3 id="存取控制">3.9. 存取控制</h3><p><strong>总述</strong></p><p>将 <em>所有</em> 数据成员声明为 <code>private</code>, 除非是<code>static const</code> 类型成员 (遵循 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量命名规则</a>).处于技术上的原因, 在使用 <ahref="https://github.com/google/googletest">Google Test</a>时我们允许测试固件类中的数据成员为 <code>protected</code>.</p><h3 id="声明顺序">3.10. 声明顺序</h3><p><strong>总述</strong></p><p>将相似的声明放在一起, 将 <code>public</code> 部分放在最前.</p><p><strong>说明</strong></p><p>类定义一般应以 <code>public:</code> 开始, 后跟<code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p><p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型(包括 <code>typedef</code>, <code>using</code> 和嵌套的结构体与类),常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</p><p>不要将大段的函数定义内联在类定义中. 通常，只有那些普通的,或性能关键且短小的函数可以内联在类定义中. 参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##inline-functions">内联函数</a>一节.</p><h3 id="译者-yulefox-笔记-2">译者 (YuleFox) 笔记</h3><ol type="1"><li>不在构造函数中做太多逻辑相关的初始化;</li><li>编译器提供的默认构造函数不会对变量进行初始化,如果定义了其他构造函数, 编译器不再提供,需要编码者自行提供默认构造函数;</li><li>为避免隐式转换, 需将单参数构造函数声明为 <code>explicit</code>;</li><li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为<code>private</code> 且无需实现;</li><li>仅在作为数据集合时使用 <code>struct</code>;</li><li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承,子类重载的虚函数也要声明 <code>virtual</code> 关键字,虽然编译器允许不这样做;</li><li>避免使用多重继承, 使用时, 除一个基类含有实现外,其他基类均为纯接口;</li><li>接口类类名以 <code>Interface</code> 为后缀,除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数,不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为<code>protected</code>;</li><li>为降低复杂性, 尽量不重载操作符, 模板,标准类中使用时提供文档说明;</li><li>存取函数一般内联在头文件中;</li><li>声明次序: <code>public</code> -&gt; <code>protected</code> -&gt;<code>private</code>;</li><li>函数体尽量短小, 紧凑, 功能单一;</li></ol></div><div class="story post-story"><h2 id="函数">4. 函数</h2><h3 id="参数顺序">4.1. 参数顺序</h3><p><strong>总述</strong></p><p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p><p><strong>说明</strong></p><p>C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之.输入参数通常是值参或 <code>const</code> 引用,输出参数或输入/输出参数则一般为非 <code>const</code> 指针.在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意,在加入新参数时不要因为它们是新参数就置于参数列表最后,而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p><p>这并非一个硬性规定. 输入/输出参数 (通常是类或结构体)让这个问题变得复杂. 并且, 有时候为了其他函数保持一致,你可能不得不有所变通.</p><h3 id="编写简短函数">4.2. 编写简短函数</h3><p><strong>总述</strong></p><p>我们倾向于编写简短, 凝练的函数.</p><p><strong>说明</strong></p><p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p><p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题,甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p><p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码:如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码,考虑将其分割为更加简短并易于管理的若干函数.</p><h3 id="引用参数">4.3. 引用参数</h3><p><strong>总述</strong></p><p>所有按引用传递的参数必须加上 <code>const</code>.</p><p><strong>定义</strong></p><p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明为引用参数:<code>int foo(int &amp;val)</code>.</p><p><strong>优点</strong></p><p>定义引用参数可以防止出现 <code>(*pval)++</code> 这样丑陋的代码.引用参数对于拷贝构造函数这样的应用也是必需的.同时也更明确地不接受空指针.</p><p><strong>缺点</strong></p><p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p><p><strong>结论</strong></p><p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">in</span>, <span class="built_in">string</span> *<span class="keyword">out</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或<code>const</code> 引用, 输出参数为指针. 输入参数可以是<code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数,除非特殊要求, 比如 <code>swap()</code>.</p><p>有时候, 在输入形参中用 <code>const T*</code> 指针比<code>const T&amp;</code> 更明智. 比如:</p><ul><li>可能会传递空指针.</li><li>函数要把指针或对地址的引用赋值给输入形参.</li></ul><p>总而言之, 大多时候输入形参往往是 <code>const T&amp;</code>. 若用<code>const T*</code> 则说明输入另有处理. 所以若要使用<code>const T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p><h3 id="函数重载">4.4. 函数重载</h3><p><strong>总述</strong></p><p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,而不用花心思猜测调用的重载函数到底是哪一种.这一规则也适用于构造函数.</p><p><strong>定义</strong></p><p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数,然后用另一个参数类型为 <code>const char*</code> 的函数对其进行重载:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><p>通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载,这同时也能为使用者带来便利.</p><p><strong>缺点</strong></p><p>如果函数单靠不同的参数类型而重载 (acgtyrant注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则,以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体,继承语义就容易令人困惑.</p><p><strong>结论</strong></p><p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用<code>AppendString()</code> 和 <code>AppendInt()</code> 等,而不是一口气重载多个 <code>Append()</code>.如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用<code>std::vector</code> 以便使用者可以用 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##braced-initializer-list">列表初始化</a>指定参数.</p><h3 id="缺省参数">4.5. 缺省参数</h3><p><strong>总述</strong></p><p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致.缺省参数与 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">函数重载</a>遵循同样的规则. 一般情况下建议使用函数重载,尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p><p><strong>优点</strong></p><p>有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数.缺省参数为这样的情形提供了便利,使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比,缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了“必要参数” 和 “可选参数”.</p><p><strong>缺点</strong></p><p>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">不应当使用函数重载的理由</a>也都适用于缺省参数.</p><p>虚函数调用的缺省参数取决于目标对象的静态类型,此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p><p>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀.作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了,而不是在每次调用时都可能会有不同的取值.</p><p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致.而函数重载不会导致这样的问题.</p><p><strong>结论</strong></p><p>对于虚函数, 不允许使用缺省参数,因为在虚函数中缺省参数不一定能正常工作.如果在每个调用点缺省参数的值都有可能不同,在这种情况下缺省函数也不允许使用. (例如, 不要写像<code>void f(int n = counter++);</code> 这样的代码.)</p><p>在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话,可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p><h3 id="函数返回类型后置语法">4.6. 函数返回类型后置语法</h3><p><strong>总述</strong></p><p>只有在常规写法 (返回类型前置)不便于书写或不便于阅读时使用返回类型后置语法.</p><p><strong>定义</strong></p><p>C++ 现在允许两种不同的函数声明方式.以往的写法是将返回类型置于函数名之前. 例如:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>C++11 引入了这一新的形式. 现在可以在函数名前使用 <code>auto</code>关键字, 在参数列表之后后置返回类型. 例如:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span> foo(<span class="built_in">int</span> x) -&gt; <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure><p>后置返回类型为函数作用域. 对于像 <code>int</code> 这样简单的类型,两种写法没有区别. 但对于复杂的情况,例如类域中的类型声明或者以函数参数的形式书写的类型,写法的不同会造成区别.</p><p><strong>优点</strong></p><p>后置返回类型是显式地指定 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##lambda-expressions">Lambda表达式</a> 的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda表达式的返回类型, 但并不是在所有的情况下都能实现.即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p><p>有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单,也更易读, 尤其是在返回类型依赖于模板参数时. 例如:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; auto add<span class="function"><span class="params">(T t, U u)</span> -&gt;</span> decltype(t + u);</span><br></pre></td></tr></table></figure><p>对比下面的例子:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">template</span> &lt;class <span class="type">T</span>, class <span class="type">U</span>&gt; decl<span class="keyword">type</span>(declval&lt;<span class="type">T</span>&amp;&gt;() + declval&lt;<span class="type">U</span>&amp;&gt;()) add(<span class="type">T</span> t, <span class="type">U</span> u);</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><p>后置返回类型相对来说是非常新的语法, 而且在 C 和 Java中都没有相似的写法, 因此可能对读者来说比较陌生.</p><p>在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍.因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下,只使用一种版本是相对来说更规整的形式.</p><p><strong>结论</strong></p><p>在大部分情况下, 应当继续使用以往的函数声明写法,即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式)或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法.但是后一种情况一般来说是很少见的,大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##template-metaprogramming">复杂的模板代码</a>.</p></div><div class="story post-story"><h2 id="来自-google-的奇技">5. 来自 Google 的奇技</h2><p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++的方式可能和你在其它地方见到的有所不同.</p><h3 id="所有权与智能指针">5.1. 所有权与智能指针</h3><p>==总述==</p><p>动态分配出的对象最好有单一且固定的所有主,并通过智能指针传递所有权.</p><p>==定义==</p><p>所有权是一种登记／管理动态内存和其它资源的技术.动态分配对象的所有主是一个对象或函数,后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享,此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享,在代码中直接把所有权传递给其它对象.</p><p>智能指针是一个通过重载 <code>*</code> 和 <code>-&gt;</code>运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作,来确保执行销毁义务到位. <ahref="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>是 C++11 新推出的一种智能指针类型,用来表示动态分配出的对象的独一无二的所有权; 当<code>std::unique_ptr</code> 离开作用域时, 对象就会被销毁.<code>std::unique_ptr</code> 不能被复制,但可以把它移动（move）给新所有主. <ahref="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制;对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时,对象也会随着被销毁.</p><p>==优点==</p><ul><li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li><li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li><li>传递所有权也比”借用”指针或引用来得简单,毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li><li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li><li>可以不用手动完成所有权的登记工作, 大大简化了代码,也免去了一大波错误之恼.</li><li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li></ul><p>==缺点==</p><ul><li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权.指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权,还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li><li>其实值语义的开销经常被高估,所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li><li>如果 API 依赖所有权的传递,就会害得客户端不得不用单一的内存管理模型.</li><li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li><li><code>std::unique_ptr</code> 的所有权传递原理是 C++11 的 move 语法,后者毕竟是刚刚推出的, 容易迷惑程序员.</li><li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制,可能不得不重构整个系统.</li><li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li><li>某些极端情况下 (例如循环引用),所有权被共享的对象永远不会被销毁.</li><li>智能指针并不能够完全代替原生指针.</li></ul><p>==结论==</p><p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中.如果其他地方要使用这个对象, 最好传递它的拷贝,或者传递一个不用改变所有权的指针或引用. 倾向于使用<code>std::unique_ptr</code> 来明确所有权传递, 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FooConsumer</span><span class="params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>如果没有很好的理由, 则不要使用共享所有权.这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显,并且操作的对象是不可变的（比如说 <code>std::shared_ptr</code> ）时候,才能这么做. 如果确实要使用共享所有权, 建议于使用<code>std::shared_ptr</code> .</p><p>不要使用 <code>std::auto_ptr</code>, 使用<code>std::unique_ptr</code> 代替它.</p><h3 id="cpplint">5.2. Cpplint</h3><p><strong>&gt; 总述</strong></p><p>使用 <code>cpplint.py</code> 检查风格错误.</p><p><strong>&gt; 说明</strong></p><p><code>cpplint.py</code> 是一个用来分析源文件,能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报,但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>,或在上一行加 <code>// NOLINTNEXTLINE</code>, 可以忽略报错.</p><p>某些项目会指导你如何使用他们的项目工具运行 <code>cpplint.py</code>.如果你参与的项目没有提供, 你可以单独下载 <ahref="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p><h3 id="译者acgtyrant笔记-2">译者（acgtyrant）笔记</h3><ol type="1"><li>把智能指针当成对象来看待的话,就很好领会它与所指对象之间的关系了.</li><li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li><li><code>scoped_ptr</code> 和 <code>auto_ptr</code> 已过时. 现在是<code>shared_ptr</code> 和 <code>uniqued_ptr</code> 的天下了.</li><li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li><li>Arch Linux 用户注意了, AUR 有对 cpplint 打包.</li></ol></div><div class="story post-story"><h2 id="其他-c-特性">6. 其他 C++ 特性</h2><h3 id="引用参数-1">6.1. 引用参数</h3><p>==Tip==</p><p>所有按引用传递的参数必须加上 <code>const</code>.</p><p>==定义:==</p><blockquote><p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数:<code>int foo(int &amp;val)</code>.</p></blockquote><p>==优点:==</p><blockquote><p>定义引用参数防止出现 <code>(*pval)++</code> 这样丑陋的代码.像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <code>NULL</code>指针.</p></blockquote><p>==缺点:==</p><blockquote><p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p></blockquote><p>==结论:==</p><blockquote><p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> string &amp;in, string *out)</span></span>;</span><br></pre></td></tr></table></figure></blockquote><p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或<code>const</code> 引用, 输出参数为指针. 输入参数可以是<code>const</code> 指针, 但决不能是非 <code>const</code>的引用参数，除非用于交换，比如 <code>swap()</code>.</p><p>有时候，在输入形参中用 <code>const T*</code> 指针比<code>const T&amp;</code> 更明智。比如：</p><ul><li>您会传 null 指针。</li><li>函数要把指针或对地址的引用赋值给输入形参。</li></ul><p>总之大多时候输入形参往往是 <code>const T&amp;</code>. 若用<code>const T*</code> 说明输入另有处理。所以若您要用<code>const T*</code>, 则应有理有据，否则会害得读者误解。</p></blockquote><h3 id="右值引用">6.2. 右值引用</h3><p>==Tip==</p><p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用<code>std::forward</code>.</p><p>==定义:==</p><blockquote><p>右值引用是一种只能绑定到临时对象的引用的一种,其语法与传统的引用语法相似. 例如,<code>void f(string&amp;&amp; s)</code>;声明了一个其参数是一个字符串的右值引用的函数.</p></blockquote><p>==优点:==</p><blockquote><p>用于定义移动构造函数 (使用类的右值引用进行构造的函数)使得移动一个值而非拷贝之成为可能. 例如, 如果 <code>v1</code> 是一个<code>vector</code>, 则 <code>auto v2(std::move(v1))</code>将很可能不再进行大量的数据复制而只是简单地进行指针操作,在某些情况下这将带来大幅度的性能提升.</p><p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能,无论其参数是否是临时对象都能正常工作.</p><p>右值引用能实现可移动但不可拷贝的类型,这一特性对那些在拷贝方面没有实际需求,但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p><p>要高效率地使用某些标准库类型, 例如 <code>std::unique_ptr</code>,<code>std::move</code> 是必需的.</p></blockquote><p>==缺点:==</p><blockquote><p>右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解.类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</p></blockquote><p>==结论:==</p><blockquote><p>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用<code>std::forward</code> 功能函数. 你可能会使用 <code>std::move</code>来表示将值从一个对象移动而不是复制到另一个对象.</p></blockquote><h3 id="函数重载-1">6.3. 函数重载</h3><p>==Tip==</p><p>若要用好函数重载，最好能让读者一看调用点（callsite）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p><p>==定义:==</p><blockquote><p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数,然后用另一个参数类型为 <code>const char*</code> 的函数重载它:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>==优点:==</p><blockquote><p>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载,同时为使用者带来便利.</p></blockquote><p>==缺点:==</p><blockquote><p>如果函数单单靠不同的参数类型而重载（acgtyrant注：这意味着参数数量不变），读者就得十分熟悉 C++五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</p></blockquote><p>==结论:==</p><blockquote><p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用<code>AppendString()</code> 和 <code>AppendInt()</code> 等，而不是一口气重载多个 <code>Append()</code>.</p></blockquote><h3 id="缺省参数-1">6.4. 缺省参数</h3><p>==Tip==</p><p>我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p><p>==优点:==</p><blockquote><p>当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</p></blockquote><p>==缺点:==</p><blockquote><p>缺省参数会干扰函数指针，害得后者的函数签名（functionsignature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（callsite）都有重复（acgtyrant注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</p></blockquote><p>==结论:==</p><blockquote><p>由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant注：即不能再通过缺省参数来省略参数了）。</p><p>其一，位于 <code>.cc</code>文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p><p>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p><p>其三，可以用来模拟变长数组。</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过空 AlphaNum 以支持四个形参</span></span><br><span class="line"><span class="function">string <span class="title">StrCat</span><span class="params">(<span class="type">const</span> AlphaNum &amp;a,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> AlphaNum &amp;b = gEmptyAlphaNum,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> AlphaNum &amp;c = gEmptyAlphaNum,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> AlphaNum &amp;d = gEmptyAlphaNum)</span></span>;</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="变长数组和-alloca">6.5. 变长数组和 alloca()</h3><p>==Tip==</p><p>我们不允许使用变长数组和 <code>alloca()</code>.</p><p>==优点:==</p><blockquote><p>变长数组具有浑然天成的语法. 变长数组和 <code>alloca()</code>也都很高效.</p></blockquote><p>==缺点:==</p><blockquote><p>变长数组和 <code>alloca()</code> 不是标准 C++ 的组成部分. 更重要的是,它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs:“在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</p></blockquote><p>==结论:==</p><blockquote><p>改用更安全的分配器（allocator），就像 <code>std::vector</code> 或<code>std::unique_ptr</code>.</p></blockquote><h3 id="友元">6.6. 友元</h3><p>==Tip==</p><p>我们允许合理的使用友元类及友元函数.</p><p>通常友元应该定义在同一文件内,避免代码读者跑到其它文件查找使用该私有成员的类.经常用到友元的一个地方是将 <code>FooBuilder</code> 声明为<code>Foo</code> 的友元, 以便 <code>FooBuilder</code> 正确构造<code>Foo</code> 的内部状态, 而无需将该状态暴露出来. 某些情况下,将一个单元测试类声明成待测类的友元会很方便.</p><p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下,相对于将类成员声明为 <code>public</code>, 使用友元是更好的选择,尤其是如果你只允许另一个类访问该类的私有成员时. 当然,大多数类都只应该通过其提供的公有成员进行互操作.</p><h3 id="异常">6.7. 异常</h3><p>==Tip==</p><p>我们不使用 C++ 异常.</p><p>==优点:==</p><blockquote><ul><li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li><li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类C++ 的语言更一脉相承。</li><li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li><li>异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或<code>Init()</code> 方法代替异常,但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“状态。</li><li>在测试框架里很好用。</li></ul></blockquote><p>==缺点:==</p><blockquote><ul><li>在现有函数中添加 <code>throw</code>语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，<code>f()</code>调用 <code>g()</code>, <code>g()</code> 又调用 <code>h()</code>, 且<code>h</code> 抛出的异常被 <code>f</code> 捕获。当心 <code>g</code>,否则会没妥善清理好。</li><li>还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li><li>异常安全需要RAII和不同的编码实践.要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说,为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交”状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码).如果允许使用异常, 我们就不得不时刻关注这样的弊端,即使有时它们并不值得.</li><li>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。</li><li>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li></ul></blockquote><p>==结论:==</p><blockquote><p>从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码,引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散,在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p><p>鉴于 Google 现有代码不接受异常,在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢,也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码,断言等会造成严重负担.</p><p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上.我们希望在 Google 使用我们自己的开源项目,但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p><p>对于 Windows 代码来说, 有个 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/exceptions/##windows-code">特例</a>.</p></blockquote><p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的,以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理,Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了,无非是基于软件管理成本上, 实际使用中还是自己决定)</p><h3 id="运行时类型识别">6.8. 运行时类型识别</h3><p>==Tip==</p><p>我们禁止使用 RTTI.</p><p>==定义:==</p><blockquote><p>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用<code>typeid</code> 或者 <code>dynamic_cast</code> 完成.</p></blockquote><p>==优点:==</p><blockquote><p>RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构.有时这样的修改并不是我们所想要的, 甚至是不可取的,尤其是在一个已经广泛使用的或者成熟的代码中.</p><p>RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时,用来验证一个新建对象是否为期望的动态类型. RTTI对于管理对象和派生对象的关系也很有用.</p><p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Base::Equal</span><span class="params">(Base* other)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Derived::Equal</span><span class="params">(Base* other)</span> </span>&#123;</span><br><span class="line">  Derived* that = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(other);</span><br><span class="line">  <span class="keyword">if</span> (that == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>==缺点:==</p><blockquote><p>在运行时判断类型通常意味着设计问题.如果你需要在运行期间确定一个对象的类型,这通常说明你需要考虑重新设计你的类.</p><p>随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p></blockquote><p>==结论:==</p><blockquote><p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意.在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中,使用 RTTI 前务必三思.如果你的代码需要根据不同的对象类型执行不同的行为的话,请考虑用以下的两种替代方案之一查询类型:</p><p>虚函数可以根据子类类型的不同而执行不同代码.这是把工作交给了对象本身去处理.</p><p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案,例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p><p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例,那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast也是一种替代方案.</p><p>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了.不要像下面这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D1)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D2)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D3)) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且,一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p><p>不要去手工实现一个类似 RTTI 的方案. 反对 RTTI的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且,这些方案会掩盖你的真实意图.</p></blockquote><h3 id="类型转换">6.9. 类型转换</h3><p>==Tip==</p><p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用<code>int y = (int)x</code> 或 <code>int y = int(x)</code>等转换方式;</p><p>==定义:==</p><blockquote><p>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</p></blockquote><p>==优点:==</p><blockquote><p>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如<code>(int)3.5</code>), 有时是在做类型转换 (如<code>(int)"hello"</code>). 另外, C++ 的类型转换在查找时更醒目.</p></blockquote><p>==缺点:==</p><blockquote><p>恶心的语法.</p></blockquote><p>==结论:==</p><blockquote><p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p><blockquote><ul><li>用 <code>static_cast</code> 替代 C 风格的值转换,或某个类指针需要明确的向上转换为父类指针时.</li><li>用 <code>const_cast</code> 去掉 <code>const</code> 限定符.</li><li>用 <code>reinterpret_cast</code>指针类型和整型或其它指针之间进行不安全的相互转换.仅在你对所做一切了然于心时使用.</li></ul></blockquote><p>至于 <code>dynamic_cast</code> 参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##rtti">6.8.运行时类型识别</a>.</p></blockquote><h3 id="流">6.10. 流</h3><p>==Tip==</p><p>只在记录日志时使用流.</p><p>==定义:==</p><blockquote><p>流用来替代 <code>printf()</code> 和 <code>scanf()</code>.</p></blockquote><p>==优点:==</p><blockquote><p>有了流, 在打印时不需要关心对象的类型.不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用<code>printf</code> 也不存在这个问题).流的构造和析构函数会自动打开和关闭对应的文件.</p></blockquote><p>==缺点:==</p><blockquote><p>流使得 <code>pread()</code> 等功能函数很难执行. 如果不使用<code>printf</code> 风格的格式化字符串, 某些格式化操作(尤其是常用的格式字符串 <code>%.*s</code>) 用流处理性能是很低的.流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</p></blockquote><p>==结论:==</p><blockquote><p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code>之类的代替.</p><p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p></blockquote><p>==拓展讨论:==</p><blockquote><p>对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则(Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型,使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是<code>printf + read/write</code>. 相反, 我们应该决定到底用哪一种方式.把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p><p>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力.他们指出的流的每个优势也都是其劣势.流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时,也是一个不足: 你很容易用错类型, 而编译器不会报警.使用流时容易造成的这类错误:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="keyword">this</span>;   <span class="comment">// 输出地址</span></span><br><span class="line">cout &lt;&lt; *<span class="keyword">this</span>;  <span class="comment">// 输出值</span></span><br></pre></td></tr></table></figure></blockquote><p>由于 <code>&lt;&lt;</code> 被重载, 编译器不会报错.就因为这一点我们反对使用操作符重载.</p><p>有人说 <code>printf</code> 的格式化丑陋不堪, 易读性差,但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p><blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cerr &lt;&lt; <span class="string">&quot;Error connecting to &#x27;&quot;</span> &lt;&lt; foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.first</span><br><span class="line">     &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.second &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; strerror(errno);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">&quot;Error connecting to &#x27;%s:%u: %s&quot;</span>,</span><br><span class="line">        foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.first, foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.second,</span><br><span class="line">        strerror(errno));</span><br></pre></td></tr></table></figure></blockquote><p>你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢?而且不要忘了, 我们的目标是使语言更紧凑,而不是添加一些别人需要学习的新装备.</p><p>每一种方式都是各有利弊, “没有最好, 只有更适合”.简单性原则告诫我们必须从中选择其一, 最后大多数决定采用<code>printf + read/write</code>.</p></blockquote><h3 id="前置自增和自减">6.11. 前置自增和自减</h3><p>==Tip==</p><p>对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增,自减运算符.</p><p>==定义:==</p><blockquote><p>对于变量在自增 (<code>++i</code> 或 <code>i++</code>) 或自减(<code>--i</code> 或 <code>i--</code>) 后表达式的值又没有没用到的情况下,需要确定到底是使用前置还是后置的自增 (自减).</p></blockquote><p>==优点:==</p><blockquote><p>不考虑返回值的话, 前置自增 (<code>++i</code>) 通常要比后置自增(<code>i++</code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值<code>i</code> 进行一次拷贝. 如果 <code>i</code>是迭代器或其他非数值类型, 拷贝的代价是比较大的.既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</p></blockquote><p>==缺点:==</p><blockquote><p>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增,特别是在 <code>for</code> 循环中. 有些人觉得后置自增更加易懂,因为这很像自然语言, 主语 (<code>i</code>) 在谓语动词 (<code>++</code>)前.</p></blockquote><p>==结论:==</p><blockquote><p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增(自减).</p></blockquote><h3 id="const-用法">6.12. <code>const</code> 用法</h3><p>==Tip==</p><p>我们强烈建议你在任何可能的情况下都要使用 <code>const</code>.此外有时改用 C++11 推出的 constexpr 更好。</p><p>==定义:==</p><blockquote><p>在声明的变量或参数前加上关键字 <code>const</code>用于指明变量值不可被篡改 (如 <code>const int foo</code> ).为类中的函数加上 <code>const</code>限定符表明该函数不会修改类成员变量的状态 (如<code>class Foo &#123; int Bar(char c) const; &#125;;</code>).</p></blockquote><p>==优点:==</p><blockquote><p>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地,也能生成更好的代码. 人们对编写正确的代码更加自信,因为他们知道所调用的函数被限定了能或不能修改变量值.即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</p></blockquote><p>==缺点:==</p><blockquote><p><code>const</code> 是入侵性的: 如果你向一个函数传入<code>const</code> 变量, 函数原型声明中也必须对应 <code>const</code>参数 (否则变量需要 <code>const_cast</code> 类型转换),在调用库函数时显得尤其麻烦.</p></blockquote><p>==结论:==</p><blockquote><p><code>const</code> 变量, 数据成员,函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此,我们强烈建议在任何可能的情况下使用 <code>const</code>:</p><blockquote><ul><li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为<code>const</code>.</li><li>尽可能将函数声明为 <code>const</code>. 访问函数应该总是<code>const</code>. 其他不会修改任何数据成员, 未调用非<code>const</code> 函数, 不会返回数据成员非 <code>const</code>指针或引用的函数也应该声明成 <code>const</code>.</li><li>如果数据成员在对象构造之后不再发生变化, 可将其定义为<code>const</code>.</li></ul></blockquote><p>然而, 也不要发了疯似的使用 <code>const</code>. 像<code>const int * const * const x;</code> 就有些过了,虽然它非常精确的描述了常量 <code>x</code>. 关注真正有帮助意义的信息:前面的例子写成 <code>const int** x</code> 就够了.</p><p>关键字 <code>mutable</code> 可以使用, 但是在多线程中是不安全的,使用时首先要考虑线程安全.</p></blockquote><p><code>const</code> 的位置:</p><blockquote><p>有人喜欢 <code>int const *foo</code> 形式, 不喜欢<code>const int* foo</code>, 他们认为前者更一致因此可读性也更好: 遵循了<code>const</code> 总位于其描述的对象之后的原则.但是一致性原则不适用于此, “不要过度使用”的声明可以取消大部分你原本想保持的一致性. 将 <code>const</code>放在前面才更易读, 因为在自然语言中形容词 (<code>const</code>) 是在名词(<code>int</code>) 之前.</p><p>这是说, 我们提倡但不强制 <code>const</code> 在前.但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把<code>const</code> 写在类型前面, 在其他地方又写在后面, 确定一种写法,然后保持一致.)</p></blockquote><h3 id="constexpr-用法">6.13. <code>constexpr</code> 用法</h3><p>==Tip==</p><p>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><p>==定义:==</p><blockquote><p>变量可以被声明成 constexpr以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成constexpr, 以用来定义 constexpr 变量。</p></blockquote><p>==优点:==</p><blockquote><p>如今 constexpr就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p></blockquote><p>==缺点:==</p><blockquote><p>若过早把变量优化成 constexpr变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</p></blockquote><p>==结论:==</p><blockquote><p>靠 constexpr 特性，方才实现了 C++在接口上打造真正常量机制的可能。好好用 constexpr来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</p></blockquote><h3 id="整型">6.14. 整型</h3><p>==Tip==</p><p>C++ 内建整型中, 仅使用 <code>int</code>.如果程序中需要不同大小的变量, 可以使用`<code>中长度精确的整型, 如</code>int16_t<code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如</code>int64_t`.此外要留意，哪怕您的值并不会超出 int所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p><p>==定义:==</p><blockquote><p>C++ 没有指定整型的大小. 通常人们假定 <code>short</code> 是 16 位,<code>int</code> 是 32 位, <code>long</code> 是 32 位,<code>long long</code> 是 64 位.</p></blockquote><p>==优点:==</p><blockquote><p>保持声明统一.</p></blockquote><p>==缺点:==</p><blockquote><p>C++ 中整型大小因编译器和体系结构的不同而不同.</p></blockquote><p>==结论:==</p><blockquote><p>`<code>定义了</code>int16_t<code>,</code>uint32_t<code>,</code>int64_t<code>等整型, 在需要确保整型大小时可以使用它们代替</code>short<code>,</code>unsignedlonglong<code>等. 在 C 整型中, 只使用</code>int<code>. 在合适的情况下, 推荐使用标准类型如</code>size_t<code>和</code>ptrdiff_t`.</p><p>如果已知整数不会太大, 我们常常会使用 <code>int</code>, 如循环计数.在类似的情况下使用原生类型 <code>int</code>. 你可以认为 <code>int</code>至少为 32 位, 但不要认为它会多于 <code>32</code> 位. 如果需要 64 位整型,用 <code>int64_t</code> 或 <code>uint64_t</code>.</p><p>对于大整数, 使用 <code>int64_t</code>.</p><p>不要使用 <code>uint32_t</code> 等无符号整型,除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出.尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反,你应该使用断言来保护数据.</p><p>如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p><p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如<code>int</code> 与 <code>unsigned int</code> 运算时，前者被提升为<code>unsigned int</code> 而有可能溢出），总有意想不到的后果。</p></blockquote><p>关于无符号整数:</p><blockquote><p>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数.这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug所淹没. 看看下面的例子:</p><blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for <span class="params">(unsigned int <span class="attr">i</span> = foo.Length()</span>-1; i &gt;= 0; <span class="params">--i</span>) <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警,但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时.主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p><p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p></blockquote><h3 id="位下的可移植性">6.15. 64 位下的可移植性</h3><p>==Tip==</p><p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较,结构体对齐时应切记:</p><ul><li><p>对于某些类型, <code>printf()</code> 的指示符在 32 位和 64位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符.不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏,所以有时我们不得不自己定义一个丑陋的版本 (头文件 <code>inttypes.h</code>仿标准风格):</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf macros for size_t, in the style of inttypes.h</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> _LP64</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> __PRIS_PREFIX <span class="string">&quot;z&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> __PRIS_PREFIX</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use these macros after a % in a printf format string</span></span><br><span class="line"><span class="comment">// to get correct 32/64 bit behavior, like this:</span></span><br><span class="line"><span class="comment">// size_t size = records.size();</span></span><br><span class="line"><span class="comment">// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIdS __PRIS_PREFIX <span class="string">&quot;d&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIxS __PRIS_PREFIX <span class="string">&quot;x&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIuS __PRIS_PREFIX <span class="string">&quot;u&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIXS __PRIS_PREFIX <span class="string">&quot;X&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIoS __PRIS_PREFIX <span class="string">&quot;o&quot;</span></span></span><br></pre></td></tr></table></figure><table><colgroup><col style="width: 32%" /><col style="width: 21%" /><col style="width: 28%" /><col style="width: 17%" /></colgroup><thead><tr class="header"><th>类型</th><th>不要使用</th><th>使用</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><code>void *</code> (或其他指针类型)</td><td><code>%lx</code></td><td><code>%p</code></td><td></td></tr><tr class="even"><td><code>int64_t</code></td><td><code>%qd, %lld</code></td><td><code>%"PRId64"</code></td><td></td></tr><tr class="odd"><td><code>uint64_t</code></td><td><code>%qu, %llu, %llx</code></td><td><code>%"PRIu64", %"PRIx64"</code></td><td></td></tr><tr class="even"><td><code>size_t</code></td><td><code>%u</code></td><td><code>%"PRIuS", %"PRIxS"</code></td><td>C99 规定 <code>%zu</code></td></tr><tr class="odd"><td><code>ptrdiff_t</code></td><td><code>%d</code></td><td><code>%"PRIdS"</code></td><td>C99 规定 <code>%zd</code></td></tr></tbody></table><p>注意 <code>PRI*</code> 宏会被编译器扩展为独立字符串.因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用<code>PRI*</code> 宏同样可以在 <code>%</code> 后包含长度指示符. 例如,<code>printf("x = %30"PRIuS"\n", x)</code> 在 32 位 Linux 上将被展开为<code>printf("x = %30" "u" "\n", x)</code>, 编译器当成<code>printf("x = %30u\n", x)</code> 处理 (Yang.Y 注: 这在 MSVC 6.0上行不通, VC 6编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p></blockquote></li><li><p>记住 <code>sizeof(void *) != sizeof(int)</code>.如果需要一个指针大小的整数要用 <code>intptr_t</code>.</p></li><li><p>你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体(Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64位系统中, 任何含有 <code>int64_t</code>/<code>uint64_t</code>成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致.大多数编译器都允许调整结构体对齐. gcc 中可使用<code>__attribute__((packed))</code>. MSVC 则提供了<code>##pragma pack()</code> 和 <code>__declspec(align())</code>(YuleFox 注, 解决方案的项目属性里也可以直接设置).</p></li><li><p>创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> my_value = <span class="number">0x123456789</span>LL;</span><br><span class="line"><span class="type">uint64_t</span> my_mask = <span class="number">3ULL</span> &lt;&lt; <span class="number">48</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用<code>##ifdef _LP64</code> 指令来切分 32/64 位代码. (尽量不要这么做,如果非用不可, 尽量使修改局部化)</p></li></ul><h3 id="预处理宏">6.16. 预处理宏</h3><p>==Tip==</p><p>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p><p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为,尤其因为宏具有全局作用域.</p><p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少.以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被<code>const</code> 变量代替. 用宏 “缩写” 长变量名可被引用代替.用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦(<code>##define</code> 防止头文件重包含当然是个特例).</p><p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中)可以看到宏的某些特性 (如用 <code>##</code> 字符串化, 用 <code>###</code>连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p><p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏,尽可能遵守:</p><blockquote><ul><li>不要在 <code>.h</code> 文件中定义宏.</li><li>在马上要使用时才进行 <code>##define</code>, 使用后要立即<code>##undef</code>.</li><li>不要只是对已经存在的宏使用##undef，选择一个不会冲突的名称；</li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏,不然也至少要附上文档说明其行为.</li><li>不要用 <code>###</code> 处理函数，类和变量的名字。</li></ul></blockquote><h3 id="nullptr-和-null">6.17. 0, <code>nullptr</code> 和<code>NULL</code></h3><p>==Tip==</p><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用<code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用<code>'\0'</code>.</p><p>整数用 <code>0</code>, 实数用 <code>0.0</code>,这一点是毫无争议的.</p><p>对于指针 (地址值), 到底是用 <code>0</code>, <code>NULL</code> 还是<code>nullptr</code>. C++11 项目用 <code>nullptr</code>; C++03 项目则用<code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对<code>NULL</code> 的定义比较特殊，可以输出有用的警告，特别是<code>sizeof(NULL)</code> 就和 <code>sizeof(0)</code> 不一样。</p><p>字符 (串) 用 <code>'\0'</code>, 不仅类型正确而且可读性好.</p><h3 id="sizeof">6.18. sizeof</h3><p>==Tip==</p><p>尽可能用 <code>sizeof(varname)</code> 代替<code>sizeof(type)</code>.</p><p>使用 <code>sizeof(varname)</code>是因为当代码中变量类型改变时会自动更新. 您或许会用<code>sizeof(type)</code>处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Struct data;</span><br><span class="line">Struct data; <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));</span><br></pre></td></tr></table></figure><p>==Warning==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(Struct));</span><br><span class="line"><span class="keyword">if</span> (raw_size &lt; <span class="built_in">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;compressed record not big enough for count: &quot;</span> &lt;&lt; raw_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="auto">6.19. auto</h3><p>==Tip==</p><p>用 <code>auto</code>绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p><p>==定义：==</p><blockquote><p>C++11 中，若变量被声明成 <code>auto</code>,那它的类型就会被自动匹配成初始化表达式的类型。您可以用 <code>auto</code>来复制初始化或绑定引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>];  <span class="comment">// 创建一份 v[0] 的拷贝。</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>];  <span class="comment">// s2 是 v[0] 的一个引用。</span></span><br></pre></td></tr></table></figure></blockquote><p>==优点：==</p><blockquote><p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sparse_hash_map&lt;string, <span class="type">int</span>&gt;::iterator iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure><p>返回类型好难读，代码目的也不够一目了然。重构其：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure><p>好多了。</p><p>没有 <code>auto</code>的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br></pre></td></tr></table></figure><p>有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p></blockquote><p>==缺点：==</p><blockquote><p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = x.<span class="built_in">Lookup</span>(key);</span><br></pre></td></tr></table></figure><p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p><p>程序员必须会区分 <code>auto</code> 和 <code>const auto&amp;</code>的不同之处，否则会复制错东西。</p><p>auto 和 C++11 列表初始化的合体令人摸不着头脑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 圆括号。</span></span><br><span class="line"><span class="keyword">auto</span> y&#123;<span class="number">3</span>&#125;;  <span class="comment">// 大括号。</span></span><br></pre></td></tr></table></figure><p>它们不是同一回事——<code>x</code> 是 <code>int</code>, <code>y</code>则是 <code>std::initializer_list</code>.其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types,它涉及到 C++ 鲜为人知的坑：<ahref="http://stackoverflow.com/a/17794965/1546088">Why is vector not aSTL container?</a>）也有大同小异的陷阱。</p><p>如果在接口里用 <code>auto</code>,比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API要翻天覆地了。</p></blockquote><p>结论：</p><blockquote><p><code>auto</code>只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化<code>auto</code> 变量。</p><p><code>auto</code> 还可以和 C++11 特性「尾置返回类型（trailing returntype）」一起用，不过后者只能用在 lambda 表达式里。</p></blockquote><h3 id="列表初始化">6.20. 列表初始化</h3><p>==Tip==</p><p>你可以用列表初始化。</p><p>早在 C++03 里，聚合类型（aggregatetypes）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line">Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>C++11中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector 接收了一个初始化列表。</span></span><br><span class="line">vector&lt;string&gt; v&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不考虑细节上的微妙差别，大致上相同。</span></span><br><span class="line"><span class="comment">// 您可以任选其一。</span></span><br><span class="line">vector&lt;string&gt; v = &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以配合 new 一起用。</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> vector&lt;string&gt;&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 接收了一些 pair, 列表初始化大显神威。</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表也可以用在返回类型上的隐式转换。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表可迭代。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用里用列表初始化。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">TestFunction2</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>用户自定义类型也可以定义接收 <code>std::initializer_list</code>的构造函数和赋值运算符，以自动列表初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// std::initializer_list 专门接收 init 列表。</span></span><br><span class="line">  <span class="comment">// 得以值传递。</span></span><br><span class="line">  <span class="built_in">MyType</span>(std::initializer_list&lt;<span class="type">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  MyType&amp; <span class="keyword">operator</span>=(std::initializer_list&lt;<span class="type">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyType m&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收<code>std::initializer_list</code> 的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="comment">// MyOtherType 没有 std::initializer_list 构造函数，</span></span><br><span class="line"> <span class="comment">// 直接上接收常规类型的构造函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOtherType</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyOtherType</span><span class="params">(string)</span></span>;</span><br><span class="line">  <span class="built_in">MyOtherType</span>(<span class="type">int</span>, string);</span><br><span class="line">&#125;;</span><br><span class="line">MyOtherType m = &#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。</span></span><br><span class="line">MyOtherType m&#123;<span class="string">&quot;b&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p><p>==Warning==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;        <span class="comment">// d 即是 std::initializer_list&lt;double&gt;</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="type">double</span>&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// 善哉 -- d 即为 double, 并非 std::initializer_list.</span></span><br></pre></td></tr></table></figure><p>至于格式化，参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##braced-initializer-list-format">9.7.列表初始化格式</a>.</p><h3 id="lambda-表达式">6.21. Lambda 表达式</h3><p>==Tip==</p><p>适当使用 lambda 表达式。别用默认 lambda捕获，所有捕获都要显式写出来。</p><p>==定义：==</p><blockquote><p>Lambda表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Weight</span>(x) &lt; <span class="built_in">Weight</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>C++11 首次提出 Lambdas,还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper）<code>std::function</code>.</p></blockquote><p>==优点：==</p><blockquote><ul><li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li><li>Lambdas, <code>std::functions</code> 和 <code>std::bind</code>可以搭配成通用回调机制（general purpose callbackmechanism）；写接收有界函数为参数的函数也很容易了。</li></ul></blockquote><p>==缺点：==</p><blockquote><ul><li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li><li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li></ul></blockquote><p>==结论：==</p><blockquote><ul><li>按 format 小用 lambda 表达式怡情。</li><li>禁用默认捕获，捕获都要显式写出来。打比方，比起<code>[=](int x) &#123;return x + n;&#125;</code>, 您该写成<code>[n](int x) &#123;return x + n;&#125;</code> 才对，这样读者也好一眼看出<code>n</code> 是被捕获的值。</li><li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant注：即把 lambda 表达式赋值给对象），或改用函数。</li><li>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</li></ul></blockquote><h3 id="模板编程">6.22. 模板编程</h3><p>==Tip==</p><p>不要使用复杂的模板编程</p><p>==定义:==</p><blockquote><p>模板编程指的是利用c++ 模板实例化机制是图灵完备性,可以被用来实现编译时刻的类型判断的一系列编程技巧</p></blockquote><p>==优点:==</p><blockquote><p>模板编程能够实现非常灵活的类型安全的接口和极好的性能,一些常见的工具比如Google Test, std::tuple, std::function 和Boost.Spirit. 这些工具如果没有模板是实现不了的</p></blockquote><p>==缺点:==</p><blockquote><ul><li>模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩, 难懂的.在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和维护起来都很麻烦</li><li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候,即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示.导致这个编译出错信息看起来非常难以理解.</li><li>大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor forC++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来,所以很难确认重构对所有的这些展开的代码有用,其次有些重构工具只对已经做过模板类型替换的代码的AST 有用.因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li></ul></blockquote><p>==结论:==</p><blockquote><ul><li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反.因此模板编程最好只用在少量的基础组件, 基础数据结构上,因为模板带来的额外的维护成本会被大量的使用给分担掉</li><li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下.考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非c++程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程.如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板,或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载,那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</li><li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化,并且尽量不要让模板对外暴漏. 你最好只在实现里面使用模板,然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性.并且你应该在这些使用模板的代码上写尽可能详细的注释.你的注释里面应该详细的包含这些代码是怎么用的,这些模板生成出来的代码大概是什么样子的.还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息.因为这些出错信息也是你的接口的一部分,所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解,并且用户很容易知道如何修改这些错误</li></ul></blockquote><h3 id="boost-库">6.23. Boost 库</h3><p>==Tip==</p><p>只使用 Boost 中被认可的库.</p><p>==定义:==</p><blockquote><p><a href="http://www.boost.org/">Boost 库集</a> 是一个广受欢迎,经过同行鉴定, 免费开源的 C++ 库集.</p></blockquote><p>==优点:==</p><blockquote><p>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白,如型别的特性, 更完善的绑定器, 更好的智能指针。</p></blockquote><p>==缺点:==</p><blockquote><p>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术,以及过度 “函数化” 的编程风格.</p></blockquote><p>==结论:==</p><blockquote><p>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost一部分经认可的特性子集. 目前允许使用以下库:</p><blockquote><ul><li><ahref="http://www.boost.org/doc/libs/1_58_0/libs/utility/call_traits.htm">CallTraits</a> : <code>boost/call_traits.hpp</code></li><li><ahref="http://www.boost.org/libs/utility/compressed_pair.htm">CompressedPair</a> : <code>boost/compressed_pair.hpp</code></li><li>[ : <code>boost/graph</code>, except serialization(<code>adj_list_serialize.hpp</code>) and parallel/distributedalgorithms and data structures(<code>boost/graph/parallel/*</code> and<code>boost/graph/distributed/*</code>)</li><li><a href="http://www.boost.org/libs/property_map/">Property Map</a> :<code>boost/property_map.hpp</code></li><li>The part of <ahref="http://www.boost.org/libs/iterator/">Iterator</a> that deals withdefining iterators: <code>boost/iterator/iterator_adaptor.hpp</code>,<code>boost/iterator/iterator_facade.hpp</code>, and<code>boost/function_output_iterator.hpp</code></li><li>The part of <a href="http://www.boost.org/libs/polygon/">Polygon</a>that deals with Voronoi diagram construction and doesn’t depend on therest of Polygon: <code>boost/polygon/voronoi_builder.hpp</code>,<code>boost/polygon/voronoi_diagram.hpp</code>, and<code>boost/polygon/voronoi_geometry_type.hpp</code></li><li><a href="http://www.boost.org/libs/bimap/">Bimap</a> :<code>boost/bimap</code></li><li><ahref="http://www.boost.org/libs/math/doc/html/dist.html">StatisticalDistributions and Functions</a> :<code>boost/math/distributions</code></li><li><a href="http://www.boost.org/libs/multi_index/">Multi-index</a> :<code>boost/multi_index</code></li><li><a href="http://www.boost.org/libs/heap/">Heap</a> :<code>boost/heap</code></li><li>The flat containers from <ahref="http://www.boost.org/libs/container/">Container</a>:<code>boost/container/flat_map</code>, and<code>boost/container/flat_set</code></li></ul></blockquote><p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p><p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p><blockquote><ul><li><a href="http://www.boost.org/libs/ptr_container/">PointerContainer</a> : <code>boost/ptr_container</code>, 改用 <ahref="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></li><li><a href="http://www.boost.org/libs/array/">Array</a> :<code>boost/array.hpp</code>, 改用 <ahref="http://en.cppreference.com/w/cpp/container/array">std::array</a></li></ul></blockquote></blockquote><h3 id="c11">6.24. C++11</h3><p>==Tip==</p><p>适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11特性前三思可移植性。</p><p>==定义：==</p><blockquote><p>C++11有众多语言和库上的<code>变革 &lt;https://en.wikipedia.org/wiki/C%2B%2B11&gt;</code>_。</p></blockquote><p>==优点：==</p><blockquote><p>在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++编译器支持。它标准化很多我们早先就在用的 C++扩展，简化了不少操作，大大改善了性能和安全。</p></blockquote><p>==缺点：==</p><blockquote><p>C++11 相对于前身，复杂极了：1300 页 vs 800页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p><p>和 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##boost">6.23.Boost 库</a> 一样，有些 C++11扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p></blockquote><p>==缺点：==</p><blockquote><p>C++11特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11特性之外，以下特性最好不要用：</p><ul><li>尾置返回类型，比如用 <code>auto foo() -&gt; int</code> 代替<code>int foo()</code>. 为了兼容于现有代码的声明风格。</li><li>编译时合数 ``, 因为它涉及一个重模板的接口风格。</li><li><code>和</code> 头文件，因为编译器尚不支持。</li><li>默认 lambda 捕获。</li></ul></blockquote><h3 id="译者acgtyrant笔记-3">译者（acgtyrant）笔记</h3><ol type="1"><li>实际上，<ahref="http://www.zhihu.com/question/24439516/answer/27858964">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把<code>void a()</code> 改成 <code>void a(int b = 0)</code>,开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选int参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li><li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li><li>我还发现 <ahref="http://www.zhihu.com/question/24439516/answer/27896004">滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。</a></li><li><code>friend</code>实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的<code>.cc</code> 文件加以定义。</li><li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li><li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##declaration-order">声明顺序</a>。</li><li><a href="http://www.zhihu.com/question/22889420">对使用 C++异常处理应具有怎样的态度？</a> 非常值得一读。</li><li>注意初始化 const 对象时，必须在初始化的同时值初始化。</li><li>用断言代替无符号整型类型，深有启发。</li><li>auto 在涉及迭代器的循环语句里挺常用。</li><li><ahref="http://stackoverflow.com/questions/11215227/should-the-trailing-return-type-syntax-style-become-the-default-for-new-c11-pr">Shouldthe trailing return type syntax style become the default for new C++11programs?</a> 讨论了 auto与尾置返回类型一起用的全新编码风格，值得一看。</li></ol></div><div class="story post-story"><h2 id="命名约定">7. 命名约定</h2><p>最重要的一致性规则是命名管理.命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义:类型, 变量, 函数, 常量, 宏, 等等, 甚至.我们大脑中的模式匹配引擎非常依赖这些命名规则.</p><p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要,所以无论你认为它们是否重要, 规则总归是规则.</p><h3 id="通用命名规则">7.1. 通用命名规则</h3><p><strong>总述</strong></p><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p><p><strong>说明</strong></p><p>尽可能使用描述性的命名, 别心疼空间,毕竟相比之下让代码易于新读者理解更重要.不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="type">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br><span class="line"><span class="type">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="type">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="type">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="type">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure><p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code>表示迭代变量和用 <code>T</code> 表示模板参数.</p><p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##type-names">类型命名</a>的规则, 而非类型模板应当遵循 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##variable-names">变量命名</a>的规则.</p><h3 id="文件命名">7.2. 文件命名</h3><p><strong>总述</strong></p><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符(<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>”更好.</p><p><strong>说明</strong></p><p>可接受的文件命名示例:</p><ul><li><code>my_useful_class.cc</code></li><li><code>my-useful-class.cc</code></li><li><code>myusefulclass.cc</code></li><li><code>myusefulclass_test.cc</code> // <code>_unittest</code> 和<code>_regtest</code> 已弃用.</li></ul><p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾.专门插入文本的文件则以 <code>.inc</code> 结尾, 参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##self-contained-headers">头文件自足</a>.</p><p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注:即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p><p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比<code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如<code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类<code>FooBar</code>.</p><p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短,就直接放在 <code>.h</code> 中.</p><h3 id="类型命名">7.3. 类型命名</h3><p><strong>总述</strong></p><p>类型名称的每个单词首字母均大写, 不包含下划线:<code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p><p><strong>说明</strong></p><p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举,类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写,不包含下划线. 例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTable</span> &#123; ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTableTester</span> &#123; ...</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123; ...</span><br></pre></td></tr></table></figure><h3 id="变量命名">7.4. 变量命名</h3><p><strong>总述</strong></p><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接.类的成员变量以下划线结尾, 但结构体的就不用, 如:<code>a_local_variable</code>, <code>a_struct_data_member</code>,<code>a_class_data_member_</code>.</p><p><strong>说明</strong></p><h6 id="普通变量命名">普通变量命名</h6><p>举例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line">string tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line">string tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure><h6 id="类数据成员">类数据成员</h6><p>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样,但要接下划线.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  string tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="type">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="结构体变量">结构体变量</h6><p>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样,不用像类那样接下划线:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> num_entries;</span><br><span class="line">  <span class="type">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体与类的使用讨论, 参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##structs-vs-classes">结构体vs. 类</a>.</p><h3 id="常量命名">7.5. 常量命名</h3><p><strong>总述</strong></p><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量,或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合.例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 <ahref="http://en.cppreference.com/w/cpp/language/storage_duration##Storage_duration">存储类型</a>)都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等,这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p><h3 id="函数命名">7.6. 函数命名</h3><p><strong>总述</strong></p><p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配:<code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>,<code>my_exciting_member_variable()</code>,<code>set_my_exciting_member_variable()</code>.</p><p><strong>说明</strong></p><p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或“帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词,更倾向于将它们视作一个单词进行首字母大写 (例如, 写作<code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AddTableEntry</span>()</span><br><span class="line"><span class="built_in">DeleteUrl</span>()</span><br><span class="line"><span class="built_in">OpenFileOrDie</span>()</span><br></pre></td></tr></table></figure><p>(同样的命名规则同时适用于类作用域与命名空间作用域的常量,因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数,因为在这时,它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p><p>取值和设值函数的命名与变量一致.一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如<code>int count()</code> 与 <code>void set_count(int count)</code>.</p><h3 id="命名空间命名">7.7. 命名空间命名</h3><p><strong>总述</strong></p><p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称.要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p><p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字.命名空间中的代码,应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p><p>注意 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##general-naming-rules">不使用缩写作为名称</a>的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称,因此没有必要在命名空间中使用缩写.</p><p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突.由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败.尤其是, 不要创建嵌套的 <code>std</code> 命名空间.建议使用更独特的项目标识符 (<code>websearch::index</code>,<code>websearch::index_util</code>) 而非常见的极易发生冲突的名称 (比如<code>websearch::util</code>).</p><p>对于 <code>internal</code> 命名空间, 要当心加入到同一<code>internal</code> 命名空间的代码之间发生冲突(由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下,请使用文件名以使得内部名称独一无二 (例如对于 <code>frobber.h</code>,使用 <code>websearch::index::frobber_internal</code>).</p><h3 id="枚举命名">7.8. 枚举命名</h3><p><strong>总述</strong></p><p>枚举的命名应当和 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量</a>或 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a>一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p><p><strong>说明</strong></p><p>单独的枚举值应该优先采用 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量</a>的命名方式. 但 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a>方式的命名也可以接受. 枚举名 <code>UrlTableErrors</code> (以及<code>AlternateUrlTableErrors</code>) 是类型,所以要用大小写混合的方式.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123;</span><br><span class="line">    kOK = <span class="number">0</span>,</span><br><span class="line">    kErrorOutOfMemory,</span><br><span class="line">    kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AlternateUrlTableErrors</span> &#123;</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2009 年 1 月之前, 我们一直建议采用 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a>的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题.由此, 这里改为优先选择常量风格的命名方式.新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格,除非宏风格确实会产生编译期问题.</p><h3 id="宏命名">7.9. 宏命名</h3><p><strong>总述</strong></p><p>你并不打算 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##preprocessor-macros">使用宏</a>,对吧? 如果你一定要用, 像这样命名:<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p><p><strong>说明</strong></p><p>参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##preprocessor-macros">预处理宏</a>;通常 <em>不应该</em> 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写,使用下划线:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROUND(x) ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure><h3 id="命名规则的特例">7.10. 命名规则的特例</h3><p><strong>总述</strong></p><p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p><p><code>bigopen()</code>: 函数名, 参照 <code>open()</code> 的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint`: `<span class="keyword">typedef</span></span><br></pre></td></tr></table></figure><p><code>bigpos</code>: <code>struct</code> 或 <code>class</code>, 参照<code>pos</code> 的形式</p><p><code>sparse_hash_map</code>: STL 型实体; 参照 STL 命名约定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LONGLONG_MAX`: 常量, 如同 `INT_MAX</span><br></pre></td></tr></table></figure><h3 id="译者acgtyrant笔记-4">译者（acgtyrant）笔记</h3><ol type="1"><li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult,接着又可以直接定义一个变量 query_result, 区分度很好; 再次,类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如<code>TextQuery::TextQuery(std::string word) : word_(word) &#123;&#125;</code> ,其中 <code>word_</code> 自然是类内私有成员.</li></ol></div><div class="story post-story"><h2 id="注释">8. 注释</h2><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要.下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要,但最好的代码应当本身就是文档. 有意义的类型名和变量名,要远胜过要用注释解释的含糊不清的名字.</p><p>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人.所以慷慨些吧, 下一个读者可能就是你!</p><h3 id="注释风格">8.1. 注释风格</h3><p><strong>总述</strong></p><p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p><p><strong>说明</strong></p><p><code>//</code> 或 <code>/* */</code> 都可以; 但 <code>//</code><em>更</em> 常用. 要在如何注释及注释风格上确保统一.</p><h3 id="文件注释">8.2. 文件注释</h3><p><strong>总述</strong></p><p>在每一个文件开头加入版权公告.</p><p>文件注释描述了该文件的内容. 如果一个文件只声明, 或实现,或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释,那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释.</p><p><strong>说明</strong></p><h6 id="法律公告和作者信息">法律公告和作者信息</h6><p>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如,Apache 2.0, BSD, LGPL, GPL)</p><p>如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p><h6 id="文件内容">文件内容</h6><p>如果一个 <code>.h</code> 文件声明了多个概念,则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系.一个一到两行的文件注释就足够了,对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中.</p><p>不要在 <code>.h</code> 和 <code>.cc</code> 之间复制注释,这样的注释偏离了注释的实际意义.</p><h3 id="类注释">8.3. 类注释</h3><p><strong>总述</strong></p><p>每个类的定义都要附带一份注释, 描述类的功能和用法,除非它的功能相当明显.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></span><br><span class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    delete iter;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GargantuanTableIterator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>类注释应当为读者理解如何使用与何时使用类提供足够的信息,同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提,请用文档说明. 如果该类的实例可被多线程访问,要特别注意文档说明多线程环境下相关的规则和常量使用.</p><p>如果你想用一小段代码演示这个类的基本用法或通常用法,放在类注释里也非常合适.</p><p>如果类的声明和定义分开了(例如分别放在了 <code>.h</code> 和<code>.cc</code> 文件中), 此时, 描述类用法的注释应当和接口定义放在一起,描述类的操作和实现的注释应当和实现放在一起.</p><h3 id="函数注释">8.4. 函数注释</h3><p><strong>总述</strong></p><p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p><p><strong>说明</strong></p><h6 id="函数声明">函数声明</h6><p>基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途.只有在函数的功能简单而明显时才能省略这些注释(例如,简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式(“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常,注释不会描述函数如何工作. 那是函数定义部分的事情.</p><p>函数声明处注释的内容:</p><ul><li>函数的输入输出.</li><li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数,是否会释放这些参数.</li><li>函数是否分配了必须由调用者释放的空间.</li><li>参数是否可以为空指针.</li><li>是否存在函数使用上的性能隐患.</li><li>如果函数是可重入的, 其同步前提是什么?</li></ul><p>举例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table.  It is the client&#x27;s</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    iter-&gt;Seek(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明.下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>注释函数重载时, 注释的重点应该是函数中被重载的部分,而不是简单的重复被重载的函数的注释. 多数情况下,函数重载不需要额外的文档, 因此也没有必要加上注释.</p><p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以“销毁这一对象” 这样的注释是没有意义的.你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权)以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释.析构函数前没有注释是很正常的.</p><h6 id="函数定义">函数定义</h6><p>如果函数的实现过程中用到了很巧妙的方式,那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧,实现的大致步骤, 或解释如此实现的理由. 举个例子,你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p><p><em>不要</em> 从 <code>.h</code>文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的,但注释重点要放在如何实现上.</p><h3 id="变量注释">8.5. 变量注释</h3><p><strong>总述</strong></p><p>通常变量名本身足以很好说明变量用途. 某些情况下,也需要额外的注释说明.</p><p><strong>说明</strong></p><h6 id="类数据成员-1">类数据成员</h6><p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途.如果有非变量的参数(例如特殊值, 数据成员之间的关系,生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而,如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p><p>特别地, 如果变量可以接受 <code>NULL</code> 或 <code>-1</code>等警戒值, 须加以说明. 比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Used to bounds-check table accesses. -1 means</span></span><br><span class="line"> <span class="comment">// that we don&#x27;t yet know how many entries the table has.</span></span><br><span class="line"> <span class="type">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure><h6 id="全局变量">全局变量</h6><p>和数据成员一样, 所有全局变量也要注释说明含义及用途,以及作为全局变量的原因. 比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kNumTestCases = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="实现注释">8.6. 实现注释</h3><p><strong>总述</strong></p><p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p><p><strong>说明</strong></p><h6 id="代码前注释">代码前注释</h6><p>巧妙或复杂的代码段前要加注释. 比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Divide result by two, taking into account that x</span></span><br><span class="line"><span class="comment">// contains the carry from the add.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result-&gt;<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">  (*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="行注释">行注释</h6><p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></span><br><span class="line">mmap_budget = <span class="built_in">max</span>&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;<span class="built_in">length</span>());</span><br><span class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !<span class="built_in">MmapData</span>(mmap_chunk_bytes, mlock))</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></span><br></pre></td></tr></table></figure><p>注意, 这里用了两段注释分别描述这段代码的作用,和提示函数返回时错误已经被记入日志.</p><p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DoSomething</span>();                  <span class="comment">// Comment here so the comments line up.</span></span><br><span class="line"><span class="built_in">DoSomethingElseThatIsLonger</span>();  <span class="comment">// Two spaces between the code and the comment.</span></span><br><span class="line">&#123; <span class="comment">// One space before comment when opening a new scope is allowed,</span></span><br><span class="line">  <span class="comment">// thus the comment lines up with the following comments and code.</span></span><br><span class="line">  <span class="built_in">DoSomethingElse</span>();  <span class="comment">// Two spaces before line comments normally.</span></span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;string&gt; list&#123;</span><br><span class="line">                    <span class="comment">// Comments in braced lists describe the next element...</span></span><br><span class="line">                    <span class="string">&quot;First item&quot;</span>,</span><br><span class="line">                    <span class="comment">// .. and should be aligned appropriately.</span></span><br><span class="line"><span class="string">&quot;Second item&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">DoSomething</span>(); <span class="comment">/* For trailing block comments, one space is fine. */</span></span><br></pre></td></tr></table></figure><h6 id="函数参数注释">函数参数注释</h6><p>如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p><ul><li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用,用以推断它们一致, 你应当用一个常量名让这一约定变得更明显,并且保证这一约定不会被打破.</li><li>考虑更改函数的签名, 让某个 <code>bool</code> 类型的参数变为<code>enum</code> 类型, 这样可以让这个参数的值表达其意义.</li><li>如果某个函数有多个配置选项,你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例.这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用,这样就能清晰地表明其意义. 同时也减少了函数参数的数量,使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项,就无需对调用点进行更改.</li><li>用具名变量代替大段而复杂的嵌套表达式.</li><li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li></ul><p>比如下面的示例的对比:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What are these arguments?</span></span><br><span class="line"><span class="type">const</span> DecimalNumber product = <span class="built_in">CalculateProduct</span>(values, <span class="number">7</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProductOptions options;</span><br><span class="line">options.<span class="built_in">set_precision_decimals</span>(<span class="number">7</span>);</span><br><span class="line">options.<span class="built_in">set_use_cache</span>(ProductOptions::kDontUseCache);</span><br><span class="line"><span class="type">const</span> DecimalNumber product =</span><br><span class="line">    <span class="built_in">CalculateProduct</span>(values, options, <span class="comment">/*completion_callback=*/</span><span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>哪个更清晰一目了然.</p><h6 id="不允许的行为">不允许的行为</h6><p>不要描述显而易见的现象, <em>永远不要</em> 用自然语言翻译代码作为注释,除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的.要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p><p>你所提供的注释应当解释代码 <em>为什么</em> 要这么做和代码的目的,或者最好是让代码自文档化.</p><p>比较这样的注释:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和这样的注释:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process &quot;element&quot; unless it was already processed.</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自文档化的代码根本就不需要注释.上面例子中的注释对下面的代码来说就是毫无必要的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsAlreadyProcessed</span>(element)) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标点-拼写和语法">8.7. 标点, 拼写和语法</h3><p><strong>总述</strong></p><p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p><p><strong>说明</strong></p><p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句.大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释,比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p><p>虽然被别人指出该用分号时却用了逗号多少有些尴尬,但清晰易读的代码还是很重要的. 正确的标点,拼写和语法对此会有很大帮助.</p><h3 id="todo-注释">8.8. TODO 注释</h3><p><strong>总述</strong></p><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用<code>TODO</code> 注释.</p><p><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>,在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一<code>TODO</code> 相关的 issue. 主要目的是让添加注释的人(也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code>格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正,因此当你加上带有姓名的 <code>TODO</code> 时, 一般都是写上自己的名字.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span></span><br></pre></td></tr></table></figure><p>如果加 <code>TODO</code> 是为了在 “将来某一天做某事”,可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项(“Remove this code when all clients can handle XML responses.”).</p><h3 id="弃用注释">8.9. 弃用注释</h3><p><strong>总述</strong></p><p>通过弃用注释（<code>DEPRECATED</code>comments）以标记某接口点已弃用.</p><p>您可以写上包含全大写的 <code>DEPRECATED</code> 的注释,以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p><p>在 <code>DEPRECATED</code> 一词后, 在括号中留下您的名字,邮箱地址以及其他身份标识.</p><p>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点. 在 C++中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口.</p><p>仅仅标记接口为 <code>DEPRECATED</code> 并不会让大家不约而同地弃用,您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p><p>修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点.如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p><h3 id="译者-yulefox-笔记-3">译者 (YuleFox) 笔记</h3><ol type="1"><li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li><li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li><li>注释要言简意赅, 不要拖沓冗余,复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li><li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem,但不管怎样, 注释是为了让别人看懂,难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li><li>注释不要太乱, 适当的缩进才会让人乐意看.但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样),UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li><li>TODO 很不错, 有时候,注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索,就知道还有哪些活要干, 日志都省了.</li></ol></div><div class="story post-story"><h2 id="格式">9. 格式</h2><p>每个人都可能有自己的代码风格和格式,但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行.每个人未必能同意下述的每一处格式规则,而且其中的不少规则需要一定时间的适应,但整个项目服从统一的编程风格是很重要的,只有这样才能让所有人轻松地阅读和理解代码.</p><p>为了帮助你正确的格式化代码, 我们写了一个 <ahref="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs配置文件</a>.</p><h3 id="行长度">9.1. 行长度</h3><p><strong>总述</strong></p><p>每一行代码字符数不超过 80.</p><p>我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则,因此我们感觉一致性更重要.</p><p><strong>优点</strong></p><p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为.很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口.大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准.那么为什么要改变呢?</p><p><strong>缺点</strong></p><p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60年代的大型机的古板缺陷; 现代设备具有更宽的显示屏,可以很轻松地显示更多代码.</p><p><strong>结论</strong></p><p>80 个字符是最大值.</p><p>如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符,这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80个字符.</p><p>包含长路径的 <code>#include</code> 语句可以超出80列.</p><p><ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">头文件保护</a>可以无视该原则.</p><h3 id="非-ascii-字符">9.2. 非 ASCII 字符</h3><p><strong>总述</strong></p><p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p><p><strong>说明</strong></p><p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如,代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串.此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8编码.</p><p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如<code>"\xEF\xBB\xBF"</code>, 或者更简洁地写作 <code>u8"\uFEFF"</code>,在 Unicode 中是 <em>零宽度 无间断</em> 的间隔符号,如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p><p>(Yang.Y 注: <code>"\xEF\xBB\xBF"</code> 通常用作 UTF-8 with BOM编码标记)</p><p>使用 <code>u8</code> 前缀把带 <code>uXXXX</code>转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8,输出就会出错.</p><p>别用 C++11 的 <code>char16_t</code> 和 <code>char32_t</code>, 它们和UTF-8 文本没有关系, <code>wchar_t</code> 同理, 除非你写的代码要调用Windows API, 后者广泛使用了 <code>wchar_t</code>.</p><h3 id="空格还是制表位">9.3. 空格还是制表位</h3><p><strong>总述</strong></p><p>只使用空格, 每次缩进 2 个空格.</p><p><strong>说明</strong></p><p>我们使用空格缩进. 不要在代码中使用制表符.你应该设置编辑器将制表符转为空格.</p><h3 id="函数声明与定义">9.4. 函数声明与定义</h3><p><strong>总述</strong></p><p>返回类型和函数名在同一行, 参数也尽量放在同一行,如果放不下就对形参分行, 分行方式与 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##function-calls">函数调用</a>一致.</p><p><strong>说明</strong></p><p>函数看上去像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同一行文本太多, 放不下所有参数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至连第一个参数都放不下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name1,  <span class="comment">// 4 space indent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以下几点:</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li><li>如果返回类型和函数名在一行放不下, 分行.</li><li>如果返回类型与函数声明或定义分行了, 不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li><li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为 2 个空格.</li><li>换行后的参数保持 4 个空格的缩进.</li></ul><p>未被使用的参数, 或者根据上下文很容易看出其用途的参数,可以省略参数名:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>(Foo&amp;&amp;);</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(Foo&amp;&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 差 - 如果将来有人要实现, 很难猜出变量的作用.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>属性, 和展开为属性的宏, 写在函数声明或定义的最前面,即返回类型之前:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MUST_USE_RESULT <span class="type">bool</span> <span class="title">IsOK</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="lambda-表达式-1">9.5. Lambda 表达式</h3><p><strong>总述</strong></p><p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理,表项用逗号隔开.</p><p><strong>说明</strong></p><p>若用引用捕获, 在变量名和 <code>&amp;</code> 之间不留空格.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="type">int</span> n) &#123; x += n; &#125;;</span><br></pre></td></tr></table></figure><p>短 lambda 就写得和内联函数一样.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">digits.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">end</span>(), [&amp;blacklist](<span class="type">int</span> i) &#123;</span><br><span class="line">               <span class="keyword">return</span> blacklist.<span class="built_in">find</span>(i) != blacklist.<span class="built_in">end</span>();</span><br><span class="line">             &#125;),</span><br><span class="line">             digits.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="函数调用">9.6. 函数调用</h3><p><strong>总述</strong></p><p>要么一行写完函数调用, 要么在圆括号里对参数分行,要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数,比如把多个参数适当地放在同一行里.</p><p><strong>说明</strong></p><p>函数调用遵循如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(argument1, argument2, argument3);</span><br></pre></td></tr></table></figure><p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐,左圆括号后和右圆括号前不要留空格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br></pre></td></tr></table></figure><p>参数也可以放在次行, 缩进四格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>(</span><br><span class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        argument3, argument4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性.有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过,比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p><p>如果一些参数本身就是略复杂的表达式, 且降低了可读性,那么可以直接创建临时变量描述该表达式, 并传递给函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> my_heuristic = scores[x] * y + bases[x];</span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(my_heuristic, x, y, z);</span><br></pre></td></tr></table></figure><p>或者放着不管, 补充上注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure><p>如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做.参数的格式处理应当以可读性而非其他作为最重要的原则.</p><p>此外, 如果一系列参数本身就有一定的结构,可以酌情地按其结构来决定参数格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.<span class="built_in">Transform</span>(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure><h3 id="列表初始化格式">9.7. 列表初始化格式</h3><p><strong>总述</strong></p><p>您平时怎么格式化函数调用, 就怎么格式化 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##braced-initializer-list">列表初始化</a>.</p><p><strong>说明</strong></p><p>如果列表初始化伴随着名字, 比如类型或变量名,格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字,就视作名字长度为零.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一行列表初始化示范.</span></span><br><span class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</span><br><span class="line"><span class="built_in">functioncall</span>(&#123;foo, bar&#125;);</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p&#123;foo, bar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不得不断行时.</span></span><br><span class="line"><span class="built_in">SomeFunction</span>(</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    some_other_function_parameter);</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    some, other, values,</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    SomeOtherType&#123;</span><br><span class="line">        <span class="string">&quot;Very long string requiring the surrounding breaks.&quot;</span>,  <span class="comment">// 非常长的字符串, 前后都需要断行.</span></span><br><span class="line">        some, other values&#125;,</span><br><span class="line">    SomeOtherType&#123;<span class="string">&quot;Slightly shorter string&quot;</span>,  <span class="comment">// 稍短的字符串.</span></span><br><span class="line">                  some, other, values&#125;&#125;;</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    <span class="string">&quot;This is too long to fit all in one line&quot;</span>&#125;;  <span class="comment">// 字符串过长, 因此无法放在同一行.</span></span><br><span class="line">MyType m = &#123;  <span class="comment">// 注意了, 您可以在 &#123; 前断行.</span></span><br><span class="line">    superlongvariablename1,</span><br><span class="line">    superlongvariablename2,</span><br><span class="line">    &#123;<span class="type">short</span>, interior, list&#125;,</span><br><span class="line">    &#123;interiorwrappinglist,</span><br><span class="line">     interiorwrappinglist2&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="条件语句">9.8. 条件语句</h3><p><strong>总述</strong></p><p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和<code>else</code> 另起一行.</p><p><strong>说明</strong></p><p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格,另一种没有.</p><p>最常见的是没有空格的格式. 哪一种都可以, 最重要的是 <em>保持一致</em>.如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码,参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你更喜欢在圆括号内部加空格:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格.右圆括号和左大括号之间也要有个空格:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格.</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格.</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 好 - IF 和 &#123; 都与空格紧邻.</span></span><br></pre></td></tr></table></figure><p>如果能增强可读性, 简短的条件语句允许写在同一行.只有当语句简单并且没有使用 <code>else</code> 子句时使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bar</span>();</span><br></pre></td></tr></table></figure><p>如果语句有 <code>else</code> 分支则不允许:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) <span class="built_in">DoThis</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">DoThat</span>();</span><br></pre></td></tr></table></figure><p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题;复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求<code>if</code> 必须总是使用大括号:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果语句中某个 <code>if-else</code> 分支使用了大括号的话,其它分支也必须使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环和开关选择语句">9.9. 循环和开关选择语句</h3><p><strong>总述</strong></p><p><code>switch</code> 语句可以使用大括号分段, 以表明 cases之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用<code>&#123;&#125;</code> 或 <code>continue</code>.</p><p><strong>说明</strong></p><p><code>switch</code> 语句中的 <code>case</code>块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话,要按照下文所述的方法.</p><p>如果有不满足 <code>case</code> 条件的枚举值, <code>switch</code>应该总是包含一个 <code>default</code> 匹配 (如果有输入值没有 case去处理, 编译器将给出 warning). 如果 <code>default</code>应该永远执行不到, 简单的加条 <code>assert</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单语句循环里, 括号可用可不用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I love you\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I take it back\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空循环体应使用 <code>&#123;&#125;</code> 或 <code>continue</code>,而不是一个简单的分号.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br><span class="line"><span class="keyword">while</span> (condition);  <span class="comment">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span></span><br></pre></td></tr></table></figure><h3 id="指针和引用表达式">9.10. 指针和引用表达式</h3><p><strong>总述</strong></p><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>)之后不能有空格.</p><p><strong>说明</strong></p><p>下面是指针和引用表达式的正确使用范例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>在访问成员时, 句点或箭头前后没有空格.</li><li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li></ul><p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="type">char</span> *c;</span><br><span class="line"><span class="type">const</span> string &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="type">char</span>* c;</span><br><span class="line"><span class="type">const</span> string&amp; str;</span><br><span class="line"><span class="type">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="type">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="type">const</span> string &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure><p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件,要遵照该文件的风格.</p><h3 id="布尔表达式">9.11. 布尔表达式</h3><p><strong>总述</strong></p><p>如果一个布尔表达式超过 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##line-length">标准行宽</a>,断行方式要统一一下.</p><p><strong>说明</strong></p><p>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</span><br><span class="line">    a_third_thing == a_fourth_thing &amp;&amp;</span><br><span class="line">    yet_another &amp;&amp; last_one) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, 上例的逻辑与 (<code>&amp;&amp;</code>) 操作符均位于行尾.这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以.可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外,直接用符号形式的操作符, 比如 <code>&amp;&amp;</code> 和 <code>~</code>,不要用词语形式的 <code>and</code> 和 <code>compl</code>.</p><h3 id="函数返回值">9.12. 函数返回值</h3><p><strong>总述</strong></p><p>不要在 <code>return</code> 表达式里加上非必须的圆括号.</p><p><strong>说明</strong></p><p>只有在写 <code>x = expr</code> 要加上括号的时候才在<code>return expr;</code> 里使用括号.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单, 没有圆括号.</span></span><br><span class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span></span><br><span class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</span><br><span class="line">        another_condition);</span><br><span class="line"><span class="keyword">return</span> (value);                <span class="comment">// 毕竟您从来不会写 var = (value);</span></span><br><span class="line"><span class="keyword">return</span>(result);                <span class="comment">// return 可不是函数！</span></span><br></pre></td></tr></table></figure><h3 id="变量及数组初始化">9.13. 变量及数组初始化</h3><p><strong>总述</strong></p><p>用 <code>=</code>, <code>()</code> 和 <code>&#123;&#125;</code> 均可.</p><p><strong>说明</strong></p><p>您可以用 <code>=</code>, <code>()</code> 和 <code>&#123;&#125;</code>,以下的例子都是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;Some Name&quot;</span>)</span></span>;</span><br><span class="line">string name = <span class="string">&quot;Some Name&quot;</span>;</span><br><span class="line">string name&#123;<span class="string">&quot;Some Name&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>请务必小心列表初始化 <code>&#123;...&#125;</code> 用<code>std::initializer_list</code> 构造函数初始化出的类型.非空列表初始化就会优先调用 <code>std::initializer_list</code>,不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用<code>std::initializer_list</code> 构造函数, 请改用括号.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure><p>此外, 列表初始化不允许整型类型的四舍五入,这可以用来避免一些类型上的编程失误.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 好 - pi == 3.</span></span><br><span class="line"><span class="type">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// 编译错误: 缩窄转换.</span></span><br></pre></td></tr></table></figure><h3 id="预处理指令">9.14. 预处理指令</h3><p><strong>总述</strong></p><p>预处理指令不要缩进, 从行首开始.</p><p><strong>说明</strong></p><p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好 - 指令从行首开始</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">#<span class="meta"># <span class="keyword">if</span> NOTIFY               <span class="comment">// 非必要 - ## 后跟空格</span></span></span><br><span class="line">    <span class="built_in">NotifyClient</span>();</span><br><span class="line">#<span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 差 - 指令缩进</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> DISASTER_PENDING  <span class="comment">// 差 - &quot;#if&quot; 应该放在行开头</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">    #<span class="meta">#<span class="keyword">endif</span>                <span class="comment">// 差 - &quot;##endif&quot; 不要缩进</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="类格式">9.15. 类格式</h3><p><strong>总述</strong></p><p>访问控制块的声明依次序是 <code>public:</code>,<code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p><p><strong>说明</strong></p><p>类声明 (下面的代码中缺少注释, 参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/comments/##class-comments">类注释</a>)的基本格式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  <span class="built_in">MyClass</span>();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> var)</span></span>;</span><br><span class="line">  ~<span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_some_var</span><span class="params">(<span class="type">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> some_var_;</span><br><span class="line">  <span class="type">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意事项:</p><ul><li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li><li>关键词 <code>public:</code>, <code>protected:</code>,<code>private:</code> 要缩进 1 个空格.</li><li>除第一个关键词 (一般是 <code>public</code>) 外,其他关键词前要空一行. 如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li><code>public</code> 放在最前面, 然后是 <code>protected</code>,最后是 <code>private</code>.</li><li>关于声明顺序的规则请参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##declaration-order">声明顺序</a>一节.</li></ul><h3 id="构造函数初始值列表">9.16. 构造函数初始值列表</h3><p><strong>总述</strong></p><p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p><p><strong>说明</strong></p><p>下面两种初始值列表方式都可以接受:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var) : <span class="built_in">some_var_</span>(var) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var), <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间格式化">9.17. 命名空间格式化</h3><p><strong>总述</strong></p><p>命名空间内容不缩进.</p><p><strong>说明</strong></p><p><ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">命名空间</a>不要增加额外的缩进层次, 例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>不要在命名空间内缩进:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>声明嵌套命名空间时, 每个命名空间都独立成行.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">namespace</span> bar &#123;</span><br></pre></td></tr></table></figure><h3 id="水平留白">9.19. 水平留白</h3><p><strong>总述</strong></p><p>水平留白的使用根据在代码中的位置决定.永远不要在行尾添加没意义的留白.</p><p><strong>说明</strong></p><h6 id="通用">通用</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="type">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> b) : <span class="built_in">Bar</span>(), <span class="built_in">baz_</span>(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格.如果确定一行代码已经修改完毕, 将多余的空格去掉;或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格,如果不支持, 考虑换一款编辑器或 IDE)</p><h6 id="循环和条件语句">循环和条件语句</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure><h6 id="操作符">操作符</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h6 id="模板和转换">模板和转换</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line">vector&lt;string&gt; x;</span><br><span class="line">y = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line">vector&lt;<span class="type">char</span> *&gt; x;</span><br></pre></td></tr></table></figure><h3 id="垂直留白">9.19. 垂直留白</h3><p><strong>总述</strong></p><p>垂直留白越少越好.</p><p><strong>说明</strong></p><p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是:两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行,函数体中也不要随意添加空行.</p><p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然,过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断.但通常是垂直留白越少越好.</p><p>下面的规则可以让加入的空行更有效:</p><ul><li>函数体内开头或结尾的空行可读性微乎其微.</li><li>在多重 if-else 块里加空行或许有点可读性.</li></ul><h3 id="译者-yulefox-笔记-4">译者 (YuleFox) 笔记</h3><ol type="1"><li>对于代码格式, 因人, 系统而异各有优缺点,但同一个项目中遵循同一标准还是有必要的;</li><li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li><li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是UNIX/Linux 下, Windows 下可以考虑宽字符),尽量不将字符串常量耦合到代码中, 比如独立出资源文件,这不仅仅是风格问题了;</li><li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li><li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行,要么所有参数并排分行;</li><li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明,各种语句的左大括号置于行尾, 所有右大括号独立成行;</li><li><code>.</code>/<code>-&gt;</code> 操作符前后不留空格,<code>*</code>/<code>&amp;</code> 不要前后都留, 一个就可,靠左靠右依各人喜好;</li><li>预处理指令/命名空间不使用额外缩进,类/结构体/枚举/函数/语句使用缩进;</li><li>初始化用 <code>=</code> 还是 <code>()</code> 依个人喜好,统一就好;</li><li><code>return</code> 不要加 <code>()</code>;</li><li>水平/垂直留白不要滥用, 怎么易读怎么来.</li><li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (<code>.cc</code>文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约,想想行首除了函数体被一对大括号封在一起之外,只有右大括号的代码看上去确实也舒服; Windows风格将左大括号置于行首的优点是匹配情况一目了然.</li></ol><h3 id="译者acgtyrant笔记-5">译者（acgtyrant）笔记</h3><ol type="1"><li>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块,超多重函数调用等等.</li><li>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码,不像奇葩的 Windows.</li><li>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号. Apple正好 <a href="http://coolshell.cn/articles/11112.html">有栽过跟头</a>.</li><li>其实我主张指针／地址操作符与变量名紧邻, <code>int* a, b</code> vs<code>int *a, b</code>, 新手会误以为前者的 <code>b</code> 是<code>int *</code> 变量, 但后者就不一样了, 高下立判.</li><li>在这风格指南里我才刚知道 C++ 原来还有所谓的 <ahref="http://en.cppreference.com/w/cpp/language/operator_alternative">Alternativeoperator representations</a>, 大概没人用吧.</li><li>注意构造函数初始值列表（Constructer InitializerList）与列表初始化（Initializer List）是两码事,我就差点混淆了它们的翻译.</li><li>事实上, 如果您熟悉英语本身的书写规则,就会发现该风格指南在格式上的规定与英语语法相当一脉相承.比如普通标点符号和单词后面还有文本的话, 总会留一个空格;特殊符号与单词之间就不用留了, 比如 <code>if (true)</code> 中的圆括号与<code>true</code>.</li><li>本风格指南没有明确规定 void 函数里要不要用 return 语句, 不过就Google 开源项目 leveldb 并没有写; 此外从 <ahref="http://stackoverflow.com/questions/9316717/is-a-blank-return-statement-at-the-end-of-a-function-whos-return-type-is-void-ne">Isa blank return statement at the end of a function whos return type isvoid necessary?</a> 来看, <code>return;</code> 比 <code>return ;</code>更约定俗成（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）,且可用来提前跳出函数栈.</li></ol></div><div class="story post-story"><h2 id="规则特例">10. 规则特例</h2><p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外,这里就是探讨这些特例.</p><h3 id="现有不合规范的代码">10.1. 现有不合规范的代码</h3><p><strong>总述</strong></p><p>对于现有不符合既定编程风格的代码可以网开一面.</p><p><strong>说明</strong></p><p>当你修改使用其他风格的代码时,为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心,可以与代码原作者或现在的负责人员商讨. 记住, <em>一致性</em>也包括原有的一致性.</p><h3 id="windows-代码">10.2. Windows 代码</h3><p><strong>总述</strong></p><p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的C++ 编程只给出一个单独的指南.</p><p><strong>说明</strong></p><p>如果你习惯使用 Windows 编码风格,这儿有必要重申一下某些你可能会忘记的指南:</p><ul><li>不要使用匈牙利命名法 (比如把整型变量命名成 <code>iNum</code>). 使用Google 命名约定, 包括对源文件使用 <code>.cc</code> 扩展名.</li><li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感),如 <code>DWORD</code>, <code>HANDLE</code> 等等. 在调用 Windows API时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型,例如使用 <code>const TCHAR *</code> 而不是 <code>LPCTSTR</code>.</li><li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高,并将所有警告(warnings)当作错误(errors)处理.</li><li>不要使用 <code>##pragma once</code>; 而应该使用 Google的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如<code>##ifndef SRC_DIR_BAR_H_</code>, 参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">##define保护</a> 一节).</li><li>除非万不得已, 不要使用任何非标准的扩展, 如 <code>##pragma</code> 和<code>__declspec</code>. 使用 <code>__declspec(dllimport)</code> 和<code>__declspec(dllexport)</code> 是允许的, 但必须通过宏来使用, 比如<code>DLLIMPORT</code> 和 <code>DLLEXPORT</code>,这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li></ul><p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p><ul><li>通常我们 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##multiple-inheritance">禁止使用多重继承</a>,但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL类/接口, 你可能不得不使用多重实现继承.</li><li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的STL) 中异常被广泛使用. 使用 ATL 时, 应定义<code>_ATL_NO_EXCEPTIONS</code> 以禁用异常. 你需要研究一下是否能够禁用STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL,自己的代码里仍然不应当包含异常处理).</li><li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为<code>StdAfx.h</code> 或 <code>precompile.h</code> 的文件.为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在<code>precompile.cc</code> 中), 使用 <code>/FI</code>编译器选项以自动包含该文件.</li><li>资源头文件通常命名为 <code>resource.h</code> 且只包含宏,这一文件不需要遵守本风格指南.</li></ul></div><div class="story post-story"><h2 id="结束语">11. 结束语</h2><p>运用常识和判断力, 并且 <em>保持一致</em>.</p><p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格.如果其它代码中 <code>if</code> 语句使用空格, 那么你也要使用.如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.</p><p>风格指南的重点在于提供一个通用的编程规范,这样大家可以把精力集中在实现内容而不是表现形式上.我们展示的是一个总体的的风格规范, 但局部风格也很重要,如果你在一个文件中新加的代码和原有代码风格相去甚远,这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏,所以要尽量避免.</p><p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Google C/C++ 规范文档。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="编程" scheme="http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://adversarr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Real-Time Cloth Simulation</title>
    <link href="http://adversarr.github.io/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/"/>
    <id>http://adversarr.github.io/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/</id>
    <published>2022-09-30T01:16:33.203Z</published>
    <updated>2022-11-05T01:55:42.640Z</updated>
    
    <content type="html"><![CDATA[<p>Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>Dynamic Solver：</p><ul><li>High resolution</li><li>High nonlinearity</li><li>High stiffness — 多次迭代、计算量</li></ul><p>Collision:</p><ul><li>Collision detection</li><li>Collision Response.</li></ul><h3 id="problem-definitions">Problem Definitions</h3><h4 id="terms">Terms</h4><p>Position Vector: <span class="math display">\[\mathbf x = [\mathbf x_0 \mathbf x_1 \cdots \mathbf x_N]&#39;\]</span> Velocity: <span class="math display">\[\mathbf v = \dot {\mathbf x}\quad \mathbf M = diag(m_0, \dots, m_N)\]</span> Energy – Holonomic(Position only): <spanclass="math display">\[E(\mathbf x)\]</span> 例如：</p><ol type="1"><li>重力势能</li><li>弹簧能量</li><li>Fixing Energy — <span class="math inline">\(\frac{\sigma}2 (\mathbfx_i -\mathbf y_i)^2\)</span></li></ol><h4 id="time-integration">Time Integration</h4><p>常用：隐式欧拉法</p><p>求解方法：</p><ol type="1"><li>消去 <span class="math inline">\(\mathbf v^{t + \Deltat}\)</span></li><li>转化为非线性优化问题</li></ol><p>从而，整个问题都变为： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x)\]</span> 其中 <span class="math inline">\(F\)</span>由动能和势能组成。</p><h4 id="碰撞">碰撞</h4><p>作为约束项出现： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad \mathbf x^{t + \Delta t} \in \Omega\]</span> <img src="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414210701587.png" class="lazyload" data-srcset="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414210701587.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="image-20220414210701587"></p><p>上式存在隧穿问题(Tunnel)。故采用CCD。 <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad s \mathbf x^t + (1-s)  \mathbf x^{t + \Delta t} \in \Omega\forall s\in [0,1]\]</span></p></div><div class="story post-story"><h2 id="dynamics">Dynamics</h2><p>非线性优化通常有如下的形式： <span class="math display">\[\mathbf x ^{k+1} = \mathbf x^k - \alpha^{k + 1}\left(A^{k+1}\right)^{-1} \mathrm{grad}\]</span></p><h3 id="newton-法">Newton 法</h3><p>优点</p><ul><li>2 阶方法</li><li>Hessian Matrix</li></ul><p>问题</p><ul><li>如何求解 <span class="math inline">\(A^{-1}f\)</span> —计算量大</li><li>不一定收敛<ul><li>减小 <span class="math inline">\(\alpha\)</span></li><li>要求 Hessian 正定</li></ul></li></ul><h3 id="梯度下降">梯度下降</h3><p><span class="math display">\[A = \mathrm{id}\]</span></p><p>优点</p><ul><li>GPU++</li><li>简单</li></ul><p>缺点</p><ul><li>1阶收敛 – 慢</li><li>没有任何实时模拟器使用</li></ul><h3 id="projective-dynamics">Projective Dynamics</h3><p>用常矩阵代替 <span class="math inline">\(A\)</span></p><p>优点：</p><ul><li>CPU++，（C 可以被预分解）</li><li>收敛快 — smoother</li></ul><p>缺点</p><ul><li>GPU不友好</li><li>1阶收敛速度（总体上很慢）</li></ul><h3 id="diagonal-hessian">Diagonal Hessian</h3><p><span class="math display">\[\mathbf A^{k+1} = \mathrm{diag\ grad}\]</span></p><p>优点</p><ul><li>收敛快于GD</li><li>GPU++</li></ul><p>缺点</p><ul><li>速度仍然差于牛顿</li></ul><h3 id="lower-hessian">Lower Hessian</h3><p>使用hessian的下三角</p><p>优缺点同 Diag Hess</p><img src="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414212056199.png" class="lazyload" data-srcset="/2022/09/30/CG/SortByCato/ContactDetection/ClothSimu/image-20220414212056199.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class=" lazyload" title="总结对比"><h3 id="acceleration">Acceleration</h3><ul><li>Chebyshev — GPU Firendly</li><li>Multiscale Acceleration</li></ul><h3 id="conclusion">Conclusion</h3><p>CPU：Projective Dynamics + Newton-Raphson</p><p>GPU：Chebyshev + Diagonal Hessian / Newton + PCG</p><h3 id="more">More</h3><h4 id="pbd-position-based-dynamics">PBD — Position-Based Dynamics</h4><p><strong>NVCLOTH</strong></p><h4 id="regular-grid-mesh">Regular Grid Mesh</h4><ul><li>Avoid Topology info</li><li>mem access</li><li>more suitable for high resolution</li></ul></div><div class="story post-story"><h2 id="碰撞-1">碰撞</h2><p>两部分：碰撞检测 + 碰撞响应 具体看综述</p><h3 id="检测">检测</h3><p>mesh -&gt; pair -&gt; collision</p><h3 id="response">Response</h3><ol type="1"><li>Iterative Position-Based Repulsion</li><li>Impact Zone Method</li><li>Untangling</li></ol></div><div class="story post-story"><h2 id="other-topics">Other Topics</h2><ul><li>Friction</li><li>Nonelastic</li><li>Locking</li><li>Physical model and measurement</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="仿真模拟" scheme="http://adversarr.github.io/tags/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="布料" scheme="http://adversarr.github.io/tags/%E5%B8%83%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Particle-In-Cell Method</title>
    <link href="http://adversarr.github.io/2022/09/30/CG/SortByCato/MPM/apic/"/>
    <id>http://adversarr.github.io/2022/09/30/CG/SortByCato/MPM/apic/</id>
    <published>2022-09-29T16:00:00.000Z</published>
    <updated>2022-11-05T01:36:02.109Z</updated>
    
    <content type="html"><![CDATA[<p>Paper Reading: The Affine Particle In Cell.</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>相比于之前的方法</p><ol type="1"><li>保留了 PIC 的稳定性，但解决了耗散/误差问题</li><li>保留了 FLIP 的动量、角动量守恒特性，但解决了不稳定的问题</li></ol><p>主要思想：用一个仿射变换来代替原本的简单插值，从而解决p-&gt;g阶段的数据丢失。</p><h3 id="mpm">MPM</h3><ol type="1"><li>欧拉网格<ol type="1"><li>求力简单：均匀网格上的拉普拉斯算子容易计算</li><li>求运动困难</li></ol></li><li>拉格朗日粒子<ol type="1"><li>求运动简单</li><li>容易让物理量守恒</li><li>求力困难：难以离散化、邻居查找较为困难</li></ol></li></ol><p>建立从Euler Grid到LagrangeParticle的信息传递，来描述一个连续体介质。</p><p>问题出现在信息传递过程中：存在信息丢失的情况（维数不同，会产生降维的情况）</p><h3 id="pic">PIC</h3><p>P→G：</p><ol type="1"><li>mass: <span class="math inline">\(m_i^n = \sum_p w_{ip}^nm_p\)</span></li><li>velocity/linear momentum: <span class="math inline">\(m_i^n \mathbfv_i ^ n = \sum_p w_{ip}^n m_p \mathbf v_p^n\)</span></li></ol><p>G update: use NS-equation and backward-euler.</p><ol type="1"><li>velocity: <span class="math inline">\(\mathbf v_i ^n \rightarrow\mathbf v_i ^{n+1}\)</span></li></ol><p>G→P:</p><ol type="1"><li>velocity: <span class="math inline">\(\mathbf v_p^{n+1} = \sum_iw_{ip}^n \mathbf v_i ^ {n+1}\)</span></li></ol><p>P update: newton equations:</p><ol type="1"><li>position: <span class="math inline">\(\mathbf x = \mathbf x +\mathbf v \Delta t\)</span></li></ol><p>P→G保角动量，但G→P只传递动量，角动量不保持。</p><h3 id="flip">FLIP</h3></div><div class="story post-story"><h2 id="apic">APIC</h2><h3 id="rpic">RPIC</h3><p>在每一个particle上添加角动量<span class="math inline">\(L _ p ^n\)</span>，并用动量相同的方法执行P→G</p><p>P→G:</p><ol type="1"><li>Angular Momentum: <span class="math inline">\(m_i^n \mathbf v_i ^ n= \sum _ p w_{ip}^n m _ p (\mathbf v_p ^ n + ((\mathbfK_p^n)^{-1}\mathbf L _ p ^ n)\times (\mathbf x_i^n - \mathbf x _ p ^n))\)</span></li></ol><blockquote><p>其中 <span class="math inline">\(\mathbf K\)</span>是转动惯量张量，且<span class="math inline">\(\mathbf \omega = (\mathbfK)^{-1} \mathbf L\)</span></p></blockquote><p>G→P:</p><ol type="1"><li>Angular Momentum: <span class="math inline">\(L_p^{n+1}= \sum_i w_{ip} ^ n (\mathbf x_i^n - \mathbf x _ p ^n)\times m_p \mathbf v_{i}^{n+1}\)</span></li></ol><p>简单粗暴的保持角动量的方法。</p><p>至此，转动动能保持、平动动能保持。对于刚体运动，其能量能够保持，信息无损失。</p><p>但考虑到流体不具有刚性，从而还需要保持shearing mode下的运动。</p><h3 id="affine-pic">Affine PIC</h3><p>核心：粒子的速度场是分片仿射的。</p><p>解决RPIC中无法进行shearing的问题。</p><p><span class="math display">\[P\rightarrow G: \mathbf v_i^n = \sum_p w_{ip}^n \mathbf (v_p^n +C_p^n(\mathbf x_i - \mathbf x_p))\]</span></p><p>Problem: How to define <span class="math inline">\(C\)</span>efficiently. see <ahref="https://www.math.ucla.edu/~cffjiang/research/apic/tech-doc.pdf">tech-doc</a>.</p><p>P→G:</p><ol type="1"><li>mass</li><li>momentum: <span class="math inline">\(m_i\mathbf v_i ^n = \sum_pw_{ip}^n m_p(\mathbf v_p^n +B_p ^n(D_p^n)^{-1}(\mathbf x_i^n - \mathbfx_i^p))\)</span></li></ol><p>G→P:</p><ol type="1"><li>update: <span class="math inline">\(B _ p ^{n+1} = \sum _ iw_{ip}^{n}\mathbf v_i^{n+1}(\mathbf x_i^n - \mathbfx_p^n)^T\)</span></li><li>velocity.</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Paper Reading: The Affine Particle In Cell.&lt;/p&gt;</summary>
    
    
    
    <category term="Anything" scheme="http://adversarr.github.io/categories/Anything/"/>
    
    
    <category term="Computer Graphic" scheme="http://adversarr.github.io/tags/Computer-Graphic/"/>
    
    <category term="PIC" scheme="http://adversarr.github.io/tags/PIC/"/>
    
    <category term="Fluid Simulation" scheme="http://adversarr.github.io/tags/Fluid-Simulation/"/>
    
  </entry>
  
  <entry>
    <title>离散微分几何 - 1 - Introduction</title>
    <link href="http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c1/"/>
    <id>http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c1/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2022-09-30T01:16:33.180Z</updated>
    
    <content type="html"><![CDATA[<p>离散微分几何 - 1 - Introduction</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>Application:</p><ul><li>Geometry Processing: Up-sample / Down-sample — 3d-surface</li><li>Shape Analysis</li><li>Machine Learning.</li><li>Numerical Simu</li></ul></div><div class="story post-story"><h2 id="what-will-we-learn-wont">What will we learn / Won't</h2><ol type="1"><li>Diff Geometry</li><li>Geo Processing</li><li>Central — Link These two perspectives</li></ol><p>Won't</p><ol type="1"><li>view points on diff geometry</li><li>huge number of algorithms</li></ol></div><div class="story post-story"><h2 id="what-is-diff-geo">What is Diff Geo</h2><h3 id="diff-geo">Diff Geo</h3><ol type="1"><li>Talk about local properties of shape</li><li>and thier connection to global properties of shape</li><li>Lang of geometry physics</li></ol><h3 id="discrete-diff-geo">Discrete Diff Geo</h3><ol type="1"><li>infinity no longer allowed</li><li>expressed in terms of lenghs, angles</li><li>Loss is littow: captures many fundamental ideas</li></ol><blockquote><p>Translate continuous to discrete</p></blockquote><h3 id="how-to">How to</h3><p>DDG — obtain discrete definitions</p><ol type="1"><li>write down several equivalent definitions in the smooth setting</li><li>apply each smooth definition to an object in discrete</li><li>Determine which properties are captured by each resultinginequivalent discrete definition</li></ol></div><div class="story post-story"><h2 id="example-discrete-curvature">Example: Discrete Curvature</h2><h3 id="curves-in-the-plane">Curves in the Plane</h3><p>in 2D, a <strong>parameterized curve</strong> is a map taking eachpoint in an interval <span class="math inline">\([0, L]\)</span>.</p><p>Discrete Curves in the Plane:</p><ul><li><p>piecewise linear parameterized curve, vertices connected bystraight line segments</p></li><li><p>view as a interval <spanclass="math inline">\(\rightarrow\)</span> Segments</p></li></ul><h3 id="tangentnormalcurvature">Tangent/Normal/Curvature</h3><p>unit tangent: <span class="math display">\[T(s) := \frac{d}{ds} \gamma(s) / |\frac{d}{ds}\gamma(s)|\]</span> unit Normal: <span class="math display">\[N(s) = \mathcal JT(s)\]</span></p><ul><li><span class="math inline">\(\mathcal J\)</span>表示顺时针旋转</li></ul><p>curvature can be expressed as the rate of change in the tangent.<span class="math display">\[\kappa(s):=\langle N, \frac{d}{ds} T\rangle\]</span></p><ul><li>Key idea 1 — curvature is a second devirative.</li><li>Key idea 2 — curvature can have sign.</li></ul><h3 id="to-discrete">To Discrete</h3><p>in continuous:</p><ol type="1"><li>Turning angle</li><li>length variation</li><li>steiner formula</li><li>osculating curve</li></ol><h3 id="integrated-curvature">Integrated Curvature</h3><p><span class="math display">\[\int _ b ^ a \kappa(s) \mathrm ds = \varphi(b) - \varphi(a)\]</span></p><p>consider <span class="math inline">\(\gamma_{i - 1}\)</span>, <spanclass="math inline">\(\gamma_{i}\)</span>,<spanclass="math inline">\(\gamma_{i + 1}\)</span> <spanclass="math display">\[\theta _ i =: \kappa_i ^A\quad (\text{turning angle})\]</span></p><ul><li>integrated rather than pointwise values</li><li>total change in angle, not derivative.</li></ul><h3 id="length-variation">Length Variation</h3><blockquote><p>The fastest way to descrease the length of a curve is to move it inthe normal direction, with speed proportioonal to curvature</p></blockquote><p>Intuition — in flat rigions, normal motions doesn't change curvelength.</p><p>变分： <span class="math display">\[\eta(0) = \eta(L) = 0\]</span> Gradient of Length for a line segment</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;离散微分几何 - 1 - Introduction&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>离散微分几何 - 1 - Introduction</title>
    <link href="http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c2a/"/>
    <id>http://adversarr.github.io/2022/08/08/CG/DiscreteGeometry/c2a/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2022-11-04T04:04:16.235Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="combinatorial-surfaces-mesh">Combinatorial Surfaces（Mesh）</h2><h3 id="what-is-a-mesh">What is a mesh?</h3><ol type="1"><li>simplical complex<ol type="1"><li>Abstract/geometric</li><li>Oriented, manifold simplical complex.</li></ol></li><li>Cell complex</li><li>Data structures.</li></ol><h3 id="connection-to-dg">Connection to DG?</h3><ol type="1"><li>Topological space. &lt;-&gt; Abstract simplical complex</li></ol><div class="story post-story"><h2 id="convex-set">Convex Set</h2><ol type="1"><li>Definition.</li><li>Convex Hull</li></ol><h3 id="simplex">Simplex</h3><ol type="1"><li>Definition: Linear Independence</li><li>Definition: Affine Independence(<span class="math inline">\(v_i =p_i - p_0\)</span> are linear indenpendent)</li></ol><p>Definition: a k-simplex is the convex hull of <spanclass="math inline">\(k+1\)</span> affine-independent points, which wecall its vertices.</p><h3 id="barycentric-coordinates">Barycentric Coordinates</h3><ul><li>we can describe a simplex more explicitly usingbarycentric-coord.</li></ul><p>any point <span class="math inline">\(p\)</span> inside simplex canbe expressed as a weighted combination of the vertices.</p><p><span class="math display">\[\sigma = \left \{\sum _{i = 0} ^ k t _ i p _ i : \sum _{i = 0} ^ k t_i = 1, t_i \ge 0\right\}\]</span></p><p>Definition: <strong>standard</strong> n-simplex(select <spanclass="math inline">\(p_i = \epsilon _ i\)</span>)</p><h3 id="simplicial-complex">Simplicial Complex</h3><blockquote><p>a bunch of simplicies.</p></blockquote><dl><dt>face</dt><dd>a face of a simplex is any simplex whose vertices are a subset of thevertices of <span class="math inline">\(\sigma\)</span></dd><dt>Simplicial Complex</dt><dd>a collection of simplicies where: 1. the intersection of any twosimplicies is a simplex. 2. every face of every simplex in the complexis also in the complex</dd></dl></div>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;combinatorial-surfaces-mesh&quot;&gt;Combinatorial Surfaces
（Mesh）&lt;/h2&gt;
&lt;h3 id=&quot;what-is-a-mesh&quot;&gt;What is a mesh?&lt;/h3&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>201-06-线性弹性有限元、拓扑优化</title>
    <link href="http://adversarr.github.io/2022/08/05/CG/GAMES/games201/g201-06/"/>
    <id>http://adversarr.github.io/2022/08/05/CG/GAMES/games201/g201-06/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-09-30T01:16:33.197Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 201 - 06 - 线性弹性有限元、拓扑优化</p><span id="more"></span><div class="story post-story"><h2 id="fem-overview">FEM Overview</h2><blockquote><p>Galerkin 方法的一种。将连续的PDE，转换为离散的线性系统</p><p>类似的还有物质点法（MPM）。（FEM是一种无元素的Galerkin方法）</p></blockquote><ol type="1"><li>将Strong-Form PDE转换为<strong>Weak-Form</strong>: 利用 testfunction <span class="math inline">\(w\)</span></li><li>分部积分，简化方程</li><li>散度定理</li><li>离散化</li><li>求解</li></ol><h3 id="d-泊松方程">2d-泊松方程</h3><p><span class="math display">\[\nabla \cdot \nabla u = 0\]</span></p><p>以及四个边界：</p><ol type="1"><li>三个Dirichlet边界：<span class="math inline">\(u(x) = f(x), x\in\partial \Omega\)</span></li><li>一个Neumann边界：<span class="math inline">\(\nabla u(x) \cdot n =g(x)\)</span></li></ol><h4 id="weak-formulation">Weak-Formulation</h4><p>任取的2d-test function<span class="math inline">\(w\)</span>：</p><p><span class="math display">\[\nabla \cdot \nabla u = 0 \iff \forall w, \iint _ \Omega w (\nabla \cdot\nabla u) \mathrm d A = 0\]</span></p><h4 id="分部积分去除二阶导数">分部积分去除二阶导数</h4><p><span class="math display">\[w\nabla \cdot \nabla u + \nabla w\cdot \nabla u = \nabla (w \nabla u)\implies\nabla w\cdot \nabla u = \nabla (w \nabla u)\]</span></p><h4 id="利用散度定理rhs">利用散度定理(RHS)</h4><p><span class="math display">\[\iint _ \Omega \nabla w \cdot \nabla u \mathrm dA = \oint _{\partial\Omega} w \nabla u \cdot \mathrm d\mathbf n\]</span></p></div><div class="story post-story"><h2 id="离散泊松方程">离散泊松方程</h2><p>取定基函数，表示<span class="math inline">\(u\)</span></p><p><span class="math display">\[u(x) = \sum_j u _ j \phi _ j (x)\]</span></p><blockquote><p>comsol - multiphysics - fem.</p></blockquote><p>并且直接用 <span class="math inline">\(\phi\)</span> 替换 <spanclass="math inline">\(w\)</span></p><p><span class="math display">\[\forall i, \quad \sum _ j (\iint \nabla \phi _ i \cdot \nabla \phi _ j\mathrm dA) u_j =\oint _ {\partial \Omega} \phi _ j \nabla u \cdot \mathrm dn\]</span></p><p>即</p><p><span class="math display">\[Ku = f\]</span></p><ul><li><span class="math inline">\(K\)</span>: stiffness matrix</li><li><span class="math inline">\(u\)</span>: solution vector</li><li><span class="math inline">\(f\)</span>: load vector</li></ul><p><span class="math display">\[K_{ij} = \iint _{\Omega} \nabla \phi_i \cdot \nabla \phi _ j \mathrm dA\]</span></p><p>右端：</p><ol type="1"><li>Dirichlet 边界条件：<span class="math inline">\(u(x) = f(x)\impliesu_i = f(x_i)\)</span></li><li>Neumann 边界条件：<span class="math inline">\(\nabla u (x) \cdot n =g(x)\)</span>: 将 <span class="math inline">\(g\)</span>插入方程右端，作为 <span class="math inline">\(f\)</span>的非零项。</li></ol></div><div class="story post-story"><h2 id="线性弹性有限元">线性弹性有限元</h2><p>柯西动量方程：</p><p><span class="math display">\[\frac{Dv}{Dt} = \frac 1 \rho \nabla \cdot \sigma + g\]</span></p><p>准静态（<span class="math inline">\(v = 0\)</span>,常密度，无重力）情况下：</p><p><span class="math display">\[\nabla \cdot \sigma = 0\]</span></p><h3 id="index-notation参考微分几何-爱因斯坦记号">IndexNotation（参考微分几何-爱因斯坦记号）</h3><p>用 <span class="math inline">\(\alpha,\beta, \gamma\)</span>表示。</p><p><span class="math display">\[\frac{Dv}{Dt} = \frac 1 \rho \nabla \cdot \sigma + g \iff\frac{Dv_\alpha}{Dt} = \frac 1 \rho \sum _ \beta\frac{\partial\sigma_{\alpha \beta}}{\partial x _ \beta} + g_\alpha\]</span></p></div><div class="story post-story"><h2 id="拓扑优化">拓扑优化</h2><p>Minimal Compliance Topology Optimization</p><p><span class="math display">\[\begin{aligned}\min L(\rho) = u^TK(\rho) u\\s.t. Ku = f\\\sum_e \rho_ e \le cV\\\rho _ e \in [\rho_\min, 1]\end{aligned}\]</span></p><ol type="1"><li><span class="math inline">\(L\)</span>：描述物质形变大小</li><li><span class="math inline">\(c\)</span>：体积系数</li><li><span class="math inline">\(\rho_e\)</span>：0表示空，1表示填充</li><li><span class="math inline">\(V\)</span>：总体积</li></ol><blockquote><ol type="1"><li>SIMP</li><li>OC</li></ol></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 201 - 06 - 线性弹性有限元、拓扑优化&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>201-05-多体问题和涡方法</title>
    <link href="http://adversarr.github.io/2022/08/04/CG/GAMES/games201/g201-05/"/>
    <id>http://adversarr.github.io/2022/08/04/CG/GAMES/games201/g201-05/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-09-30T01:16:33.197Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES201-5-多体问题和涡方法</p><span id="more"></span><h2 id="多体问题---introduction-to-fast-simulation">多体问题 -Introduction to Fast Simulation</h2><p>例如：万有引力</p><p><span class="math display">\[f(x) = \nabla \phi\]</span></p><blockquote><p>使用快速多级展开 -- 线性时间内求解<spanclass="math inline">\(n^2\)</span>的问题</p></blockquote><h3 id="d-泊松方程">2d-泊松方程</h3><p>考察给定原点，和在<spanclass="math inline">\(z\)</span>处的势能，使用泰勒（洛朗）展开</p><p>多极点的情况下：</p><p><span class="math display">\[\phi(z) = \sum q_j \log (z - z_j)= (\sum q_j \log z) - \sum_{k = 1}^p\frac {\sum _ j q_j z_j ^ k}{z^k}\quadQ_k = - \sum _ j \frac{q_j z_j^k}{k}\]</span></p><h3 id="tree-code">Tree Code</h3><p>类似于图像金字塔，网格划分。</p><h3 id="快速多级展开">快速多级展开</h3><p>思路：从一个Multipole到另一个Multipole直接计算，即在已经计算过的点处进行展开：</p><p><span class="math display">\[\begin{aligned}\phi(z) = Q\log(z - z_2) + \sum_{k = 1} ^ p \frac {b_k}{z^k} =Q\log z +  \sum_{k = 1} ^ p \frac {Q_k}{z^k}\end{aligned}\]</span></p><p>其中的 <span class="math inline">\(b_k\)</span> 是对于 <spanclass="math inline">\(Q_k\)</span> 的泛化 （M2M变换）</p><p><span class="math display">\[b_k = - \frac{Q (z_1 - z_2) ^ k}{k} + \sum_{i = 1} ^ k Q_i(z_1-z_2)^{k-i} C^{k-1}_{i-1}\]</span></p><blockquote><p>M2M Transform, M2L Transform ......</p></blockquote><!--TODO...-->]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES201-5-多体问题和涡方法&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的微分几何整理</title>
    <link href="http://adversarr.github.io/2022/07/15/study/Math/SummerCamp/DiffGeometry/"/>
    <id>http://adversarr.github.io/2022/07/15/study/Math/SummerCamp/DiffGeometry/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-11-05T01:27:14.326Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><div class="story post-story"><h2 id="欧氏空间">欧氏空间</h2><h3 id="向量空间">向量空间</h3><h4 id="向量空间的基本概念">向量空间的基本概念</h4><p>首先是相关概念。</p><ol type="1"><li>定义了内积的有限维向量空间是欧氏向量空间</li><li>经过 Schmidt 正交化可以得到标准正交基</li><li>可以定义外积运算</li></ol><dl><dt>外积的性质</dt><dd>设<span class="math inline">\(\mathbf v_{1} ..\mathbfv_{4}\)</span>是向量，则： 1. <span class="math inline">\(\mathbf v_1\wedge (\mathbf v_2 \wedge \mathbf v_3) = \langle\mathbf v_1 , \mathbfv_3\rangle - \langle \mathbf v_1,\mathbf v_2\rangle \mathbf v_3\)</span>2. 拉格朗日恒等式 3. 混合积循环不变</dd></dl><h4 id="向量分析">向量分析</h4><p>考虑向量值/数量值-向量/数量函数的微分：</p><ol type="1"><li><span class="math inline">\(\frac{d}{dt}(\lambda \mathbf a ) =\frac{d\lambda}{dt} a + \lambda \frac{d\mathbf a}{dt}\)</span></li><li>外积也满足上述公式</li><li>混合积也满足上述公式</li><li>多变量时，可以进行偏导和微分，也满足上述公式</li></ol><p>引入 <strong>梯度</strong> 场 和 Nabla算子： <spanclass="math display">\[\mathbf {grad} f = \nabla f\]</span></p><p>引入散度和旋度场： <span class="math display">\[\mathrm{div} \mathbf F\quad \mathbf{rot} \mathbf F\]</span></p><h3 id="欧氏空间-1">欧氏空间</h3><h4 id="向量运算">向量运算</h4><p>注意外积的运算： 1. 反交换律 2. 分配律</p><h4 id="坐标变换">坐标变换</h4><p>注意欧氏空间的定向：</p><dl><dt>定向</dt><dd>两个标架之间的正交变换<spanclass="math inline">\(T\)</span>的行列式为<spanclass="math inline">\(1\)</span>时，称之为定向相同。</dd></dl><h4 id="合同变换">合同变换</h4><dl><dt>Theo</dt><dd>设<span class="math inline">\(\mathcal T\)</span>是合同变换，则存在<spanclass="math inline">\(\mathbf T\in O(3)\)</span>以及<spanclass="math inline">\(P \in E^3\)</span>，使得： <spanclass="math display">\[\mathcal T(X) = X\mathbf T + P,\quad \forall X = (x^1,x^2, x^3)\in E^3\]</span> 即合同变换是正交变换和平移的复合</dd></dl><p>不难验证：合同变换的全体是一个群，称为三维合同变换群，当<spanclass="math inline">\(\det =1\)</span>是，对应的合同变换是刚体运动（也是一个群），反之称为反向刚体运动。</p><h4 id="正交标架和合同变换群">正交标架和合同变换群</h4><p><span class="math inline">\(E^3\)</span>的标架全体<spanclass="math inline">\(\mathcal F\)</span>与<spanclass="math inline">\(E^3\)</span>的欧式变换群之间有一一对应。</p><blockquote><p>即<spanclass="math inline">\(E^3\)</span>的所有元素的稳定化子只有<spanclass="math inline">\(\mathbf{id}\)</span>，并且<spanclass="math inline">\(E^3\)</span>中只有一个轨道。</p></blockquote></div><div class="story post-story"><h2 id="曲线">曲线</h2><h3 id="曲线的概念">曲线的概念</h3><p>在这里我们只考虑如下定义的正则曲线</p><dl><dt>正则曲线</dt><dd>如果曲线满足，每一个分量都是<spanclass="math inline">\(C^\infty\)</span>且 <spanclass="math inline">\(|dr/dt| &gt; 0\)</span>，对于所有<spanclass="math inline">\(t\)</span>，则称该曲线是正则曲线。</dd></dl><blockquote><p>平面上连续可微的参数曲线不一定是正规的</p></blockquote><p><span class="math display">\[\mathbf r(t) = (t^3 , t ^ 2)\]</span></p><h3 id="曲线的弧长">曲线的弧长</h3><p>假设有参数方程<span class="math inline">\(\mathbf r = \mathbfr(t)\)</span>，那么： <span class="math display">\[s= \int _ a ^ b \| \mathbf r&#39;(t)\| \mathrm dt\]</span> 是其弧长，是曲线的一个<strong>不变量</strong></p><h3 id="曲率frenet-标架">曲率、Frenet 标架</h3><dl><dt>Theo</dt><dd></dd></dl></div><div class="story post-story"><h2 id="测地曲率和测地线">测地曲率和测地线</h2><p>根据 Gauss 绝妙定理，<span class="math inline">\(K\)</span>只决定于曲面的第一基本形式，在保长对应下不变，是曲面的内蕴性质。在这里继续研究曲面内蕴几何的主要研究对象。</p><h3 id="测地曲率和测地线-1">测地曲率和测地线</h3><p>我们考虑正则曲面<span class="math inline">\(S:\mathbf r = \mathbfr(u^1, u^2)\)</span>，设有曲线<span class="math inline">\(u^\alpha =u^\alpha (s)\)</span> 是一条弧长参数曲线。其作为空间中的曲线参数方程为：<span class="math display">\[\mathbf r = \mathbf r(s) = \mathbf r (u^1, u^2)\]</span> 建立新的正交标架： <span class="math display">\[\begin{aligned}\mathbf e_1  &amp;= \frac {d\mathbf r(s)}{ds} = \alpha(s)\\\mathbf e_2 &amp;= \mathbf n(s)\times \alpha(s) \\\mathbf  e_3 &amp;= \mathbf n(s)\end{aligned}\]</span> 对于该曲线来考察原曲面的性质： <span class="math display">\[\begin{cases}\frac{d\mathbf r}{ds} &amp;= \mathbf e_1&amp;\\\frac{d\mathbf e_1}{ds} &amp;= &amp; +\kappa _g\mathbf e_2 &amp; +\kappa_n\mathbf e_3\\\frac{d\mathbf e_2}{ds} &amp;= -\kappa_g\mathbf e_1 &amp;&amp;+\tau_g\mathbf e_3 \\\frac{d\mathbf e_3}{ds} &amp;= -\kappa_n \mathbf e_1 &amp; +\tau_g\mathbf e_2\\\end{cases}\]</span> 显然，式中的：</p><ul><li><span class="math inline">\(\kappa_n\)</span> 就是曲面<spanclass="math inline">\(S\)</span>沿着曲线<spanclass="math inline">\(C\)</span>的切方向的法曲率；</li></ul><p>而也可以求解出其他的参数： <span class="math display">\[\kappa_g = \left( \mathbf n, \mathbf r&#39;, \mathbf r&#39;&#39; \right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地曲率</strong>； <span class="math display">\[\tau_g = \left( \mathbf n, \mathbf n&#39;,\mathbf r&#39;\right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地挠率</strong>。</p><p>下面的定理描述了测地曲率和测地挠率的几何意义：</p><dl><dt><strong>Theo</strong></dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条正则曲线，其在 <spanclass="math inline">\(p\)</span>处的测地曲率等于将其投影到切平面上的曲线的相对曲率，其平面的正向由曲面<span class="math inline">\(S\)</span> 在点 <spanclass="math inline">\(p\)</span> 的法向量给出。</dd><dt><strong>Theo</strong></dt><dd>曲面<span class="math inline">\(S\)</span>上任一条曲线<spanclass="math inline">\(C\)</span>的测地曲率是保长对应的不变量，即：<strong>测地曲率是内蕴量</strong>。</dd></dl><p>在取正交参数系的情况下，计算测地曲率有如下的<strong>Liouville公式</strong>：</p><dl><dt><strong>Theo</strong></dt><dd>设<span class="math inline">\((u,v)\)</span>是<spanclass="math inline">\(S\)</span>上的正交参数系，从而<spanclass="math inline">\(S\)</span>的第一基本形式为 <spanclass="math display">\[I = E(du)^2 + G(dv)^2\]</span> 假设<span class="math inline">\(C\)</span>与<spanclass="math inline">\(u\)</span>曲线的夹角为<spanclass="math inline">\(\theta\)</span>，那么其测地曲率是 <spanclass="math display">\[\kappa_g = \frac{d\theta}{ds} - \frac{1}{2\sqrt G} \frac{\partial \logE}{\partial v} \cos \theta + \frac{1}{2\sqrt E} \frac{\partial \logG}{\partial u}\sin \theta\]</span></dd></dl><p>最后我们讨论测地挠率，从自然标架的运动公式可以得出： <spanclass="math display">\[\tau _ g = \frac{1} {\sqrt g}\begin{vmatrix}&amp;\left(\frac{du^2}{ds} \right)^2 &amp; - \frac{du^1du^2}{dsds} &amp;\left(\frac{du^1}{ds} \right)^2 \\&amp;g_{11} &amp;g_{12} &amp; g_{22}\\&amp;b_{11} &amp;b_{22} &amp; b_{22}\end{vmatrix}\]</span> 故测地挠率和测地曲率一样，是<spanclass="math inline">\(S\)</span>上切方向的函数，反映的是曲面<spanclass="math inline">\(S\)</span>本身的性质，但其不是内蕴量。</p><p>对比主方向的方程，主方向恰好是测地挠率为 0的切方向。同时也有如下定理成立：</p><dl><dt>Theo</dt><dd>在曲面上非直线的渐进曲线<span class="math inline">\(C\)</span>的挠率是<span class="math inline">\(S\)</span>沿着曲面<spanclass="math inline">\(C\)</span>的切方向的测地挠率。</dd></dl><h3 id="测地线">测地线</h3><p>观察到测地曲率是内蕴量，从而要观察曲面上测地曲率为 0的曲线（测地线）</p><dl><dt>Theo</dt><dd>曲面上曲线<spanclass="math inline">\(C\)</span>是测地线，当且仅当，它或是一条直线，或者其主法向量处处是曲面的法向量</dd></dl><blockquote><p>例如：</p><ol type="1"><li>旋转面上的经线是测地线</li><li>若曲面上运动的质点 <span class="math inline">\(p\)</span>只受到将它约束在曲面上的力的作用，而不受到任何其他外力作用，则<spanclass="math inline">\(p\)</span>的轨迹是测地线</li></ol></blockquote><dl><dt>Theo</dt><dd>对于曲面上任意一点<span class="math inline">\(p\)</span>和曲面在<spanclass="math inline">\(p\)</span>的任意单位切向量<spanclass="math inline">\(v\)</span>，在曲面上存在唯一的一条弧长参数测地线通过<spanclass="math inline">\(p\)</span>且以<spanclass="math inline">\(v\)</span>为切向量</dd></dl><blockquote><p>平面 – 直线</p><p>曲面 – 测地线</p></blockquote><dl><dt>Theo</dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条曲线，则<spanclass="math inline">\(C\)</span>的弧长在任意一个有固定端点的变分<spanclass="math inline">\(C_t\)</span>中达到临界值的充分必要条件是<spanclass="math inline">\(C\)</span>是<spanclass="math inline">\(S\)</span>的测地线。</dd></dl><p>从而我们有：若曲线<span class="math inline">\(C\)</span>是连接<spanclass="math inline">\(p,q\)</span>的最短线，则<spanclass="math inline">\(C\)</span>是测地线。</p><h3 id="测地坐标系和法坐标系">测地坐标系和法坐标系</h3><h4 id="测地线族">测地线族</h4><p>在研究了测地线的性质后，我们研究测地线族的性质。</p><dl><dt>Theo</dt><dd>设<span class="math inline">\(\Sigma\)</span>是曲面<spanclass="math inline">\(S\)</span>上覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族，<spanclass="math inline">\(\Sigma_1\)</span>是由在区域<spanclass="math inline">\(D\)</span>内与<spanclass="math inline">\(\Sigma\)</span>中的曲线正交的轨线构成的曲线组，则其中任意两条曲线在<spanclass="math inline">\(\Sigma\)</span>中各条测地线上截出的曲线段长度相等。</dd></dl><blockquote><p>也就是说，测地线族的任意两条正交轨线之间的距离是处处相等的。</p><p>即：测地线族的任意两条正交轨线是<strong>测地平行</strong>的</p></blockquote><dl><dt>Theo</dt><dd>设<span class="math inline">\(C\)</span>是曲面<spanclass="math inline">\(S\)</span>上连接了<spanclass="math inline">\(p,q\)</span>两点的一条测地线，若曲线<spanclass="math inline">\(C\)</span>能够潜入到覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族<spanclass="math inline">\(\Sigma\)</span>中，且<spanclass="math inline">\(p,q\in D\)</span>，则其是区域内连接两点的最短线</dd></dl><h4 id="测地平行坐标系">测地平行坐标系</h4><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点<spanclass="math inline">\(p\)</span>的一个充分小的邻域内必定存在参数系<spanclass="math inline">\((u,v)\)</span>使得<spanclass="math inline">\(p\rightarrow (0,0)\)</span>，而第一基本形式可以写作 <span class="math display">\[I = (du)^2 + G(u,v) (dv)^2\]</span> 函数 <span class="math inline">\(G\)</span> 满足：$G(0, v)=1<span class="math inline">\(，\)</span>(0, v) =0<spanclass="math inline">\(，参数系\)</span>(u,v)$是<strong>测地平行坐标系</strong></dd></dl><h4 id="测地极坐标系">测地极坐标系</h4><p>定义指数映射： <span class="math display">\[\exp_p : T_pS \rightarrow S\quad \mathbf v\rightarrowtail\gamma(|\mathbf v|, \mathbf v_0)\]</span> <span class="math inline">\(\gamma\)</span>对于点<spanclass="math inline">\(p\)</span>处的单位切向量<spanclass="math inline">\(\mathbfv_0\)</span>，映射为弧长参数测地线上的参数为<spanclass="math inline">\(s\)</span>的位置。</p><p>显然指数映射 <span class="math inline">\(\exp_p\)</span>是连续可微的。于是有 <strong>法坐标系</strong>： <spanclass="math display">\[u^\alpha = u ^ \alpha(\exp_p(\mathbf v)) = u ^ \alpha(v^1, v^2)\]</span> 从而有<strong>测地圆</strong>（以<spanclass="math inline">\(p\)</span>为中心，<spanclass="math inline">\(s_0\)</span>为半径）</p><dl><dt>Theo 高斯引理</dt><dd>从<span class="math inline">\(p\)</span>出发的测地线与以点<spanclass="math inline">\(p\)</span>为中心的测地圆是彼此正交的。（即曲线族<spanclass="math inline">\(\Sigma_1\)</span>中的每一条曲线都是测地线族<spanclass="math inline">\(\Sigma\)</span>的正交轨线。</dd></dl><p>由此可以推导出测地极坐标系 <spanclass="math inline">\(（s,\theta)\)</span></p><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点的<spanclass="math inline">\(p\)</span>邻域内，出去从点<spanclass="math inline">\(p\)</span>出发的一条测地线外，也存在测地极坐标系，使得曲面第一形式为<span class="math display">\[I = (ds)^2 + G(d\theta)^2\quad \begin{cases}\lim _{s\rightarrow 0} \sqrt G = 0\\\lim_{s\rightarrow 0} \frac{\partial }{\partial S} \sqrt{G(s,\theta)} =1\end{cases}\]</span> 对应了平面上的极坐标系</dd></dl><h3 id="常曲率曲面">常曲率曲面</h3><p>高斯曲率为常数的曲面为<strong>常曲率曲面</strong>。</p><p>由于高斯曲率为内蕴量，我们不难考虑如下的定理：</p><dl><dt>Theo</dt><dd>有相同高斯曲率的任意两块常曲率曲面在局部上有保长对应。</dd></dl><blockquote><p>从现在的观点来看：</p><ol type="1"><li>常曲率曲面的第一基本形式是由其高斯曲率完全决定的</li><li>非欧几何学：将平面几何学推广到常曲率曲面</li></ol></blockquote><h3 id="平行移动">平行移动</h3><blockquote><p>考虑切向量场的协变微分和平行移动</p></blockquote><h3 id="gauss-bonnet公式">Gauss-Bonnet公式</h3><p>假定曲线是邮箱曲面上的一条分段光滑简单闭曲线，其包围的区域是曲面<span class="math inline">\(S\)</span> 的一个单连通区域，则 <spanclass="math display">\[\oint _C. \kappa _ g \mathrm d s + \iint _D K \mathrm d \sigma = 2 \pi -\sum _ {i = 1} ^ n \alpha _ i\]</span></p><ul><li><span class="math inline">\(\kappa_g\)</span>是曲线的测地曲率，</li><li><span class="math inline">\(K\)</span> 是曲面的高斯曲率</li><li>$_ i $ 表示曲线在角点<spanclass="math inline">\(i\)</span>的外角</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="微分几何" scheme="http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
</feed>
