<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逆版本战士の部落格</title>
  
  
  <link href="http://adversarr.github.io/atom.xml" rel="self"/>
  
  <link href="http://adversarr.github.io/"/>
  <updated>2022-06-22T06:30:07.737Z</updated>
  <id>http://adversarr.github.io/</id>
  
  <author>
    <name>Adversarr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库机试</title>
    <link href="http://adversarr.github.io/2022/06/16/study/ComputerScience/fragments/dbex/"/>
    <id>http://adversarr.github.io/2022/06/16/study/ComputerScience/fragments/dbex/</id>
    <published>2022-06-15T16:00:00.000Z</published>
    <updated>2022-06-22T06:30:07.737Z</updated>
    
    <content type="html"><![CDATA[<p>rt.</p><span id="more"></span><div class="story post-story"><h2 id="rman-全库备份">RMAN 全库备份</h2><p>前提：</p><ol type="1"><li>dbca创建数据库 <code>ctest</code>（主要是怕搞错）</li><li><code>@?/rdbms/admin/utlsampl.sql</code></li></ol><p>准备：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ORACLE_SID=ctest</span><br></pre></td></tr></table></figure><h3 id="准备实验数据">准备实验数据</h3><p>创建表+checkpoint(写入)</p><p>RMAN:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.baktest(a <span class="type">varchar</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.baktest <span class="keyword">values</span>(<span class="string">&#x27;Before Backup&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> checkpoint;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure><img src="image-20220614200507403.png" class="lazyload" data-srcset="image-20220614200507403.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220614200507403" /><figcaption aria-hidden="true">image-20220614200507403</figcaption></figure><h3 id="检查数据库情况">检查数据库情况</h3><h4 id="初始化参数文件">初始化参数文件</h4><p>sqlplus:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> spfile;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS<span class="variable">@ctest</span><span class="operator">&gt;</span><span class="keyword">show</span> <span class="keyword">parameter</span> spfile;</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE                   <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line">spfile                               string                 <span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>product<span class="operator">/</span><span class="number">19.3</span><span class="number">.0</span><span class="operator">/</span>dbhome_1<span class="operator">/</span>dbs<span class="operator">/</span>spfilectest.ora</span><br></pre></td></tr></table></figure><p>记录下spfile的位置：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/u01/</span>app<span class="regexp">/oracle/</span>product<span class="regexp">/19.3.0/</span>dbhome_1<span class="regexp">/dbs/</span>spfilectest.ora</span><br></pre></td></tr></table></figure><h4 id="查看控制文件位置">查看控制文件位置</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> v$controlfile;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>control01.ctl</span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>fast_recovery_area<span class="operator">/</span>CTEST<span class="operator">/</span>control02.ctl</span><br></pre></td></tr></table></figure><h4 id="查看重做日志">！！查看重做日志</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS<span class="variable">@ctest</span><span class="operator">&gt;</span><span class="keyword">select</span> <span class="keyword">member</span> <span class="keyword">from</span> v$logfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">MEMBER</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>redo03.log</span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>redo02.log</span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>redo01.log</span><br></pre></td></tr></table></figure><h4 id="检查datafile">检查datafile</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS<span class="variable">@ctest</span><span class="operator">&gt;</span><span class="keyword">select</span> name <span class="keyword">from</span> v$datafile;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>system01.dbf</span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>sysaux01.dbf</span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>undotbs01.dbf</span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>users01.dbf</span><br></pre></td></tr></table></figure><h4 id="查看状态">查看状态</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS<span class="variable">@ctest</span><span class="operator">&gt;</span><span class="keyword">select</span> tablespace_name, status <span class="keyword">from</span> dba_tablespaces;</span><br><span class="line"></span><br><span class="line">TABLESPACE_NAME                                              STATUS</span><br><span class="line"><span class="comment">------------------------------------------------------------ ------------------</span></span><br><span class="line"><span class="keyword">SYSTEM</span>                                                       ONLINE</span><br><span class="line">SYSAUX                                                       ONLINE</span><br><span class="line">UNDOTBS1                                                     ONLINE</span><br><span class="line">TEMP                                                         ONLINE</span><br><span class="line">USERS                                                        ONLINE</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rman设置修改">RMAN设置修改</h3><blockquote><p>RMAN内执行</p></blockquote><p>打开控制文件备份：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">configure</span> controlfile autobackup <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><p>创建备份目的目录： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> &lt;backup&gt; &amp;&amp; <span class="built_in">cd</span> &lt;backup&gt;</span><br><span class="line"><span class="built_in">mkdir</span> auto </span><br></pre></td></tr></table></figure></p><p>设置 controlfile 备份目的地</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">configure controlfile autobackup format <span class="keyword">for</span> device type disk <span class="keyword">to</span> <span class="string">&#x27;/u01/&lt;backup&gt;/auto/%F&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其他的设置</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">show</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> archive log <span class="keyword">current</span>; # 归档日志</span><br><span class="line"># 设置 channel</span><br><span class="line">configure channel device type disk format <span class="string">&#x27;/u01/&lt;backup&gt;/%d_%u.bak&#x27;</span>;</span><br><span class="line"># 删除之前的备份</span><br><span class="line"><span class="keyword">delete</span> backup;</span><br></pre></td></tr></table></figure><h3 id="执行全盘备份">执行全盘备份</h3><blockquote><p>RMAN内执行</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">backup database plus archivelog;</span><br></pre></td></tr></table></figure><h3 id="举手示意备份完成">！！！「举手示意，备份完成」</h3><h3 id="增加新数据">增加新数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.baktest <span class="keyword">values</span>(<span class="string">&#x27;After Backup&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> scott.baktest;</span><br></pre></td></tr></table></figure><figure><img src="image-20220614202258052.png" class="lazyload" data-srcset="image-20220614202258052.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220614202258052" /><figcaption aria-hidden="true">image-20220614202258052</figcaption></figure><h3 id="复制连接的日志文件">复制连接的日志文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in back directory:</span></span><br><span class="line">sql&gt; select * from v<span class="variable">$logfile</span>;</span><br><span class="line"><span class="built_in">cp</span> &lt;...&gt; .</span><br><span class="line"><span class="built_in">cp</span> &lt;...&gt; . <span class="comment"># redo log</span></span><br><span class="line"><span class="built_in">cp</span> &lt;...&gt; .</span><br><span class="line"><span class="comment"># 或者直接 cp /u01/app/oracle/oradata/CTEST/redo0* .</span></span><br></pre></td></tr></table></figure><h3 id="破坏数据库">破坏数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbca</span><br><span class="line"><span class="comment"># 如果没有 -- vim /etc/oratab</span></span><br></pre></td></tr></table></figure><h3 id="启动例程">启动例程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rman target /</span><br><span class="line">startup nomount; <span class="comment"># 不挂载（缺少spfile）</span></span><br></pre></td></tr></table></figure><p>然后恢复启动参数文件：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">restore spfile <span class="keyword">from</span> <span class="string">&#x27;/u01/&lt;&gt;/auto/...&#x27;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20220614203112028.png" class="lazyload" data-srcset="image-20220614203112028.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220614203112028" /><figcaption aria-hidden="true">image-20220614203112028</figcaption></figure><h3 id="创建对应的目录">创建对应的目录</h3><p>bash 查看目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /u01/app/oracle/product/19.3.0/dbhome_1/dbs/spfilectest.ora</span><br></pre></td></tr></table></figure><p>应该是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /u01/app/oracle/admin/CTEST/adump</span><br><span class="line"><span class="built_in">mkdir</span> -p /u01/app/oracle/oradata/CTEST</span><br><span class="line"><span class="built_in">mkdir</span> -p /u01/app/oracle/fast_recovery_area/CTEST</span><br></pre></td></tr></table></figure><h3 id="重启例程">重启例程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">shutdown immediate;</span><br><span class="line">exit</span><br><span class="line">startup nomount</span><br></pre></td></tr></table></figure><h3 id="还原控制文件">还原控制文件：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RMAN<span class="operator">&gt;</span> restore controlfile <span class="keyword">from</span> <span class="string">&#x27;/u01/_backup_test1/auto/c-899807147-20220614-00&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Starting restore <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br><span class="line"><span class="keyword">using</span> target database control file instead <span class="keyword">of</span> recovery catalog</span><br><span class="line">allocated channel: ORA_DISK_1</span><br><span class="line">channel ORA_DISK_1: SID<span class="operator">=</span><span class="number">261</span> device type<span class="operator">=</span>DISK</span><br><span class="line"></span><br><span class="line">channel ORA_DISK_1: restoring control file</span><br><span class="line">channel ORA_DISK_1: restore complete, elapsed <span class="type">time</span>: <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line">output file name<span class="operator">=</span><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>control01.ctl</span><br><span class="line">output file name<span class="operator">=</span><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>fast_recovery_area<span class="operator">/</span>CTEST<span class="operator">/</span>control02.ctl</span><br><span class="line">Finished restore <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br></pre></td></tr></table></figure><h3 id="加载数据库">加载数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database mount;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">shutdown immediate;</span><br><span class="line">startup mount;</span><br></pre></td></tr></table></figure><h3 id="还原数据文件">还原数据文件：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">restore database;</span><br><span class="line"></span><br><span class="line">Starting restore <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br><span class="line">Starting implicit crosscheck backup <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br><span class="line">allocated channel: ORA_DISK_1</span><br><span class="line">channel ORA_DISK_1: SID<span class="operator">=</span><span class="number">379</span> device type<span class="operator">=</span>DISK</span><br><span class="line">Crosschecked <span class="number">3</span> objects</span><br><span class="line">Finished implicit crosscheck backup <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br><span class="line"></span><br><span class="line">Starting implicit crosscheck <span class="keyword">copy</span> <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br><span class="line"><span class="keyword">using</span> channel ORA_DISK_1</span><br><span class="line">Finished implicit crosscheck <span class="keyword">copy</span> <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br><span class="line"></span><br><span class="line">searching <span class="keyword">for</span> <span class="keyword">all</span> files <span class="keyword">in</span> the recovery area</span><br><span class="line">cataloging files...</span><br><span class="line"><span class="keyword">no</span> files cataloged</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> channel ORA_DISK_1</span><br><span class="line"></span><br><span class="line">channel ORA_DISK_1: starting datafile backup <span class="keyword">set</span> restore</span><br><span class="line">channel ORA_DISK_1: specifying datafile(s) <span class="keyword">to</span> restore <span class="keyword">from</span> backup <span class="keyword">set</span></span><br><span class="line">channel ORA_DISK_1: restoring datafile <span class="number">00001</span> <span class="keyword">to</span> <span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>system01.dbf</span><br><span class="line">channel ORA_DISK_1: restoring datafile <span class="number">00003</span> <span class="keyword">to</span> <span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>sysaux01.dbf</span><br><span class="line">channel ORA_DISK_1: restoring datafile <span class="number">00004</span> <span class="keyword">to</span> <span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>undotbs01.dbf</span><br><span class="line">channel ORA_DISK_1: restoring datafile <span class="number">00007</span> <span class="keyword">to</span> <span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>users01.dbf</span><br><span class="line">channel ORA_DISK_1: reading <span class="keyword">from</span> backup piece <span class="operator">/</span>u01<span class="operator">/</span>_backup_test1<span class="operator">/</span>CTEST_03102deq.bak</span><br><span class="line">channel ORA_DISK_1: piece handle<span class="operator">=</span><span class="operator">/</span>u01<span class="operator">/</span>_backup_test1<span class="operator">/</span>CTEST_03102deq.bak tag<span class="operator">=</span>TAG20220614T201938</span><br><span class="line">channel ORA_DISK_1: restored backup piece <span class="number">1</span></span><br><span class="line">channel ORA_DISK_1: restore complete, elapsed <span class="type">time</span>: <span class="number">00</span>:<span class="number">00</span>:<span class="number">07</span></span><br><span class="line">Finished restore <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br></pre></td></tr></table></figure><h3 id="复制redolog文件">!!! 复制RedoLog文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> redo* /u01/app/oracle/oradata/CTEST/</span><br></pre></td></tr></table></figure><h3 id="恢复数据库">恢复数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">recover database;</span><br><span class="line"></span><br><span class="line">Starting recover <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br><span class="line"><span class="keyword">using</span> channel ORA_DISK_1</span><br><span class="line"></span><br><span class="line">starting media recovery</span><br><span class="line"></span><br><span class="line">archived log <span class="keyword">for</span> thread <span class="number">1</span> <span class="keyword">with</span> sequence <span class="number">8</span> <span class="keyword">is</span> already <span class="keyword">on</span> disk <span class="keyword">as</span> file <span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>fast_recovery_area<span class="operator">/</span>CTEST<span class="operator">/</span>archivelog<span class="operator">/</span><span class="number">2022</span>_06_14<span class="operator">/</span>o1_mf_1_8_kbjz71dj_.arc</span><br><span class="line">archived log <span class="keyword">for</span> thread <span class="number">1</span> <span class="keyword">with</span> sequence <span class="number">9</span> <span class="keyword">is</span> already <span class="keyword">on</span> disk <span class="keyword">as</span> file <span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>redo03.log</span><br><span class="line">archived log file name<span class="operator">=</span><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>fast_recovery_area<span class="operator">/</span>CTEST<span class="operator">/</span>archivelog<span class="operator">/</span><span class="number">2022</span>_06_14<span class="operator">/</span>o1_mf_1_8_kbjz71dj_.arc thread<span class="operator">=</span><span class="number">1</span> sequence<span class="operator">=</span><span class="number">8</span></span><br><span class="line">archived log file name<span class="operator">=</span><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>redo03.log thread<span class="operator">=</span><span class="number">1</span> sequence<span class="operator">=</span><span class="number">9</span></span><br><span class="line">media recovery complete, elapsed <span class="type">time</span>: <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Finished recover <span class="keyword">at</span> <span class="number">14</span><span class="operator">-</span>JUN<span class="number">-22</span></span><br></pre></td></tr></table></figure><h3 id="打开数据库注意设置resetlog">打开数据库，注意设置resetlog</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span> resetlogs;</span><br></pre></td></tr></table></figure><h3 id="检查">检查！</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> scott.baktest;</span><br></pre></td></tr></table></figure><figure><img src="image-20220614210608902.png" class="lazyload" data-srcset="image-20220614210608902.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220614210608902" /><figcaption aria-hidden="true">image-20220614210608902</figcaption></figure><p>结束</p></div><div class="story post-story"><h2 id="logminer">Logminer</h2><h3 id="启用日志挖掘器">启用日志挖掘器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SUPPLEMENTAL_LOG_DATA_MIN <span class="keyword">from</span> v$database;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> <span class="keyword">NO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> database <span class="keyword">add</span> supplemental log data;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> Database altered.</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> SUPPLEMENTAL_LOG_DATA_MIN <span class="keyword">from</span> v$database;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> YES</span><br></pre></td></tr></table></figure><p>Note: 删除方法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database <span class="keyword">drop</span> supplemental log data;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> Database altered.</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> SUPPLEMENTAL_LOG_DATA_MIN <span class="keyword">from</span> v$database;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> <span class="keyword">NO</span></span><br></pre></td></tr></table></figure><h3 id="产生数据字典文件">产生数据字典文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> dbms_logmnr_d</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">PROCEDURE</span> BUILD</span><br><span class="line"> Argument Name                  Type                    <span class="keyword">In</span><span class="operator">/</span><span class="keyword">Out</span> <span class="keyword">Default</span>?</span><br><span class="line"> <span class="comment">------------------------------ ----------------------- ------ --------</span></span><br><span class="line"> DICTIONARY_FILENAME            VARCHAR2                <span class="keyword">IN</span>     <span class="keyword">DEFAULT</span></span><br><span class="line"> DICTIONARY_LOCATION            VARCHAR2                <span class="keyword">IN</span>     <span class="keyword">DEFAULT</span></span><br><span class="line"> OPTIONS                        NUMBER                  <span class="keyword">IN</span>     <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="keyword">PROCEDURE</span> SET_TABLESPACE</span><br><span class="line"> Argument Name                  Type                    <span class="keyword">In</span><span class="operator">/</span><span class="keyword">Out</span> <span class="keyword">Default</span>?</span><br><span class="line"> <span class="comment">------------------------------ ----------------------- ------ --------</span></span><br><span class="line"> NEW_TABLESPACE                 VARCHAR2                <span class="keyword">IN</span></span><br></pre></td></tr></table></figure><p>产生方法：</p><h4 id="创建目录">创建目录</h4><p>操作系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /u01/&lt;dict&gt;</span><br></pre></td></tr></table></figure><p>oracle：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> directory dict1 <span class="keyword">as</span> <span class="string">&#x27;/u01/dict&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="创建文件">创建文件</h4><p>注意大小写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">execute</span> dbms_logmnr_d.build(<span class="string">&#x27;v816dict.ora&#x27;</span>, <span class="string">&#x27;DICT1&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="开始事务">开始事务</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn scott<span class="operator">/</span>tiger</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> Connected.</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> sal<span class="operator">=</span><span class="number">1800</span> <span class="keyword">where</span> empno<span class="operator">=</span><span class="number">7369</span>;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> <span class="number">1</span> <span class="type">row</span> updated.</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> <span class="keyword">Commit</span> complete.</span><br></pre></td></tr></table></figure><h3 id="添加需要分析的日志文件">添加需要分析的日志文件</h3><h4 id="查看当前日志文件">查看当前日志文件</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">group</span>#, status <span class="keyword">from</span> v$log;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">GROUP</span># STATUS</span><br><span class="line"><span class="comment">---------- --------------------------------</span></span><br><span class="line">         <span class="number">1</span> INACTIVE</span><br><span class="line">         <span class="number">2</span> INACTIVE</span><br><span class="line">         <span class="number">3</span> <span class="keyword">CURRENT</span></span><br></pre></td></tr></table></figure><p>查看对应的恢复日志文件：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">member</span> <span class="keyword">from</span> v$logfile <span class="keyword">where</span> <span class="keyword">group</span>#<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">/</span>u01<span class="operator">/</span>app<span class="operator">/</span>oracle<span class="operator">/</span>oradata<span class="operator">/</span>CTEST<span class="operator">/</span>redo03.log</span><br></pre></td></tr></table></figure><h4 id="添加要分析的日志">添加要分析的日志</h4><p>一定要注意不能写错路径查了别的数据库的log！</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">execute</span> dbms_logmnr.add_logfile(LogFileName<span class="operator">=</span><span class="operator">&gt;</span><span class="string">&#x27;/u01/app/oracle/oradata/CTEST/redo03.log&#x27;</span>, Options<span class="operator">=</span><span class="operator">&gt;</span>dbms_logmnr.new);</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> </span><br><span class="line">PL<span class="operator">/</span><span class="keyword">SQL</span> <span class="keyword">procedure</span> successfully completed.</span><br></pre></td></tr></table></figure><h3 id="启动分析">启动分析</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">execute</span> dbms_logmnr.start_logmnr(DictFileName<span class="operator">=</span><span class="operator">&gt;</span><span class="string">&#x27;/u01/_logmin_test1/v816dict.ora&#x27;</span>);</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span></span><br><span class="line">PL<span class="operator">/</span><span class="keyword">SQL</span> <span class="keyword">procedure</span> successfully completed.</span><br></pre></td></tr></table></figure><h3id="查询结果vlogmnr_contents">查询结果<code>v$logmnr_contents</code></h3><h4 id="修改时间戳格式">修改时间戳格式</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> nls_date_format<span class="operator">=</span><span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span></span><br><span class="line">Session altered.</span><br></pre></td></tr></table></figure><h4 id="查询最终结果">查询最终结果</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username, <span class="type">timestamp</span>, sql_redo <span class="keyword">from</span> v$logmnr_contents <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;SCOTT&#x27;</span>;</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="type">timestamp</span>, username, sql_redo <span class="keyword">from</span> v$logmnr_contents <span class="keyword">where</span> USERNAME<span class="operator">=</span><span class="string">&#x27;SCOTT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">TIMESTAMP</span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line">USERNAME</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line">SQL_REDO</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">17</span></span><br><span class="line">SCOTT</span><br><span class="line"><span class="keyword">set</span> transaction read write;</span><br><span class="line"></span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">17</span></span><br><span class="line">SCOTT</span><br><span class="line"><span class="keyword">update</span> &quot;SCOTT&quot;.&quot;EMP&quot; <span class="keyword">set</span> &quot;SAL&quot; <span class="operator">=</span> <span class="string">&#x27;1800&#x27;</span> <span class="keyword">where</span> &quot;SAL&quot; <span class="operator">=</span> <span class="string">&#x27;2900&#x27;</span> <span class="keyword">and</span> ROWID <span class="operator">=</span> <span class="string">&#x27;AAAR34AAHAAAAFvAAA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">17</span></span><br><span class="line">SCOTT</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></div><div class="story post-story"><h2 id="oracle-数据库系统结构概述">Oracle 数据库系统结构概述</h2><p><ahref="https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/introduction-to-oracle-database.html#GUID-8F2EEEC8-0372-4419-88FF-7D77A9C0FCAD">官方参考资料</a></p><p>Oracle数据库由<code>数据库存储结构</code>和<code>数据库实例</code>两部分构成。</p><ul><li><p>数据库</p><p>数据库是位于磁盘上的一组文件，用于存储数据。这些文件可以独立于数据库实例而存在。</p></li><li><p>数据库实例</p><p>实例是一组管理数据库文件的内存结构。该实例由一个共享内存区域（称为系统全局区域<code>SGA</code>）和一组后台进程组成。实例可以独立于数据库文件而存在。</p></li></ul><p>下图显示了数据库及其实例。对于与实例的每个用户连接，客户端进程将运行该应用程序。每个客户端进程都与自己的服务器进程相关联。服务器进程具有自己的专用会话内存，称为程序全局区域<code>PGA</code>。</p><p><ahref="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-18-12-46.png"><imgsrc="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-18-12-46.png"alt="Oracle实例和数据库" /></a></p><p>其中<code>存储结构</code>包括<code>物理存储结构</code>和<code>逻辑存储结构</code>，是<code>数据存储及空间分配</code>的基础；<code>实例</code>是构成Oracle数据库的<code>软件结构</code>，包括<code>内存结构</code>和<code>后台进程</code>，是<code>数据库运行与管理</code>的基础。</p><p>Oracle数据库由存放在磁盘上的数据库<code>DB</code>和对磁盘上的数据库进行管理的数据库管理系统<code>DBMS</code>两部分构成，分别对应着数据库的<code>存储结构</code>和<code>软件结构</code>。</p><p>Oracle 数据库的存储结构（StorageStructure）分为<code>物理存储结构</code>和<code>逻辑存储结构</code>两种，分别描述了在<code>操作系统</code>中和<code>数据库系统</code>内部数据的组织与管理方式。其中，物理存储结构表现为操作系统中一系列文件，逻辑存储结构是对物理存储结构的逻辑组织与管理。</p><p>Oracle 数据库的软件结构，即 Oracle实例（Instance），包括<code>内存结构</code>与<code>后台进程结构</code>两部分。</p><p><ahref="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-18-12-10.png"><imgsrc="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-18-12-10.png"alt="Oracle数据库系统结构内部关系" /></a></p><p>图描述了 Oracle数据库<code>内存结构</code>、<code>后台进程结构</code>、<code>存储结构</code>之间的关系。从图中可以看出，用户的所有操作都是通过<code>实例</code>完成的，首先在<code>内存结构</code>中进行，在一定条件下由数据库的<code>后台进程结构</code>写入数据库的<code>物理存储结构</code>做永久保存</p><h3 id="存储结构">存储结构</h3><p>Oracle数据库的存储结构分为<code>物理存储结构</code>和<code>逻辑存储结构</code>两种。</p><ul><li>物理存储结构主要用于描述在 Oracle数据库外部数据的存储，即在操作系统层面中如何组织和管理数据，与具体的操作系统有关。</li><li>逻辑存储结构主要描述 Oracle数据库内部数据的组织和管理方式，即在数据库管理系统的层面中如何组织和管理数据，与操作系统没有关系。</li></ul><p>物理存储结构具体表现为一系列的操作系统文件，是可见的；而逻辑存储结构是物理存储结构的抽象体现，是不可见的，可以通过查询数据库数据字典了解逻辑存储结构信息。</p><p>Oracle数据库的物理存储结构与逻辑存储结构既相互独立又相互联系，如图所示。</p><p><ahref="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-07-20.png"><imgsrc="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-07-20.png"alt="Oracle数据库物理存储结构与逻辑存储结构的关系" /></a></p><p>从图中可以看出数据库物理存储结构与逻辑存储结构的基本关系。</p><ul><li>一个数据库在物理上包含多个数据文件，在逻辑上包含多个表空间。</li><li>一个表空间包含一个或多个数据文件，一个数据文件只能从属于某个表空间。</li><li>数据库的逻辑块由一个或多个操作系统块构成。</li><li>一个逻辑区只能从属于某一个数据文件，而一个数据文件可包含一个或多个逻辑区。</li></ul><h4 id="物理存储结构概述">1. 物理存储结构概述</h4><p>Oracle数据库的物理存储结构是由一系列操作系统文件组成的，存放于物理磁盘上，是数据库的实际存储单元。这些文件主要包括数据文件、控制文件、重做日志文件、归档文件、初始化参数文件、跟踪文件、告警文件等。每种文件都存储特定内容的信息，其数量也因文件类型不同而不同。</p><ul><li>数据文件：是数据库中所有数据的实际存储空间，所有数据文件的大小和构成了数据库的大小。</li><li>控制文件：记录数据库结构信息的重要的二进制文件，由 Oracle 系统进行读/ 写操作，DBA 不能直接操作控制文件。</li><li>重做日志文件：是以重做记录的形式记录、保存用户对数据库所进行的变更操作，是数据库中最重要的物理文件。</li><li>归档日志文件：是历史联机重做日志文件的集合，是联机重做日志文件被覆盖之前备份的副本。</li><li>初始化参数文件：是数据库启动过程所必需的文件，记录了数据库显式参数的设置。数据库启动的第一步就是根据初始化参数文件中的设置，创建并启动实例，即分配内存空间、启动后台进程。</li><li>跟踪文件：是数据库中重要的诊断文件，是获取数据库信息的重要工具，对管理数据库的实例起着至关重要的作用。跟踪文件中包含数据库系统运行过程中所发生的重大事件的有关信息，可以为数据库运行故障的解决提供重要信息。</li><li>告警文件：是数据库中重要的诊断文件，记录数据库在启动、关闭和运行期间后台进程的活动情况。</li></ul><h4 id="逻辑存储结构概述">2. 逻辑存储结构概述</h4><p>Oracle数据库的逻辑存储结构是从逻辑的角度来分析数据库的构成的，也就是数据库创建后利用逻辑概念来描述Oracle数据库内部数据的组织和管理形式。在操作系统中，没有数据库逻辑存储结构信息，而只有物理存储结构信息。数据库的逻辑存储结构概念存储在数据库的数据字典中，可以通过数据字典查询逻辑存储结构信息。</p><p>Oracle 数据库的逻辑存储结构分为 Oracle 数据块（Oracle DATEBlock）、区（Extent）、段（Segment）和表空间（Table space）4种，它们之间的关系如图所示。一个或多个连续的 Oracle数据块构成区，一个或多个区构成段，一个或多个段构成表空间，所有表空间构成数据库。</p><p><ahref="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-09-00.png"><imgsrc="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-09-00.png"alt="Oracle数据库逻辑存储结构之间的关系" /></a></p><ol type="1"><li><p>Oracle 数据块</p><p>Oracle数据块是数据库中最小的逻辑存储单元，是数据库执行输入、输出操作的最小单位，由一个或者多个操作系统块构成。在Oracle 11g数据库中，数据块分为标准块和非标准块两种，其中标准块由数据库初始化参数DB_BLOCK_SIZE 设置，其大小不可更改。Oracle数据库的默认数据缓冲区就是由标准数据块构成的。</p></li><li><p>区</p><p>区是由一系列连续的数据块构成的逻辑存储单元，是存储空间分配的最小单位。当创建一个数据库对象时，Oracle为对象分配若干个区，以构成一个段来为对象提供初始的存储空间。当段中已分配的区都写满后，Oracle会为段分配一个新区，以容纳更多的数据。构成一个段的所有区只能在一个文件中。在Oracle数据库中，引入区的目的是为了提高系统存储空间分配的效率，以区为单位的存储空间分配大大减少了磁盘分配的次数。</p></li><li><p>段</p><p>段是由一个或多个连续或不连续的区组成的逻辑存储单元，用于存储特定的、具有独立存储结构的数据库对象。根据存储对象类型不同，分为表段、索引段、临时段和回退段4 类。</p><ul><li>表段，又称数据段，用来存储表或簇的数据，可以细分为普通表段（TABLE）、分区表段（TABLEPartition）、簇段（Cluster）、索引化表段（INDEX-organized TABLE）。</li><li>索引段用来存放索引数据，包括 ROWID 和索引键值。</li><li>临时段是进行查询、排序等操作时，如果内存空间不足，用于保存 SQL语句在解释和执行过程中产生的临时数据。会话结束时，为该操作分配的临时段将被释放。</li><li>回退段用于保存数据库的回退信息，包含当前未提交事务所修改的数据的原始版本。利用回退段中保存的回退信息，可以实现事务回滚、数据库恢复、数据的读一致性和闪回查询。</li></ul></li><li><p>表空间</p><p>表空间是 Oracle数据库最大的逻辑存储单元，数据库的大小从逻辑上看就是由表空间决定的，所有表空间大小的和就是数据库的大小。在Oracle 数据库中，存储结构管理主要就是通过对表空间的管理来实现的。</p><p>表空间与数据库文件直接关联，一个表空间包含一个或多个数据文件，一个数据文件只能从属于某一个表空间，数据库对象就是存储在表空间对应的一个或多个数据文件中。</p><p>表空间根据存储数据的类型不同，分为系统表空间和非系统表空间两类。系统表空间主要存放数据库的系统信息，如数据字典信息、数据库对象定义信息、数据库组件信息等。非系统表空间又分为撤销表空间、临时表空间和用户表空间等。其中，撤销表空间用于自动管理数据库的回退信息，临时表空间用于管理数据库的临时信息，用户表空间用于存储用户的业务数据。Oracle11g 数据库在创建时会自动创建 6 个表空间，见表 3-1。</p></li></ol><p>Oracle 11g 数据库自动创建的表空间</p><table><colgroup><col style="width: 10%" /><col style="width: 13%" /><col style="width: 76%" /></colgroup><thead><tr class="header"><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>SYSTEM</td><td>系统表空间</td><td>存放数据字典、数据库对象定义、PL/SQL 程序源代码等系统信息</td></tr><tr class="even"><td>SYSAUX</td><td>系统表空间</td><td>辅助系统表空间，存储数据库组件等信息</td></tr><tr class="odd"><td>TEMP</td><td>临时表空间</td><td>存放临时数据，用于排序等操作</td></tr><tr class="even"><td>UNDOTBS1</td><td>撤销表空间</td><td>存储、管理回退信息</td></tr><tr class="odd"><td>USERS</td><td>用户表空间</td><td>存放用户业务数据信息</td></tr><tr class="even"><td>EXAMPLE</td><td>示例表空间</td><td>示例表空间，存放示例的数据库方案对象信息</td></tr></tbody></table><h3 id="内存结构">内存结构</h3><p>Oracle数据库实例由一系列内存结构和后台进程组成。用户操作数据库的过程实质上是与数据库实例建立连接，然后通过实例来操作数据库的过程。用户的所有操作都在内存中进行，最后由数据库后台进程将操作结果写入各种物理文件中永久性保存。</p><p>内存结构是 Oracle 数据库体系结构的重要组成部分，是 Oracle数据库重要的信息缓存和共享区域。根据内存区域信息使用范围的不同，分为系统全局区（SystemGlobal Area，SGA）和程序全局区（Program Global Area，PGA）。</p><h4 id="sga">1. SGA</h4><p>SGA 是由 Oracle分配的共享内存结构，包含一个数据库实例的数据和控制信息。SGA数据供所有的服务器进程和后台进程共享，所以 SGA 又称为共享全局区（SharedGlobal Area）。用户对数据库的各种操作主要在 SGA中进行。该内存区随数据库实例的创建而分配，随实例的终止而释放。</p><p>SGA 主要由数据高速缓冲区（Database Buffer Cache）、共享池（SharedPool）、重做日志缓冲区（Redo Log Cache）、大型池（Large Pool）、Java池（Java Pool）、流池（Streams Pool）和其他结构（如固定SGA、锁管理等）组成。</p><ol type="1"><li><p>数据高速缓冲区</p><p>数据高速缓冲区存储的是最近从数据文件中检索出来的数据，供所有用户共享。当用户要操作数据库中的数据时，先由服务器进程将数据从磁盘的数据文件中读取到数据高速缓冲区中，然后在缓冲区中进行处理。用户处理后的结果被存储在数据高速缓冲区中，最后由数据库写入进程DBWR 写到硬盘的数据文件中永久保存，如图所示。</p><p><ahref="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-15-14.png"><imgsrc="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-15-14.png"alt="数据高速缓冲区的工作过程" /></a></p><p>根据数据缓冲区中存放的信息的不同，数据高速缓冲区分为下列 4种类型。</p><ul><li>脏缓存块（DirtyBuffers）：脏缓存块中保存的是已经被修改过的数据。</li><li>空闲缓存块（FreeBuffers）：空闲缓存块中不包含任何数据，它们等待后台进程或服务器进程向其中写入数据。</li><li>命中缓存块（PinnedBuffers）：命中缓存块是那些正被使用的数据块，同时还有很多会话等待修改或访问的数据块。</li><li>干净缓存块（CleanBuffers）：干净缓存块是指那些当前没有被使用，即将被换出内存的缓存块，这些块中的数据要么没有被修改，要么在内存中有该数据块的快照。</li></ul><p>在 Oracle 11g中，数据高速缓冲区由标准缓冲区和非标准缓冲区构成，两者的和决定了数据高速缓冲区大小。标准缓冲区大小由参数DB_CACHE_SIZE 设定，非标准缓冲区由参数 DB_nK_CACHE_SIZE 设定。</p></li><li><p>重做日志缓冲区</p><p>重做日志缓冲区用于缓存用户对数据库进行修改操作时生成的重做记录。为了提高工作效率，重做记录并不是直接写入到重做日志文件中，而是首先被服务器进程写入重做日志缓冲区中，在一定条件下，再由日志写入进程LGWR把重做日志缓冲区的内容写入到重做日志文件中做永久性保存。在归档模式下，当重做日志切换时，由归档进程ARCH 将重做日志文件的内容写入到归档文件中，如图所示。</p><p><ahref="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-16-17.png"><imgsrc="https://liushilive.github.io/github_exercise_oracle/lsbook_import_img/2020-06-21-19-16-17.png"alt="重做日志缓冲区的工作过程" /></a></p><p>重做日志缓存区大小由初始化参数 LOG_BUFFER 设定。</p></li><li><p>共享池</p><p>共享池用于缓存最近执行过的 SQL 语句、PL/SQL 程序和数据字典信息，是对SQL 语句、PL/SQL 程序进行语法分析、编译、执行的区域。</p><p>共享池由库缓存（Library Cache）和数据字典缓存（DictionaryCache）组成。</p><ul><li><p>库缓存</p><p>Oracle 执行用户提交 SQL 语句或 PL/SQL程序之前，先要对其进行语法分析、对象确认、权限检查、执行优化等一系列操作，并生成执行计划。这一系列操作会占用一定的系统资源，如果多次执行相同的SQL 语句、PL/SQL程序，都要进行如此操作的话，将浪费很多系统资源。库缓存的作用就是缓存最近被解释并执行过的SQL 语句、PL/SQL 程序代码正文、编译后代码以及执行计划，以提高SQL、PL/SQL 程序的执行效率。当执行 SQL 语句或 PL/SQL 程序时，Oracle首先在共享池的库缓存中搜索，查看正文完全相同的 SQL 语句或 PL/SQL程序是否已经被分析、解析、执行并缓存过。如果有，Oracle将利用缓存中的分析结果和执行计划来执行该语句，而不必重新对它进行解析，从而大大提高了系统的执行速度。</p></li><li><p>数据字典缓存区</p><p>数据字典缓存区中保存最常使用的数据字典信息，如数据库对象信息、账户信息、数据库结构信息等。当用户访问数据库时，可以从数据字典缓存中获得对象是否存在、用户是否有操作权限等信息，大大提高了执行效率。</p><p>共享池的大小由初始化参数 SHARED_POOL_SIZE 设定。</p></li></ul></li><li><p>大型池</p><p>大型池是一个可选的内存配置项，主要为 Oracle 共享服务器、服务器 I/O进程、数据库备份与恢复操作、执行具有大量排序操作的 SQL语句、执行并行化的数据库操作等需要大量缓存的操作提供内存空间。如果没有在SGA 中创建大型池，上述操作所需要的缓存空间将在共享池或 PGA中分配，因而会影响共享池或 PGA 的使用效率。</p><p>大型池的大小由初始化参数 LARGE_POOL_SIZE 设定。</p></li><li><p>Java 池</p><p>Java 池是一个可选的内存配置项，提供对 Java 程序设计的支持，用于存储Java 代码、Java 语句的语法分析表、Java 语句的执行方案和进行 Java程序开发等。</p><p>Java 池大小由初始化参数 JAVA_POOL_SIZE 设定。</p></li><li><p>流池</p><p>流池是一个可选的内存配置项，用于对流的支持。</p><p>流池大小由初始化参数 STREAMS_POOL_SIZE 设定。</p></li></ol><h4 id="pga">2. PGA</h4><p>Oracle创建一个服务器进程的同时要为该服务器进程分配一个内存区，该内存区称为程序全局区（ProgramGlobal Area，PGA）。PGA是一个私有的内存区，不能共享，每个服务器进程只能访问自己的 PGA，因此 PGA又称为私有全局区（Private GlobalArea）。系统同时为每个后台进程分配私有的 PGA 区。所有服务器进程 PGA与所有后台进程 PGA 大小的和，即为实例的 PGA 的大小。PGA随着服务器进程与后台进程的启动而分配，随着服务器进程和后台进程终止而被释放。</p><p>PGA 由下列 4 部分组成。</p><ol type="1"><li>排序区（SORT Area）：存放排序操作所产生的临时数据。</li><li>游标信息区（CursorInformation）：存放执行游标操作时所产生的数据。</li><li>会话信息区（SessionInformation）：保存用户会话所具有的权限、角色、性能统计信息。</li><li>堆栈区（StackSpace）：用于保存会话过程中的绑定变量、会话变量等信息。</li></ol><h3 id="后台进程">后台进程</h3><h4 id="oracle-进程概述">1. Oracle 进程概述</h4><ol type="1"><li><p>进程概念</p><p>进程是操作系统中一个独立的可以调度的活动，用于完成指定的任务。进程与程序的区别在于：</p><p>进程是动态的概念，即动态创建，完成任务后立即消亡；而程序是一个静态实体。进程强调执行过程，而程序仅仅是指令的有序集合。</p></li><li><p>进程类型</p><p>在 Oracle 数据库服务器中，进程分为用户进程（USERProcess）、服务器进程（Server Process）和后台进程（Background Process）3种。</p><ul><li><p>用户进程</p><p>当用户连接数据库执行一个应用程序时，会创建一个用户进程，来完成用户所指定的任务。</p></li><li><p>服务器进程</p><p>Oracle 服务器进程由 Oracle自身创建，用于处理连接到数据库实例的用户进程所提出的请求。</p><p>服务器进程主要完成以下任务：</p><ol type="1"><li>解析并执行用户提交的 SQL 语句和 PL/SQL 程序。</li><li>在 SGA的数据高速缓冲区中搜索用户进程所要访问的数据，如果数据不在缓冲区中，则需要从硬盘数据文件中读取所需的数据，再将它们复制到缓冲区中。</li><li>将用户改变数据库的操作信息写入日志缓冲区中。</li><li>将查询或执行后的结果数据返回给用户进程。</li></ol></li><li><p>后台进程</p><p>为了保证 Oracle数据库在任意一个时刻都可以处理多用户的并发请求，进行复杂的数据操作，而且优化系统性能，Oracle数据库启用了一些相互独立的附加进程，称为后台进程。服务器进程在执行用户进程请求时，会调用后台进程来实现对数据库的操作。</p></li></ul></li></ol><h4 id="oracle-后台进程">2. Oracle 后台进程</h4><p>Oracle实例的主要后台进程包括数据库写入进程（DBWR）、日志写入进程（LGWR）、检查点进程（CKPT）、系统监控进程（SMON）、进程监控进程（PMON）、归档进程（ARCH）、恢复进程（RECO）、锁进程（LCKn）、调度进程（Dnnn）等，其中前5 个后台进程是必需的。</p><p>数据库的后台进程随数据库实例的启动而自动启动，它们协调服务器进程的工作，优化系统的性能。可以通过初始化参数文件中参数的设置来确定启动后台进程的数量。</p><ol type="1"><li><p>DBWR</p><p>数据库写入进程负责把数据高速缓冲区中已经被修改过的数据（脏缓存块）成批写入数据文件中永久保存，同时使数据高速缓冲区有更多的空闲缓存块，保证服务器进程将所需要的数据从数据文件中读取到数据高速缓冲区中，提高缓存命中率。</p><p>当下列某个条件满足时，DBWR进程将启动，将数据高速缓冲区中的脏数据写入数据文件：</p><ul><li>服务器进程在数据高速缓存区中搜索一定数量的缓存块后，仍然没有找到可用的空闲缓存块，此时DBWR 进程将被启动；</li><li>检查点发生时，将启动 DBWR 进程；</li><li>当数据高速缓冲区中 LRU 列表长度达到初始化参数 DB_BLOCK_WRITE_BATCH指定值的一半时，DBWR 进程将被启动；</li><li>DBWR 进程发生超时（约 3s），DBWR 进程将被启动。</li></ul><blockquote><p>注意：DBWR 进程启动的时间与用户提交事务的时间完全无关。</p></blockquote></li><li><p>LGWR</p><p>日志写入进程负责把重做日志缓冲区的重做记录写入重做日志文件中永久保存。</p><p>DBWR 进程在工作之前，需要了解 LGWR进程是否已经把相关的日志缓冲区中的重做记录写入重做日志文件中。如果还没有写入重做日志文件，DBWR进程将通知 LGWR 进程完成相应的工作，然后 DBWR进程才开始写入。这样可以保证先将与脏缓存块相关的重做记录信息写入重做日志文件，然后将脏缓存块写入数据文件，即先写重做日志文件，后写数据文件。</p><p>当下列事件发生时，LGWR进程会将重做日志缓冲区中的重做记录写入重做日志文件：</p><ul><li>用户通过 COMMIT 语句提交当前事务；</li><li>重做日志缓冲区被写满三分之一；</li><li>DBWR 进程开始将脏缓存块写入数据文件；</li><li>LGWR 进程超时（约 3s），LGWR 进程将启动。</li></ul></li><li><p>CKPT</p><p>检查点是一个事件，当该事件发生时（每隔一段时间发生），DBWR进程把数据高速缓冲区中的脏缓存块写入数据文件中，同时 Oracle将对数据库控制文件和数据文件的头部的同步序号进行更新，以记录下当前的数据库结构和状态，保证数据的同步。</p><p>在执行了一个检查点事件后，Oracle知道所有已提交的事务对数据库所做的更改已经全部被写入到数据文件中，此时数据库处于一个完整状态。在发生数据库崩溃后，只需要将数据库恢复到上一个检查点执行时刻即可。因此，缩短检查点执行的间隔，可以缩短数据库恢复所需的时间。</p><p>CKPT 进程的作用就是执行检查点，完成下列操作：</p><ul><li>更新控制文件与数据文件的头部，使其同步；</li><li>触发 DBWR 进程，将脏缓存块写入数据文件。</li></ul></li><li><p>SMON</p><p>如果由于某种原因系统崩溃了，那么 SGA中任何没有来得及写入磁盘文件中的信息都将丢失。如果有些已经提交的数据还没有真正写入数据文件中就会丢失了，当数据库重新启动时，SMON进程将自动执行 Oracle 实例的恢复工作。</p><p>除了进行数据库实例恢复外，SMON 进程还具有以下功能：</p><ul><li>回收不再使用的临时空间；</li><li>将各个表空间的空闲碎片合并（表空间的存储参数 PCTINCREASE 不为 0时）。</li><li>SMON进程除了在实例启动时执行一次外，在实例运行期间，它会被定期唤醒，检查是否有工作需要它来完成。如果有其他任何进程需要使用SMON 进程的功能，它们将随时唤醒 SMON 进程。</li></ul></li><li><p>PMON</p><p>PMON 进程的主要功能包括：</p><ul><li>负责恢复失败的用户进程或服务器进程，并且释放进程所占用的资源；</li><li>清除非正常中断的用户进程留下的孤儿会话，回退未提交的事务，释放会话所占用的锁、SGA、PGA等资源；</li><li>监控调度进程和服务器进程的状态，如果它们失败，则尝试重新启动它们，并释放它们所占用的各种资源。</li><li>与 SMON 进程类似，PMON进程在实例运行期间会被定期唤醒，检查是否有工作需要它来完成。如果有其他任何进程需要使用PMON 进程的功能，它们将随时唤醒 PMON 进程。</li></ul></li><li><p>ARCH</p><p>ARCH进程负责在日志切换后将已经写满的重做日志文件复制到归档目标，以防止写满的重做日志文件被覆盖。</p><p>只有当数据库运行在归档模式，并且初始化参数 LOG_ARCHIVE_START 设置为TRUE，即启动自动归档功能时，才能启动 ARCH进程；否则当重做日志文件全部被写满后，数据库将被挂起，等待 DBA进行手工归档。</p></li></ol><h3 id="数据字典">数据字典</h3><h4 id="概述">1.概述</h4><ol type="1"><li><p>数据字典的内容与作用</p><p>数据字典是数据库重要组成部分，是在数据库创建过程中创建的，保存了数据库系统信息以及数据库中所有的对象信息，是数据库系统运行的基础。</p><p>Oracle数据库的数据字典由一系列表和视图构成，这些表和视图对于所有的用户，包括DBA，都是只读的。只有 Oracle 系统才可以对数据字典进行管理与维护。在Oracle 数据库中，所有数据字典表和视图都属于 SYS 模式，存储于 SYSTEM表空间中。</p><p>Oracle数据字典保存数据库本身的系统信息及所有数据库对象信息，包括：</p><ul><li>各种数据库对象的定义信息，包括表、视图、索引、同义词、序列、存储过程、函数、包、触发器及其他各种对象；</li><li>数据库存储空间分配信息，如为某个数据库对象分配了多少空间，已经使用了多少空间等；</li><li>数据库的安全信息，包括用户、权限、角色、完整性等；</li><li>数据库运行时的性能和统计信息；</li><li>其他数据库本身的基本信息。</li></ul><p>数据字典除了用于 Oracle 进行系统管理外，对于 DBA以及普通数据库用户都有着非常重要的作用。数据字典的主要用途包括：</p><ul><li>Oracle通过访问数据字典获取用户、模式对象、数据库对象定义与存储等信息，以判断用户权限合法性、模式对象存在性及存储空间的可用性等；</li><li>使用 DDL 语句修改数据库对象后，Oracle将在数据字典中记录所做的修改；</li><li>任何数据库用户都可以从数据字典只读视图中获取各种数据库对象信息；</li><li>DBA可以从数据字典动态性能视图中获取数据库的运行状态，作为进行性能调整的依据。</li></ul></li><li><p>数据字典的管理与维护</p><p>数据字典主要是由 Oracle数据库服务器使用的，服务器通过访问数据字典基表获取用户、数据库对象、存储结构等信息，并利用这些信息进行数据库的管理与维护。只有Oracle 系统可以对数据字典进行管理与维护。在 Oracle数据库运行过程中，如果数据库结构发生变化，Oracle数据库服务器会及时地修改相应的数据字典以记录这些变化。</p><p>当数据库中执行下列各种 SQL 语句操作时，Oracle数据库服务器会修改数据字典信息。</p><ul><li>DDL 语句。如增加或减少表空间、增加或减少用户。</li><li>DCL 语句。如授予用户权限、回收用户权限。</li><li>DML 语句。某些 DML语句，如引起表的存储空间扩展的插入、修改语句，Oracle会将磁盘上存储空间的变化信息记录到数据字典中。</li></ul><p>包括数据库管理员（DBA）在内的任何用户都不能直接使用 DML语句修改数据字典中的内容。所有用户和管理员（DBA）只能通过访问数据字典视图来得到数据库的相关信息。一些数据字典视图可以被所有用户访问，而另一些只能被数据库管理员访问。</p></li></ol><h4 id="数据字典的结构">2. 数据字典的结构</h4><p>数据字典主要包括数据字典表和数据字典视图两种。根据数据字典对象的虚实性不同，分为静态的数据字典和动态数据字典两种，其中，静态数据字典在用户访问数据字典时不会发生改变，但动态数据字典是依赖数据库运行的性能的，反映数据库运行的一些内在信息，所以在访问这类数据字典时往往不是一成不变的。</p><ol type="1"><li><p>静态数据字典表</p><p>静态数据字典表是在数据库创建过程中自动运行sql.bsq（<code>%Oracle_HOME%\RDBMS\ADMIN\sql.bsq</code>）脚本创建的，由SYS用户所拥有，表中信息都是经过加密处理的。数据字典中的所有信息实际上都是存储在静态数据字典表中的。静态数据字典表的命名中通常包含<code>$</code> 符号。只有 Oracle 才能读 /写这些静态数据字典表。例如，静态数据字典表 <code>tab$</code>。</p></li><li><p>静态数据字典视图</p><p>由于静态数据字典表对于用户而言是不可访问的，因此，通过对静态数据字典表进行解密和处理，创建了一系列用户可读的静态数据字典视图。在数据库创建过程中，通过自动运行catalog.sql（<code>%Oracle_HOME%\RDBMS\ADMIN\catalog.sql</code>）脚本创建静态数据字典视图及其公共同义词，并进行授权。例如，静态数据字典视图USER_TABLES。</p></li><li><p>动态数据字典表</p><p>动态数据字典表是在数据库实例运行过程中由 Oracle动态创建和维护的一系列“虚表”，在实例关闭时被释放。动态数据字典表中记录与数据库运行的性能相关的统计信息，因此又称为动态性能表。通常，动态性能表的命名以<code>X$</code>开头。动态性能表由 SYS 用户所拥有。例如，动态性能表<code>X$KSPPI</code>。</p></li><li><p>动态数据字典视图</p><p>在动态性能表上创建的视图称为动态数据字典视图，又称动态性能视图。所有动态性能视图命名都以V开头，Oracle自动为这些视图创建了以‘V开头，*O<strong>r</strong>a<strong>c</strong>l**e<em>自动为这些视图创建了以‘</em>V*<code>开头命名的公共同义词，因此动态性能视图又称为</code>V$视图<code>。例如，动态性能视图</code>V$DATAFILE`。</p><p>通过查询表dictionary，可以获得全部可以访问的数据字典表或视图的名称和解释；通过查询表dict_columns，可以获得全部可以访问的数据字典表或视图中字段名称和解释。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dictionary;</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dict_columns <span class="keyword">WHERE</span> TABLE_NAME<span class="operator">=</span><span class="string">&#x27;USER_TABLES&#x27;</span>;</span><br></pre></td></tr></table></figure><p>SQL</p><p>Copy</p></li></ol><h4 id="数据字典的使用">3. 数据字典的使用</h4><ol type="1"><li><p>静态数据字典表的使用</p><p>静态数据字典表只能由 Oracle进行维护，用户不能对这些表进行直接操作。当用户执行 DDL 操作时，Oracle系统自动对相应的静态数据字典表进行操作。例如，当执行 CREATE TABLE、ALTERTABLE 和 DROP TABLE 操作时，系统会自动对 <code>TAB$</code> 表进行INSERT、UPDATE 和 DELETE 操作。</p></li><li><p>静态数据字典视图的使用</p><p>通常，用户通过对静态数据字典视图的查询可以获取所需要的所有数据库信息。</p><p>Oracle 静态数据字典视图可以分为 3类，各类视图具有独特的前缀，其表示形式和含义如表所描述。</p><p>静态数据字典视图分类及其含义</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr class="header"><th>名称前缀</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>USER_</td><td>包含当前数据库用户所拥有的所有的模式对象的信息</td></tr><tr class="even"><td>ALL_</td><td>包含当前数据库用户可以访问的所有的模式对象的信息</td></tr><tr class="odd"><td>DBA_</td><td>包含所有数据库对象信息，只有具有 DBA角色的用户才能够访问这些视图</td></tr></tbody></table><p>例如，查询当前用户所拥有的表的信息、可以访问的表的信息及当前数据库所有表的信息，可以分别执行下列语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> USER_TABLES;</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ALL_TABLES;</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SYS.DBA_TABLES;</span><br></pre></td></tr></table></figure><p>SQL</p><p>Copy</p><p>注意：以USER_、ALL_开头的数据字典视图都具有与其同名公共同义词，用户可以直接访问，而以DBA_开头的数据字典视图归 SYS用户所有，没有与其对应的同名公共同义词，因此非 SYS 用户访问时，需在DBA_视图名前加 SYS 前缀。</p></li><li><p>动态性能表的使用</p><p>动态性能表是数据库实例启动后动态创建的表，用于存放数据库运行过程中的性能相关的信息。动态性能表都属于SYS 用户，Oracle 使用这些表生成动态性能视图。</p><p>可以通过下列语句查询当前数据库中所有的动态性能表和动态性能视图：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> V_$FIXED_TABLE;</span><br></pre></td></tr></table></figure><p>SQL</p><p>Copy</p></li><li><p>动态性能视图的使用</p><p>动态性能视图是 SYS 用户所拥有的，在默认状况下，只有 SYS 用户和拥有DBA角色的用户可以访问。与静态数据字典表和视图不同，在数据库启动的不同阶段只能访问不同的动态性能视图。</p><p>当数据库启动到 NOMOUNT 状态时，Oracle 数据库打开初始化参数文件，分配SGA 并启动后台进程，因此只能访问从 SGA 中获得信息的动态性能视图，如<code>V$PARAMETER</code>、<code>V$SGA</code>、<code>V$SESSION</code>、<code>V$PROCESSE</code>、<code>V$INSTANCE</code>、<code>V$VERSION</code>、<code>V$OPTION</code>等。</p><p>当数据库启动到 MOUNT 状态时，Oracle 打开控制文件，因此不仅能访问从SGA中获得信息的动态性能视图，还可以访问从控制文件中获得信息的动态性能视图，如<code>V$LOG</code>、<code>V$LOGFILE</code>、<code>V$DATAFILE</code>、<code>V$CONTROLFILE</code>、<code>V$DATABASE</code>、<code>V$THREAD</code>、<code>V$DATAFILE_HEADER</code>等。</p><p>当数据库完全启动后，可以访问 <code>V_$fixed_table</code>表中所有的动态性能视图。</p><p>例如，利用动态性能视图查询当前数据库参数设置信息、数据文件信息。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$<span class="keyword">PARAMETER</span>;</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> DATAFILE;</span><br></pre></td></tr></table></figure></li></ol></div><div class="story post-story"><h2 id="数据类型">数据类型</h2><p>要使用数据库来存储数据，首先就要知道这个数据库都能存储什么类型的数据。</p><p>数据类型是在向数据表中存储数据前必须设定好的，就像如果要使用记事本查看文件内容，那么文件就要是文本的，不能有图片，否则图片是查看不了的，因为记事本中只能查看文本文件。</p><p><ahref="https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6">官网文档</a></p><p>在 Oracle 11g 中提供的数据类型有 23 种，下面介绍常用的数据类型。</p><h3 id="字符型">1. 字符型</h3><p>字符型在 Oracle 11g 中有 varchar2、char、nchar、nvarchar2 和 long五种，它们在数据库中是以 ASCII 码的格式存储的。</p><table><colgroup><col style="width: 15%" /><col style="width: 84%" /></colgroup><thead><tr class="header"><th>数据类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>CHAR(n)</td><td>存储固定长度的字符串，长度以字节为单位，默认和最小字符数为1，最大字符数为 2000</td></tr><tr class="even"><td>VARCHAR2(n)</td><td>存储可变长度的字符串，长度以字节为单位，最小字符数是 1，最大字符数是4000</td></tr></tbody></table><h3 id="数字型">2. 数字型</h3><p>数字型在 Oracle 11g 中常用的有 number 和 float类型两种，可以用它们来表示整数和小数。</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th>数据类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>NUMBER(p, s)</td><td>可以存储 0、正数和负数。p 表示数值的总位数（精度），取值范围为1～38；s 表示刻度，取值为−84～127</td></tr></tbody></table><h3 id="日期类型">3. 日期类型</h3><p>日期类型在 Oracle 11g 中常用的有 date 和 timestamp两种类型，可以用它们来存放日期和时间。</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th>数据类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>DATE</td><td>用于存储日期和时间。可以存储的日期范围为公元前 4712 年 1 月 1日到公元后 9999 年 12 月 31 日，占据 7字节的空间，由世纪、年、月、日、时、分、秒组成</td></tr><tr class="even"><td>TIMESTAMP(n)</td><td>表示时间戳，是 DATE 数据类型的扩展，允许存储小数形式的秒值。p表示秒的小数位数，取值范围为 0～9，默认值为 6</td></tr></tbody></table><h3 id="其他数据类型">4. 其他数据类型</h3><p>除了上面讲过的字符型、数字型、日期类型之外，在 Oracle 11g中还有存放大数据的数据类型以及存放二进制文件的数据类型。</p><table><colgroup><col style="width: 11%" /><col style="width: 83%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th>数据类型</th><th>取值范围（字节）</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>CLOB</td><td>用于存储单字节或多字节的大型字符串对象，支持使用数据库字符集的定长或变长字符。在Oracle 11g 中 CLOB 类型最大存储容量为 128TB</td><td></td></tr><tr class="even"><td>BLOB</td><td>用于存储大型的、未被结构化的变长的二进制数据（如二进制文件、图片文件、音频和视频等非文本文件）。在Oracle 11g 中 BLOB 类型最大存储容量为 128TB</td><td></td></tr><tr class="odd"><td>BFILE</td><td>用于存储指向二进制格式文件的定位器，该二进制文件保存在数据库外部的操作系统中。在Oracle 11g 中 BFILE 文件最大容量为 128TB，不能通过数据库操作修改 BFILE定位器所指向的文件</td><td></td></tr><tr class="even"><td>RAW(n)</td><td>用于存储变长的二进制数据，n 表示数据长度，取值范围为 1～2000字节</td><td></td></tr><tr class="odd"><td>LONG RAW</td><td>用于存储变长的二进制数据，最大存储数据量为 2GB。Oracle 建议使用 BLOB类型代替 LONG RAW 类型</td><td></td></tr><tr class="even"><td>ROWID</td><td>行标识符，表示表中行的物理地址的伪列类型</td><td></td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;rt.&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="数据库" scheme="http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>理论力学 -- 静力学和期末复习课</title>
    <link href="http://adversarr.github.io/2022/06/15/study/Physics/TheoMechanics/"/>
    <id>http://adversarr.github.io/2022/06/15/study/Physics/TheoMechanics/</id>
    <published>2022-06-14T16:00:00.000Z</published>
    <updated>2022-06-21T15:53:09.754Z</updated>
    
    <content type="html"><![CDATA[<p>理论力学复习笔记</p><span id="more"></span><hr /><p>静力学</p><div class="story post-story"><h2 id="静力学公理和受力分析">静力学公理和受力分析</h2><h3 id="静力学公理">静力学公理</h3><ol type="1"><li><strong>二力平衡原理</strong>：受靓丽作用的刚体，平衡的充要条件时两个力大小相等、方向相反、作用在同一直线；<ol type="1"><li>二力构件</li></ol></li><li><strong>加减平衡力系原理</strong>：在作用域刚体的任何一个力系上，加上/减去任意多个平衡利息，不改变原力系对于刚体的效应<ol type="1"><li>不适合变形体</li><li>推论 – <strong>力的可传性</strong>：力可以沿着作用线任意移动</li></ol></li><li><strong>平行四边形法则</strong><ol type="1"><li>推论 – <strong>三力平衡汇交定理</strong>：三力平衡时，如果其中两个力的作用线相交于一点，则三力必须共面且共点</li></ol></li><li><strong>作用和反作用定律</strong>（牛三）</li><li><strong>刚化原理</strong>：变形体在力系作用下处于平衡状态时，可以假象变形体是刚体，在原力系作用下保持平衡</li></ol><h3 id="约束和约束力">约束和约束力</h3><ol type="1"><li><strong>自由体</strong>：空间中运动不受限制的物体</li><li><strong>约束</strong>：限制物体运动的条件<ol type="1"><li>约束反应 = 约束力</li></ol></li></ol><h4 id="柔性索">柔性索</h4><p>不及自重，不可伸长，只能承受拉力 – 力只沿着柔索</p><h4 id="光滑接触面">光滑接触面</h4><p>约束力：沿接触点的公法线，指向被约束的物体。</p><p>例如：齿轮传动</p><h4 id="光滑圆柱铰链">光滑圆柱铰链</h4><ol type="1"><li>圆柱铰链 – 约束力xy正交分解</li><li>固定铰链 – xy正交分解</li><li>滚动铰链 – 垂直于接触面</li></ol><h4 id="光滑球铰链">光滑球铰链</h4><p>约束力过球心 – xyz正交分解</p><h4 id="轴承">轴承</h4><ol type="1"><li>向心轴承 – xy正交分解</li><li>止推轴承 – xyz正交分解</li></ol><h4 id="必考链杆-二力杆"><code>必考</code>链杆 – 二力杆</h4><h3 id="受力分析受力图">受力分析、受力图</h3><ol type="1"><li>确定研究对象</li><li>分析力作用</li><li>分析相互作用力</li></ol><p>说明：</p><ol type="1"><li>字母标注</li><li>尽可能画在力的作用点上</li><li>不能用合力代替分布载荷</li><li>受力图上不用画出内力</li></ol></div><div class="story post-story"><h2 id="平面汇交力系和平面力偶系">平面汇交力系和平面力偶系</h2><h3 id="平面汇交力系">平面汇交力系</h3><p>– 力的作用线共面且汇交于一点</p><h4 id="几何法">几何法</h4><p>首尾相连</p><h4 id="几何条件">几何条件</h4><p>力多边形自行封闭</p><h3id="平面汇交力系合成平衡的解析法">平面汇交力系合成、平衡的解析法</h3><h4 id="力在坐标轴上的投影">力在坐标轴上的投影</h4><h4 id="汇交力系合成的解析法">汇交力系合成的解析法</h4><p>合力投影定理：在任意轴上的投影等于分力在同一轴上投影的代数和。</p><h4 id="平面汇交力系平衡方程">平面汇交力系平衡方程</h4><p>平衡的充要条件是力系的合力为0</p><h3 id="平面内力对于点的矩">平面内力对于点的矩</h3><h4 id="平面内力对点的矩">平面内力对点的矩</h4><p>合理矩定理：合力对任力系中各力对该点之矩矢的矢量和。 <spanclass="math display">\[M_O(F_R) = \sum M_O(F_i)\]</span> 适用于有合力的任意力系</p><h4 id="平面力偶系">平面力偶系</h4><dl><dt>力偶</dt><dd><p>大小相等，方向相反，不共线的两个力组成的力系<spanclass="math inline">\((F, F&#39;)\)</span></p></dd></dl><ol type="1"><li>力偶作用面、力偶臂</li><li>力偶效应：改变刚体的转动状态<ol type="1"><li>是力学中的<strong>基本量</strong></li></ol></li></ol><dl><dt>力偶矩</dt><dd>度量力偶对物体转动效应的量 – <span class="math inline">\(M= \pm d \cdotF\)</span></dd></dl><p>力偶是滑动矢量 – 与矩心的位置无关</p><h5 id="力偶的性质">力偶的性质</h5><ol type="1"><li>力偶无合力 – <span class="math inline">\(F_R &#39; = \sum F_i =0\)</span></li><li>力偶的效应<strong>只和</strong>力偶矩有关</li><li>力偶只与力偶矩相等的另一力偶等效</li><li>力偶对其作用面上任何一点的矩等于力偶矩</li></ol><blockquote><p>静止时，力偶不能与任一力平衡</p></blockquote><h5 id="平面力偶系合成">平面力偶系合成</h5><p>合成的结果为： <span class="math display">\[M = \sum _ i M_i\]</span> 即一个合力偶，力偶矩等于原力偶系中所有力偶矩的代数和</p><p>平面力偶系的平衡方程为： <span class="math display">\[\sum _i M_i = 0 \quad(i.e. \sum M = 0)\]</span></p></div><div class="story post-story"><h2 id="平面任意力系">平面任意力系</h2><h3 id="力系简化">力系简化</h3><h4 id="力的平移定理">力的平移定理</h4><dl><dt>力的平移定理</dt><dd>可以把刚体上一点的力向任意点平移，但要附加一个力偶，其力偶矩等于原来力对移动点（新点）的矩。</dd></dl><blockquote><p>相当于在目标点作一个力，然后设法使之等效。</p></blockquote><h4 id="平面力系向面内一点简化">平面力系向面内一点简化</h4><p>简化结果是：</p><ol type="1"><li>力系主矢 <span class="math inline">\(F_R&#39;= \sum_{i=1}^nF_i\)</span></li><li>力系主矩 <span class="math inline">\(M_O=\sum_{i = 1} ^ nM_O(F_i)\)</span></li></ol><p>其中 <span class="math inline">\(O\)</span> 是简化中心：</p><ol type="1"><li>力系主矢与<span class="math inline">\(O\)</span>无关</li><li>力系主矩<strong>一般</strong>和<spanclass="math inline">\(O\)</span>有关 –注意可能最终是一个合力偶的情况</li></ol><h5 id="简化结果的情况">简化结果的情况</h5><ol type="1"><li>力偶 – <span class="math inline">\(F_R&#39; = 0, M_O \ne0\)</span></li><li>平衡 – <span class="math inline">\(F&#39;_R = 0, M_O =0\)</span></li><li>合力 – 其他的情况</li></ol><h4 id="合理矩定理">合理矩定理</h4><dl><dt>合理矩定理</dt><dd>平面任意力系的合力对作用面任一点的矩等于力系中各力对同一点的矩的代数和<span class="math display">\[M_O(F_R) = \sum M_O(F_i)\]</span></dd></dl><h3 id="平衡方程和平衡条件">平衡方程和平衡条件</h3><h4 id="平衡的充要条件">平衡的充要条件</h4><p>充要条件是主矢和主矩都为0. <span class="math display">\[\begin{cases}F_R&#39; = 0\\M_O = 0\end{cases}\]</span> 则最简单的平衡方程为（一矩式） <span class="math display">\[\begin{cases}\sum F_x = 0\\\sum F_y = 0\\\sum M_O(F) = 0\end{cases}\]</span> 三个独立方程 – 三个未知量</p><h4 id="平衡方程的三种形式">平衡方程的三种形式</h4><p>两矩式 <span class="math display">\[\begin{cases}\sum F_x = 0\\\sum M_A(F) = 0\\\sum M_B(F) = 0\end{cases}\]</span></p><blockquote><p>要求<span class="math inline">\(AB\)</span>不垂直于<spanclass="math inline">\(x\)</span>轴</p></blockquote><p>三矩式 <span class="math display">\[\begin{cases}\sum M_A(F) = 0\\\sum M_B(F) = 0\\\sum M_C(F) = 0\end{cases}\]</span></p><blockquote><p>要求<span class="math inline">\(ABC\)</span>不共线</p></blockquote><h3 id="平衡问题">平衡问题</h3><p>特殊情况下，平衡方程可以解的位置量减少：</p><ol type="1"><li>汇交力系 — 两个独立方程</li><li>平行力系 — 两个独立方程</li><li>力偶系 — 一个独立方程</li></ol><blockquote><p>其中<span class="math inline">\(x, y\)</span>方向选择具有一定的任意性– 线性无关</p></blockquote><h4 id="静定问题和静不定问题">静定问题和静不定问题</h4><ol type="1"><li>静定问题 – 平衡方程可以求解所有未知数</li><li>静不定问题 – 平衡方程无法求出所有未知数</li></ol><p>确定方法：</p><ol type="1"><li>未知数和方程数比较</li><li>几何分析</li><li>计算自由度</li></ol><h3 id="桁架">桁架</h3><h4 id="分类">分类</h4><ol type="1"><li>平面桁架</li><li>空间桁架</li></ol><h4 id="工程实例与理想桁架">工程实例与理想桁架</h4><ol type="1"><li>无余杆 – 去掉任意一根，形状可变</li><li>有余杆</li></ol><h4 id="内力计算方法">内力计算方法</h4><p>节点法</p><ol type="1"><li>以节点为研究对象</li><li>平面汇交力系平衡方程 – <span class="math inline">\(F_x = 0\quad F_y= 0\)</span></li></ol><p>截面法</p><ol type="1"><li>假象截面截开桁架</li><li>局部桁架平衡，直接求内力</li></ol><p>考试题、关键点：找零力杆</p><ol type="1"><li>截面单杆 –截面法中如果被切断的二力杆除了一根外，其余都交于一点或互相平行，此根杆为单杆。</li><li>节点单杆 – 节点法中列平衡方程可以求出内力的杆</li></ol></div><div class="story post-story"><h2 id="摩擦">摩擦</h2><h3 id="滑动摩擦">滑动摩擦</h3><dl><dt>滑动摩擦</dt><dd>力 –两个粗糙表面的物体，接触面之间有相对滑动趋势/相对滑动时，彼此作用，阻碍相对滑动的阻力。方向– 与相对滑动相反</dd></dl><p>最大静摩擦 <span class="math display">\[F = f_s F_N\]</span></p><h3 id="摩擦角和自锁">摩擦角和自锁</h3><p>全约束反力： <span class="math display">\[F_R = F_N + F_S\]</span></p><blockquote><p>注意力的作用点需要按照其他力的作用线来判断</p></blockquote><p>摩擦角： <span class="math display">\[\tan \varphi _ m = f_s\]</span> 自锁 : 摩擦角范围内，不论主动力多大，物体都会保持平衡。</p><h3 id="摩擦平衡">摩擦平衡</h3><p>临界滑动</p><p>翻倒</p><h3 id="滚动摩阻">滚动摩阻</h3><hr /></div><div class="story post-story"><h2 id="作业和复习课">作业和复习课</h2><h3 id="静力学">静力学</h3><p><code>受力图</code></p><ol type="1"><li>隔离法各个物体单独画</li></ol><p>列方程： <span class="math display">\[\begin{aligned}\sum F_x = 0 &amp;\quad ... + ... + ... =0\\\sum F_y = 0 &amp;\quad ... + ... + ... =0\\\sum M_f = 0 &amp;\quad ... + ... + ... =0\end{aligned}\]</span> <strong>固定端</strong>必考 – 这次必考（作业题2）</p><ul><li>注意约束力偶矩 – 受力图！</li></ul><p>这甜蜜和近代物理老师送分没啥区别。</p><p>二力构件和二力杆 – 填空题、作图题（画受力图 – 3题） –只要受到两个力而平衡，就是二力构件。</p><p>三力汇交必考</p><h3 id="运动学">运动学</h3><p>点的合成运动</p><p>8-22 明确写出以谁为动点、以谁为动系 – 3+3分</p><ul><li><span class="math inline">\(v_a\)</span> – 绝对</li><li><span class="math inline">\(v_e\)</span> – 牵连</li><li><span class="math inline">\(v_r\)</span> – 相对</li></ul><p>加速度同理，<span class="math inline">\(a_c\)</span></p><p>8-29 只是求<span class="math inline">\(a_c\)</span> – 相对速度 +角速度</p><p>9-</p><h3 id="考试">考试</h3><p>选择、填空（计算）、判断</p><p>做图</p><p>计算题</p><blockquote><p>u1s1-不如报答案</p></blockquote><p>判断</p><ul><li>2个-牵连运动、牵连速度！是否和定义一致？</li><li>质心运动定理一定要理解<span class="math inline">\(m a_c = \sum \vecF\)</span> ，包括主动力、约束力都要考虑！</li><li>达朗贝尔原理、惯性力系简化（平移、惯性力偶矩、合力？）<ul><li>平移和瞬时平移（平面运动的一个特例）是不同的！</li></ul></li></ul><p>单选填空作图</p><ul><li>作图：受力图 – 明确方向！<ul><li>能够看出二力杆：受拉力还是压力？</li></ul></li><li>参考 书本P83图4-13</li><li>空间力系-求对轴的矩？力和轴平行时为0</li><li>重心<ul><li>组合法</li><li>负面积法</li></ul></li><li>速度顺心 – 平面运动 – 作图题</li><li>选择填空：<ul><li><span class="math inline">\(J_c \alpha = \sum M_c (\vec F)\)</span>–对比一下选答案 （所有外力）</li><li>平面运动的动能 <span class="math inline">\(T = \frac 1 2 m v_c ^ 2 +\frac 1 2 J_c \omega^2\)</span></li><li>13-5 动量动能动量矩</li><li>p270 – 11-4 串并联、固有频率、求解方法</li></ul></li></ul><p>计算</p><ul><li><p>静力学：有固定端（约束力偶矩），谁是固定端，其他很简单</p><ul><li>要分开画受力图</li><li>协调性原则 – 方向（牛3）、标注（<span class="math inline">\(F\rightarrow F&#39;\)</span>）</li></ul></li><li><p>桁架：零力杆（要写理由）截面法、节点法 – 送分</p></li><li><p>动力学：P184图8-16、速度合成定理、刚体的平面运动（动点动系记得要写-3分）</p><ul><li>基点法、投影定理、瞬心 – 求加速度只能用基点法</li><li>判断加速度方向</li><li>速度瞬心法 – 如果是又滚又滑</li></ul></li><li><p>动力学：P413 16-24题：</p></li><li><p>达朗贝尔原理 或者用：<span class="math inline">\(J_c \alpha =\sum M_c (\vec F)\)</span> （对单个物体成立）和<spanclass="math inline">\(Ma_c = \sum F\)</span></p><ul><li>建立坐标系 – 放在正半轴的一般位置？</li></ul></li></ul><p>复习个xxxxx</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;理论力学复习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="物理" scheme="http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>神奇的 C++ 代码片段（模版元编程）</title>
    <link href="http://adversarr.github.io/2022/05/27/study/ComputerScience/fragments/Snippets/"/>
    <id>http://adversarr.github.io/2022/05/27/study/ComputerScience/fragments/Snippets/</id>
    <published>2022-05-26T16:00:00.000Z</published>
    <updated>2022-05-27T07:29:55.952Z</updated>
    
    <content type="html"><![CDATA[<p>哈希函数</p><span id="more"></span><h3 id="the-code">The code</h3><p>理论上说，把任何类型丢进去都能够直接hash了：</p><ol type="1"><li>vector、map、set等stl容器</li><li>tuple、pair 等固定长模版容器</li><li>定义了 <code>size_t hash()</code> 成员函数的任何类/结构体</li><li>可变参数模版</li><li>……（todo...）</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">typename</span> enable_if&lt;!is_class&lt;T&gt;::value, <span class="type">size_t</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;T&gt;&#123;&#125;(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">size_t</span> __hash_reduce(<span class="type">size_t</span> h) <span class="type">const</span> &#123; <span class="keyword">return</span> h; &#125;</span><br><span class="line">  <span class="type">size_t</span> __hash_combine(<span class="type">size_t</span> l, <span class="type">size_t</span> r) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (l &lt;&lt; <span class="number">1</span>) ^ r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">size_t</span> __hash_reduce(<span class="type">size_t</span> h, <span class="type">size_t</span> t...) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> __hash_combine(h, __hash_reduce(t));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">size_t</span> <span class="title">comb</span><span class="params">(<span class="type">const</span> T &amp;t)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Hash&#123;&#125;(t); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">comb</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args &amp;...args)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __hash_reduce(Hash&#123;&#125;(t), <span class="built_in">comb</span>(args...));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T1 &amp;t1, <span class="type">const</span> T2 &amp;t2, <span class="type">const</span> Args &amp;...args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">comb</span>(t1, t2, args...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;L, R&gt; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Hash&#123;&#125;(p.first, p.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="keyword">typename</span> C = <span class="keyword">typename</span> I::const_iterator&gt;</span><br><span class="line">  <span class="type">size_t</span> <span class="built_in">operator</span>()(<span class="type">const</span> I &amp;it) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> hv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : it) &#123;</span><br><span class="line">      hv = __hash_combine(hv, Hash&#123;&#125;(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hv;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">bool</span>&gt; &amp;bs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> hv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      hv = __hash_combine(hv, Hash&#123;&#125;((<span class="type">int</span>)bs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hv;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> tuple&lt;Args...&gt; &amp;tup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">apply</span>([](Args... v) -&gt; <span class="type">size_t</span> &#123; <span class="keyword">return</span> Hash&#123;&#125;.<span class="built_in">comb</span>&lt;Args...&gt;(v...); &#125;,</span><br><span class="line">                 tup);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Hashable,</span><br><span class="line">    <span class="keyword">typename</span> = is_same&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;Hashable&gt;().<span class="built_in">hash</span>()), <span class="type">size_t</span>&gt;&gt;</span><br><span class="line">  <span class="type">size_t</span> <span class="built_in">operator</span>()(<span class="type">const</span> Hashable &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> v.<span class="built_in">hash</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希函数&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>离散微分几何 01 - Introduction</title>
    <link href="http://adversarr.github.io/2022/04/30/CG/DiscreteGeometry/c1/"/>
    <id>http://adversarr.github.io/2022/04/30/CG/DiscreteGeometry/c1/</id>
    <published>2022-04-30T13:02:28.245Z</published>
    <updated>2022-04-30T15:18:43.139Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>Application:</p><ul><li>Geometry Processing: Up-sample / Down-sample — 3d-surface</li><li>Shape Analysis</li><li>Machine Learning.</li><li>Numerical Simu</li></ul></div><div class="story post-story"><h2 id="what-will-we-learn-wont">What will we learn / Won't</h2><ol type="1"><li>Diff Geometry</li><li>Geo Processing</li><li>Central — Link These two perspectives</li></ol><p>Won't</p><ol type="1"><li>view points on diff geometry</li><li>huge number of algorithms</li></ol></div><div class="story post-story"><h2 id="what-is-diff-geo">What is Diff Geo</h2><h3 id="diff-geo">Diff Geo</h3><ol type="1"><li>Talk about local properties of shape</li><li>and thier connection to global properties of shape</li><li>Lang of geometry physics</li></ol><h3 id="discrete-diff-geo">Discrete Diff Geo</h3><ol type="1"><li>infinity no longer allowed</li><li>expressed in terms of lenghs, angles</li><li>Loss is littow: captures many fundamental ideas</li></ol><blockquote><p>Translate continuous to discrete</p></blockquote><h3 id="how-to">How to</h3><p>DDG — obtain discrete definitions</p><ol type="1"><li>write down several equivalent definitions in the smooth setting</li><li>apply each smooth definition to an object in discrete</li><li>Determine which properties are captured by each resultinginequivalent discrete definition</li></ol></div><div class="story post-story"><h2 id="example-discrete-curvature">Example: Discrete Curvature</h2><h3 id="curves-in-the-plane">Curves in the Plane</h3><p>in 2D, a <strong>parameterized curve</strong> is a map taking eachpoint in an interval <span class="math inline">\([0, L]\)</span>.</p><p>Discrete Curves in the Plane:</p><ul><li><p>piecewise linear parameterized curve, vertices connected bystraight line segments</p></li><li><p>view as a interval <spanclass="math inline">\(\rightarrow\)</span> Segments</p></li></ul><h3 id="tangentnormalcurvature">Tangent/Normal/Curvature</h3><p>unit tangent: <span class="math display">\[T(s) := \frac{d}{ds} \gamma(s) / |\frac{d}{ds}\gamma(s)|\]</span> unit Normal: <span class="math display">\[N(s) = \mathcal JT(s)\]</span></p><ul><li><span class="math inline">\(\mathcal J\)</span>表示顺时针旋转</li></ul><p>curvature can be expressed as the rate of change in the tangent.<span class="math display">\[\kappa(s):=\langle N, \frac{d}{ds} T\rangle\]</span></p><ul><li>Key idea 1 — curvature is a second devirative.</li><li>Key idea 2 — curvature can have sign.</li></ul><h3 id="to-discrete">To Discrete</h3><p>in continuous:</p><ol type="1"><li>Turning angle</li><li>length variation</li><li>steiner formula</li><li>osculating curve</li></ol><h3 id="integrated-curvature">Integrated Curvature</h3><p><span class="math display">\[\int _ b ^ a \kappa(s) \mathrm ds = \varphi(b) - \varphi(a)\]</span></p><p>consider <span class="math inline">\(\gamma_{i - 1}\)</span>, <spanclass="math inline">\(\gamma_{i}\)</span>,<spanclass="math inline">\(\gamma_{i + 1}\)</span> <spanclass="math display">\[\theta _ i =: \kappa_i ^A\quad (\text{turning angle})\]</span></p><ul><li>integrated rather than pointwise values</li><li>total change in angle, not derivative.</li></ul><h3 id="length-variation">Length Variation</h3><blockquote><p>The fastest way to descrease the length of a curve is to move it inthe normal direction, with speed proportioonal to curvature</p></blockquote><p>Intuition — in flat rigions, normal motions doesn't change curvelength.</p><p>变分： <span class="math display">\[\eta(0) = \eta(L) = 0\]</span> Gradient of Length for a line segment</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;div class=&quot;story post-story&quot;&gt;&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Geometry Processi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>201-04-欧拉视角</title>
    <link href="http://adversarr.github.io/2022/04/25/CG/GAMES/g201-04/"/>
    <id>http://adversarr.github.io/2022/04/25/CG/GAMES/g201-04/</id>
    <published>2022-04-24T16:00:00.000Z</published>
    <updated>2022-04-25T03:33:14.864Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 201–欧拉视角</p><span id="more"></span><blockquote><p>Fluid Simulation for computer graphics</p></blockquote><div class="story post-story"><h2 id="overview">Overview</h2><p>Material Derivatives — L. vs E. <span class="math display">\[\frac{D}{Dt} =\frac{\partial }{\partial t} + \mathbf u \cdot \nabla\]</span> 例如，温度<span class="math inline">\(T\)</span>： <spanclass="math display">\[\frac{DT}{Dt} = \frac{\partial T}{\partial t} + \mathbf u \cdot \nabla T\]</span></p><ul><li>温度随着时间的导数</li><li>粒子移动导致变化</li></ul><p>例如，物质的速度<span class="math inline">\(\mathbf u_x\)</span><span class="math display">\[\frac{D \mathbf u_x}{D\mathbf u_x} = \frac{\partial  \mathbfu_x}{\partial t} + \mathbf u \cdot \nabla \mathbf u_x\]</span></p><h3 id="不可压缩的ns方程">（不可压缩的）NS方程</h3><p><span class="math display">\[\frac{D\mathbf u}{Dt} = -\frac 1 \rho \nabla p  +\nu \nabla^2 \mathbfu+\mathbf g\\\nabla \cdot \mathbf u = 0\]</span></p><ul><li><span class="math inline">\(\mu\)</span> — dynamic viscosity</li></ul><p>分成几份： <span class="math display">\[\frac{D\mathbf u}{Dt} = -\frac 1 \rho \nabla p  +\mathbf g\\\nabla \cdot \mathbf u = 0\]</span> 变为： <span class="math display">\[\frac{D\mathbf u}{Dt}  = 0\\\frac{D\alpha}{Dt}  =0\\\frac{\partial \mathbf u}{\partial t} = \mathbf g\\\frac{\partial \mathbf u}{\partial t} = - \frac{1}{\rho} \nabla p\quads.t. \nabla \cdot \mathbf u = \mathbf 0\]</span></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 201–欧拉视角&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>201-03-拉格朗日视角2</title>
    <link href="http://adversarr.github.io/2022/04/21/CG/GAMES/g201-03/"/>
    <id>http://adversarr.github.io/2022/04/21/CG/GAMES/g201-03/</id>
    <published>2022-04-20T16:00:00.000Z</published>
    <updated>2022-04-21T02:44:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 201 -高级物理引擎实战 - 4 - 拉格朗日视角</p><span id="more"></span><div class="story post-story"><h2 id="变形-deformation">变形 – Deformation</h2><blockquote><p>Reading：</p><ol type="1"><li>The classical FEM method and discretization methodology</li><li>The MPM for simulating continuous …</li></ol></blockquote><p>形变就是一个单对单的映射： <span class="math display">\[\phi : \mathbb R^3 \rightarrow \mathbb R^3\]</span> 从而形变梯度为： <span class="math display">\[\mathbf F = \frac{\partial \mathbf x_{deformed}}{\partial \mathbfx_{rest}}\]</span> 不难发现到<span class="math inline">\(\mathbfF\)</span>是平移不变的。</p><p>体积变化即为：<span class="math inline">\(J = \det \mathbfF\)</span></p></div><div class="story post-story"><h2 id="弹性">弹性</h2><dl><dt>弹性</dt><dd>材料有恢复原始状态的性质</dd></dl><ul><li>我们只观察超形变物体（有strain能量函数<spanclass="math inline">\(\Psi\)</span>）的</li></ul><p>注意区别：</p><ol type="1"><li>stress</li><li>strain – 直接替换为 <span class="math inline">\(\mathbfF\)</span></li></ol><h3 id="stress-tensor">Stress Tensor</h3><p>表明了材料微元和其他材料微元的相互作用：</p><p>有不同的stress tensor</p><ul><li>PK1：<span class="math inline">\(\mathbf P(\mathbf F) = \partial\Psi (\mathbf F) /\partial \mathbf F\)</span> –容易计算，但在restspace</li><li>Kirchhoff stress：<span class="math inline">\(\tau\)</span></li><li>Cauchy Stress：<span class="math inline">\(\sigma\)</span></li></ul><p>相互关系为： <span class="math display">\[\tau = J \sigma = \mathbf P\mathbf F^T\]</span></p><ul><li>Traction = <span class="math inline">\(\mathbf t = \sigma^T \mathbfn\)</span></li></ul><h4 id="常用属性">常用属性</h4><ol type="1"><li>杨氏模量 – <span class="math inline">\(E = \sigma /\varepsilon\)</span></li><li>Bulk modulus</li><li>泊松比</li></ol><p>考虑 Lame Parameters：</p><ul><li><span class="math inline">\(\mu\)</span></li><li><span class="math inline">\(\lambda\)</span></li></ul><p>可以相互转换，只要指定泊松比和杨氏模量</p><h4 id="常用超弹性模型">常用超弹性模型</h4><ol type="1"><li>Linear elsaticity – 小形变下可以，但对于旋转没有惩罚</li><li>Neo-Hookean</li><li>Fixed Corotated</li></ol><p><img src="g201-03/image-20220421102323599.png" class="lazyload" data-srcset="g201-03/image-20220421102323599.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div><div class="story post-story"><h2 id="fem">FEM</h2><p>对于形变物体： <span class="math display">\[\mathbf x_{def} = \mathbf F \mathbf x _{rest} + \mathbf b\]</span> 对于每一个元素： <span class="math display">\[U(e)=\int_e \psi(\mathbf F(\mathbf x))\mathbf x = V_e \psi (\mathbf F_e)\]</span> 求出力： <span class="math display">\[f_{t, i} = - \frac{\partial U}{\partial \mathbf x_i}= - \sum_e V_e\mathbf P(\mathbf F_e)\frac{\partial \mathbf F_e}{\partial \mathbf x_i}\]</span></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 201 -高级物理引擎实战 - 4 - 拉格朗日视角&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-05-B样条曲线</title>
    <link href="http://adversarr.github.io/2022/04/20/CG/GAMES/g102-05/"/>
    <id>http://adversarr.github.io/2022/04/20/CG/GAMES/g102-05/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-26T13:29:00.253Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 102 -- 5 B样条曲线</p><span id="more"></span><div class="story post-story"><h2 id="b-样条曲线">B 样条曲线</h2><h3 id="建模的两种形式">建模的两种形式</h3><ol type="1"><li>重建 – 形状已经有了，猜出来– 基函数组合</li><li>设计 – 产生 – 自行组合权系数</li></ol><h3 id="如果用-bernstein-基函数">如果用 Bernstein 基函数？</h3><p>顶点和曲线的关联性强，具有较高的几何意义</p><p><span class="math inline">\(n\)</span> 次Bernstein基函数 <spanclass="math display">\[B_i ^{(n)} (t) = C_n ^ i t ^ i ( 1- t ) ^{n - i}\]</span> 从而： <span class="math display">\[\mathbf f ( t ) = \sum_{i = 1} ^ n b_i ( t )\mathbf p_i, \quad t \in [0,1]\]</span> 我们使用Bernstein基函数替代权函数： <spanclass="math display">\[x(t) = \sum_{i=0}^n B_i^n(t) b_i\]</span> <img src="g102-05/image-20220421233511284.png"alt="使用 Bernstein 基函数构造的曲线" /></p></div><div class="story post-story"><h2 id="b曲线的性质">B曲线的性质</h2><p>观察基函数：</p><ol type="1"><li>具有对称性（关于 <span class="math inline">\(i\)</span>）</li><li>当 <span class="math inline">\(t = i/n\)</span> 最大</li><li>非负性 + 权性（加和为1）— 具有凸包性<ol type="1"><li>曲线始终在凸包内</li></ol></li><li>基性 – 是<span class="math inline">\(n\)</span>次多项式空间的基</li><li>递推公式（从组合系数证明）</li><li>端点差值 – 经过始末顶点</li><li>端点性质 –<ol type="1"><li>插值</li><li>切线方向和边相同</li></ol></li><li>升阶 — 通过递推公式来推导</li></ol></div><div class="story post-story"><h2 id="de-casteljau-算法">de Casteljau 算法</h2><p>输入：点</p><p>输出：在 <span class="math inline">\(t\)</span> 位置的值</p><p>思想：反复用 <span class="math inline">\(t \mathbf x + (1-t)\mathbfy\)</span> 作用在相邻点上</p><p>复杂度 – <span class="math inline">\(O(n^2)\)</span></p><p>算法只有线性运算，计算稳定</p><p>应用：离散、求根</p></div><div class="story post-story"><h2 id="两bezier曲线的拼接条件">两Bezier曲线的拼接条件</h2><p>要求<span class="math inline">\(C^1\)</span>：要求有连接点同向</p><p>要求<span class="math inline">\(C^2\)</span>：要求连接点是中点</p><h3 id="广义样条曲线">广义样条曲线</h3><p>分段的多项式曲线（Bezier曲线）</p></div><div class="story post-story"><h2 id="b-样条">B 样条</h2><p>Bezier 曲线的不足：</p><ol type="1"><li>全局性！牵一发而动全身-不利于设计</li></ol><p>思考：怎样统一表达？</p><p>类比：每个控制顶点用一个基函数 <span class="math display">\[x(t) = \sum N_{i, k}(t) \cdot d_i\]</span> 性质：</p><ol type="1"><li>局部性</li><li>正、权性</li><li>……</li></ol><p>启发：根据递推公式–</p><ol type="1"><li>局部类似，由一个基函数平移得到</li><li>高阶的由两个低阶的基函数升阶得到</li></ol><h3 id="b-样条-1">B-样条</h3><p>对于均匀节点<spanclass="math inline">\(\cdots,i,i+1,\cdots\)</span></p><p>定义如下： <span class="math display">\[N_i^1(t) = \begin{cases}1, &amp; i \le t &lt; i + 1\\0\end{cases}\]</span> 那么： <span class="math display">\[N_i^k= \frac{t-i}{k-1}N_i^{k-1} + \frac{i+k-t}{k-1}N_{i+1}^{k-1}\]</span> 对于非均匀节点：<span class="math inline">\(t_0&lt; t_1 &lt;\cdots&lt;t_n\)</span> <span class="math display">\[N_i^1(t) = \begin{cases}1, &amp; t_i \le t &lt; t_{i + 1}\\0\end{cases}\]</span></p><p><span class="math display">\[N_i^k= \frac{t-t_i}{t_{i+k-1}-t_i}N_i^{k-1} + \frac{t_{i+k}-t}{t_{i + k}- t_{i + 1}}N_{i+1}^{k-1}\]</span></p><h3 id="样条曲线">样条曲线</h3><p>从而根据上述基函数，可以定义样条曲线。</p><p>设置重数：</p><figure><img src="g102-05/image-20220425162243893.png"alt="设置重数来避免始末点不重合" /><figcaption aria-hidden="true">设置重数来避免始末点不重合</figcaption></figure><h3 id="其他理论知识">其他理论知识</h3><p>性质很多：</p><ol type="1"><li>局部凸包性</li><li>变分缩减性</li><li>包络性</li><li>导数、积分</li><li>几何作图</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 102 -- 5 B样条曲线&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-04-B样条曲线</title>
    <link href="http://adversarr.github.io/2022/04/20/CG/GAMES/g102-06/"/>
    <id>http://adversarr.github.io/2022/04/20/CG/GAMES/g102-06/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-28T12:56:59.341Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><div class="story post-story"><h2 id="b-样条">B-样条</h2><p>Bezier 曲线问题：无法表示圆弧</p><h3 id="投影几何">投影几何：</h3><p>齐次坐标： <span class="math display">\[x\rightarrow \left(wx, w\right)\]</span> 提出有理Bezier曲线</p><h3 id="有理bezier曲线">有理Bezier曲线</h3><p>在每个控制顶点上设置权函数 <span class="math display">\[f^{eucl}(t) =\sum_{i=0}^n\mathbf p_i\frac{B_i^d(t) \omega_i}{\sum_{j =1} ^ n B_j^{d} (t) \omega _i}=\sum_{i=0}^n\mathbf q_i(t)p_i\]</span></p></div><div class="story post-story"><h2 id="nurbs-非均匀有理b样条">NURBS — 非均匀有理B样条</h2><p>定义： <span class="math display">\[f(t) = \frac{\sum_{i = 1} ^ n N_i^{(d)} (t) \omega_i \mathbf p_i}{\sum _{i = 1} ^ n N_i^{(d)} \omega_i}\]</span> 影响 NURBS 曲线因素：</p><ol type="1"><li>控制顶点 — 用户交互</li><li>节点向量 — 决定了 B-样条基函数</li><li>权系数 — 形状</li></ol></div><div class="story post-story"><h2 id="细分曲线">细分曲线</h2><p>回顾 Bezier 曲线作图法</p><ul><li>逐步割角、磨光</li></ul><h3 id="思想">思想</h3><ol type="1"><li>拓扑规则：加入新的点 — splitting</li><li>几何规则：移动顶点 — averaging</li></ol><h3 id="chaikin细分">Chaikin细分</h3><p>割角法</p><ol type="1"><li>每条边取中点，生成新的点</li><li>取相邻点的平均作为新的点</li></ol><p>如果用矩阵表示， <span class="math display">\[x&#39; = M x\]</span> 那么可以用极限来计算</p><p>好的细分规则，则其最大特征根 <span class="math inline">\(=1\)</span></p><h3 id="插值型细分方法">插值型细分方法</h3><p>细分方法：</p><ol type="1"><li>保留原有顶点</li><li>对每个边增加新顶点</li><li>迭代生成新曲线</li></ol><figure><img src="g102-06/image-20220428194913207.png" class="lazyload" data-srcset="g102-06/image-20220428194913207.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="思路" /><figcaption aria-hidden="true">思路</figcaption></figure><p>可以看成“补角”法</p><h4 id="四点插值细分">四点插值细分</h4><p><span class="math display">\[p&#39;_{2i + 1} = \frac{p_i+p_i+1}{2}+ \alpha (\frac{p_i + p_ i + 1}{2}-\frac{p_{i - 1} + p _ {i + 2}}{2})\]</span></p></div><div class="story post-story"><h2 id="隐式曲线">隐式曲线</h2><p>隐函数定理：存在且唯一 — 难以找到</p><h3 id="隐式曲线-1">隐式曲线</h3><p>升高一维： <span class="math display">\[z = f(x, y)\]</span> 可以看作是二元函数的零等值线</p><p>同时可以定义曲线的内部和外部。</p><h3 id="隐式曲线的绘制">隐式曲线的绘制</h3><p>例如：</p><ol type="1"><li>直线 — 三元一次方程</li></ol><h4 id="等值线抽取">等值线抽取</h4><ol type="1"><li>输入：一个二院隐式函数</li><li>输出：等值线</li></ol><p>目的 — 参数化</p><p>Marching Cubes算法：最常用算法</p><p>思想：</p><ol type="1"><li>在离散格子上求值</li><li>利用局部连续性来插值</li><li>按一定的顺序形成离散曲线</li></ol><p>还有很多其他歧义的情况。</p><p>Adaptive Grids：</p><h3 id="隐式曲线拟合">隐式曲线拟合</h3><p>输入：平面上的一些点（设为自封闭曲线）</p><p>输出：拟合这些点的一个隐式曲面</p><p>转化为拟合问题。</p><p>构造方法很多</p></div><div class="story post-story"><h2 id="nurbs曲面">NURBS曲面</h2><p>参数曲面 — <span class="math inline">\(\mathbb R ^ 2 \rightarrow\mathbb R ^ 3\)</span></p><p>基本方法：张量积函数转化为张量积曲面</p><p>可以看作是曲线的曲线</p><p>两个参数的顺序无关。</p><h3 id="bezier-曲面">Bezier 曲面</h3><p><img src="g102-06/image-20220428205051034.png" class="lazyload" data-srcset="g102-06/image-20220428205051034.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>曲面性质 — 类似于曲线</p><p>作图法：de Casteljau</p><p>Bezier曲面拼接连续</p><h3 id="表达带洞非矩形边界的曲面">表达带“洞”/非矩形边界的曲面</h3><p>使用参数域上的洞来表达</p><p>三角面片也可以对应定义Bazier曲面片</p><h3 id="总结">总结</h3><p>张量积曲面：</p><ul><li>两个独立方向的“曲线的曲线”</li><li>性质类同于曲线的性质</li><li>表达、公式形式比曲线情况更加复杂</li><li>特殊性 — 角点是否光滑？</li></ul><p>张量积体：</p><ul><li>Bezier 体</li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;div class=&quot;story post-story&quot;&gt;&lt;h2 id=&quot;b-样条&quot;&gt;B-样条&lt;/h2&gt;
&lt;p&gt;Bezier 曲线问题：无法表示圆弧&lt;/p&gt;
&lt;h3 id=&quot;投影几何&quot;&gt;投影几何：&lt;/h3&gt;
&lt;p&gt;齐次坐标： &lt;s</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Programming</title>
    <link href="http://adversarr.github.io/2022/04/19/study/ComputerScience/fragments/WhyProgramming/"/>
    <id>http://adversarr.github.io/2022/04/19/study/ComputerScience/fragments/WhyProgramming/</id>
    <published>2022-04-19T15:25:31.924Z</published>
    <updated>2022-04-21T14:54:19.222Z</updated>
    
    <content type="html"><![CDATA[<p>占坑</p><span id="more"></span><div class="story post-story"><h2 id="为什么要研究语言">为什么要研究语言</h2><p>很多时候，我们会在网络上看到一些没有意义的问题：</p><blockquote><p>Q: 什么是世界上最好的语言？</p></blockquote><details ><summary> anwser </summary>              <div class='content'>              <p>肯定不是php。</p>              </div>            </details><p>这类问题是怎么产生的呢？我们日常开发中经常见到的一个场景是：</p><div class="note "><p><strong>Why????</strong></p><ol type="1"><li>写 C++：<ol type="1"><li>为什么这个文件无法通过编译！</li><li>为什么别人的代码无法在我的机器上运行！</li><li>为什么别人的代码和我学过的完全不是一个东西！</li><li>xxxx……</li></ol></li><li>写 Python：<ol type="1"><li>为什么这个变量传递进去就是错的！</li><li>为什么没有自动补全</li><li>为什么这么慢！</li><li>这是个什么神奇的语法？</li><li>为什么这个变量不变/变了！！！</li></ol></li><li>写函数式：<ol type="1"><li>为什么我要写/学这个东西？！</li></ol></li><li>写 Java / C#：<ol type="1"><li>为什么能够有人不用ide就开发！</li></ol></li><li>写 Swift：<ol type="1"><li>为什么这个语法如此的丑陋！</li></ol></li></ol></div><p>诸如此类，这些乱七八糟问题都会促使工程师们（码农们）去想要用别的语言来处理当前/原有的业务。</p><p>回到最开始的那个问题，为什么人们会孜孜不倦的讨论世界上最好的语言这个问题？实际上问题在于，对于一个极其复杂的业务，一种编程语言，或者说一种编程范式，其始终无法满足需求。而当一个新的语言，在当前的业务逻辑上，相交于之前的语言的实现上更加简单且高效的时候，程序员一定会破口大骂，为什么自己没有早点发现/学习这个语言。</p><blockquote><p>最经典的场景莫过于绝大多数的同学，在大二开始接触Python/Java的时候，疯狂抱怨自己为什么要学习C/C++，为什么学校还要墨守陈规得继续教授C++。</p></blockquote><p>从上面的问题中，我们不难看到几个关键词：</p><ol type="1"><li>编程范式：什么是面向对象/数据/过程/函数式</li><li>效率：简单、高效的实现/程序加速</li></ol><p>这些东西我们分开来一个个谈吧。</p><h3 id="到底程序是个啥">到底程序是个啥</h3><blockquote><p>程序 = 方法 + 数据</p><p>（一般在设计 Class的时候，人们更倾向于把成员函数称为一个<code>方法</code>，而对于一些其他的函数，我们就叫做<code>函数</code>。Anyway，如果你和我一样只是把函数和方法都看作数据上的操作的话，实际上也没有必要特别区分方法和函数，因此在我考虑问题、设计程序算法的时候，我通常不区分<code>方法</code>和<code>函数</code>）</p></blockquote><p>这几乎就是我们进行所谓的<strong>程序设计</strong>的一个起点！很大程度上，我在程序设计的起点，我需要搞明白的很少的一些东西：</p><ol type="1"><li>这个程序的输入是什么</li><li>这个程序的输出是什么</li><li>这个程序会对外部（例如操作系统状态）产生什么影响</li></ol><p>举一些🌰：</p><ol type="1"><li>一个矩阵乘法程序，就是拿到两个矩阵的数据，对它们进行矩阵乘法这个方法，然后吐出来一个矩阵</li><li>一个计算器，就是监听用户的输入，并记录下来，使用内置的一些固定的方法，在记录的数据上做操作，然后给用户一个输出</li><li>……（你也可以再想想自己写过的啥程序）</li></ol><p>对于其中的<code>数据</code>我们再熟悉不过了，在你见到的几乎所有的语言中，他们就是你直接操作的常/变量。对于这些量而言，在<strong>设计</strong>算法的初期，我们几乎不考虑它具体的值，我们更加关心的是它的类型！（有关类型，会在后面进行介绍）但是对于程序而言，一个运行时的程序，通常更加关注它的值。</p><p>正如SICP中对于程序设计的描述上，其关键点有：</p><ol type="1"><li>定义出这个程序的<strong>输入</strong>和<strong>输出</strong></li><li>定义出这个程序所需要的数据，例如<code>Point&#123; int x; int y; &#125;</code></li><li>根据我们拿到的数据、输入，来设计我们程序的大体框架（画流程图、伪代码等等）</li><li>设计函数：把上面的框架做拆解，通常我习惯于类似于做一个广度遍历，逐步把上面流程图中涉及的一些方法做一个实现。</li><li>开始你的实现。</li></ol><h3 id="语言逻辑表达能力">语言逻辑、表达能力</h3><p>好吧，我们这里根本不考虑所谓<strong>程序</strong>，因为我们绝大多数人从来都不是直接写二进制程序的！因此我们这里考虑的是语言的<strong>表达能力</strong>。（虽然我们在后文中不太考虑程序和代码的区别）</p><p>实际上我们已经知道答案了 —— <strong>图灵完备</strong>：</p><blockquote><p>In computability theory, a system of data-manipulation rules (such asa computer's instruction set, a programming language, or a cellularautomaton) is said to be Turing-complete or computationally universal ifit can be used to simulate any Turing machine (devised by Englishmathematician and computer scientist Alan Turing). This means that thissystem is able to recognize or decide other data-manipulation rule sets.Turing completeness is used as a way to express the power of such adata-manipulation rule set. Virtually all programming languages todayare Turing-complete.</p></blockquote><p>TLDR：从理论上说，我们使用的所有语言都有相同的表达能力！</p><p>那么问题是，为什么我们还需要考虑一个编程语言的表达能力呢？从我的理解来看，回答这个问题就和Hello World 一样简单：</p><p>对于 Python：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello World&quot;</span>  <span class="comment"># py2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>) <span class="comment"># py3</span></span><br></pre></td></tr></table></figure><p>对于 C：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 C++： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 Racket（一种函数式编程语言）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(print &quot;Hello World&quot;)</span><br></pre></td></tr></table></figure><p>从这里我们就能看出问题了，为了实现相同的功能，三种语言体现出完全不同的复杂、直观程度。</p><ol type="1"><li>Python：直观的、简单 -- 很简单</li><li>C：直观的、不简单 -- 至少函数叫做 <code>print</code></li><li>C++：不直观的、不简单 -- 什么是 <code>cout</code>？什么是<code>&lt;&lt;</code>？为什么是 <code>&lt;&lt;</code>？</li><li>Racket：不直观、简单 -- 问题在于为什么需要这个括号？</li></ol><!-- TODO --><h3 id="程序数据函数">程序=数据+函数</h3><h3 id="范式">范式</h3><p>函数是第一公民</p><p>ASYNC</p><h3 id="词法语法解析与执行">词法、语法、解析与执行</h3><h3 id="nfl">NFL</h3><ol type="1"><li>简单 + 舒适</li><li>复杂 + 舒适</li><li>简单 + 难受</li><li>复杂 + 难受</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;占坑&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>102-03-参数曲线拟合</title>
    <link href="http://adversarr.github.io/2022/04/19/CG/GAMES/g102-03/"/>
    <id>http://adversarr.github.io/2022/04/19/CG/GAMES/g102-03/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-19T03:40:08.873Z</updated>
    
    <content type="html"><![CDATA[<p>几何建模与处理</p><span id="more"></span><div class="story post-story"><h2 id="多元函数">多元函数</h2><p><span class="math display">\[f:\R ^n \rightarrow \R\]</span></p><h3 id="二元函数基函数构造">二元函数基函数构造</h3><p>方法：<strong>张量积</strong>（两两相乘）</p><figure><img src="g102-03/image-20220419111126729.png" class="lazyload" data-srcset="g102-03/image-20220419111126729.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="张量基函数" /><figcaption aria-hidden="true">张量基函数</figcaption></figure><p>优点：定义简单，多个一元基函数的乘积形式</p><p>不足：</p><ul><li>维数增加 – 基函数个数 <span class="math inline">\(n^2\)</span> –变量（参数数量）增加</li></ul><h3 id="神经网络表达">神经网络表达</h3><ul><li>用单变量函数 <span class="math inline">\(\sigma(x)\)</span>和不同的仿射变换来构造基函数。</li></ul></div><div class="story post-story"><h2 id="向量值函数">向量值函数</h2><p><span class="math display">\[f:\R^m \rightarrow \R^n\]</span></p><ul><li>看成多个单变量函数，各个函数独立无关。</li><li>共享基函数</li></ul><p>几何上：</p><ul><li>对于<span class="math inline">\(m=1\)</span> – 轨迹为曲线 —本质维度=1</li><li>对于 <span class="math inline">\(\R^2 \rightarrow \R^3\)</span> —参数曲面 — 本质维度=2 —</li><li><span class="math inline">\(3\rightarrow3\)</span> — 变形 –应用：有限元、图像变形</li><li><span class="math inline">\(3\rightarrow 2\)</span> — 降维映射 —例如 AutoEncoder</li></ul><figure><img src="g102-03/image-20220419112717602.png" class="lazyload" data-srcset="g102-03/image-20220419112717602.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="总结" /><figcaption aria-hidden="true">总结</figcaption></figure></div><div class="story post-story"><h2 id="曲线拟合">曲线拟合</h2><h3 id="曲线拟合问题">曲线拟合问题</h3><ul><li>输入：给定平面上的点</li><li>输出：一条参数曲线，拟合这些点</li></ul><p><span class="math display">\[f:\R \rightarrow \R^2\]</span></p><p>参数化 — <span class="math display">\[\begin{cases}x = x(t)\\y = y(t)\end{cases}\]</span></p><ul><li><p>问题转化为：对数据点 <spanclass="math inline">\((x_i,y_i)\)</span>，对应哪个参数<spanclass="math inline">\(t_i\)</span>？</p></li><li><p><span class="math inline">\(E = \sum\|\mathbf p (t_i) - \mathbfp_i\|\)</span></p></li></ul><p>如何确定 <span class="math inline">\(t\)</span></p><ul><li><p>均匀参数化（Equidistant Parameterization）</p></li><li><p>弦长参数化 <span class="math inline">\(t_{i+1} - t_i =\|\mathbfb_{i+1} -\mathbf b\|\)</span></p></li><li><p>中心参数化</p></li></ul><blockquote><p><strong>需要好的参数化</strong></p><p>目的：保持原有结构！</p></blockquote><h3 id="曲面参数化">曲面参数化</h3><ul><li>三维点找二维的参数 — 降维问题</li></ul><p>例如：</p><ul><li>纹理映射</li><li>世界地图</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;几何建模与处理&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-04-三次样条函数</title>
    <link href="http://adversarr.github.io/2022/04/19/CG/GAMES/g102-04/"/>
    <id>http://adversarr.github.io/2022/04/19/CG/GAMES/g102-04/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-19T07:52:10.194Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 102 – 几何建模与处理</p><span id="more"></span><div class="story post-story"><h2 id="三次样条函数">三次样条函数</h2><h3 id="力学解释">力学解释</h3><ul><li><p>曲线：弹性梁 — 弹性模量为 <spanclass="math inline">\(E\)</span></p></li><li><p>利用贝努利-欧拉方程，得到近似为分段三次函数</p></li><li><p>2次 — 无法表达拐点、三次 — <spanclass="math inline">\(C^2\)</span>，四次 — 误差大</p></li></ul><p>如何求？满足什么条件？</p><h3 id="思路">思路</h3><p>分段三次多项式，四个变量待定 <span class="math display">\[y_{i}(x) = a_i + b_i x. + c_i x ^ 2 + d_i x ^ 3\]</span> 从而有 <span class="math inline">\(4n-2\)</span>个约束条件，加上两个边界条件。</p><p>列出三弯矩方程组（对称、三对角、对角占优），可以使用追赶法来计算。</p><h3 id="边界条件">边界条件</h3><ul><li>自由端 — 指定二阶导数</li><li>夹持端 — 指定一阶导数</li></ul><h3 id="三次基样条">三次基样条</h3><p>使用三次基函数，计算在基函数下的“坐标”</p></div><div class="story post-story"><h2 id="三次样条曲线">三次样条曲线</h2><ul><li>取 <span class="math inline">\(x,y,z\)</span></li><li>参数化</li></ul></div><div class="story post-story"><h2 id="曲线的连续性">曲线的连续性</h2><p>参数连续性：<span class="math inline">\(C^2\)</span>连续 —和参数有关</p><p>几何连续性：设 <span class="math inline">\(\phi(t)\)</span>是给定曲线的参数方程，存在参数变换，可以达到的连续性是几何连续性。记为<spanclass="math inline">\(G^n\)</span></p><p>具体：</p><ul><li><span class="math inline">\(G^0\)</span>，连续</li><li><span class="math inline">\(G^1\)</span> 切线相同</li><li><span class="math inline">\(G^2\)</span> 曲率相同</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 102 – 几何建模与处理&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>实时布料仿真</title>
    <link href="http://adversarr.github.io/2022/04/14/CG/ContactDetection/ClothSimu/"/>
    <id>http://adversarr.github.io/2022/04/14/CG/ContactDetection/ClothSimu/</id>
    <published>2022-04-14T12:58:15.554Z</published>
    <updated>2022-04-14T14:07:32.651Z</updated>
    
    <content type="html"><![CDATA[<p>Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021</p><span id="more"></span><div class="story post-story"><h2 id="introduction">Introduction</h2><p>Dynamic Solver：</p><ul><li>High resolution</li><li>High nonlinearity</li><li>High stiffness — 多次迭代、计算量</li></ul><p>Collision:</p><ul><li>Collision detection</li><li>Collision Response.</li></ul><h3 id="problem-definitions">Problem Definitions</h3><h4 id="terms">Terms</h4><p>Position Vector: <span class="math display">\[\mathbf x = [\mathbf x_0 \mathbf x_1 \cdots \mathbf x_N]&#39;\]</span> Velocity: <span class="math display">\[\mathbf v = \dot {\mathbf x}\quad \mathbf M = diag(m_0, \dots, m_N)\]</span> Energy – Holonomic(Position only): <spanclass="math display">\[E(\mathbf x)\]</span> 例如：</p><ol type="1"><li>重力势能</li><li>弹簧能量</li><li>Fixing Energy — <span class="math inline">\(\frac{\sigma}2 (\mathbfx_i -\mathbf y_i)^2\)</span></li></ol><h4 id="time-integration">Time Integration</h4><p>常用：隐式欧拉法</p><p>求解方法：</p><ol type="1"><li>消去 <span class="math inline">\(\mathbf v^{t + \Deltat}\)</span></li><li>转化为非线性优化问题</li></ol><p>从而，整个问题都变为： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x)\]</span> 其中 <span class="math inline">\(F\)</span>由动能和势能组成。</p><h4 id="碰撞">碰撞</h4><p>作为约束项出现： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad \mathbf x^{t + \Delta t} \in \Omega\]</span> <img src="ClothSimu/image-20220414210701587.png"alt="image-20220414210701587" /></p><p>上式存在隧穿问题(Tunnel)。故采用CCD。 <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad s \mathbf x^t + (1-s)  \mathbf x^{t + \Delta t} \in \Omega\forall s\in [0,1]\]</span></p></div><div class="story post-story"><h2 id="dynamics">Dynamics</h2><p>非线性优化通常有如下的形式： <span class="math display">\[\mathbf x ^{k+1} = \mathbf x^k - \alpha^{k + 1}\left(A^{k+1}\right)^{-1} \mathrm{grad}\]</span></p><h3 id="newton-法">Newton 法</h3><p>优点</p><ul><li>2 阶方法</li><li>Hessian Matrix</li></ul><p>问题</p><ul><li>如何求解 <span class="math inline">\(A^{-1}f\)</span> —计算量大</li><li>不一定收敛<ul><li>减小 <span class="math inline">\(\alpha\)</span></li><li>要求 Hessian 正定</li></ul></li></ul><h3 id="梯度下降">梯度下降</h3><p><span class="math display">\[A = \mathrm{id}\]</span></p><p>优点</p><ul><li>GPU++</li><li>简单</li></ul><p>缺点</p><ul><li>1阶收敛 – 慢</li><li>没有任何实时模拟器使用</li></ul><h3 id="projective-dynamics">Projective Dynamics</h3><p>用常矩阵代替 <span class="math inline">\(A\)</span></p><p>优点：</p><ul><li>CPU++，（C 可以被预分解）</li><li>收敛快 — smoother</li></ul><p>缺点</p><ul><li>GPU不友好</li><li>1阶收敛速度（总体上很慢）</li></ul><h3 id="diagonal-hessian">Diagonal Hessian</h3><p><span class="math display">\[\mathbf A^{k+1} = \mathrm{diag\ grad}\]</span></p><p>优点</p><ul><li>收敛快于GD</li><li>GPU++</li></ul><p>缺点</p><ul><li>速度仍然差于牛顿</li></ul><h3 id="lower-hessian">Lower Hessian</h3><p>使用hessian的下三角</p><p>优缺点同 Diag Hess</p><figure><img src="ClothSimu/image-20220414212056199.png" class="lazyload" data-srcset="ClothSimu/image-20220414212056199.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="总结对比" /><figcaption aria-hidden="true">总结对比</figcaption></figure><h3 id="acceleration">Acceleration</h3><ul><li>Chebyshev — GPU Firendly</li><li>Multiscale Acceleration</li></ul><h3 id="conclusion">Conclusion</h3><p>CPU：Projective Dynamics + Newton-Raphson</p><p>GPU：Chebyshev + Diagonal Hessian / Newton + PCG</p><h3 id="more">More</h3><h4 id="pbd-position-based-dynamics">PBD — Position-Based Dynamics</h4><p><strong>NVCLOTH</strong></p><h4 id="regular-grid-mesh">Regular Grid Mesh</h4><ul><li>Avoid Topology info</li><li>mem access</li><li>more suitable for high resolution</li></ul></div><div class="story post-story"><h2 id="碰撞-1">碰撞</h2><p>两部分：碰撞检测 + 碰撞响应 具体看综述</p><h3 id="检测">检测</h3><p>mesh -&gt; pair -&gt; collision</p><h3 id="response">Response</h3><ol type="1"><li>Iterative Position-Based Repulsion</li><li>Impact Zone Method</li><li>Untangling</li></ol></div><div class="story post-story"><h2 id="other-topics">Other Topics</h2><ul><li>Friction</li><li>Nonelastic</li><li>Locking</li><li>Physical model and measurement</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="仿真模拟" scheme="http://adversarr.github.io/tags/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="布料" scheme="http://adversarr.github.io/tags/%E5%B8%83%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 6 - 综述</title>
    <link href="http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/"/>
    <id>http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-15T04:13:25.291Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测 学习笔记</p><span id="more"></span><p>[toc]</p><div class="story post-story"><h2 id="碰撞处理简述">碰撞处理简述</h2><p>碰撞处理的难度是不大的，主要问题是如何进行快速、准确的碰撞检测。碰撞检测主要算法执行流程如下图：</p><figure><img src="2022-04-05-17-32-22.png" class="lazyload" data-srcset="2022-04-05-17-32-22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GAMES-103-Wang" /><figcaption aria-hidden="true">GAMES-103-Wang</figcaption></figure></div><div class="story post-story"><h2 id="碰撞检测----introduction">碰撞检测 -- Introduction</h2><p>首先再次引一下 PhyX 里面的内容，这也是这篇文章整体的一个思路。</p><blockquote><p><strong>Overview of Collision in PhysX</strong></p><ul><li>Broad Phase<ul><li>AABB vs AABB, 3 axis sweep and prune</li></ul></li><li>Mid Phase<ul><li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABBtree</li></ul></li></ul><p>对于 Narrow Phase：</p><ul><li><p>流体-SPH Fluids (CCD)</p><ul><li>Particles vs static triangle mesh • Particles vs dynamicprimitives</li></ul></li><li><p>布料-Cloth (CCD)</p><ul><li>Vertices vs static triangle mesh • Vertices vs dynamicprimitives</li></ul></li><li><p>刚体-Rigid body (Discrete) – GJK or SAT</p><ul><li><p>Convex mesh and primitives vs static triangle mesh</p></li><li><p>Convex, primitives vs Convex, primitives</p></li></ul></li></ul></blockquote><p>解释一些事情：</p><ol type="1"><li><p>对于<strong>大多数</strong>情况下的碰撞，我们只考虑<strong>物体之间</strong>的情况，而不是物体内部。</p></li><li><p>Broad-Phase做的实际上是<em>生成式</em>的，而非<em>筛选式</em>的，Mid-Phase对于Broad-Phase进行筛选，Narrow-Phase是筛选结果来精确计算是否真正发生了碰撞。</p><blockquote><p>很多研究认为 Narrow-Phase的效率并不需要太多考虑，而前两个筛选的效率大大影响了结果</p></blockquote></li><li><p>对于Narrow-Phase中的三类物体，它们有不同的属性：</p><ol type="1"><li>流体 -- SPH模拟假设为一个个小的水块，自相交检测策略不同</li><li>布料 -- Mass-Spring orPBD，约束为任何物体不能穿透布料表面，也适用于自身，所以需要进行自碰撞处理</li><li>刚体 -- 不可能发生自碰撞，只考虑物体之间的碰撞。</li></ol></li></ol></div><div class="story post-story"><h2 id="broad-phase">Broad-Phase</h2><p>实际上这个没啥好讲的，主要思路就是建立空间数据结构，然后加速计算。</p><ol type="1"><li>BVHs</li><li>Spatial Hashing</li></ol><h3 id="加速结构">加速结构</h3><p>就如之前提到的，Broad-Phase主要是使用<strong>空间数据结构</strong>来加速碰撞检查，这类数据结构按照欧氏空间的坐标来对于整个空间进行索引加速，从而实现快速查找近邻的目的。</p><h4 id="oct-treekdtree">OCT-tree/kdTree</h4><ul><li><p><strong>八叉树</strong>：将一个Box按照点<spanclass="math inline">\(P\)</span>和经过<spanclass="math inline">\(P\)</span>平行于<spanclass="math inline">\(xOy,yOz,zOx\)</span>的平面划分。</p></li><li><p><strong>kd树</strong>：每一次选择一个超平面划分所有点，超平面的选择依照<spanclass="math inline">\(xOy, yOz,zOx,xOy,yOz,\cdots\)</span>的顺序选择。</p></li></ul><p>可能碰撞转化为查询轨迹和物体是否相交，等价于查询是否和当前节点的覆盖范围相交，若检查到轨迹和结点覆盖范围</p><ol type="1"><li>相交：<ul><li>叶子节点，认定为可能碰撞的目标</li><li>非叶结点，继续递归查询</li></ul></li><li>不相交： 停止递归查询</li></ol><p>这样构造层次结构的问题是：</p><ol type="1"><li>过于规则：容易出现不均匀分割，从而导致内存浪费和查询效率下降。</li><li>不利于并行计算—这也是层次结构的通病</li></ol><h4 id="bvh">BVH</h4><p>BVH可以看作是OCT-Tree和kdTree的一个推广：Bounding VolumnHierarchy（BVH） 将全空间进行划分，对于维度为 1的情况，BVH与<em>线段树</em>几乎没有区别。不过，BVH和OCT-Tree等的最大的区别在于OCT-Tree 和kdTree进行划分时使用的是边界去切分整个平面，而BVH用的是<strong>有限体积的“框”</strong>去做空间细分。典型的BVH包括：</p><ul><li>AABB：轴对齐包围盒</li><li>OBB：旋转包围盒</li><li>kDOP：k边形包围盒</li><li>Bounding Sphere：包围球</li></ul><p>可以看出，各个算法不同的部分是选用的“框”的形状。另外，在构造上BVH有启发算法，可以是的其构造的层次结构尽量均匀，进一步提高BVH的加速能力。</p><h4 id="spatial-hashing-spatial-partitioning">Spatial Hashing / SpatialPartitioning</h4><p>Spatial Hashing的思想是为每一个空间一个编号。最简单的方法是均匀的使用格点来对于全空间进行划分。最基础的Spatial Hashing在为每一个格子建立列表，列表中存放所有和该格子有重合区域的物体（即一个物体可能出现在多个格子内），在查询碰撞时即对于同一列表中的不同物体进行查询即可。</p><figure><img src="image-20220409103734403.png" class="lazyload" data-srcset="image-20220409103734403.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Spatial Partitioning" /><figcaption aria-hidden="true">Spatial Partitioning</figcaption></figure><p>如图所示，其将全空间划分为16个格子。考虑到减少空间浪费的问题，将这些物体的按id进行排序，即可在不为每一个id建立表格的情况下完成筛选。</p><p>该算法的主要问题在于，现代的渲染常常物体、面元分布极不均匀，在可能在几个小的cell中包含大量物体，而产生大量的可能碰撞物体对，极大的降低了其查询效率。</p><p>但是得益于其可以轻松在并行计算环境，特别是GPU上进行实现，其在物理引擎中也得到了广泛的应用。</p><h3 id="mid-phase">Mid-Phase</h3><p>之所以把Mid-Phase放在BroadPhase中是因为它用的算法和数据结构实际上和BroadPhase几乎是一致的。</p><p>Mid-Phase会对Broad-Phase筛选出的pair进行进一步筛选，针对每一个物体，其通过细分为更小的物体块（如凸包，面元组等），然后继续应用加速结构进行筛选。</p><blockquote><p>在这个的基础上还有一些 local 的加速方法，但这也不能算是 Broad-Phase的方法，因为这个方法针对于 <em>Deformed</em>的物体进行计算的效率较高。这些方法在曲面上进行划分，相当于在曲面上定义了一个空间划分。比如通过形变能量来指导在其上的空间划分，最后精细化求解使用三次方程法求解。例如：该论文提出，可以依照形变能量，在曲面的表面上建立BVH，来指导Culling进行。</p></blockquote><figure><img src="image-20220413220403382.png"alt="Energy-based Self-Collision Culling for Arbitrary Mesh Deformations" /><figcaption aria-hidden="true">Energy-based Self-Collision Culling forArbitrary Mesh Deformations</figcaption></figure></div><div class="story post-story"><h2 id="narrow-phase-1-刚体">Narrow-phase 1 刚体</h2><h3 id="dcd">DCD</h3><h4 id="signed-distance-function">Signed Distance Function</h4><p>如果我们能为刚体定义一个连续函数，使得对于<spanclass="math inline">\(\mathbf x \in \Omega -\partial\Omega\)</span>有<span class="math inline">\(\phi(\mathbf x) &lt;0\)</span>对于所有<span class="math inline">\(x\not \in \overline\Omega\)</span>，有<span class="math inline">\(\phi(x) &gt;0\)</span>，则可以很简单的通过函数零点的存在性来判断是否碰撞。</p><p>但对于一般的网格，难以定义这样一个带符号的距离函数。</p><h4 id="凸包刚体的dcd计算">凸包/刚体的DCD计算</h4><p>对于一般的刚体之间的碰撞检测，一般采用分解为凸包的算法来进行精准的碰撞检测。因此，最基础的针对凸物体的碰撞检测算法（即凸物体之间的碰撞检测）</p><h5 id="gjk算法">GJK算法</h5><h6 id="idea">Idea</h6><p>设<span class="math inline">\(\mathcal A = \{\mathbfx\}\)</span>，<span class="math inline">\(\mathcal B = \{\mathbfx\}\)</span>是两个凸集，定义其 Minkowski 差为： <spanclass="math display">\[\mathcal A - \mathcal B :=\{\mathbf x_1 - \mathbf x_2| \mathbf x_1 \in\mathcal A, \mathbf x_2 \in \mathcal B \}\]</span> 不难证明，<span class="math inline">\(\mathcalA\)</span>和<span class="math inline">\(\mathcalB\)</span>碰撞，当且仅当<span class="math inline">\(0 \in \mathcal A -\mathcal B\)</span>。</p><p>问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于<strong>凸物体</strong>，我们可以有快速算法实现。</p><h6 id="support-函数和-simplex-单纯形">Support 函数和 Simplex单纯形</h6><p>其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski差的一个子集包含了<spanclass="math inline">\(0\)</span>，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。</p><p>为了生成这样的单纯形，我们计算 support函数来快速获取给定方向上的支撑点，如图所示[^1]。</p><p><img src="v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg" class="lazyload" data-srcset="v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h6 id="迭代求解">迭代求解</h6><p>有了如上的论述，我们可以通过如此构造单纯形：</p><ol type="1"><li>随机生成一个单纯形</li><li>假定当前的单纯形为<spanclass="math inline">\(\{v\}\)</span>则选择距离原点最远的抛弃，对于 n - 1维单纯形求法向量，求support（两个）</li><li>直到<ol type="1"><li>检查到 0 =&gt; 碰撞</li><li>如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞</li></ol></li></ol><p>可以证明，这样的算法一定在有限步内结束。</p><h5 id="sat算法">SAT算法</h5><p>一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个<spanclass="math inline">\(n - 1\)</span>维的超平面能够完全分开这两个凸集合。遍历所有的边（三维则是面），投影到其正交补空间上。若<strong>存在</strong>一个边，能使得投影完全分离，则其是不相交的，反之相交。具体实现为遍历所有的边来进行判断。</p><h5 id="凸包分解和碰撞检测">凸包分解和碰撞检测</h5><p>对于一般的刚体，我们可以选择使用<strong>凸包分解（V-HACD）</strong>，将刚体“拆分”成小的凸包。并使用适用于凸包的Collision Detect 来进行碰撞的判断。</p><h3 id="ccd">CCD</h3><p>刚体的CCD算法大致有如下几类：</p><ol type="1"><li>求解代数方程</li><li>滑动体积法（Swept Volume）</li><li>二分搜索</li><li>Conservative Advancement上述大部分都难以处理一般的多面体情况。但也有一些特殊情况。</li></ol><!-- 也可以使用分离轴定理计算CCD --><h4 id="代数方程求解">代数方程求解</h4><p>这种方法仅适用于简单而特殊的情况，例如<ahref="http://www.realtimerendering.com/intersections.html">Ref</a>：</p><ol type="1"><li>光线</li><li>平面</li><li>球体、圆柱、圆锥、视锥</li><li>AABB、OBB、kDOP</li><li>凸包</li></ol><h4 id="近似ccd">“近似CCD”</h4><p>通过减小模拟的时间步长，可以将 DCD 近似为 CCD。</p><h4 id="二分搜索">二分搜索</h4><p>这个方法仅仅用于确定 TOI</p><p>物理模拟中有时会使用二分法（二分搜索）来查找撞击时间：使用这种方案，可以非常快速地到达撞击时间，但我们不涉及Tunnel问题，因为如果在第i 帧和第 i + 1 帧没有碰撞，二分就不会开始。</p><h4 id="swept-volumn">Swept Volumn</h4><p>考察<span class="math inline">\(t\)</span>和<spanclass="math inline">\(t+1\)</span>时刻物体对应点连线（按物体形状、沿直线执行扫描）构成的体积区域，不难发现，如果有相交，则可能会出现碰撞。计算TOI（碰撞时间）后将物体移动到改时间，执行碰撞处理（如计算速度等）然后重新扫描。</p><p>在物体角速度很大的情况下会产生不精确的结果 <ahref="https://docs.unity3d.com/Manual/ContinuousCollisionDetection.html">Ref</a>：</p><figure><img src="2022-04-14-15-52-26.png" class="lazyload" data-srcset="2022-04-14-15-52-26.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Unity 3D" /><figcaption aria-hidden="true">Unity 3D</figcaption></figure><h4 id="speculative-ccd">Speculative CCD</h4><p>Speculative CCD的工作原理是根据物体的速度和角速度，计算物体的AABB，从而推测出下一个物理步骤中所有潜在的接触。然后将所有可能接触送入求解器，以确保满足所有接触约束，以便对象不会通过任何穿模（Tunnel）的情况。求解器使用速度、体积来精确计算CCD。</p><p><img src="2022-04-14-15-55-41.png" class="lazyload" data-srcset="2022-04-14-15-55-41.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>但该方法并不能完全解决所有碰撞问题。考虑如下的情况，小球因为被杆击打而获得更大的速度，先前计算的AABB并不能检测到这样的速度变化：</p><p><img src="2022-04-14-16-00-14.png" class="lazyload" data-srcset="2022-04-14-16-00-14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="ray-cast">Ray-cast</h4><p>小而高速和大而低速物体之间的碰撞检测中可以视作光投射到低速物体上的过程，该方法在Unreal Engine中被作为试验性功能提供（支持GPU加速）。算法将光线从对象中心点投射到低速物体上，在高速物体中放置更多的采样点并投射出多条光线，可以获得更好的结果。缺点在于，由于假设了其速度差距极大，该方法不适合计算两个运动的物体的碰撞检测。</p><h4 id="conservasive-advancement">Conservasive Advancement</h4><blockquote><p>Ref:</p><ol type="1"><li>C<sup>2</sup>A: Controlled Conservative Advancement for ContinuousCollision Detection of Polygonal Models</li></ol></blockquote><p>在每次迭代中，计算两个对象的最近点（例如使用GJK）。使用此信息，计算对象可以在避免碰撞的同时移动的安全距离。仅经过几次迭代，就可以找到影响时间。</p></div><div class="story post-story"><h2 id="narrow-phase-2-变形体">Narrow-Phase 2 变形体</h2><h3 id="dcd-1">DCD</h3><p>DCD检查的是如下的方程的解的问题（考察 V-E)：</p><p><span class="math display">\[\begin{cases}   \left( ((1-t)\mathbf{x}_a + t \mathbf x _ b - \mathbf x_0 ) \quad\mathbf x _{10} \quad x_{20}\right) = 0\\   t = (\mathbf x_{0a} \mathbf x_{10}\mathbf  x_{20}) / (\mathbf x_{ba}\mathbf   x_{10} \mathbf x_{20})\\   t \in [0, 1]\\   \mathbf x(t) \text{ inside } \triangle\end{cases}\]</span></p><p>分为三步求解：</p><ol type="1"><li>求解前两行的方程</li><li>判断<span class="math inline">\(t\)</span>是否在<spanclass="math inline">\([0, 1]\)</span></li><li>判断<span class="math inline">\(\mathbfx(t)\)</span>是否在三角形内</li></ol><p>这一部分基本很少有人做，原因在于现代的模拟算法越来越追求计算效率，使用较大的时间步长来进行模拟计算。若仅仅使用DCD，容易产生“穿模”的问题。</p><h3 id="ccd-1">CCD</h3><p>对于变形体（主要是三角网格）的连续碰撞检测处理算法研究主体还是对于三次方程（即VT/EE条件求解），同时也借鉴了一些在刚体碰撞检测中常用的技巧：</p><ol type="1"><li>二分法<ol type="1"><li>IRF：interval-root-finder</li><li>UIRF：Unifromed-Interval-Root-Finder</li></ol></li><li>（针对三角网格）求解三次方程：<ol type="1"><li>FPRF：floating-point time-of-impact root finder</li><li>TightCCD(TCCD)</li><li>BSC</li></ol></li><li>光线投射<ol type="1"><li>Root Parity(RP)</li><li>Rational implementation of RP （RRP）</li></ol></li><li>分割空间微元</li></ol><h4 id="preliminaries">Preliminaries</h4><p>沿用IPC中的记号。对于碰撞检测而言，最基本的模型是假设其在两个迭代步骤之间是线性的，即</p><p><span class="math display">\[\mathbf x(t) = t \cdot \mathbf x ^{i + 1}  + (1 - t) \cdot \mathbf x^{i}\]</span></p><p>其中：</p><p>-<span class="math inline">\(t\)</span>为归一化后的时间，即<spanclass="math inline">\(t = (t - t_{i}) / (t_{i + 1} - t _i)\)</span>其中右侧的<span class="math inline">\(t\)</span>是模拟运行时间-<span class="math inline">\(\mathbfx\)</span>是坐标，是关于时间的函数。上标表示迭代代数</p><p>为了简单期间，用<span class="math inline">\(\mathcal A = \mathbfx_1\cdots \mathbf x_i\)</span>来表示一个<spanclass="math inline">\(n\)</span>维单纯形，用<spanclass="math inline">\(\mathbf x_{ij}\)</span>来表示<spanclass="math inline">\(\mathbf x_{i} - \mathbf x_{j}\)</span>。</p><p>在这样的记号下，碰撞可以用<spanclass="math inline">\(t\)</span>来描述，即：</p><p>单纯形<span class="math inline">\(\mathcal A = \{\mathbf x_1\cdots\mathbf x_n\}\)</span>和<span class="math inline">\(\mathcal B =\{\mathbf x_1 \cdots \mathbf x_m\}\)</span>碰撞，当且仅当：</p><p><span class="math display">\[\exists t\in[0, 1]\quad s.t. \  \mathcal A(t) \cap \mathcal B(t) \ne\emptyset\]</span></p><p>这个公式仅仅是一个定义，并没有很大的计算价值，因此我们需要对于这样的问题进行适当的简化。主要有几种思路：</p><ol type="1"><li>二分搜索，找可能的碰撞时间<spanclass="math inline">\(t\)</span></li><li>约束为三角网格再：<ol type="1"><li>求解重心坐标<span class="math inline">\((u,v)\)</span>和<spanclass="math inline">\(t\)</span></li><li>简化为三次方程求根</li></ol></li><li>光线投射方法</li><li></li></ol><h4 id="二分法">二分法</h4><h5 id="irf">IRF</h5><blockquote><p>Ref:</p><ol type="1"><li>Interval Analysis For Computer Graphics</li><li>Interval Methods for Multi-Point Collisions between Time-DependentCurved Surfaces</li></ol></blockquote><p>逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p><p>优点：</p><ol type="1"><li>不会有遗漏的碰撞情况，并且每一步都保证包含 <spanclass="math inline">\(0\)</span>，所以能够确保检查到碰撞</li><li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li></ol><p>缺点：</p><ol type="1"><li>基于二分查找 — 太慢</li><li>难以实施编译优化</li></ol><h5 id="uirf">UIRF</h5><p>差不多的思路，但是是用二分法求的是单变量的方程根。</p><blockquote><p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p><p>与此同时，它不能满足控制求解器的运行精度</p></blockquote><h4id="针对三角网格的三次方程求解方法">针对三角网格的三次方程求解方法</h4><blockquote><p>Ref:</p><ol type="1"><li>Collision and self-collision handling in cloth model dedicated todesign garments</li></ol></blockquote><p>针对于三角网格，上文提出：</p><dl><dt>Theorem</dt><dd>碰撞发生，当且仅当至少发生以下一种碰撞：</dd></dl><ol type="1"><li>Vertex-Triangle</li><li>Edge-Edge</li></ol><p>在这篇论文中，还提出了这两类条件的符号语言描述：</p><p><span class="math display">\[VT\iff \exists t\in [0, 1]\quad \begin{cases}\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\\mathbf x_4 \in \left\{ x_1 x_2 x_3 \right\}\end{cases}\]</span></p><p>其中：<span class="math inline">\(1,2,3\)</span>为三角形顶点，<spanclass="math inline">\(4\)</span>为顶点</p><p><span class="math display">\[EE\iff \exists t\in [0, 1] \quad \begin{cases}\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\\left\{\mathbf x_1 \mathbf x_2\right\} \cap \left\{\mathbf x_3 \mathbfx_4\right\} \ne \emptyset\end{cases}\]</span></p><p>对于上述两种做法，我们观察到条件中都有一个关于<spanclass="math inline">\(t\)</span>的三次方程（因为每一个<spanclass="math inline">\(\mathbf x_i\)</span>都是关于<spanclass="math inline">\(t\)</span>仿射），因此我们的解决思路就是：</p><ol type="1"><li>求三次方程在<span class="math inline">\([0, 1]\)</span>内的根</li><li>检查这个根是否满足第二个条件</li></ol><p>其中的<strong>数值精度</strong>问题体现在：</p><ol type="1"><li>三次方程求解：<ol type="1"><li>不能使用求根公式（误差放大几个数量级） -- 只能用牛顿法求</li><li>何时停止迭代</li></ol></li><li>判断是否碰撞时的误差上界？</li></ol><h5 id="fprf">FPRF</h5><p>最老、最经典的一篇论文</p><blockquote><p>Ref:</p><ol type="1"><li>Collision and self-collision handling in cloth model dedicated todesign garments</li></ol></blockquote><p>思想：解三次方程，解出来的解对应函数值是小于一常数，则判断为碰撞。</p><p>主要问题：</p><ol type="1"><li>FN太多，即有很多碰撞点不被检测到。</li><li>当平行时无法处理 EE 的情况。</li></ol><p>优点：</p><ol type="1"><li>速度</li></ol><h5 id="tightccd">TightCCD</h5><blockquote><p>Ref:</p><ol type="1"><li>TightCCD: Efﬁcient and Robust Continuous Collision Detection usingTight Error Bounds</li></ol></blockquote><p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算，观察的是</p><p><span class="math display">\[Y(0),Y&#39;(0),Y&#39;(1),Y&#39;&#39;(0),Y&#39;&#39;(1)\]</span></p><p><img src="2022-04-14-19-56-39.png" class="lazyload" data-srcset="2022-04-14-19-56-39.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>优点：</p><ol type="1"><li>速度快，准确率也高，几乎是最好的算法</li><li>完全没有检测不出的碰撞</li></ol><p>问题：</p><ol type="1"><li>为了 FN == 0，牺牲了 FP</li><li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li></ol><h5 id="bsc">BSC</h5><blockquote><p>Ref:</p><ol type="1"><li>Fast and exact continuous collision detection with bernstein signclassification</li></ol></blockquote><p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p><p>缺点：</p><ol type="1"><li>False Positive + False Negative</li></ol><blockquote><p>实际上这两个思路和我一开始想的是一致的：</p><p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p><p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p></blockquote><p>原理上：给定一个三次函数 <span class="math inline">\(Y(t)\)</span>用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p><p><img src="image-20220412105920274.png" class="lazyload" data-srcset="image-20220412105920274.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>从而通过观察：</p><p><span class="math display">\[Y(0), Y(1/3), Y(2/3), Y(1)\]</span></p><p>（其中 <span class="math inline">\(Y\)</span>即为三次方程对应的函数）的值来减少计算开销并提升精度。</p><h4 id="光线投射-rp-rrp">光线投射 RP / RRP</h4><p>转化为光线投射问题：设 <span class="math inline">\(\partial\Omega\)</span>是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p><p>问题：</p><ol type="1"><li>实际上只能做DCD – 小TS</li><li>容易出现漏报的问题：在 <span class="math inline">\([t,t+\Deltat]\)</span> 内有 2 解</li></ol><p>原理：</p><blockquote><p>根据 Brouwer topological degree theory：</p><p>假设 <span class="math inline">\(\Omega\)</span> 是一个 <spanclass="math inline">\(n\)</span> 多面体，设 <spanclass="math inline">\(F:\Omega \rightarrow \mathbb R^{n}\)</span>满足<spanclass="math inline">\(C^2\)</span>，且有有限多个根，且没有在边界<spanclass="math inline">\(\Gamma=\partial \Omega\)</span>上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <spanclass="math inline">\(0\)</span> 出发，记交点数为 <spanclass="math inline">\(q\)</span> ，<spanclass="math inline">\(F\)</span> 在交点处光滑且不相切于光线，那么 <spanclass="math inline">\(p,q\)</span> 有相同的奇偶性。</p></blockquote><p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p><h3 id="碰撞处理">碰撞处理</h3><blockquote><p>在这里假设在上一步已经获取了碰撞的时刻（TOI）</p><p>Ref:</p><ol type="1"><li>Robust Treatment of Collisions, Contact and Friction for ClothAnimation</li></ol></blockquote><p>根据王老师在GAMES103和2021图形学大会讲的内容（Real-Time ClothSimulation on GPUs），其程序流程如下：</p><figure><img src="image-20220414221444102.png" class="lazyload" data-srcset="image-20220414221444102.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="A Practical System" /><figcaption aria-hidden="true">A Practical System</figcaption></figure><p>前两种方法都是基于如下公式： <span class="math display">\[\mathbf x^{k+1} = \arg\min \|\mathbf x - \mathbf x ^ *\|\]</span> 而Untangle Cloth不基于上式直接进行解除相交问题。</p><h4 id="interior-point-method-内点法">Interior Point Method 内点法</h4><p>思想：添加<spanclass="math inline">\(\log\)</span>边界函数，保持在可行域内，逐步迭代：</p><p>优点</p><ul><li>Always succeed</li></ul><p>缺点：</p><ul><li>可能达到局部最优解</li><li>需要计算所有的顶点来迭代</li><li>小步长 — 速度慢</li></ul><figure><img src="image-20220414221940838.png" class="lazyload" data-srcset="image-20220414221940838.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Interior Point Method" /><figcaption aria-hidden="true">Interior Point Method</figcaption></figure><h4 id="impact-zone-optimization">Impact Zone Optimization</h4><p>思想：直接从 <span class="math inline">\(\mathbf x^*\)</span>开始迭代，逐步逼进可行域，如下图</p><figure><img src="image-20220414222918767.png" class="lazyload" data-srcset="image-20220414222918767.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Impact Zone Optimization" /><figcaption aria-hidden="true">Impact Zone Optimization</figcaption></figure><p>优点：</p><ul><li>很容易得到一个可能的解。</li><li>只需要对不满足约束的点处理</li><li>可以使用大步长</li></ul><p>缺点：</p><ul><li>可能不收敛到可行域内</li></ul><h4 id="相交解除-untangle-cloth">相交解除 — Untangle Cloth</h4><blockquote><p>Ref</p><ol type="1"><li>Untangle Cloth</li><li>Resolving Surface Collisions through Intersection ContourMinimization</li></ol></blockquote><p>当拿到碰撞点后，使用“注水”法，可以直接求出交叉的区域。对于这两个交叉的边界，假设为“紧密贴合”。</p><p>优点：</p><ol type="1"><li>保证在绝大部分情况下能够处理</li></ol><p>缺点：</p><ol type="1"><li>原文中之处理了相交的闭区域，对于边界交叉处理不方便。</li><li>物理上不真实</li><li>难以在GPU上实现</li></ol><h4 id="rigid-impact-zone">Rigid Impact Zone</h4><p>如果上述方法都失败了，那么就考虑使用该方法，其对于不满足要求的点，直接回退到上一模拟步的状态（无相交的状态）。</p></div><div class="story post-story"><h2 id="非接触方法">非接触方法</h2><p>这一类方法都将原有的碰撞条件增强为保持一些点/面之间的距离大于一定值，从而避免CCD 过程。正如zhihu上所说：</p><blockquote><p>之前大家试过很多方法，比如定义物体表面距离很近的“点-三角”对和“边-边”对（接触元对）组成的四面体的有符号体积要恒大于0；或者在每个时间歩开始时，找到距离近的每个接触元对上距离最近的点对，限定这些点对的距离大于0等。这些定义的问题在于，如果物体在某个时间歩移动比较多，他们可能无法正确描述无穿透这件事。另外这类方法大多基于sequentialquadraticprogramming优化方法，没法像无约束条件时的牛顿迭代那样方便地通过linesearch保证稳定收敛。</p><p>By Minchen Li.</p></blockquote><h3 id="ipc">IPC</h3><blockquote><p>Ref:</p><ol type="1"><li>Incremental potential contact: intersection-and inversion-free,large-deformation dynamics</li><li>Medial IPC: accelerated incremental potential contact with medialelastics</li><li>Codimensional incremental potential contact</li><li>BFEMP: Interpenetration-Free MPM-FEM Coupling with BarrierContact</li></ol></blockquote><p>主要思路：迭代的每一步，都把所有 primitive pair 分成两类：</p><ol type="1"><li><span class="math inline">\(0&lt;\min \mathrm{distance} \le \hatd\)</span>：设置 <span class="math inline">\(\log\)</span>-barrier函数，防止直接碰撞</li><li><span class="math inline">\(\min \mathrm{distance} &gt; \hatd\)</span>：设置迭代最大步长，避免距离在迭代路径上碰撞（穿透）</li></ol><p>依据这两个基本假设来避免 CCD。</p><p>首先，其主要处理的是如何<strong>避免连续碰撞检测</strong>，在论文中，其提出：</p><blockquote><p>我们称一个状态是可接受的，当且仅当存在一条可行路径，到达该状态，或以该状态为极限。</p><p>一个迭代路径是可接受的，当且仅当其可以作为上述的极限过程中的状态序列</p></blockquote><p><span class="math display">\[\mathbf x \in \Omega \iff \exists \mathbf x_i \in \Omega.\\lim_{i\rightarrow \infty} = \mathbf x\]</span></p><p>那么，基于以上假设，我们完全可以不去度量是否<strong>产生了</strong>碰撞，而把约束换成</p><p><span class="math display">\[\|\mathbf x - \mathbf x&#39;\| &gt; 0,\quad \forall \mathbf x&#39; \in\partial \Omega\]</span></p><p>这样，我们可以将问题转化为：</p><p><span class="math display">\[\|\mathbf x - \mathbf y\| \ge \epsilon, \forall \mathbf x ,\mathbfy\text{ from different primitives}\]</span></p><p>那么，可以将动力学方程和约束放在一起求解即：</p><p><span class="math display">\[\begin{aligned}\min_{\mathbf x}\quad &amp;F(\mathbf x) + G(\min\mathrm{distance}(\mathbf x))\\\text{s.t.}\quad &amp;\mathbf x \text{ is feasible}\end{aligned}\]</span></p><p>其中：</p><ul><li><span class="math inline">\(F\)</span> 为动力学方程中的能量</li><li><span class="math inline">\(G\)</span> 为障碍函数</li></ul><p>这是一个几乎没有约束的优化问题：因为原来的碰撞处理的全套流程转化为在迭代求解过程中，保证迭代路径是可接受的！</p><p>具体而言，Log函数为了避免在不充分接近时也出现“抵抗力”，其在保证<spanclass="math inline">\(C^2\)</span>的情况下，构造了如下的“log-barrier”：</p><p><img src="2022-04-15-08-56-06.png" class="lazyload" data-srcset="2022-04-15-08-56-06.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><blockquote><p>该方法可以看作是一个“内点法”</p></blockquote><h4 id="如何计算-距离">如何计算 “距离”</h4><p>IPC方法中并不限于三角网格等具体的空间结构，因此距离的计算并不需要依赖于物体表示的维数。基本思路是通过重心坐标构造两个primitive 上的点<span class="math inline">\(\mathbf x\)</span>和<spanclass="math inline">\(\mathbf y\)</span>，从而计算</p><p><span class="math display">\[d(\mathbf x, \mathbf y) = \min \|\mathbf x - \mathbf y\|\]</span></p><p>来得到距离。</p><h4 id="constraint-set">Constraint Set</h4><p>通过 Spatial Hashing 算法来加速 Constraint Set 计算，定义为：</p><p><span class="math display">\[\{\langle i , j \rangle | d(\mathbf x_i, \mathbf x_j) \le \hat d \}\]</span></p><h4 id="迭代过程中如何保证约束">迭代过程中如何保证约束</h4><p>算法使用 Intersection-AwareLine-Search（回溯线搜索）来进行迭代。并且在每次执行搜索之前，重新计算Constraint Set。而观察到对于：</p><ol type="1"><li>Constraint Set中的元素对：一定出现在优化的能量函数中，通过barrier函数避免碰撞</li><li>不在其中的元素对：初始距离<span class="math inline">\(&gt;\hatd\)</span></li></ol><p>从而可以通过 <span class="math inline">\(\hat d\)</span>指导迭代的最大步长。</p><p>从而将原本难以解决的CCD问题避免。</p><h4 id="总结">总结</h4><p>优点：</p><ol type="1"><li>不需要繁琐的 CCD -- 速度、精度都有保证</li><li>嵌入到 Dynamic Solver 迭代过程中</li><li>容易在GPU上实现</li></ol><p>缺点：</p><ol type="1"><li>非接触方法，摩擦难以解决</li></ol><h3 id="siggraph-2021----repulsion-method">SIGGRAPH 2021 -- RepulsionMethod</h3><blockquote><p>Ref:</p><ol type="1"><li>A Safe and Fast Repulsion Method for GPU-based Cloth SelfCollisions</li></ol></blockquote><p>思路：找到使不产生VT/EE碰撞的充分条件，且该充分条件仅需要考虑顶点之间的距离，而和三角网格无关。</p><p><span class="math display">\[\min d(\mathbf v_i, \mathbf v_j) \ge \hat d = L / 2\]</span></p><p>其中<span class="math inline">\(L\)</span>为三角网格的最大边长。</p><p>求解过程分为两部分：</p><ol type="1"><li>Soft-Phase</li><li>Hard-Phase</li></ol><p>并且为了避免约束过强，使用了自适应的重采样方法。</p><h4 id="soft-phase">Soft-Phase</h4><p><span class="math display">\[\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm{init}} \| − \rho \min \left\{c_{ij} (\mathbf x) − \varepsilon_{slack} ,0  \right\}\right\}\]</span></p><h4 id="hard-phase">Hard-Phase</h4><p><span class="math display">\[\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm{init}} \| − \mu \sum {\log (f(c_{ij}(x), \varepsilon_{slack}))}\right\}\]</span></p><p>其中的 <span class="math inline">\(f\)</span> 是满足 <spanclass="math inline">\(C^1\)</span> 的分段函数：</p><p><span class="math display">\[f = \begin{cases}   x &amp; x\le 0\\   ax^3 + bx^2 + cx + d &amp; 0 &lt;x \le \varepsilon\\   \varepsilon&amp; \text{otherwise}\end{cases}\]</span></p><h4 id="adaptive-resampling">Adaptive Resampling</h4><p>由于要求所有距离大于 <span class="math inline">\(L /2\)</span>，为了使得这个条件不是过于充分的，要求最小边长和最大边长<spanclass="math inline">\(l\)</span>与<spanclass="math inline">\(L\)</span>的比例大于一定值。</p><p><img src="2022-04-15-11-19-43.png" class="lazyload" data-srcset="2022-04-15-11-19-43.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测 学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 5 - 2021 A large scale benchmark and an Inclusion-based Algorithm</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:32.603Z</updated>
    
    <content type="html"><![CDATA[<p>Collision Detection 整理5 – CCD 算法对比</p><span id="more"></span><p>准确说，这篇blog是一篇论文的整理emmm，但由于老板的任务就是做 collsion的汇总，这篇论文的涉及面也算是相对 Broad 的了。</p><p>论文主要用了：</p><ol type="1"><li>IRF：interval-root-finder</li><li>UIRF：Unifromed-Interval-Root-Finder</li><li>FPRF：floating-point time-of-impact root finder</li><li>TightCCD(TCCD)</li><li>Root Parity(RP)</li><li>Rational implementation of RP</li><li>MSRF：minimum seperation floating-point time-of-impact rootfinder</li></ol><div class="story post-story"><h2 id="预备知识">预备知识</h2><p>首先论文对于 CCD的数学背景进行了简要的介绍：考虑三角网格，每一个时间步长内都以线性轨迹运动。那么CCD可以简化为VT和EE检查。</p><h3 id="multivariate-ccd-formulation">Multivariate CCD Formulation</h3><p>最简单的方法是直接对于CCD条件参数化，转化为关于 <spanclass="math inline">\(u,v,t\)</span> 的方程求解即可。</p><h3 id="univariate-ccd-单变量ccd">Univariate CCD 单变量CCD</h3><p>实际上上面一种求解方法一步到位解出了 <spanclass="math inline">\(u,v,t\)</span>但没有注意到在接触时，四点共面的事实，所以，在[Provot 97]中，改为先求解三次方程，然后检查是否满足条件的问题</p></div><div class="story post-story"><h2 id="方法介绍">方法介绍</h2><h3 id="irf">IRF</h3><p>类似于计算 Minkowski差，逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p><p>优点：</p><ol type="1"><li>保守估计，每一步都保证包含 <spanclass="math inline">\(0\)</span>，所以能够确保检查到碰撞</li><li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li></ol><p>缺点：</p><ol type="1"><li>基于二分查找 — 慢</li><li>难以实施编译优化</li></ol><h3 id="uirf">UIRF</h3><p>差不多的思路，但是是用二分法求的是单变量的方程根。</p><blockquote><p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p><p>与此同时，它不能满足控制求解器的运行精度</p></blockquote><h3 id="fprf">FPRF</h3><blockquote><p>Robust treatment of simultaneous collisions.</p></blockquote><p>主要问题：</p><ol type="1"><li>FN太多，即有很多碰撞点不被检测到。</li><li>当平行时无法处理 EE 的情况。</li></ol><p>优点：</p><ol type="1"><li>速度</li></ol><h3 id="tightccd">TightCCD</h3><p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算。</p><p>优点：</p><ol type="1"><li>速度快</li><li>完全没有检测不出的点</li></ol><p>问题：</p><ol type="1"><li>为了 FN == 0，牺牲了 FP</li><li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li></ol><h3 id="rp-rrp">RP / RRP</h3><p>转化为光线投射问题：设 <span class="math inline">\(\partial\Omega\)</span>是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p><p>问题：</p><ol type="1"><li>实际上只能做DCD – 小TS</li><li>容易出现漏报的问题：在 <span class="math inline">\([t,t+\Deltat]\)</span> 内有 2 解</li></ol><p>原理：</p><blockquote><p>根据 Brouwer topological degree theory：</p><p>假设 <span class="math inline">\(\Omega\)</span> 是一个 <spanclass="math inline">\(n\)</span> 多面体，设 <spanclass="math inline">\(F:\Omega \rarr \mathbb R^{n}\)</span>满足 <spanclass="math inline">\(C^2\)</span>，且有有限多个根，且没有在边界<spanclass="math inline">\(\Gamma=\partial \Omega\)</span>上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <spanclass="math inline">\(0\)</span> 出发，记交点数为 <spanclass="math inline">\(q\)</span> ，<spanclass="math inline">\(F\)</span> 在交点处光滑且不相切于光线，那么 <spanclass="math inline">\(p,q\)</span> 有相同的奇偶性。</p></blockquote><p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p><h3 id="bsc">BSC</h3><blockquote><p>Fast and exact continuous collision detection with bernstein signclassification</p></blockquote><p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p><p>缺点：</p><ol type="1"><li>False Positive + False Negative</li></ol><blockquote><p>实际上这个思路和我一开始想的是几乎一致的：</p><p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p><p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p></blockquote><p>原理上：给定一个三次函数 <span class="math inline">\(Y(t)\)</span>用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p><p><img src="image-20220412105920274.png" class="lazyload" data-srcset="image-20220412105920274.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div><div class="story post-story"><h2 id="其他思路">其他思路</h2><h3 id="bridson-2009">Bridson 2009</h3><p>添加一个时间维度，通过在四维空间中的相交检测来实现碰撞检测。</p><p>问题：</p><ol type="1"><li>不直观、不常用</li><li>导致了 FP 的出现 — 平行的两个三角形认定为碰撞。</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Collision Detection 整理5 – CCD 算法对比&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>201-02-拉格朗日视角1</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/GAMES/g201-02/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/GAMES/g201-02/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-13T05:59:19.797Z</updated>
    
    <content type="html"><![CDATA[<p>games201 拉格朗日视角</p><span id="more"></span><div class="story post-story"><h2 id="拉格朗日视角简介">拉格朗日视角简介</h2><p>两种视角：</p><ol type="1"><li>拉格朗日视角 – 粒子，携带位置、速度等<ol type="1"><li>MPM、弹簧质点模型……</li></ol></li><li>欧拉视角 – 通过固定的“传感器”来表示<ol type="1"><li>烟雾模拟</li></ol></li></ol><h2 id="弹簧质点模型-mass-spring-system">弹簧质点模型 Mass-SpringSystem</h2><ul><li>Extremely example</li><li>But very useful. – cloth/hair</li></ul><h3 id="基本原理">基本原理</h3><p>利用 <strong>胡克定律</strong> 和 <strong>牛顿第二定律</strong>来计算 加速度-速度-位置</p><ul><li><span class="math inline">\(k\)</span> — stiffness — 刚度</li></ul><h3 id="时间积分">时间积分</h3><h4 id="forward-euler-前向欧啦">Forward Euler 前向欧啦</h4><p><span class="math display">\[v_{t+1} = v_t + \frac{f_t}{m}\Delta t\]</span></p><h4 id="半隐式欧拉法">半隐式欧拉法</h4><p>用 <span class="math inline">\(t+1\)</span> 时刻的 <spanclass="math inline">\(v\)</span> 计算 <spanclass="math inline">\(x\)</span> 的更新。</p><h4 id="implementation">Implementation</h4><ul><li>使用 substep — 保证小步长</li></ul><h3 id="积分器对比">积分器对比</h3><blockquote><p><strong>数值分析</strong></p></blockquote><h4 id="显式积分器">显式积分器</h4><ol type="1"><li>未来仅仅基于过去</li><li>简单</li><li>容易出现数值爆炸问题 — 前向欧拉</li><li>对于 <span class="math inline">\(stiff \gg 1\)</span>效果很差。</li></ol><h4 id="隐式积分器">隐式积分器</h4><ol type="1"><li>未来需要基于自己和过去</li><li>复杂！难以实现、难以优化、GPU……</li><li>Timestep 更大，但是计算更加昂贵</li><li>Numerical damping</li></ol><h3 id="弹簧质点的隐式积分器">弹簧质点的隐式积分器</h3><p>假设： <span class="math display">\[\begin{cases}\mathbf x_{t+1} = \mathbf x_t + \Delta t \mathbf v_{t+1}\\\mathbf v_{t+1} = \mathbf v_t + \Delta t \mathbf M ^{-1}\mathbf f_{t+1}\end{cases}\]</span> 在上式中消除 <span class="math inline">\(\mathbfx_{t+1}\)</span>，使用泰勒公式： <span class="math display">\[\left[I - \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbf f}{\partial\mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbf v_t + \Delta t\mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span> 在这一节课中，仅仅使用 Jacobbi 迭代解上述方程。</p><h3 id="在显式和隐式之间转换">在显式和隐式之间转换</h3><p><span class="math display">\[\left[I - \beta \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbff}{\partial \mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbfv_t + \Delta t \mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span></p><p>其中 <span class="math inline">\(\beta\)</span>控制了在显式、隐式之间的“比例”</p><ul><li><span class="math inline">\(\beta = 1\)</span> — Explicit</li><li><span class="math inline">\(\beta = .5\)</span> — Semi-Implicit</li><li><span class="math inline">\(\beta = 0\)</span> — Implicit</li></ul><h3 id="大规模情况">大规模情况</h3><ol type="1"><li>稀疏矩阵</li><li>共轭梯度法</li><li>Preconditioning</li><li>PBD</li></ol></div><div class="story post-story"><h2 id="拉格朗日法流体模拟-sph">拉格朗日法流体模拟 — SPH</h2><p>用一些粒子（并附带物理量）以及一个核函数去模拟一个物理场。</p><p>优点：</p><ol type="1"><li>不需要 Mesh、适合自由表面物体</li><li>容易理解</li></ol><h3 id="wcsph">WCSPH</h3><blockquote><p>可压缩物体模拟</p></blockquote><p>Momentum Equation: <span class="math display">\[\frac{D\mathbf v}{D t} = - 1/\rho \nabla p + \mathbf g,\quad p =B\left(\left( \frac{\rho}{\rho_0}\right)^\gamma - 1\right)\]</span></p><ol type="1"><li>表面张力、粘滞力</li></ol><h3 id="sph-simulation-cycle">SPH simulation Cycle</h3><p>通过半隐式欧拉法计算</p><h3 id="sph-变种">SPH 变种</h3><h3 id="cfl条件">CFL条件</h3><p>对于显式积分，<span class="math inline">\(dt\)</span> 具有上界：<span class="math display">\[C = \frac{u\Delta t}{\Delta x} \le C_\max \sim ~\]</span></p><ol type="1"><li><span class="math inline">\(C\)</span>: CFL number</li></ol><p>Application</p><ol type="1"><li>SPH: <span class="math inline">\(C_\max\sim 0.4\)</span></li><li>MPM:<span class="math inline">\(C_\max -0.3\sim1\)</span></li></ol><h3 id="加速-sph">加速 SPH</h3><p>通过 Neighbour search with hashing（空间数据结构）</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;games201 拉格朗日视角&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>libigl 简述</title>
    <link href="http://adversarr.github.io/2022/04/10/CG/Libigl/"/>
    <id>http://adversarr.github.io/2022/04/10/CG/Libigl/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:19.081Z</updated>
    
    <content type="html"><![CDATA[<p>TODO: Libigl 教程（翻译和解释）</p><p>现挖个坑，后面补上。 <span id="more"></span></p><h1 id="libigl-tutorial">libigl Tutorial</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;TODO: Libigl 教程（翻译和解释）&lt;/p&gt;
&lt;p&gt;现挖个坑，后面补上。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>102-08-离散微分几何</title>
    <link href="http://adversarr.github.io/2022/04/09/CG/GAMES/g102-08/"/>
    <id>http://adversarr.github.io/2022/04/09/CG/GAMES/g102-08/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-04-13T05:59:16.345Z</updated>
    
    <content type="html"><![CDATA[<p>Games 102 - 离散微分几何</p><span id="more"></span><div class="story post-story"><h2 id="三角网格存储">三角网格存储</h2><p>常用的是<strong>半边数据结构</strong>（Half-Edge）数据结构</p><ul><li>将网络连接关系存储在边上，表达为两条半边</li><li>目的：提高点线面和查找效率</li></ul></div><div class="story post-story"><h2 id="曲线曲面微分几何">曲线、曲面微分几何</h2><h3 id="曲线的微分几何学">曲线的微分几何学</h3><ul><li><p>Frenet标架</p></li><li><p>Curvature <span class="math inline">\(\kappa\)</span> 和密切圆</p></li><li><p>与参数选择无关 — 本征量</p></li></ul><h3 id="曲面的微分几何学">曲面的微分几何学</h3><ul><li>关于 <span class="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 的偏导 — 切平面</li><li>切平面的法向 — <span class="math inline">\(r_u\timesr_v\)</span></li><li>法平面和曲面求交线，可以定义出一个空间曲线，可以定义其曲率 –方向曲率（法曲率）— 描述曲面沿着方向的弯曲程度</li></ul><h3 id="曲面的曲率">曲面的曲率</h3><p>观察法曲率：</p><ol type="1"><li>有两个正交的方向，使得其能够取最大 <spanclass="math inline">\(\kappa_1\)</span> 和最小<spanclass="math inline">\(\kappa_2\)</span></li></ol><p>有 Euler's Equation 成立： <span class="math display">\[\kappa = \kappa_1 \cos^2\theta +  \kappa_2 \sin^2\theta\]</span> 高斯曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \kappa_1\kappa_2\)</span></li><li><strong>等距变换的不变量</strong></li><li>处处为 0 的曲面 — 可展曲面</li><li><strong>可展曲面</strong>可以分类为：<ul><li>柱面</li><li>锥面</li><li>切线面</li></ul></li></ol><p>平均曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \frac {\kappa_1 +\kappa_2}{2}\)</span></li><li>处处平均曲率为 0 的曲面 — 极小曲面 — 所有点都是鞍点</li></ol></div><div class="story post-story"><h2 id="离散微分几何">离散微分几何</h2><p>考虑到三角网格只有 <span class="math inline">\(C^0\)</span>，使用采样的点来估计原有曲面属性。</p><h3 id="方法">方法</h3><h4 id="连续逼近">连续逼近</h4><p>考虑使用一个简单的曲面来拟合曲面的局部。从而就能计算出</p><h4 id="离散估计">离散估计</h4><p>用面积/角度等特征来进行计算</p><h3 id="例子">例子</h3><h4 id="平均曲率计算">平均曲率计算</h4><p>由 Laplace-Beltrami 定理： <span class="math display">\[\mathbf K (\mathbf x_i) = \frac{1}{2\mathcal A_M} \sum_{j\in N_1(i)}(\cot \alpha_{ij}+ \cot \beta_{ij})(\mathbf x_i - \mathbf x_j)\]</span></p><h4 id="高斯曲率计算">高斯曲率计算</h4><p>由 Gauss-Bonnet 定理： <span class="math display">\[\kappa(\mathbf x_i) = (2\pi - \sum_{j = 1}^{\#f} \theta_j) / \mathcalA_M\]</span></p><blockquote><p>Discrete differential-geometry operators for trangulated 2-manifolds.– 2003</p></blockquote><h3 id="极小曲面">极小曲面</h3></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Games 102 - 离散微分几何&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-09-微分坐标</title>
    <link href="http://adversarr.github.io/2022/04/09/CG/GAMES/g102-09/"/>
    <id>http://adversarr.github.io/2022/04/09/CG/GAMES/g102-09/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-05-17T08:06:08.068Z</updated>
    
    <content type="html"><![CDATA[<p>Games 102 - 微分坐标</p><span id="more"></span><div class="story post-story"><h2 id="section"></h2></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Games 102 - 微分坐标&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的微分几何整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/</id>
    <published>2022-03-28T03:44:29.465Z</published>
    <updated>2022-05-21T08:50:03.176Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p><div class="story post-story"><h2 id="欧氏空间">欧氏空间</h2><h3 id="向量空间">向量空间</h3><h4 id="向量空间的基本概念">向量空间的基本概念</h4><p>首先是相关概念。</p><ol type="1"><li>定义了内积的有限维向量空间是欧氏向量空间</li><li>经过 Schmidt 正交化可以得到标准正交基</li><li>可以定义外积运算</li></ol><dl><dt>外积的性质</dt><dd>设<span class="math inline">\(\mathbf v_{1} ..\mathbfv_{4}\)</span>是向量，则： 1. <span class="math inline">\(\mathbf v_1\wedge (\mathbf v_2 \wedge \mathbf v_3) = \langle\mathbf v_1 , \mathbfv_3\rangle - \langle \mathbf v_1,\mathbf v_2\rangle \mathbf v_3\)</span>2. 拉格朗日恒等式 3. 混合积循环不变</dd></dl><h4 id="向量分析">向量分析</h4><p>考虑向量值/数量值-向量/数量函数的微分：</p><ol type="1"><li><span class="math inline">\(\frac{d}{dt}(\lambda \mathbf a ) =\frac{d\lambda}{dt} a + \lambda \frac{d\mathbf a}{dt}\)</span></li><li>外积也满足上述公式</li><li>混合积也满足上述公式</li><li>多变量时，可以进行偏导和微分，也满足上述公式</li></ol><p>引入 <strong>梯度</strong> 场 和 Nabla算子： <spanclass="math display">\[\mathbf {grad} f = \nabla f\]</span></p><p>引入散度和旋度场： <span class="math display">\[\mathrm{div} \mathbf F\quad \mathbf{rot} \mathbf F\]</span></p><h3 id="欧氏空间-1">欧氏空间</h3><h4 id="向量运算">向量运算</h4><p>注意外积的运算： 1. 反交换律 2. 分配律</p><h4 id="坐标变换">坐标变换</h4><p>注意欧氏空间的定向：</p><dl><dt>定向</dt><dd>两个标架之间的正交变换<spanclass="math inline">\(T\)</span>的行列式为<spanclass="math inline">\(1\)</span>时，称之为定向相同。</dd></dl><h4 id="合同变换">合同变换</h4><dl><dt>Theo</dt><dd>设<span class="math inline">\(\mathcal T\)</span>是合同变换，则存在<spanclass="math inline">\(\mathbf T\in O(3)\)</span>以及<spanclass="math inline">\(P \in E^3\)</span>，使得： <spanclass="math display">\[\mathcal T(X) = X\mathbf T + P,\quad \forall X = (x^1,x^2, x^3)\in E^3\]</span> 即合同变换是正交变换和平移的复合</dd></dl><p>不难验证：合同变换的全体是一个群，称为三维合同变换群，当<spanclass="math inline">\(\det =1\)</span>是，对应的合同变换是刚体运动（也是一个群），反之称为反向刚体运动。</p><h4 id="正交标架和合同变换群">正交标架和合同变换群</h4><p><span class="math inline">\(E^3\)</span>的标架全体<spanclass="math inline">\(\mathcal F\)</span>与<spanclass="math inline">\(E^3\)</span>的欧式变换群之间有一一对应。</p><blockquote><p>即<spanclass="math inline">\(E^3\)</span>的所有元素的稳定化子只有<spanclass="math inline">\(\mathbf{id}\)</span>，并且<spanclass="math inline">\(E^3\)</span>中只有一个轨道。</p></blockquote></div><div class="story post-story"><h2 id="曲线">曲线</h2><h3 id="曲线的概念">曲线的概念</h3><p>在这里我们只考虑如下定义的正则曲线</p><dl><dt>正则曲线</dt><dd>如果曲线满足，每一个分量都是<spanclass="math inline">\(C^\infty\)</span>且 <spanclass="math inline">\(|dr/dt| &gt; 0\)</span>，对于所有<spanclass="math inline">\(t\)</span>，则称该曲线是正则曲线。</dd></dl><blockquote><p>平面上连续可微的参数曲线不一定是正规的</p></blockquote><p><span class="math display">\[\mathbf r(t) = (t^3 , t ^ 2)\]</span></p><h3 id="曲线的弧长">曲线的弧长</h3><p>假设有参数方程<span class="math inline">\(\mathbf r = \mathbfr(t)\)</span>，那么： <span class="math display">\[s= \int _ a ^ b \| \mathbf r&#39;(t)\| \mathrm dt\]</span> 是其弧长，是曲线的一个<strong>不变量</strong></p><h3 id="曲率frenet-标架">曲率、Frenet 标架</h3><dl><dt>Theo</dt><dd></dd></dl></div><div class="story post-story"><h2 id="测地曲率和测地线">测地曲率和测地线</h2><p>根据 Gauss 绝妙定理，<span class="math inline">\(K\)</span>只决定于曲面的第一基本形式，在保长对应下不变，是曲面的内蕴性质。在这里继续研究曲面内蕴几何的主要研究对象。</p><h3 id="测地曲率和测地线-1">测地曲率和测地线</h3><p>我们考虑正则曲面<span class="math inline">\(S:\mathbf r = \mathbfr(u^1, u^2)\)</span>，设有曲线<span class="math inline">\(u^\alpha =u^\alpha (s)\)</span> 是一条弧长参数曲线。其作为空间中的曲线参数方程为：<span class="math display">\[\mathbf r = \mathbf r(s) = \mathbf r (u^1, u^2)\]</span> 建立新的正交标架： <span class="math display">\[\begin{aligned}\mathbf e_1  &amp;= \frac {d\mathbf r(s)}{ds} = \alpha(s)\\\mathbf e_2 &amp;= \mathbf n(s)\times \alpha(s) \\\mathbf  e_3 &amp;= \mathbf n(s)\end{aligned}\]</span> 对于该曲线来考察原曲面的性质： <span class="math display">\[\begin{cases}\frac{d\mathbf r}{ds} &amp;= \mathbf e_1&amp;\\\frac{d\mathbf e_1}{ds} &amp;= &amp; +\kappa _g\mathbf e_2 &amp; +\kappa_n\mathbf e_3\\\frac{d\mathbf e_2}{ds} &amp;= -\kappa_g\mathbf e_1 &amp;&amp;+\tau_g\mathbf e_3 \\\frac{d\mathbf e_3}{ds} &amp;= -\kappa_n \mathbf e_1 &amp; +\tau_g\mathbf e_2\\\end{cases}\]</span> 显然，式中的：</p><ul><li><span class="math inline">\(\kappa_n\)</span> 就是曲面<spanclass="math inline">\(S\)</span>沿着曲线<spanclass="math inline">\(C\)</span>的切方向的法曲率；</li></ul><p>而也可以求解出其他的参数： <span class="math display">\[\kappa_g = \left( \mathbf n, \mathbf r&#39;, \mathbf r&#39;&#39; \right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地曲率</strong>； <span class="math display">\[\tau_g = \left( \mathbf n, \mathbf n&#39;,\mathbf r&#39;\right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地挠率</strong>。</p><p>下面的定理描述了测地曲率和测地挠率的几何意义：</p><dl><dt><strong>Theo</strong></dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条正则曲线，其在 <spanclass="math inline">\(p\)</span>处的测地曲率等于将其投影到切平面上的曲线的相对曲率，其平面的正向由曲面<span class="math inline">\(S\)</span> 在点 <spanclass="math inline">\(p\)</span> 的法向量给出。</dd><dt><strong>Theo</strong></dt><dd>曲面<span class="math inline">\(S\)</span>上任一条曲线<spanclass="math inline">\(C\)</span>的测地曲率是保长对应的不变量，即：<strong>测地曲率是内蕴量</strong>。</dd></dl><p>在取正交参数系的情况下，计算测地曲率有如下的<strong>Liouville公式</strong>：</p><dl><dt><strong>Theo</strong></dt><dd>设<span class="math inline">\((u,v)\)</span>是<spanclass="math inline">\(S\)</span>上的正交参数系，从而<spanclass="math inline">\(S\)</span>的第一基本形式为 <spanclass="math display">\[I = E(du)^2 + G(dv)^2\]</span> 假设<span class="math inline">\(C\)</span>与<spanclass="math inline">\(u\)</span>曲线的夹角为<spanclass="math inline">\(\theta\)</span>，那么其测地曲率是 <spanclass="math display">\[\kappa_g = \frac{d\theta}{ds} - \frac{1}{2\sqrt G} \frac{\partial \logE}{\partial v} \cos \theta + \frac{1}{2\sqrt E} \frac{\partial \logG}{\partial u}\sin \theta\]</span></dd></dl><p>最后我们讨论测地挠率，从自然标架的运动公式可以得出： <spanclass="math display">\[\tau _ g = \frac{1} {\sqrt g}\begin{vmatrix}&amp;\left(\frac{du^2}{ds} \right)^2 &amp; - \frac{du^1du^2}{dsds} &amp;\left(\frac{du^1}{ds} \right)^2 \\&amp;g_{11} &amp;g_{12} &amp; g_{22}\\&amp;b_{11} &amp;b_{22} &amp; b_{22}\end{vmatrix}\]</span> 故测地挠率和测地曲率一样，是<spanclass="math inline">\(S\)</span>上切方向的函数，反映的是曲面<spanclass="math inline">\(S\)</span>本身的性质，但其不是内蕴量。</p><p>对比主方向的方程，主方向恰好是测地挠率为 0的切方向。同时也有如下定理成立：</p><dl><dt>Theo</dt><dd>在曲面上非直线的渐进曲线<span class="math inline">\(C\)</span>的挠率是<span class="math inline">\(S\)</span>沿着曲面<spanclass="math inline">\(C\)</span>的切方向的测地挠率。</dd></dl><h3 id="测地线">测地线</h3><p>观察到测地曲率是内蕴量，从而要观察曲面上测地曲率为 0的曲线（测地线）</p><dl><dt>Theo</dt><dd>曲面上曲线<spanclass="math inline">\(C\)</span>是测地线，当且仅当，它或是一条直线，或者其主法向量处处是曲面的法向量</dd></dl><blockquote><p>例如：</p><ol type="1"><li>旋转面上的经线是测地线</li><li>若曲面上运动的质点 <span class="math inline">\(p\)</span>只受到将它约束在曲面上的力的作用，而不受到任何其他外力作用，则<spanclass="math inline">\(p\)</span>的轨迹是测地线</li></ol></blockquote><dl><dt>Theo</dt><dd>对于曲面上任意一点<span class="math inline">\(p\)</span>和曲面在<spanclass="math inline">\(p\)</span>的任意单位切向量<spanclass="math inline">\(v\)</span>，在曲面上存在唯一的一条弧长参数测地线通过<spanclass="math inline">\(p\)</span>且以<spanclass="math inline">\(v\)</span>为切向量</dd></dl><blockquote><p>平面 – 直线</p><p>曲面 – 测地线</p></blockquote><dl><dt>Theo</dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条曲线，则<spanclass="math inline">\(C\)</span>的弧长在任意一个有固定端点的变分<spanclass="math inline">\(C_t\)</span>中达到临界值的充分必要条件是<spanclass="math inline">\(C\)</span>是<spanclass="math inline">\(S\)</span>的测地线。</dd></dl><p>从而我们有：若曲线<span class="math inline">\(C\)</span>是连接<spanclass="math inline">\(p,q\)</span>的最短线，则<spanclass="math inline">\(C\)</span>是测地线。</p><h3 id="测地坐标系和法坐标系">测地坐标系和法坐标系</h3><h4 id="测地线族">测地线族</h4><p>在研究了测地线的性质后，我们研究测地线族的性质。</p><dl><dt>Theo</dt><dd>设<span class="math inline">\(\Sigma\)</span>是曲面<spanclass="math inline">\(S\)</span>上覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族，<spanclass="math inline">\(\Sigma_1\)</span>是由在区域<spanclass="math inline">\(D\)</span>内与<spanclass="math inline">\(\Sigma\)</span>中的曲线正交的轨线构成的曲线组，则其中任意两条曲线在<spanclass="math inline">\(\Sigma\)</span>中各条测地线上截出的曲线段长度相等。</dd></dl><blockquote><p>也就是说，测地线族的任意两条正交轨线之间的距离是处处相等的。</p><p>即：测地线族的任意两条正交轨线是<strong>测地平行</strong>的</p></blockquote><dl><dt>Theo</dt><dd>设<span class="math inline">\(C\)</span>是曲面<spanclass="math inline">\(S\)</span>上连接了<spanclass="math inline">\(p,q\)</span>两点的一条测地线，若曲线<spanclass="math inline">\(C\)</span>能够潜入到覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族<spanclass="math inline">\(\Sigma\)</span>中，且<spanclass="math inline">\(p,q\in D\)</span>，则其是区域内连接两点的最短线</dd></dl><h4 id="测地平行坐标系">测地平行坐标系</h4><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点<spanclass="math inline">\(p\)</span>的一个充分小的邻域内必定存在参数系<spanclass="math inline">\((u,v)\)</span>使得<spanclass="math inline">\(p\rightarrow (0,0)\)</span>，而第一基本形式可以写作 <span class="math display">\[I = (du)^2 + G(u,v) (dv)^2\]</span> 函数 <span class="math inline">\(G\)</span> 满足：$G(0, v)=1<span class="math inline">\(，\)</span>(0, v) =0<spanclass="math inline">\(，参数系\)</span>(u,v)$是<strong>测地平行坐标系</strong></dd></dl><h4 id="测地极坐标系">测地极坐标系</h4><p>定义指数映射： <span class="math display">\[\exp_p : T_pS \rightarrow S\quad \mathbf v\rightarrowtail\gamma(|\mathbf v|, \mathbf v_0)\]</span> <span class="math inline">\(\gamma\)</span>对于点<spanclass="math inline">\(p\)</span>处的单位切向量<spanclass="math inline">\(\mathbfv_0\)</span>，映射为弧长参数测地线上的参数为<spanclass="math inline">\(s\)</span>的位置。</p><p>显然指数映射 <span class="math inline">\(\exp_p\)</span>是连续可微的。于是有 <strong>法坐标系</strong>： <spanclass="math display">\[u^\alpha = u ^ \alpha(\exp_p(\mathbf v)) = u ^ \alpha(v^1, v^2)\]</span> 从而有<strong>测地圆</strong>（以<spanclass="math inline">\(p\)</span>为中心，<spanclass="math inline">\(s_0\)</span>为半径）</p><dl><dt>Theo 高斯引理</dt><dd>从<span class="math inline">\(p\)</span>出发的测地线与以点<spanclass="math inline">\(p\)</span>为中心的测地圆是彼此正交的。（即曲线族<spanclass="math inline">\(\Sigma_1\)</span>中的每一条曲线都是测地线族<spanclass="math inline">\(\Sigma\)</span>的正交轨线。</dd></dl><p>由此可以推导出测地极坐标系 <spanclass="math inline">\(（s,\theta)\)</span></p><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点的<spanclass="math inline">\(p\)</span>邻域内，出去从点<spanclass="math inline">\(p\)</span>出发的一条测地线外，也存在测地极坐标系，使得曲面第一形式为<span class="math display">\[I = (ds)^2 + G(d\theta)^2\quad \begin{cases}\lim _{s\rightarrow 0} \sqrt G = 0\\\lim_{s\rightarrow 0} \frac{\partial }{\partial S} \sqrt{G(s,\theta)} =1\end{cases}\]</span> 对应了平面上的极坐标系</dd></dl><h3 id="常曲率曲面">常曲率曲面</h3><p>高斯曲率为常数的曲面为<strong>常曲率曲面</strong>。</p><p>由于高斯曲率为内蕴量，我们不难考虑如下的定理：</p><dl><dt>Theo</dt><dd>有相同高斯曲率的任意两块常曲率曲面在局部上有保长对应。</dd></dl><blockquote><p>从现在的观点来看：</p><ol type="1"><li>常曲率曲面的第一基本形式是由其高斯曲率完全决定的</li><li>非欧几何学：将平面几何学推广到常曲率曲面</li></ol></blockquote><h3 id="平行移动">平行移动</h3><blockquote><p>考虑切向量场的协变微分和平行移动</p></blockquote><h3 id="gauss-bonnet公式">Gauss-Bonnet公式</h3><p>假定曲线是邮箱曲面上的一条分段光滑简单闭曲线，其包围的区域是曲面<span class="math inline">\(S\)</span> 的一个单连通区域，则 <spanclass="math display">\[\oint _C. \kappa _ g \mathrm d s + \iint _D K \mathrm d \sigma = 2 \pi -\sum _ {i = 1} ^ n \alpha _ i\]</span></p><ul><li><span class="math inline">\(\kappa_g\)</span>是曲线的测地曲率，</li><li><span class="math inline">\(K\)</span> 是曲面的高斯曲率</li><li>$_ i $ 表示曲线在角点<spanclass="math inline">\(i\)</span>的外角</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="微分几何" scheme="http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 2 - Broad Phase 阶段</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T16:05:28.166Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几种在各类代码库中应用的 Broad Phase 算法</p><span id="more"></span><blockquote><p>来源包括但不限于：</p><ol type="1"><li>Unity</li><li>UE</li><li>Nvidia</li><li>PhyX</li><li>各大博客</li><li>论文</li></ol></blockquote><div class="story post-story"><h2 id="broad-phase-algorithms">Broad Phase Algorithms</h2><p>根据 Nvidia-GPU Gems 3<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>的描述，BroadPhase最主要的还是依靠一些最基础的<code>观察</code>来降低时间复杂度。主要的算法有：</p><ol type="1"><li><code>Sort and Sweep</code>：按Axis排序，然后扫描分段，认为每一个在Axis上相邻的即可能会相交。</li><li><code>Spatial Subdivision</code>：空间细分算法。可以有两种主要的形式，包括固定空间划分（每个格子尺寸一致）</li><li><code>BVH</code>（层次包围盒 –AABB/k-DOP/OBB，更基础的还有oct-tree这些数据结构）算法。实际上固定的空间划分算法和SortAnd Sweep可以互相转化。</li></ol><blockquote><p>不考虑并行的情况下，固定的空间划分算法是明显慢的。但考虑到SpatialSubdivision可以在GPU上运行，实际上这类算法也很常用。</p></blockquote><p>在实际的游戏引擎中，为了达到实时的要求，使用的算法也相对简单：</p><ol type="1"><li><code>Sweep-based</code>：考察物体运动所划过的面积，是否相互接触。计算TOI（impact产生时刻），然后重新计算。 — 会增加 CPU的负载、角速度大时会产生误差。</li><li><code>Speculative CCD</code>：计算运动过程中的AABB，然后对于覆盖到的物体进行针对性检查。– maybe cheaper，但是会出现误检为collision 的问题。</li></ol><p>其次，对于每一个物体，其也可能有针对性的优化措施，例如在UnrealEngine中，每一个物体的碰撞处理可以设置为不同的细度，从而获取不同的效果。同时其也对于输入的物体Mesh/Obj进行</p><ol type="1"><li>凸包变换（V-HACD<a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>），并使用适用于凸包的 CollisionDetect 来进行碰撞的判断</li><li>设置 k-DOP</li></ol><p>无一例外，这些算法都是BVH的变体。</p><p>其他的，例如 PhysX中，碰撞检测还可以通过光线投射（<code>Raycast</code>）算法计算得出。</p><ul><li>对于高速物体–低速物体的情形，可以考虑在每一次计算得到无碰撞位移后，通过Raycast算法得出运动路径上是否与其余物体有碰撞产生。</li></ul><blockquote><p><strong>Overview of Collision in PhysX</strong></p><ul><li>Broadphase<ul><li>AABB vs AABB, 3 axis sweep and prune</li></ul></li><li>Midphase<ul><li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABBtree</li></ul></li></ul><p>对于 Narrow Phase：</p><ul><li><p>流体-SPH Fluids (CCD)</p><ul><li>Particles vs static triangle mesh • Particles vs dynamicprimitives</li></ul></li><li><p>布料-Cloth (CCD)</p><ul><li>Vertices vs static triangle mesh • Vertices vs dynamicprimitives</li></ul></li><li><p>刚体-Rigid body (Discrete) – GJK or SAT</p><ul><li><p>Convex mesh and primitives vs static triangle mesh</p></li><li><p>Convex, primitives vs Convex, primitives</p></li></ul></li></ul></blockquote><figure><imgsrc="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/32fig01.jpg"alt="Nvidia- Sort and sweep" /><figcaption aria-hidden="true">Nvidia- Sort and sweep</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD1.gif"alt="Sweep Method 的角速度过大，导致CCD失败" /><figcaption aria-hidden="true">Sweep Method的角速度过大，导致CCD失败</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD2.png"alt="speculative ccd" /><figcaption aria-hidden="true">speculative ccd</figcaption></figure><p>考虑两种情形：</p><ol type="1"><li>只有 Rigid Body：不可能产生自交问题，这样子的话</li><li>Rigid +Deformed：Rigid肯定不会自交，但是Deformed物体可能存在自交问题、Rigid-Deformed之间可能产生相交</li></ol><p>BVH 和 Spatial Hashing 来实现</p><hr /><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"role="doc-endnote"><p>https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>https://github.com/kmammou/v-hacd<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍几种在各类代码库中应用的 Broad Phase 算法&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
</feed>
