<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逆版本战士の部落格</title>
  
  
  <link href="http://adversarr.github.io/atom.xml" rel="self"/>
  
  <link href="http://adversarr.github.io/"/>
  <updated>2022-04-12T16:04:59.529Z</updated>
  <id>http://adversarr.github.io/</id>
  
  <author>
    <name>Adversarr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Collision Detection 整理 6 - 综述</title>
    <link href="http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/"/>
    <id>http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T16:04:59.529Z</updated>
    
    <content type="html"><![CDATA[<p>终于到了综述了。</p><span id="more"></span><p>这一篇的思路很清楚，从最核心的CCD开始说起，一步步解决碰撞检测的问题。</p><h2 id="narrow-phase">Narrow-phase</h2><div class="story post-story"><h3 id="preliminaries">Preliminaries</h3><p>沿用IPC中的记号。对于碰撞检测而言，最基本的模型是假设其在两个迭代步骤之间是线性的，即</p><p><span class="math display">\[\mathbf x(t) = t \cdot \mathbf x ^{i + 1}  + (1 - t) \cdot \mathbf x^{i}\]</span></p><p>其中：</p><ul><li><span class="math inline">\(t\)</span> 为归一化后的时间，即 <spanclass="math inline">\(t = (t - t_{i}) / (t_{i + 1} - t _i )\)</span>其中右侧的 <span class="math inline">\(t\)</span> 是模拟运行时间</li><li><span class="math inline">\(\mathbf x\)</span>是坐标，是关于时间的函数。上标表示迭代代数</li></ul><p>为了简单期间，用 <span class="math inline">\(\mathcal A = \mathbfx_1\cdots \mathbf x_i\)</span> 来表示一个 <spanclass="math inline">\(n\)</span> 维单纯形，用 <spanclass="math inline">\(\mathbf x_{ij}\)</span> 来表示 <spanclass="math inline">\(\mathbf x_{i} - \mathbf x_{j}\)</span>。</p><p>在这样的记号下，碰撞可以用 <span class="math inline">\(t\)</span>来描述，即：</p><p>单纯形 <span class="math inline">\(\mathcal A = \{\mathbf x_1\cdots\mathbf x_n\}\)</span> 和 <span class="math inline">\(\mathcal B =\{\mathbf x_1 \cdots \mathbf x_m\}\)</span> 碰撞，当且仅当：</p><p><span class="math display">\[\exists t\in[0, 1]\quad s.t. \  \mathcal A(t) \cap \mathcal B(t) \ne\emptyset\]</span></p><p>这个公式仅仅是一个定义，并没有很大的计算价值，因此我们需要对于这样的问题进行适当的简化。主要有几种思路：</p><ol type="1"><li>和求出凸包交点的思路一致，进行 Minkowski差操作，然后二分查找一下根的情况。</li><li>二分搜索，找可能的碰撞时间 <spanclass="math inline">\(t\)</span></li><li>约束为三角网格再：<ol type="1"><li>求解重心坐标<span class="math inline">\((u,v)\)</span> 和 <spanclass="math inline">\(t\)</span></li><li>简化为三次方程求根</li></ol></li><li>光线投射方法</li><li>基于法向量简化</li></ol><h3 id="ccd">CCD</h3></div><h2 id="broad-phase">Broad-Phase</h2><div class="story post-story"><p>实际上这个没啥好讲的，主要思路就是建立空间数据结构，然后加速计算。</p><ol type="1"><li>BVHs</li><li>Spatial Hashing</li></ol><p>好吧实际上还有一些，在这个的基础上还有一些 local的加速方法，但这也不能算是 Broad-Phase 的方法，因为这个方法针对于<em>Deformed</em>的物体进行计算的效率较高。这些方法在曲面上进行划分，相当于在曲面上定义了一个空间划分。比如通过形变能量来指导在其上的空间划分，最后精细化求解使用三次方程法求解。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于到了综述了。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 5 - 2021 A large scale benchmark and an Inclusion-based Algorithm</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:32.603Z</updated>
    
    <content type="html"><![CDATA[<p>Collision Detection 整理5 – CCD 算法对比</p><span id="more"></span><p>准确说，这篇blog是一篇论文的整理emmm，但由于老板的任务就是做 collsion的汇总，这篇论文的涉及面也算是相对 Broad 的了。</p><p>论文主要用了：</p><ol type="1"><li>IRF：interval-root-finder</li><li>UIRF：Unifromed-Interval-Root-Finder</li><li>FPRF：floating-point time-of-impact root finder</li><li>TightCCD(TCCD)</li><li>Root Parity(RP)</li><li>Rational implementation of RP</li><li>MSRF：minimum seperation floating-point time-of-impact rootfinder</li></ol><h2 id="预备知识">预备知识</h2><div class="story post-story"><p>首先论文对于 CCD的数学背景进行了简要的介绍：考虑三角网格，每一个时间步长内都以线性轨迹运动。那么CCD可以简化为VT和EE检查。</p><h3 id="multivariate-ccd-formulation">Multivariate CCD Formulation</h3><p>最简单的方法是直接对于CCD条件参数化，转化为关于 <spanclass="math inline">\(u,v,t\)</span> 的方程求解即可。</p><h3 id="univariate-ccd-单变量ccd">Univariate CCD 单变量CCD</h3><p>实际上上面一种求解方法一步到位解出了 <spanclass="math inline">\(u,v,t\)</span>但没有注意到在接触时，四点共面的事实，所以，在[Provot 97]中，改为先求解三次方程，然后检查是否满足条件的问题</p></div><h2 id="方法介绍">方法介绍</h2><div class="story post-story"><h3 id="irf">IRF</h3><p>类似于计算 Minkowski差，逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p><p>优点：</p><ol type="1"><li>保守估计，每一步都保证包含 <spanclass="math inline">\(0\)</span>，所以能够确保检查到碰撞</li><li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li></ol><p>缺点：</p><ol type="1"><li>基于二分查找 — 慢</li><li>难以实施编译优化</li></ol><h3 id="uirf">UIRF</h3><p>差不多的思路，但是是用二分法求的是单变量的方程根。</p><blockquote><p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p><p>与此同时，它不能满足控制求解器的运行精度</p></blockquote><h3 id="fprf">FPRF</h3><blockquote><p>Robust treatment of simultaneous collisions.</p></blockquote><p>主要问题：</p><ol type="1"><li>FN太多，即有很多碰撞点不被检测到。</li><li>当平行时无法处理 EE 的情况。</li></ol><p>优点：</p><ol type="1"><li>速度</li></ol><h3 id="tightccd">TightCCD</h3><p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算。</p><p>优点：</p><ol type="1"><li>速度快</li><li>完全没有检测不出的点</li></ol><p>问题：</p><ol type="1"><li>为了 FN == 0，牺牲了 FP</li><li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li></ol><h3 id="rp-rrp">RP / RRP</h3><p>转化为光线投射问题：设 <span class="math inline">\(\partial\Omega\)</span>是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p><p>问题：</p><ol type="1"><li>实际上只能做DCD – 小TS</li><li>容易出现漏报的问题：在 <span class="math inline">\([t,t+\Deltat]\)</span> 内有 2 解</li></ol><p>原理：</p><blockquote><p>根据 Brouwer topological degree theory：</p><p>假设 <span class="math inline">\(\Omega\)</span> 是一个 <spanclass="math inline">\(n\)</span> 多面体，设 <spanclass="math inline">\(F:\Omega \rarr \mathbb R^{n}\)</span>满足 <spanclass="math inline">\(C^2\)</span>，且有有限多个根，且没有在边界<spanclass="math inline">\(\Gamma=\partial \Omega\)</span>上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <spanclass="math inline">\(0\)</span> 出发，记交点数为 <spanclass="math inline">\(q\)</span> ，<spanclass="math inline">\(F\)</span> 在交点处光滑且不相切于光线，那么 <spanclass="math inline">\(p,q\)</span> 有相同的奇偶性。</p></blockquote><p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p><h3 id="bsc">BSC</h3><blockquote><p>Fast and exact continuous collision detection with bernstein signclassification</p></blockquote><p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p><p>缺点：</p><ol type="1"><li>False Positive + False Negative</li></ol><blockquote><p>实际上这个思路和我一开始想的是几乎一致的：</p><p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p><p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p></blockquote><p>原理上：给定一个三次函数 <span class="math inline">\(Y(t)\)</span>用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p><p><img src="image-20220412105920274.png" class="lazyload" data-srcset="image-20220412105920274.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div><h2 id="其他思路">其他思路</h2><div class="story post-story"><h3 id="bridson-2009">Bridson 2009</h3><p>添加一个时间维度，通过在四维空间中的相交检测来实现碰撞检测。</p><p>问题：</p><ol type="1"><li>不直观、不常用</li><li>导致了 FP 的出现 — 平行的两个三角形认定为碰撞。</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Collision Detection 整理5 – CCD 算法对比&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>games201-02-拉格朗日视角 1</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/GAMES/g201-2/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/GAMES/g201-2/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-11T03:44:44.286Z</updated>
    
    <content type="html"><![CDATA[<p>games201 拉格朗日视角</p><span id="more"></span><h2 id="拉格朗日视角简介">拉格朗日视角简介</h2><div class="story post-story"><p>两种视角：</p><ol type="1"><li>拉格朗日视角 – 粒子，携带位置、速度等<ol type="1"><li>MPM、弹簧质点模型……</li></ol></li><li>欧拉视角 – 通过固定的“传感器”来表示<ol type="1"><li>烟雾模拟</li></ol></li></ol><h2 id="弹簧质点模型-mass-spring-system">弹簧质点模型 Mass-SpringSystem</h2><ul><li>Extremely example</li><li>But very useful. – cloth/hair</li></ul><h3 id="基本原理">基本原理</h3><p>利用 <strong>胡克定律</strong> 和 <strong>牛顿第二定律</strong>来计算 加速度-速度-位置</p><ul><li><span class="math inline">\(k\)</span> — stiffness — 刚度</li></ul><h3 id="时间积分">时间积分</h3><h4 id="forward-euler-前向欧啦">Forward Euler 前向欧啦</h4><p><span class="math display">\[v_{t+1} = v_t + \frac{f_t}{m}\Delta t\]</span></p><h4 id="半隐式欧拉法">半隐式欧拉法</h4><p>用 <span class="math inline">\(t+1\)</span> 时刻的 <spanclass="math inline">\(v\)</span> 计算 <spanclass="math inline">\(x\)</span> 的更新。</p><h4 id="implementation">Implementation</h4><ul><li>使用 substep — 保证小步长</li></ul><h3 id="积分器对比">积分器对比</h3><blockquote><p><strong>数值分析</strong></p></blockquote><h4 id="显式积分器">显式积分器</h4><ol type="1"><li>未来仅仅基于过去</li><li>简单</li><li>容易出现数值爆炸问题 — 前向欧拉</li><li>对于 <span class="math inline">\(stiff \gg 1\)</span>效果很差。</li></ol><h4 id="隐式积分器">隐式积分器</h4><ol type="1"><li>未来需要基于自己和过去</li><li>复杂！难以实现、难以优化、GPU……</li><li>Timestep 更大，但是计算更加昂贵</li><li>Numerical damping</li></ol><h3 id="弹簧质点的隐式积分器">弹簧质点的隐式积分器</h3><p>假设： <span class="math display">\[\begin{cases}\mathbf x_{t+1} = \mathbf x_t + \Delta t \mathbf v_{t+1}\\\mathbf v_{t+1} = \mathbf v_t + \Delta t \mathbf M ^{-1}\mathbf f_{t+1}\end{cases}\]</span> 在上式中消除 <span class="math inline">\(\mathbfx_{t+1}\)</span>，使用泰勒公式： <span class="math display">\[\left[I - \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbf f}{\partial\mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbf v_t + \Delta t\mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span> 在这一节课中，仅仅使用 Jacobbi 迭代解上述方程。</p><h3 id="在显式和隐式之间转换">在显式和隐式之间转换</h3><p><span class="math display">\[\left[I - \beta \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbff}{\partial \mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbfv_t + \Delta t \mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span></p><p>其中 <span class="math inline">\(\beta\)</span>控制了在显式、隐式之间的“比例”</p><ul><li><span class="math inline">\(\beta = 1\)</span> — Explicit</li><li><span class="math inline">\(\beta = .5\)</span> — Semi-Implicit</li><li><span class="math inline">\(\beta = 0\)</span> — Implicit</li></ul><h3 id="大规模情况">大规模情况</h3><ol type="1"><li>稀疏矩阵</li><li>共轭梯度法</li><li>Preconditioning</li><li>PBD</li></ol></div><h2 id="拉格朗日法流体模拟-sph">拉格朗日法流体模拟 — SPH</h2><div class="story post-story"><p>用一些粒子（并附带物理量）以及一个核函数去模拟一个物理场。</p><p>优点：</p><ol type="1"><li>不需要 Mesh、适合自由表面物体</li><li>容易理解</li></ol><h3 id="wcsph">WCSPH</h3><blockquote><p>可压缩物体模拟</p></blockquote><p>Momentum Equation: <span class="math display">\[\frac{D\mathbf v}{D t} = - 1/\rho \nabla p + \mathbf g,\quad p =B\left(\left( \frac{\rho}{\rho_0}\right)^\gamma - 1\right)\]</span></p><ol type="1"><li>表面张力、粘滞力</li></ol><h3 id="sph-simulation-cycle">SPH simulation Cycle</h3><p>通过半隐式欧拉法计算</p><h3 id="sph-变种">SPH 变种</h3><h3 id="cfl条件">CFL条件</h3><p>对于显式积分，<span class="math inline">\(dt\)</span> 具有上界：<span class="math display">\[C = \frac{u\Delta t}{\Delta x} \le C_\max \sim ~\]</span></p><ol type="1"><li><span class="math inline">\(C\)</span>: CFL number</li></ol><p>Application</p><ol type="1"><li>SPH: <span class="math inline">\(C_\max\sim 0.4\)</span></li><li>MPM:<span class="math inline">\(C_\max -0.3\sim1\)</span></li></ol><h3 id="加速-sph">加速 SPH</h3><p>通过 Neighbour search with hashing（空间数据结构）</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;games201 拉格朗日视角&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>libigl 简述</title>
    <link href="http://adversarr.github.io/2022/04/10/CG/Libigl/"/>
    <id>http://adversarr.github.io/2022/04/10/CG/Libigl/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:19.081Z</updated>
    
    <content type="html"><![CDATA[<p>TODO: Libigl 教程（翻译和解释）</p><p>现挖个坑，后面补上。 <span id="more"></span></p><h1 id="libigl-tutorial">libigl Tutorial</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;TODO: Libigl 教程（翻译和解释）&lt;/p&gt;
&lt;p&gt;现挖个坑，后面补上。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Games 102 - 08 - 离散微分几何</title>
    <link href="http://adversarr.github.io/2022/04/09/CG/Talk/"/>
    <id>http://adversarr.github.io/2022/04/09/CG/Talk/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-04-09T15:29:00.287Z</updated>
    
    <content type="html"><![CDATA[<p>Games 102 - 离散微分几何</p><span id="more"></span><h2 id="三角网格存储">三角网格存储</h2><div class="story post-story"><p>常用的是<strong>半边数据结构</strong>（Half-Edge）数据结构</p><ul><li>将网络连接关系存储在边上，表达为两条半边</li><li>目的：提高点线面和查找效率</li></ul></div><h2 id="曲线曲面微分几何">曲线、曲面微分几何</h2><div class="story post-story"><h3 id="曲线的微分几何学">曲线的微分几何学</h3><ul><li><p>Frenet标架</p></li><li><p>Curvature <span class="math inline">\(\kappa\)</span> 和密切圆</p></li><li><p>与参数选择无关 — 本征量</p></li></ul><h3 id="曲面的微分几何学">曲面的微分几何学</h3><ul><li>关于 <span class="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 的偏导 — 切平面</li><li>切平面的法向 — <span class="math inline">\(r_u\timesr_v\)</span></li><li>法平面和曲面求交线，可以定义出一个空间曲线，可以定义其曲率 –方向曲率（法曲率）— 描述曲面沿着方向的弯曲程度</li></ul><h3 id="曲面的曲率">曲面的曲率</h3><p>观察法曲率：</p><ol type="1"><li>有两个正交的方向，使得其能够取最大 <spanclass="math inline">\(\kappa_1\)</span> 和最小<spanclass="math inline">\(\kappa_2\)</span></li></ol><p>有 Euler's Equation 成立： <span class="math display">\[\kappa = \kappa_1 \cos^2\theta +  \kappa_2 \sin^2\theta\]</span> 高斯曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \kappa_1\kappa_2\)</span></li><li><strong>等距变换的不变量</strong></li><li>处处为 0 的曲面 — 可展曲面</li><li><strong>可展曲面</strong>可以分类为：<ul><li>柱面</li><li>锥面</li><li>切线面</li></ul></li></ol><p>平均曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \frac {\kappa_1 +\kappa_2}{2}\)</span></li><li>处处平均曲率为 0 的曲面 — 极小曲面 — 所有点都是鞍点</li></ol></div><h2 id="离散微分几何">离散微分几何</h2><div class="story post-story"><p>考虑到三角网格只有 <span class="math inline">\(C^0\)</span>，使用采样的点来估计原有曲面属性。</p><h3 id="方法">方法</h3><h4 id="连续逼近">连续逼近</h4><p>考虑使用一个简单的曲面来拟合曲面的局部。从而就能计算出</p><h4 id="离散估计">离散估计</h4><p>用面积/角度等特征来进行计算</p><h3 id="例子">例子</h3><h4 id="平均曲率计算">平均曲率计算</h4><p>由 Laplace-Beltrami 定理： <span class="math display">\[\mathbf K (\mathbf x_i) = \frac{1}{2\mathcal A_M} \sum_{j\in N_1(i)}(\cot \alpha_{ij}+ \cot \beta_{ij})(\mathbf x_i - \mathbf x_j)\]</span></p><h4 id="高斯曲率计算">高斯曲率计算</h4><p>由 Gauss-Bonnet 定理： <span class="math display">\[\kappa(\mathbf x_i) = (2\pi - \sum_{j = 1}^{\#f} \theta_j) / \mathcalA_M\]</span></p><blockquote><p>Discrete differential-geometry operators for trangulated 2-manifolds.– 2003</p></blockquote><h3 id="极小曲面">极小曲面</h3></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Games 102 - 离散微分几何&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 2 - Broad Phase 阶段</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T16:05:28.166Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几种在各类代码库中应用的 Broad Phase 算法</p><span id="more"></span><blockquote><p>来源包括但不限于：</p><ol type="1"><li>Unity</li><li>UE</li><li>Nvidia</li><li>PhyX</li><li>各大博客</li><li>论文</li></ol></blockquote><h2 id="broad-phase-algorithms">Broad Phase Algorithms</h2><div class="story post-story"><p>根据 Nvidia-GPU Gems 3<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>的描述，BroadPhase最主要的还是依靠一些最基础的<code>观察</code>来降低时间复杂度。主要的算法有：</p><ol type="1"><li><code>Sort and Sweep</code>：按Axis排序，然后扫描分段，认为每一个在Axis上相邻的即可能会相交。</li><li><code>Spatial Subdivision</code>：空间细分算法。可以有两种主要的形式，包括固定空间划分（每个格子尺寸一致）</li><li><code>BVH</code>（层次包围盒 –AABB/k-DOP/OBB，更基础的还有oct-tree这些数据结构）算法。实际上固定的空间划分算法和SortAnd Sweep可以互相转化。</li></ol><blockquote><p>不考虑并行的情况下，固定的空间划分算法是明显慢的。但考虑到SpatialSubdivision可以在GPU上运行，实际上这类算法也很常用。</p></blockquote><p>在实际的游戏引擎中，为了达到实时的要求，使用的算法也相对简单：</p><ol type="1"><li><code>Sweep-based</code>：考察物体运动所划过的面积，是否相互接触。计算TOI（impact产生时刻），然后重新计算。 — 会增加 CPU的负载、角速度大时会产生误差。</li><li><code>Speculative CCD</code>：计算运动过程中的AABB，然后对于覆盖到的物体进行针对性检查。– maybe cheaper，但是会出现误检为collision 的问题。</li></ol><p>其次，对于每一个物体，其也可能有针对性的优化措施，例如在UnrealEngine中，每一个物体的碰撞处理可以设置为不同的细度，从而获取不同的效果。同时其也对于输入的物体Mesh/Obj进行</p><ol type="1"><li>凸包变换（V-HACD<a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>），并使用适用于凸包的 CollisionDetect 来进行碰撞的判断</li><li>设置 k-DOP</li></ol><p>无一例外，这些算法都是BVH的变体。</p><p>其他的，例如 PhysX中，碰撞检测还可以通过光线投射（<code>Raycast</code>）算法计算得出。</p><ul><li>对于高速物体–低速物体的情形，可以考虑在每一次计算得到无碰撞位移后，通过Raycast算法得出运动路径上是否与其余物体有碰撞产生。</li></ul><blockquote><p><strong>Overview of Collision in PhysX</strong></p><ul><li>Broadphase<ul><li>AABB vs AABB, 3 axis sweep and prune</li></ul></li><li>Midphase<ul><li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABBtree</li></ul></li></ul><p>对于 Narrow Phase：</p><ul><li><p>流体-SPH Fluids (CCD)</p><ul><li>Particles vs static triangle mesh • Particles vs dynamicprimitives</li></ul></li><li><p>布料-Cloth (CCD)</p><ul><li>Vertices vs static triangle mesh • Vertices vs dynamicprimitives</li></ul></li><li><p>刚体-Rigid body (Discrete) – GJK or SAT</p><ul><li><p>Convex mesh and primitives vs static triangle mesh</p></li><li><p>Convex, primitives vs Convex, primitives</p></li></ul></li></ul></blockquote><figure><imgsrc="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/32fig01.jpg"alt="Nvidia- Sort and sweep" /><figcaption aria-hidden="true">Nvidia- Sort and sweep</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD1.gif"alt="Sweep Method 的角速度过大，导致CCD失败" /><figcaption aria-hidden="true">Sweep Method的角速度过大，导致CCD失败</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD2.png"alt="speculative ccd" /><figcaption aria-hidden="true">speculative ccd</figcaption></figure><p>考虑两种情形：</p><ol type="1"><li>只有 Rigid Body：不可能产生自交问题，这样子的话</li><li>Rigid +Deformed：Rigid肯定不会自交，但是Deformed物体可能存在自交问题、Rigid-Deformed之间可能产生相交</li></ol><p>BVH 和 Spatial Hashing 来实现</p><hr /><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"role="doc-endnote"><p>https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>https://github.com/kmammou/v-hacd<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍几种在各类代码库中应用的 Broad Phase 算法&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 4 - Deformed Object</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/Deformed/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/Deformed/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-10T06:39:13.320Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测 4 - Deformed Object</p><span id="more"></span><h2 id="初">90-00初</h2><div class="story post-story"><p>变形体和三角网格的处理的经典论文是：</p><ol type="1"><li>[Bridson02] Robust Treatment of Collisions, Contact and Friction forCloth Animation</li><li>[Provet97] Collision and self-collision handling in cloth modeldedicated to design garments</li></ol><p>其中这两篇论文几乎可以说是篇篇论文都在引了。其主要的思想在于</p><h3 id="provet-97">Provet 97</h3><h4 id="简介">简介</h4><p>这篇论文之所以重要，是因为其提出了三角网格产生碰撞一个充分必要条件：对于三角网格而言，其产生碰撞，当且仅当，存在</p><ol type="1"><li>Vertical - Triangle （原文 Point Triangle collision）碰撞</li><li>Edge - Edge 碰撞</li></ol><p>之一（或兼有）</p><p>显然的是，两个碰撞都导致了<strong>四点共面</strong>的情况。根据空间几何的知识，<spanclass="math inline">\(\mathbf x_{1}\cdots\mathbf x_4\)</span>共面，当且仅当： <span class="math display">\[(\mathbf x_{12}\quad \mathbf x_{13} \quad \mathbf x_{14}) = 0\]</span> 其中 <span class="math inline">\((\quad)\)</span>记号为混合积。因此为检测碰撞，转化为求解一个关于 <spanclass="math inline">\(t\)</span> 的三次方程，即： <spanclass="math display">\[\exists t \in [0, 1]\quad (\mathbf x_{12}\quad \mathbf x_{13} \quad\mathbf x_{14}) = 0\]</span></p><blockquote><p>其中的三次方程采用牛顿法求解。</p></blockquote><p>求解出 <span class="math inline">\(t\)</span>是不够的，因为方程可能出现 V 不处于 T 内部，或 E 和 E不交的情况，但考虑到已经共面，下一步的判断是简单的，几乎不需要计算。因此该算法主要的计算量在于三次方程的求解上。</p><h4 id="broad-phase-剔除">Broad Phase 剔除</h4><ol type="1"><li>BVH</li><li>计算曲率：根据显然的事实 —给定一个曲面局部，如果它是凸的，且有充分低的曲率，则其不可能产生自相交。</li></ol><h4 id="impact-zone">Impact Zone</h4><p>为了消除一个碰撞，可能会引入其他的碰撞，这是因为在处理碰撞的时候，我们只针对当前选出来的碰撞对进行更新，在该更新过程中是不考虑其他点的情况的。</p><p>因此，若一个 Impact Zone在充分大的时候，考虑Frozen，并通过群速度、群角速度进行整体更新。</p><h4 id="相关内容">相关内容</h4><ol type="1"><li>Fast CCD</li><li>Safe CCD</li><li><strong>Tight CCD</strong></li></ol><h3 id="bridson-02">Bridson 02</h3><p>这篇嘛是一个完整的Workflow介绍了，从文章标题也能看出来主要是为了准确和高鲁棒性来实现的。主要还是处理了自碰撞的问题。</p><h4 id="碰撞检测">碰撞检测</h4><p>Broad-Phase：AABB，自下而上构造。</p><p>Narrow-Phase：还是基于上面的共面，但是判断是否在内部改进为解线性方程组（分解到现有基底上）</p><h4 id="处理">处理</h4><p>摩擦：库伦定律（摩擦角）用于静摩擦和动摩擦。</p><p>Rigid Impact Zone：用于失败的补偿机制</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测 4 - Deformed Object&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 1 - Introduction</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/Introduction/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/Introduction/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T16:07:38.217Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测相关介绍</p><span id="more"></span><h1 id="碰撞检测">碰撞检测</h1><p>众所又周知啊，碰撞检测是一个老大难的问题，在很多的仿真模拟、游戏引擎中间都会用哈</p><p>碰撞检测的主要流程是 <a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>：</p><figure><img src="2022-04-05-17-32-22.png"alt="GAMES 103- Collision Handling" /><figcaption aria-hidden="true">GAMES 103- CollisionHandling</figcaption></figure><p>其中：</p><ul><li><span class="math inline">\(\{\mathbf x, \mathbf x^{new}\}\)</span>分别是更新前后的顶点位置向量</li><li>Pair Condidates 是指可能发生碰撞的 primitive pairq</li><li>Colliding Pairs 是指真实发生碰撞的 primitive pair</li></ul><blockquote><p><strong>注意</strong>：</p><p>一般而言，所谓的 primitive 是指组成这个 body (不管是 deformable 还是rigid) 的单位元素，例如：</p><ol type="1"><li>三角网格 (mass-spring 模型）中的三角面片</li><li>多边形模型（例如 FEM ）中的面片</li><li>图的顶点、边</li></ol></blockquote><p>可以看出，总体上的碰撞检测分为两个阶段：第一阶段（Broad-Phase）去除不可能出现的pairs（当然肯定使用反向计算出可能产生collision 的 pair去做的。第二阶段（Narrow-Phase）去针对每一个pair计算。</p><h2 id="broad-phase">Broad-Phase</h2><div class="story post-story"><p>碰撞剔除两种常见的方法：</p><ol type="1"><li>Spatial Hashing：空间哈希</li><li>BVH：层次包围盒</li></ol><h3 id="空间划分">空间划分</h3><h4 id="基本思想">基本思想</h4><p>将整个空间划分为各自，然后将Primitive存在单元格内。（有相交就存储，可能出现在多个格子里面）</p><p>对于每一个格子里面的所有 Primitive-Pair 输出。</p><h4 id="动态过程">动态过程</h4><p>我们将 <span class="math inline">\(x^{new}\)</span> 和 <spanclass="math inline">\(x\)</span> 都认为是其位置，再进行划分。</p><h4 id="存在的问题">存在的问题</h4><p>三维空间的格子 – 100x100x100 – 计算量大</p><p>可能出现：分布不均匀</p><ol type="1"><li>浪费存储空间</li><li>大量的三角形聚集在几个格子里</li></ol><h4 id="改进方案">改进方案</h4><h5 id="排序">排序</h5><figure><img src="image-20220409103734403.png" class="lazyload" data-srcset="image-20220409103734403.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="排序" /><figcaption aria-hidden="true">排序</figcaption></figure><p><strong>目的</strong>：所有的Pair都按照格子的编号排列（类似于稀疏矩阵压缩），从而节约内存开销。</p><h5 id="为了达到连续内存访问">为了达到连续内存访问</h5><p>使用 <code>Morton Code</code> 编码，</p><h3 id="bvh-层次包围盒">BVH 层次包围盒</h3><p>递归的建立一棵树，例如：</p><figure><img src="image-20220409104753151.png" class="lazyload" data-srcset="image-20220409104753151.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BVH" /><figcaption aria-hidden="true">BVH</figcaption></figure><p>Idea：把包围盒组合成新的包围盒</p><p>如何检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ProcessNode(A) &#123;</span><br><span class="line">for_each(B: A.child)&#123;</span><br><span class="line">ProcessNode(B);</span><br><span class="line">&#125;</span><br><span class="line">for_each([B, C]: A.childrenPair) &#123;</span><br><span class="line"><span class="keyword">if</span> B-C intersect &#123;</span><br><span class="line">ProcessPair(B, C)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessPair(B, C) &#123;</span><br><span class="line">for_each(B<span class="number">&#x27;</span>: B.child) &#123;</span><br><span class="line">for_each(C<span class="number">&#x27;</span>: C.child) &#123;</span><br><span class="line"><span class="keyword">if</span> B<span class="number">&#x27;</span>-C<span class="number">&#x27;</span> intersect &#123;</span><br><span class="line">ProcessPair(B<span class="number">&#x27;</span>, C<span class="number">&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见的包围盒">常见的包围盒</h4><ol type="1"><li><strong>AABB</strong>：intersect 当且仅当在轴上有相交</li><li>球</li><li>OBB：任意方向的包围盒</li></ol><h4 id="问题">问题</h4><p>难以处理紧邻的情况。 – 只有便利到底层才能解决</p><blockquote><p>Energy-based Self-Collision Culling for Arbitary MeshDeformations</p><ol type="1"><li>形变越大，越容易相交</li></ol></blockquote><h3 id="对比">对比</h3><p>SH =&gt; Edge-Triangle</p><ol type="1"><li>Easy to implement</li><li>GPU-Friendly</li><li>Need to recompute after updating obj.</li></ol><p>BVH =&gt; VT &amp; EE</p><ol type="1"><li>More Involved</li><li>Not GPU Friendly</li><li>To update BVH, just update BV</li></ol></div><h2 id="narrow-phase">Narrow Phase</h2><div class="story post-story"><p>进一步看是否真的有碰撞，两种：DCD和CCD</p><h3 id="dcd-相交检测">DCD — 相交检测</h3><p>只考虑是否相交（而非碰撞）</p><p>对于Triangle Mesh，只考虑 Edge-Triangle. <spanclass="math display">\[\begin{cases}((1-t) x_a+tx_b -x_0)\cdot x_{10} \times x_{20} =0\\t = \frac{x_{0a}\cdot x_{10} \times x_{20}}{x_{ba}\cdot x_{10} \timesx_{20}}\end{cases}\]</span> 若解出来的 <span class="math inline">\(t\in [0, 1]\)</span>则能够判断出在 <span class="math inline">\(t\)</span> 处相交</p><figure><img src="image-20220409111138061.png" class="lazyload" data-srcset="image-20220409111138061.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DCD" /><figcaption aria-hidden="true">DCD</figcaption></figure><h4 id="问题-1">问题</h4><p>可能会产生穿透问题（运动很快的情况）。对于大体积问题的概率低，但是如果是cloth等薄物体，容易发生。</p><ol type="1"><li>减少dt</li></ol><h3 id="ccd">CCD</h3><p>测试两个状态（之间）有无碰撞产生。</p><p>一般是做 VT 和 EE 的检测：</p><figure><img src="image-20220409111542472.png" class="lazyload" data-srcset="image-20220409111542472.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="V-T测试" /><figcaption aria-hidden="true">V-T测试</figcaption></figure><figure><img src="image-20220409111601254.png" class="lazyload" data-srcset="image-20220409111601254.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="EE测试" /><figcaption aria-hidden="true">EE测试</figcaption></figure><p>共同点：</p><ol type="1"><li>解一元三次方程。观察解的情况</li></ol><h4 id="数值问题">数值问题</h4><ol type="1"><li>公式法：开三次方的数值误差大</li><li>牛顿法：速度</li><li>GPU — 单精度</li><li>Expensive — 可以考虑加强 Broad-Phase</li></ol><blockquote><p>Bridson2002-Robust … …</p></blockquote><h1 id="碰撞处理">碰撞处理</h1><figure><img src="image-20220409112929873.png" class="lazyload" data-srcset="image-20220409112929873.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IPM / IZO" /><figcaption aria-hidden="true">IPM / IZO</figcaption></figure><h3 id="内点法">内点法</h3><blockquote><p>截断 – IPC</p></blockquote><figure><img src="image-20220409112859592.png" class="lazyload" data-srcset="image-20220409112859592.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内点法" /><figcaption aria-hidden="true">内点法</figcaption></figure><p>反复进行碰撞检测</p><blockquote><p>Robust……</p></blockquote><h3 id="impact-zone-method.">Impact Zone Method.</h3><h3 id="备选">备选</h3><ol type="1"><li>Rigid Impact Zone</li></ol><figure><img src="image-20220409113154440.png" class="lazyload" data-srcset="image-20220409113154440.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="一个常见的思路为" /><figcaption aria-hidden="true">一个常见的思路为</figcaption></figure><h1 id="相交解除">相交解除</h1><blockquote><p>碰撞不是灾难，可以在发生之后进行解除</p></blockquote><p>处理当前已有的相交情况。</p><blockquote><p>Untangling Cloth.</p></blockquote><p>改进方法：</p><p>期望相交曲线变短，直到相交解除</p><ul><li>Not always work.</li></ul><blockquote><p>Resolving Service Collisons through</p></blockquote><hr /><blockquote><p>实际上，Narrow Phase 还可以继续细分：</p><p>The narrow phase obtains the collision pair list and for every pair,using their actual geometry, it checks whether the two partners arecolliding. This phase can get arbitrarily complex, so in the context ofreal-time physics simulation, the participating colliding shapes areusually restricted to being convex. For nonconvex shapes, only theconvex hull will then be used for collision detection. In most casesthis is good enough—for example if the concavities are small orconstitute object parts where you don't want a game character to goanyway, such as the exhaust pipes of a spacecraft or other irrelevantplaces. To improve collision quality and performance, we can decomposebig or concave objects into convex pieces. A game object therefore mighthold a simplified collision geometry that is different from the onedisplayed. In this chapter we investigate a narrow-phase algorithm fordetermining the distance between two convex objects. For the two objectsin Figure 33-1b, the contact point marked with the yellow star isdetected, and its location is calculated and stored with the collisionpair.（转化为凸包，进一步简化加速）</p></blockquote><p>根据 [Provet97] <a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a> 的描述，其可以通过</p><hr /><p>UE4 中的碰撞检测：</p><ul><li>射线检测RayCasts</li><li>重叠检测Overlaps</li><li>渗透深度计算Penetration Depth</li><li>Sweeps检测</li><li>InitialOverlaps检测</li></ul><blockquote><p>https://zhuanlan.zhihu.com/p/33529865</p></blockquote><p>刚体碰撞</p><p>Penalty Method</p><p>Impulse Method</p><p>空间划分 — Spatial Hashing</p><ul><li>Easy Implement</li><li>GPU Friendly</li><li>Recompute after updating. 包围盒 AABB</li><li>More involved</li><li>Not gpu friendly</li><li>Update BVH -&gt; Update Bounding Volumes.</li></ul><p>两种碰撞检测方式：</p><p>DCD — Discrete Collision Detection</p><ul><li>当前状态下有无自相交 CCD — Continuous Collision Detection</li><li>两个状态之间是否相交</li><li>对于三角网格：<ul><li>点 - 三角</li><li>边 - 边</li></ul></li><li>Co-planar</li><li>Issues:<ul><li>误差 - 三次方程 - GPU-float32</li><li>比 DCD 慢很多</li><li>难以实现</li></ul></li></ul><p>处理方法：</p><ul><li>Interior Point Method<ul><li>每一步都是安全的</li><li>Slow - far from solution - all of vertices - cautiously by smallsteps</li><li>Log-Barrier IPM. E(x) = -log |xij| + Gradient Descent<ul><li>IPC - not GD.</li><li></li></ul></li></ul></li><li>Impact Zone Optimization<ul><li>逐步满足 Constraint</li><li>Fast - Close To solution - only vertices in collision - can takelarge steps sizes</li><li>May not succeed. (Due to large dT)</li></ul></li><li>Rigid Impact Zones.<ul><li>回到前一帧 -&gt; 没有碰撞（视为刚体） CCD -&gt; IZO -&gt; IPM orRIZ</li></ul></li></ul><p>相交解除</p><ul><li>Not always intersection free.</li></ul><p>V-V intersection C-V intersection</p><ul><li>推出即可 C-C</li><li>无法处理边界</li><li>难以在 GPU 上实现</li></ul><hr /></div><h2 id="reference">Reference</h2><div class="story post-story"><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>GAMES103 Collision Handling<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Collision and self-collision handlingin cloth model dedicated to design garments<a href="#fnref2"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测相关介绍&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 3 - Narrow Phase 阶段</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/NarrowPhase/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/NarrowPhase/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T12:43:58.767Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测笔记 3 — Narrow Phase</p><span id="more"></span><p>一般而言的 Narrow Phase是基于点线面的关系推导得到的。而且在很多情况下，我们不需要知道碰撞在两个插值点之间的具体位置，而只需要知道其是否碰撞。针对不同的物体，一可以有不同的优化策略。</p><h2 id="一般物体间的碰撞检测">一般物体间的碰撞检测</h2><div class="story post-story"><ol type="1"><li>凸物体</li><li>刚体</li><li>变形体 &amp; 三角网格</li></ol><h3 id="凸物体的碰撞检测">凸物体的碰撞检测</h3><p>一般而言，凸物体的碰撞可以通过 GJK 和 SAT 方法来判断。</p><h4 id="gilbert-johnson-keerthi-gjk-算法">Gilbert-Johnson-Keerthi (GJK)算法</h4><h5 id="idea">Idea</h5><p>设 <span class="math inline">\(\mathcal A = \{\mathbf x\}\)</span>，<span class="math inline">\(\mathcal B = \{\mathbf x\}\)</span>是两个点集，定义其 Minkowski 差为： <span class="math display">\[\mathcal A - \mathcal B :=\{\mathbf x_1 - \mathbf x_2| \mathbf x_1 \in\mathcal A, \mathbf x_2 \in \mathcal B \}\]</span> 不难证明，<span class="math inline">\(\mathcal A\)</span> 和<span class="math inline">\(\mathcal B\)</span> 碰撞，当且仅当 <spanclass="math inline">\(0 \in \mathcal A - \mathcal B\)</span>。</p><p>问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于<strong>凸物体</strong>，我们可以有快速算法实现。</p><h5 id="support-函数和-simplex-单纯形">Support 函数和 Simplex单纯形</h5><p>其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski差的一个子集包含了 <spanclass="math inline">\(0\)</span>，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。</p><p>为了生成这样的单纯形，我们计算 support函数来快速获取给定方向上的支撑点，如图所示<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg"alt="Support 函数返回的点" /><figcaption aria-hidden="true">Support 函数返回的点</figcaption></figure><h5 id="迭代求解">迭代求解</h5><p>有了如上的论述，我们可以通过如此构造单纯形：</p><ol type="1"><li>随机生成一个单纯形</li><li>假定当前的单纯形为 <span class="math inline">\(\{v\}\)</span>则选择距离原点最远的抛弃，对于 n - 1维单纯形求法向量，求support（两个）</li><li>直到<ol type="1"><li>检查到 0 =&gt; 碰撞</li><li>如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞</li></ol></li></ol><p>可以证明，这样的算法一定在有限步内结束。</p><h4 id="sat-分离轴算法">SAT 分离轴算法</h4><p>一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个<span class="math inline">\(n - 1\)</span>维的超平面能够完全分开这两个凸集合。遍历所有的边（三维则是面），投影到其正交补空间上。若<strong>存在</strong>一个边，能使得投影完全分离，则其是不相交的，反之相交。</p><h3 id="刚体碰撞检测">刚体碰撞检测</h3><p>刚体碰撞的检测正如在 <a href="BroadPhase">Broad Phase</a>里提到：</p><blockquote><p><strong>凸包变换（V-HACD）</strong>，并使用适用于凸包的 CollisionDetect 来进行碰撞的判断。</p></blockquote><p>这类方法将原来的刚体预计算处理为凸包，用户可以控制其分割的<em>粒度</em>，从而权衡其加速/精度。</p><h3 id="变形体-三角网格">变形体 &amp; 三角网格</h3><p>基本思路为：</p><ol type="1"><li>求解三次方程；</li><li>设置两个非邻接顶点/面的距离下界为一个固定/可变的非零数（可以按照siggraph2022的论文结果强化到点-点距离）</li><li>在变形体网格上建立局部 BVH 来增加一部，返回1/2求解</li></ol><hr /><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"role="doc-endnote"><p>https://zhuanlan.zhihu.com/p/127844705<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测笔记 3 — Narrow Phase&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的抽象代数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/Algebra/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/Algebra/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-03-28T03:49:07.263Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="抽象代数" scheme="http://adversarr.github.io/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的复变函数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/ComplexAnalysis/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/ComplexAnalysis/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-06T03:03:56.421Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="复变函数" scheme="http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的微分几何整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-03-28T03:49:02.444Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="微分几何" scheme="http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的实变函数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/RealAnalysis/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/RealAnalysis/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-03-28T03:49:04.737Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="实变函数" scheme="http://adversarr.github.io/tags/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hexo in 30 Minutes</title>
    <link href="http://adversarr.github.io/2022/01/08/talk-chat/hexo-in-30-minutes/"/>
    <id>http://adversarr.github.io/2022/01/08/talk-chat/hexo-in-30-minutes/</id>
    <published>2022-01-07T16:00:00.000Z</published>
    <updated>2022-01-08T14:25:55.702Z</updated>
    
    <content type="html"><![CDATA[<p>三十分钟实现你的Hexo博客。</p><span id="more"></span><div class="note "><p><strong>Prerequisite</strong></p><ol type="1"><li>一定的命令行操作基础（<code>cd</code>等基础命令的使用）</li><li>（可能需要）科学上网，以登入 Github</li><li>一定的耐心（来调bug）</li></ol><p>软件上：</p><ol type="1"><li>代码编辑器，例如vscode</li><li><a href="http://nodejs.cn/download/">Node.js</a></li><li>git：下载地址<ahref="https://mirrors.tuna.tsinghua.edu.cn/">tuna</a>点右侧的<code>获取下载链接</code>按钮，找Git。安装时全默认即可。</li></ol></div><h2 id="创建你的-github-账号和与你的账号关联的repo">创建你的 Github账号和与你的账号关联的repo</h2><blockquote><p>Reference: <ahref="https://pages.github.com">https://pages.github.com</a></p></blockquote><h3 id="github-账号">Github 账号</h3><p>这个超级简单，就不展开了，但需要记住你的<code>username</code>（例如我的是Jerryyang2001）</p><h3 id="创建repo">创建repo</h3><p>repo创建时，必须满足：</p><ol type="1"><li>Public访问权限（通过下面的选项来确定）</li><li>名字：必须是 <code>username.github.io</code></li></ol><p>例如：</p><p><img src="2022-01-08-17-54-19.png" class="lazyload" data-srcset="2022-01-08-17-54-19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h3 id="测试效果">测试效果</h3><p>实际上，你已经完成了这里面（<ahref="https://pages.github.com">https://pages.github.com</a>）最难的一个部分，下面要测试你的网站的代码仓库是否成功创建：</p><h2 id="配置网站">配置网站</h2><div class="story post-story"><h3 id="下载-repo-到本地">下载 repo 到本地</h3><p>首先，先打开一个terminal（Windows下的Powershell），并且用cd命令转到一个用来存放你的网站源码的文件夹，例如我的：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">cd D:<span class="regexp">/Documents/</span><span class="keyword">Repositories</span>/</span><br></pre></td></tr></table></figure><p>通过：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/username/u</span>sername.github.io</span><br></pre></td></tr></table></figure><p>来下载你这个网站对应的代码。</p><h4 id="打开你的repo">打开你的repo</h4><p>首先，你需要一个vscode（或者sublime，或者任何一个轻量级的代码编辑器），用它打开这个repo的文件夹（想必大家都很熟悉）</p><details ><summary> 这个时候，如果你不放心是否你的repo已经设置好了，可以看看这里 </summary>              <div class='content'>              <p>创建一个新的 <code>index.html</code> 文件</p><p>内容简单的写一句：</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>就可以了～</p><p>然后将它push到远端：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span> <span class="comment">--all</span></span><br><span class="line">git <span class="keyword">commit</span> <span class="operator">-</span>m &quot;Initial commit&quot;</span><br><span class="line">git push <span class="operator">-</span>u origin main</span><br></pre></td></tr></table></figure><p>然后稍微等等，然后访问：<code>https://username.github.io</code>网站，应该就能看到结果。</p>              </div>            </details><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>接着，执行：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">hexo init .</span><br><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><p>然后，在当前文件夹应该就能看到hexo和npm自动生成了你的blog源码，配置好了相关环境。从这里起，你的Blog之旅将正式开始。</p><h3 id="站点配置">站点配置</h3><p>一个Hexo站点主要由五部分组成：</p><ol type="1"><li>软件框架环境（Hexo、Nodejs等）</li><li>主题文件（一个主题一个文件夹，可以通过npm指令安装，也可以直接放在<code>themes</code>文件夹下）</li><li>sourse文件夹下的blog内容，markdown格式<ol type="1"><li>其中的<code>_posts</code>为内容</li><li>其他的文件夹下为一些特殊页面的内容，例如aboutme，categories，tags页面的布局和特殊设置</li></ol></li><li>不同的branch！一般而言，repo中需要包含【源代码】和用源代码生成的、用于给用户看到的【网页源码】，但是【网页源码】和【源代码】不需要放在一起，就像开发人员开发了一个app，给你的只是一个软件，而不是源代码一样。我们希望实现这样的功能<ol type="1"><li>在一个分支部署网站，用来存放【网站源码】，供github<strong>自动</strong>部署。</li><li>在另一个分支存放自己的源代码。例如：</li></ol></li><li>github远端</li></ol><h3 id="部署">部署</h3><blockquote><p><ahref="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a>只有Git章节有用</p></blockquote><p>先讲讲第四部分，就是不同的branch组织源码库。这一部分需要：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">git branch gh-pages-<span class="keyword">source</span></span><br><span class="line">git checkout gh-pages-<span class="keyword">source</span></span><br></pre></td></tr></table></figure><p>然后在你的<code>_config.yml</code>文件中添加：</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">deploy:</span></span><br><span class="line"><span class="language-xml">  type: git</span></span><br><span class="line"><span class="language-xml">  repository: git@github.com:username/username.github.io.git</span></span><br><span class="line"><span class="language-xml">  branch: master # 这里就是你存放【网站源码】的地方</span></span><br><span class="line"><span class="language-xml">  message: Site updated:</span><span class="template-variable">&#123;&#123; <span class="name">now</span>(<span class="name">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>) &#125;&#125;</span><span class="language-xml">)</span></span><br></pre></td></tr></table></figure><p>然后试试看：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure><p>就能直接把生成的【网站源码】push到github仓库中，让github自动部署网站到<code>username.github.io</code>。<details ><summary> 当然你也可以在 github repo 的设置中设置你想要的branch作为【网站源码】的路径 </summary>              <div class='content'>              <p><img src="2022-01-08-22-07-28.png" class="lazyload" data-srcset="2022-01-08-22-07-28.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>              </div>            </details></p></div><h2 id="资料">资料</h2><div class="story post-story"><p>我正在用的主题：<a href="https://volantis.js.org">Volantis</a></p><p>曾经用过，感觉还行的一个主题：<ahref="https://fluid-dev.github.io/hexo-fluid-docs/start/">Fluid文档</a><a href="https://hexo.fluid-dev.com">Fluid 官网</a></p><p>一些更多的折腾资料：</p><p>一定要多看 hexo 的官网介绍：</p><ol type="1"><li><ahref="https://hexo.io/docs/one-command-deployment#Git">一键部署</a></li><li><a href="https://hexo.io/docs/setup">站点基础组织结构</a></li><li><a href="https://hexo.io/docs/configuration">站点配置文件</a></li></ol></div><h2 id="当然也可以">当然也可以：</h2><div class="story post-story"><p>如果你懒的话，也可以直接clone我的源码嘛。毕竟都是配置好的东西，拿来就用就是了。（记得把我的内容全都删了）</p><p>在clone完我的源码之后需要注意的是：</p><p>我的【源代码】在<code>gh-pages-volantis</code>分支下。记得checkout到这个分支上，然后：</p><ol type="1"><li>删除<code>sourse/_posts</code>文件夹下的所有文件</li><li>修改<code>sourse/about</code> <code>sourse/categories</code><code>sourse/chat</code> 等源码中的一些不属于你的标题……</li><li>修改所有的config文件中的东西（<code>_config.volantis.yml</code> 和<code>_config.yml</code></li></ol><p>就这样？后面挺复杂的（细节太多了）各位慢慢摸索吧，百度上都有相应的解决方案的。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;三十分钟实现你的Hexo博客。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="http://adversarr.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库原理</title>
    <link href="http://adversarr.github.io/2021/12/27/study/ComputerScience/fragments/DB2021/"/>
    <id>http://adversarr.github.io/2021/12/27/study/ComputerScience/fragments/DB2021/</id>
    <published>2021-12-26T16:00:00.000Z</published>
    <updated>2022-04-06T03:32:23.577Z</updated>
    
    <content type="html"><![CDATA[<p>数据库原理复习提纲。</p><span id="more"></span><h2 id="引言">引言</h2><div class="story post-story"><h3 id="数据管理的发展">数据管理的发展</h3><h4 id="数据密集型应用">数据密集型应用</h4><p>数据密集型应用</p><ol type="1"><li>数据量大</li><li>数据不随程序的结束而消失</li><li>数据为多个 app 共享</li></ol><p>数据库对比文件系统：</p><ol type="1"><li>编写应用程序很不方便</li><li>文件设计难以满足多种应用程序的不同要求 → 产生数据冗余</li><li>文件结构的修改导致应用程序修改，应用程序的维护工作量大</li><li>文件系统一般不支持文件的并发访问</li></ol><h4 id="数据库系统">数据库系统</h4><p>DBMS — 管理数据库的软件 → 数据库的<strong>核心</strong></p><p>DBA — 数据库管理员</p><p>数据库系统 — app+DBMS+DBA</p><p>现代 DBMS 的功能：</p><ol type="1"><li>提供高级的数据接口（抽象出物理存储的细节 →物理形式和逻辑形式能够互相映射、GUI、非过程的 sql 语言）</li><li>查询处理和查询优化（性能）</li><li>数据目录管理（包含数据的逻辑属性、存储结构定义、访问、管理的信息）</li><li>并发控制</li><li>恢复功能</li><li>完整性约束检查（数据在<strong>语义</strong>上的约束—完整性约束）</li><li>访问控制</li></ol><blockquote><p>数据管理—如何有效的组织、存储、维护和使用大量的相关数据</p></blockquote><blockquote><p>数据库 — 利用计算机进行数据管理的一种技术</p></blockquote><div class="note "><p><strong>数据库中的数据的性质</strong></p><p>数据库是一个按<strong>数据结构</strong>来存储和管理数据的计算机软件系统。</p><p>与数据文件相比，有如下的优点：</p><ol type="1"><li>数据库中的数据具有数据整体性</li><li>数据库中的数据具有数据共享性<ol type="1"><li>用法不同 -为用户提供不同的数据是图，满足个别用户对于数据结构、数据命名、约束条件的特殊要求</li><li>同时共享 - 不同的用户可以同时存取数据库中的同一个数据</li></ol></li></ol><p>和文件系统相比的主要特点：</p><ol type="1"><li>以数据模型为基础</li><li>数据冗余度小、数据共享度高</li><li>数据和程序之间具有较高的独立性<ol type="1"><li><u>物理独立性</u>：指应用程序对于数据<strong>存储结构（物理结构）</strong>的依赖程度。</li><li><u>逻辑独立性</u>：应用程序对于数据全局<strong>逻辑结构</strong>的依赖程序。</li></ol></li><li>通过 DBMS 实现数据安全性和数据完整性控制</li><li>最小存取单位是数据项</li></ol></div><div class="timeline"><p class='p h2'>数据库系统发展</p><div class="timenode"><div class="meta"><p><p>手工管理数据阶段</p></p></div><div class="body"><ol type="1"><li>不保存大量的数据</li><li>没有软件系统对于数据进行管理</li><li>没有文件的概念<ul><li>数据组成和数据存储过程必须由程序员自行设计</li></ul></li><li>一组数据对应一个程序<ul><li>相同数据重复多</li></ul></li></ol></div></div><div class="timenode"><div class="meta"><p><p>文件系统管理阶段</p></p></div><div class="body"><p>特点：</p><ol type="1"><li>管理的数据以文件的形式存储在计算机的外村中</li><li>文件系统由专门数据管理软件提供有关数据的存取、查询、维护功能</li><li>文件系统的数据文件已经具有对氧化</li><li>文件系统的数据存取是以记录为单位</li></ol><p>缺点：</p><ol type="1"><li>表现<ol type="1"><li>数据冗余度大（Redundancy）</li><li>缺乏程序间的独立性</li></ol></li><li>反映<ol type="1"><li>数据文件为某一特定应用服务，可重复使用率低</li><li>数据的逻辑结构改变时，必须改应用程序，修改文件结构的定义</li><li>反之，应用程序的改变，影响文件数据结构的改变</li></ol></li></ol></div></div></div><h3 id="数据数据模型数据模式">数据、数据模型、数据模式</h3><h4 id="数据">数据</h4><p>对事物描述的符号记录是数据</p><ol type="1"><li>从数据中获取有意义的内容 → 信息</li><li>数据是信息的一种存在形式，通过解释处理才成为有用的信息</li></ol><h4 id="数据模型">数据模型</h4><p>数据模型是用来描述数据的一组<strong>概念</strong>和<strong>定义</strong>，数据库的设计基础是数据模型。</p><blockquote><p>例如：层次模型、网状模型、关系模型等</p></blockquote><ol type="1"><li>数据结构：数据的静态属性 →数据的基本结构、数据间的联系(、数据的约束)</li><li>数据操作：数据的动态属性 → 定义在数据上的操作</li><li>数据约束条件</li></ol><blockquote><p>数据模型应该能自然的反应现实世界、接近现实世界的观察和理解；同时接近数据在计算机中的物理表示，便于实现、减少开销。</p></blockquote><ol type="1"><li>概念数据模型（需求导向）：面向用户的、面向现实世界的数据模型，和DBMS 无关，是用来描述一个单位的概念化结构。<ol type="1"><li>和 DBMS 无关</li><li>需要相关工作人员的参与</li><li>常常用 ER 图表示</li></ol></li><li>逻辑数据模型 — 用户从数据库看到的数据模型<ol type="1"><li>和 DBMS 有关</li><li>关系数据模型是目前最常用的逻辑数据模型</li><li>面向用户 且 面向实现</li></ol></li><li>物理数据模型 —数据的逻辑结构（文件、记录、字段等）不反映存储结构，例如物理块、指针、索引等<ol type="1"><li>和 DBMS 有关、和 OS 和硬件有关</li></ol></li></ol><p>对某一类数据的结构、联系、约束的描述（型的描述），成为<strong>数据模式</strong>。</p><p>例如：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">数据模式：</span><br><span class="line">  <span class="comment">(name, id, gender, birth)</span></span><br><span class="line">数据实例：</span><br><span class="line">  <span class="comment">(yang, 615, male, 2001)</span></span><br></pre></td></tr></table></figure><p>有三级<strong>数据模式</strong>结构：</p><ol type="1"><li>概念模式（逻辑模式）：用<strong>逻辑数据模型</strong>对一个单位的数据的描述— 最基础任务</li><li>外模式 — 对用户用到的数据描述（从概念模式推导） — 逻辑数据模型</li><li>内模式 — 物理数据模型对数据的描述（和内模式相互映射） —物理数据模型</li></ol><p>关系为：</p><ol type="1"><li>概念数据库是物理数据库的逻辑抽象形式。</li><li>物理数据库是概念数据库的具体实现</li><li>用户数据库是概念数据库的子集、是物理数据库子集的逻辑描述</li></ol><div class="timeline"><p class='p h2'>三级数据模型</p><div class="timenode"><div class="meta"><p><p>概念模式</p></p></div><div class="body"><p>包括：</p><ol type="1"><li>数据记录型、数据项的型、记录间联系的描述</li><li>安全性定义、数据库完整性约束、寻址方式等</li></ol><p>目的：</p><ol type="1"><li>减小数据冗余</li><li>实现数据共享</li><li>对所有用户的数据进行综合抽象的全局统一视图</li></ol></div></div><div class="timenode"><div class="meta"><p><p>外模式</p></p></div><div class="body"><p>对于各个用户或程序设计的数据逻辑结构和数据特征的描述。</p><p>设计对于子模式的数据结构、数据域、数据构造规则和数据安全性和完整性等属性的描述。</p><p>优点如下：</p><ol type="1"><li>不必考虑与自己无关的数据，无需了解数据的存储结构，简化用户、程序设计工作</li><li>有利于数据的安全和保密</li><li>有利于数据的独立性和共享性</li></ol></div></div><div class="timenode"><div class="meta"><p><p>内模式和物理数据库</p></p></div><div class="body"><p>对于数据的内部表示、底层描述。</p><p>设计目标：将全局逻辑模式组织称最优的无力模式，提高数据的存取效率，改善系统的性能指标。</p><p>在数据库系统中，只有物理数据库是真实存在的，是存放在外存中的数据文件。</p></div></div></div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">内模式 --&gt; a[概念模式] --&gt; 外模式1 --&gt; 用户1</span><br><span class="line">a--&gt;外模式2--&gt;用户2</span><br><span class="line">a--&gt;外模式3--&gt;用户3</span><br></pre></td></tr></table></figure><p><strong>物理独立性</strong>是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。即，数据在磁盘上怎样存储由DBMS(DataBase Management System数据库管理系统)管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变。</p><p><strong>逻辑独立性</strong>是指用户的应用程序与数据库的逻辑结构是相互独立的，即：</p><ul><li>当数据的逻辑结构改变时，用户程序也可以不变。</li></ul><details ><summary> 数据、数据模型、数据模式区分 </summary>              <div class='content'>              <h4id="数据data数据模型data-model数据模式data-schema区分">数据(data)，数据模型(datamodel)，数据模式(data schema)区分</h4><h5 id="数据">数据</h5><p>数据是对事物描述的符号记录，是信息的存在的一种形式，只有经过解释和处理才能成为有用的信息。</p><p>数据使用数据操作语言(DML)进行修改和访问</p><h5 id="数据模型">数据模型</h5><p>模型是现实世界特征的模拟和抽象。数据模型是现实世界数据特征的抽象，用来描述某种数据的概念和定义。数据模型通常由数据结构、数据操作、完整性约束三部分组成。使用数据模型描述数据时不仅要描述数据本身，还要描述数据之间的联系。其中，三级数据模型分别为：概念数据模型、逻辑数据模型、物理数据模型。</p><ol type="1"><li>数据结构：数据结构是对系统静态特性的描述。常见结构有层次结构、网状结构、关系结构。</li><li>数据操作：数据操作是对系统动态特性的描述。指对数据库中各种对象(型)的实例(值)运行执行的操作的集合，包括操作及有关操作的规则。数据库主要有检索和更新两大类操作，数据模型必须定义这些操作的确切含义、操作符号、操作规则(优先级)以及实现这些操作的语言。</li><li>完整性约束：数据的约束条件是一组完整性规则的集合。完整性规则用以限定符合数据模型的数据库的状态以及状态的变化，以保证数据的正确、有效、相容。</li></ol><h5 id="数据模式">数据模式</h5><p>数据模式是以一定的数据模型对一个单位的类型、结构、及其相互间的关系所进行的描述。</p><p>数据模型有型与值之分，型——框架，值——实例。</p><p>ps:数据模型是描述现实世界数据的手段、工具。数据模式是利用这个手段和工具对具体对象相互间关系所进行的描述。是关于型的描述。数据模型可类比为c 语言，数据模式可类为 c 语言编写的程序。</p><h4 id="数据库的三级模式levels-of-abstraction">数据库的三级模式(levelsof abstraction)</h4><ol type="1"><li>物理模式 physical schema(内模式):表示数据库的存储结构</li><li>逻辑模式 conceptual/logical schema:定义了数据模型的逻辑结构</li><li>外模式 external schema(视图view):对用户所用到的那部分数据的描述</li></ol><p>物理模式、逻辑描述、外模式都存储与数据目录中，是数据目录的最基本内容。DBMS通过数据目录管理和访问数据模式。</p><p>模式使用数据定义语言(DDL)定义。</p><div class="note"><p><strong>数据模式、数据模型</strong></p><p>数据模型是描述数据的手段，而数据模式是用给定的数据模型对具体数据的描述。</p></div><div class="note"><p><strong>三级数据模式、两级数据映像</strong></p><p><strong>两级映像</strong>：</p><ol type="1"><li><strong>外模式/模式映像</strong>。模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。数据库中的同一模式可以有任意多个外模式，对于每个外模式，都存在一个外模式/模式映像，它确定了数据的局部逻辑结构与全局逻辑结构之间的对应关系。例如，在原有的记录型之间增加新的联系，或在某些记录型中增加新的数据项时，由数据库管理员对各个外模式/模式映像作相应改变，这一映像功能保证了数据的局部逻辑结构不变（即外模式保持不变）。由于应用程序是根据数据的局部逻辑结构编写的，所以应用程序不必修改，从而保证了数据与程序间的逻辑独立性。</li><li><strong>模式/内模式映像</strong>。数据库中的模式和内模式只有一个，所以模式/内模式映像是唯一的。它确定了数据的全局逻辑结构与储存逻辑结构之间的对应关系。存储结构变化时，如果采用了更先进的存储结构，由数据库管理员对模式/内模式映像作相应的变化，使其模式仍保持不变，即把存储结构变化的影响限制在模式之下，这使数据的存储结构和存储方法较高地独立于应用程序，通过映像功能保证数据存储结构的变化不影响数据的全局逻辑结构的改变，从而不必修改应用程序，即保证了数据的物理独立性。</li></ol><p><strong>好处</strong>：</p><ol type="1"><li>保证数据独立性。将模式和内模式分开，保证了数据的物理独立性；将外模式和模式分开，保证了数据的逻辑独立性。</li><li>简化了用户接口。按照外模式编写应用程序或输入命令，而不需要了解数据库内部的存储结构，方便用户使用系统。</li><li>有利于数据共享。在不同的外模式下可以有多个用户共享系统中数据，减少了数据冗余。</li><li>有利于数据的安全保密。在外模式下根据需要进行操作，只能对限定的数据操作，保证了其他数据的安全。</li></ol></div>              </div>            </details><h3 id="数据独立性database-independence">数据独立性(databaseindependence)</h3><p>两级数据独立性分别为逻辑数据性和物理独立性，数据独立性表示应用访问数据库时不受数据结构和存储的影响。即在我们修改数据之间的关系和数据的存储方式之后，我们无需对应用进行修改，而只需修改物理模式到逻辑模式及逻辑模式到外模式的映射。(因为应用访问的是外模式下的数据，我们只需保证用户看到的数据库视图不变)</p><div class="note "><p><strong>数据独立性为什么越高越好</strong></p><blockquote><p>要回答独立性具体是什么（物理独立性、逻辑独立性）</p><p>与此同时阐明 独立性的意义即可</p></blockquote><p>总的来说：</p><ol type="1"><li>数据的物理独立性：<ol type="1"><li>数据的存取和程序分离，数据存储结构与存取方法改变不要求修改程序</li><li>使得数据共享成为可能，只要知道数据测存取结构，不同程序可以共用同一个数据文件</li></ol></li><li>数据的逻辑独立性：<ol type="1"><li>数据的使用和数据的逻辑结构分离</li></ol></li></ol><p>数据独立性是指建立在数据的逻辑结构和物理结构分离的基础上，用户以简单的逻辑结构操作数据而无需考虑数据的物理结构，转换工作由数据库管理系统实现。数据独立性分为数据的物理独立和数据的逻辑独立。</p></div></div><h2 id="数据模型-1">数据模型</h2><div class="story post-story"><ol type="1"><li>层次数据模型</li><li>网状数据模型</li></ol><h3 id="关系数据模型">关系数据模型</h3><h4 id="基本概念和定义">基本概念和定义</h4><h5 id="属性域">属性、域</h5><ol type="1"><li>属性（attribute） — 描述事物的特征</li><li>域（domain） — 属性可以取值的范围。</li><li>1NF 的限制 — 所有的域都是原子数据</li><li>有条件的有 NULL 存在</li></ol><h5 id="关系元组">关系、元组</h5><p><span class="math display">\[R=(A_1/D_1, \cdots, A_n /D_n)\]</span></p><p>上式事对于<span class="math inline">\(R\)</span>的型的描述。→ R的模式</p><p><span class="math display">\[r = \{ t_1, t_2 \cdots , t_m\}\]</span></p><p><span class="math inline">\(r\)</span>是 <spanclass="math inline">\(R\)</span> 的一个值。</p><ol type="1"><li>一般来说，关系模式相对稳定、关系的值相对变化</li></ol><h5 id="键">键</h5><p>候选键 candidate key— 唯一决定一个元组的“最小”集合</p><p>超键 superkey — 一个真子集是候选键</p><p>主键 primary key</p><p>全键 all key</p><p>主属性 prime attribute — 包含在任何一个候选键中的属性</p><p>非主属性 non-prime attribute</p><p>外键 foreign key</p><h4 id="约束">约束</h4><p>完整性约束 — 语义限制。一般有四类</p><ol type="1"><li><strong>域完整性约束</strong>（最基本的、最简单的）</li><li>实体完整性约束</li><li>引用完整性约束</li><li>一般完整性约束</li></ol><div class="note "><p><strong>常用的两个完整性约束</strong></p><ul><li>域完整性约束: 插入属性的值是否符合值域</li><li>实体完整性约束: 主键不能为空</li><li>引用完整性约束: 外键要么是空缺的要么是实际存在的主键值</li></ul></div><h4 id="操作">操作</h4><p>关系代数操作— 关系操作。（关系专用、集合操作）</p><ol type="1"><li>选择操作： <span class="math inline">\(\sigma_C(R)\)</span></li><li>投影操作： <span class="math inline">\(\Pi_A(R)\)</span></li><li>集合操作：交并补</li><li>连接操作：连接、等连接、自然连接</li><li>除操作： <span class="math inline">\(R\div S = \Pi _X(R) -\Pi_X(\Pi_X(R) \times S) - R)\)</span></li><li>外连接操作</li><li>外并操作</li></ol><h4 id="关系演算">关系演算</h4><h5 id="元组关系演算">元组关系演算</h5><ol type="1"><li>投影</li><li>选择</li><li>并</li><li>差</li><li>连接</li></ol><p>和关系代数有相同的表达能力 — 关系完备</p><p>基本形式为：</p><p><span class="math display">\[\{t|P(t)\}\]</span></p><p>其中，<span class="math inline">\(t\)</span>为元组变量。</p><p>其中 <span class="math inline">\(P(t)\)</span> 可以由：</p><ol type="1"><li><span class="math inline">\(s\in R,s[A]\text{ op } C,s[A]\text{ op }u[B]\)</span></li><li><span class="math inline">\(\neg P\)</span></li><li><span class="math inline">\(P_1\vee P_2,P_1\wedge P_2\)</span></li><li><span class="math inline">\(\exists t\in R.P(t),\quad \forall t\inR.P(t)\)</span></li></ol><h3 id="对传统数据模型的评价">对传统数据模型的评价</h3><p>继承了文件的字段、记录的概念</p><p>物理级 — 借鉴了文件索引、散列的存取方法 —在记录的基础上定义了各自数据的基本结构，约束和操作</p><p>向用户提供了统一的数据模型和相应的数据库语言。</p><ol type="1"><li>以记录为基础，不能很好的面向用户和应用</li><li>不能以自然的方式表示实体之间的联系</li><li>语义信息贫乏</li><li>数据类型少、难以满足需要</li></ol><h3 id="er-数据模型">ER 数据模型</h3><h4 id="基本概念">基本概念</h4><p>E-R 模型— 实体联系数据模型 → 面向现实世界的，不考虑如何实现</p><p>提出目的：</p><ol type="1"><li>建立一个统一的数据模型来概括三种传统数据模型</li><li>作为三种传统数据模型转换的中间模型</li><li>作为超脱 DBMS 的一种概念数据模型，以比较自然的方式模拟现实世界</li></ol><p>三类抽象概念：</p><ol type="1"><li>实体</li><li>属性</li><li>联系</li></ol><h4 id="er-图">ER 图</h4></div><h2 id="sql">SQL</h2><div class="story post-story"><ul><li>集数据定义语言(DDL),数据操纵语言(DML)，数据控制语言(DCL)功能于一体</li><li>可以独立完成数据库生命周期中的全部活动</li><li>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行</li><li>数据操作符统一</li><li>高度非过程</li><li>面向集合的操作方式</li><li>以同一种语法结构提供多种使用方式</li><li>语言简洁，易学易用</li></ul><h3 id="数据库的用户接口">数据库的用户接口</h3><p>DBMS 需要给用户提供命令和语言 → 非过程性语言 → SQL</p><h3 id="sql-语言概况">SQL 语言概况</h3><p>四个部分：</p><ol type="1"><li>DDL → 数据定义语言</li><li>QL → 查询语言</li><li>DML → 增删改</li><li>DCL → 权限控制</li></ol><h3 id="数据定义语言">数据定义语言</h3><h4 id="术语数据类型">术语、数据类型</h4><p>在 SQL 中，表分为：</p><ol type="1"><li>基表 base table</li><li>视图 view</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line"> (sno <span class="type">char</span>(<span class="number">7</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  sname <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  ...</span><br><span class="line">  height <span class="type">dec</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="keyword">primary</span> key(sno));</span><br><span class="line">注意要写分号</span><br></pre></td></tr></table></figure><h4 id="基表模式的修改">基表模式的修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>[<span class="operator">&lt;</span>creator<span class="operator">&gt;</span>, ...] <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">add</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">add</span> <span class="keyword">primary</span> key (<span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>t1<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">add</span> <span class="keyword">foreign</span> key [<span class="operator">&lt;</span>fk_name<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>)</span><br><span class="line">    <span class="keyword">references</span> <span class="operator">&lt;</span>t2<span class="operator">&gt;</span></span><br><span class="line">      [<span class="keyword">on</span> <span class="keyword">delete</span>&#123;restrict<span class="operator">|</span>cascade<span class="operator">|</span><span class="keyword">set</span> <span class="keyword">null</span>&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sql-查询语言">SQL 查询语言</h3><h4 id="基本-sql-查询">基本 SQL 查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><h4 id="一些例子">一些例子</h4><h5 id="union-操作的实现">Union 操作的实现</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">where</span> c1 <span class="keyword">or</span> c2</span><br></pre></td></tr></table></figure><h5 id="intersect-操作的实现">Intersect 操作的实现</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">where</span> c1 <span class="keyword">and</span> c2</span><br></pre></td></tr></table></figure><h5 id="嵌套查询">嵌套查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span></span><br><span class="line">  (<span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要考虑是否消除非<strong>闭包</strong>运算。</p><h5 id="找出只被-1-个水手预定的船">找出只被 1 个水手预定的船</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> bid</span><br><span class="line"><span class="keyword">from</span> reserves r1</span><br><span class="line"><span class="keyword">where</span> bid <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> bid</span><br><span class="line">  <span class="keyword">from</span> reserves r2</span><br><span class="line">  <span class="keyword">where</span> r2.sid <span class="operator">!=</span> r1.sid);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>只被 1 个预定 iff 对于第一个人，不存在第二个人也预定了这条船</p></blockquote><h5 id="除法">除法</h5><p>用集合差实现：不存在一个船，不被这个人预定。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name</span><br><span class="line"><span class="keyword">from</span> sailors s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">  (<span class="keyword">select</span> b.bid <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span></span><br><span class="line">   <span class="keyword">select</span> r.bid <span class="keyword">from</span> reserves r <span class="keyword">where</span> r.sid <span class="operator">=</span> s.sid)</span><br></pre></td></tr></table></figure><p>不用集合差实现：不存在不被我预定的船</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name</span><br><span class="line"><span class="keyword">from</span> sailors s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">  <span class="keyword">select</span> b.bid</span><br><span class="line">  <span class="keyword">from</span> boats b</span><br><span class="line">  <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.bid <span class="operator">=</span> b.bid <span class="keyword">and</span> r.sid <span class="operator">=</span> s.sid))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="其他的集合比较操作">其他的集合比较操作</h5><ol type="1"><li>EXIST</li><li>IN</li><li>UNIQUE</li><li><op> ANY/ALL</li></ol><h5 id="聚合函数">聚合函数</h5><p>count, sum, avg, max, min</p><h5 id="分组-group-by">分组 GROUP-BY</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">distinct</span>] target<span class="operator">-</span>list</span><br><span class="line"><span class="keyword">from</span> relation<span class="operator">-</span>list</span><br><span class="line"><span class="keyword">where</span> qualification</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">grouping</span><span class="operator">-</span>list</span><br><span class="line"><span class="keyword">having</span> group_qualification</span><br></pre></td></tr></table></figure><p>需要满足：</p><ol type="1"><li>group_qualification 单值</li><li>target-list 必须包含一个 group-list 的子集</li></ol><h5 id="嵌套查询汇总">嵌套查询汇总</h5><p>分为 3 类：</p><ol type="1"><li>标量子查询</li><li>表表达式</li><li>公共表表达式</li></ol><h5 id="递归查询">递归查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> agents(name, salary) <span class="keyword">as</span></span><br><span class="line">  ((<span class="keyword">select</span> name, salary <span class="keyword">from</span> FedEmp</span><br><span class="line">    <span class="keyword">where</span> manager <span class="operator">=</span> &quot;Hover&quot;)</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">   (<span class="keyword">select</span> f.name, f.salary</span><br><span class="line">    <span class="keyword">from</span> agents <span class="keyword">as</span> a, FedEmp <span class="keyword">as</span> f))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实质上是不动点算法</p><h3 id="sql-操纵语言">SQL 操纵语言</h3><h4 id="insert">insert</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(attr<span class="operator">-</span>list) <span class="keyword">values</span> (...)</span><br></pre></td></tr></table></figure><h4 id="delete">delete</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sc</span><br><span class="line">  <span class="keyword">where</span> c;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="update">update</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> xxx</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">new</span><span class="operator">-</span>vals</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><h3 id="视图">视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> xxx</span><br><span class="line">  <span class="keyword">as</span> <span class="operator">&lt;</span><span class="keyword">SQL</span><span class="operator">-</span>statement<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="和表的区别">和表的区别</h4><ol type="1"><li>从基表或其他视图导出的虚表，</li></ol><p>对于查询：原则上可以操作</p><p>对于更新，有三个要求：</p><ol type="1"><li>三个基表的主键都在视图中 → 可以唯一确定构成它的元组</li><li>……</li></ol><h3 id="嵌入式-sql">嵌入式 SQL</h3><p>主要是嵌入式 C 语言</p><h4 id="说明部分">说明部分</h4><p>sql 语句需要用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span></span><br></pre></td></tr></table></figure><p>开头。例如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">  <span class="type">char</span> SNO[<span class="number">7</span>];</span><br><span class="line">  <span class="type">char</span> GIVENSNO[<span class="number">7</span>];</span><br><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="可执行语句">可执行语句</h4><p>例如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL SELECT GRADE</span><br><span class="line">  INTO: GRADE, : GRADEI</span><br><span class="line">  FROM SC</span><br><span class="line">  WHERE SNO=:GIVENSNO AND CNO=:GIVENSNO;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用游标需要下面四条语句</p><h5 id="说明游标">说明游标</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL DECLARE &lt;cursor-name&gt; CURSOR FOR</span><br><span class="line">  SELECT ...</span><br><span class="line">  FROM ...</span><br><span class="line">  WHERE ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="打开游标">打开游标</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL OPEN &lt;cursor-name&gt;;</span><br></pre></td></tr></table></figure><h5 id="取数语句">取数语句</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL FETCH &lt;cursor-name&gt; INTO: hostvar1, hostvar2, ...;</span><br></pre></td></tr></table></figure><h5 id="关闭游标语句">关闭游标语句</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL CLOSE &lt;cursor-name&gt;;</span><br></pre></td></tr></table></figure><h5 id="完整实例">完整实例</h5><p>简单版本：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL DECLARE C1 CURSOR FOR</span><br><span class="line">  SELECT SNO, GRADE</span><br><span class="line">  FROM SC</span><br><span class="line">  WHERE CNO = :GIVENCNO;</span><br><span class="line">EXEC SQL OPEN C1;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line">  EXEC SQL FETCH C1 INTO :SNO, :GRADE, :GRADEI;</span><br><span class="line">  <span class="keyword">if</span> (SQLCA.SQLCODE == <span class="number">100</span>) <span class="comment">// 表示当前游标中的数已经取完</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (SQLCA.SQLCODE &lt; <span class="number">0</span>) <span class="comment">// 出错</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  处理游标</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE C1;</span><br></pre></td></tr></table></figure><p>复杂一些的，打印绩点在 3.5 以上的学生名单：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说明部分</span></span><br><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">char</span> sname[<span class="number">20</span>];</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"><span class="comment">// 游标说明</span></span><br><span class="line">EXEC SQL DECLARE student_cursor CURSOR FOR</span><br><span class="line">    SELECT sname</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE gpa &gt; <span class="number">3.5</span>;</span><br><span class="line"><span class="comment">// 打开游标</span></span><br><span class="line">EXEC SQL OPEN student_cursor;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取数</span></span><br><span class="line">    EXEC SQL FETCH student_cursor INTO :sname;</span><br><span class="line">    <span class="keyword">if</span> (SQLCA.SQLCODE == <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (SQLCA.SQLCODE &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭游标</span></span><br><span class="line">EXEC SQL CLOSE student_cursor;</span><br></pre></td></tr></table></figure><p>几个环节都不能少</p></div><h2 id="数据库管理系统">数据库管理系统</h2><div class="story post-story"><ul><li>基本功能 → 安全可靠的执行数据库语言的语句</li></ul><h3 id="事务">事务</h3><p>事务是 DBMS 的执行单位，它由有限个数据库操作序列组。事务有 ACID性质：</p><ol type="1"><li>原子性（Atomic）：遵守 nothing or all 的原则 — 不允许部分完成</li><li>更新操作的保持一致性（Consistency）：事务对数据库的作用应该让数据库从一个一致状态</li><li>隔离性（Isolation）：如果多个并发的事务执行，应该和各个事务独立执行相同</li><li>持久性（Durability）：成功执行的事务，对数据库的影响是持久的，可恢复的</li></ol><blockquote><p>上述四个性质被称为 ACID 准则</p></blockquote><h3 id="dbms-的进程结构">DBMS 的进程结构</h3><p>以进程为执行者的缺点</p><ol type="1"><li>创建、撤销、切换、通信开销大</li><li>并发运行的进程数量过多 → 系统开销太大 → 性能下降</li><li>不利于事务共享内存空间</li></ol><p>以线程为执行者的优点：</p><ol type="1"><li>按照 DBMS 的需要进行线程调度</li><li>线程切换可以在操作系统的用户态进行，不必进入内核态</li><li>提高可移植性</li></ol></div><h2 id="存储结构">存储结构</h2><div class="story post-story"><h3 id="dmbs-的系统结构">DMBS 的系统结构</h3><ol type="1"><li>集中式</li><li>分布环境下的客户、服务器结构</li><li>Web 下的三层客户、服务器结构</li><li>高可用、高缩放、高性能的数据库系统结构</li></ol><h3 id="数据目录">数据目录</h3><p>数据目录是关于数据的数据 → 元数据</p><p>DBMS的任务是管理大量的、共享的，持久的数据。关于数据的定义、描述必须长期保存在系统中→ 数据目录。</p><p>数据目录中的数据按易变程度可以非为两类：</p><ol type="1"><li>一类来自基表、视图和索引 — 相对稳定</li><li>一类来自数据库状态的统计 — 进程变化</li></ol><h3 id="数据库存储介质的特点">数据库存储介质的特点</h3><blockquote><p>数据库是大量、持久数据的集合</p></blockquote><p>内存/磁盘：</p><ol type="1"><li>容量</li><li>易失存储器</li><li>成本</li></ol><p>磁盘 — 物理存储以块为单位</p><p>延迟写入、预先读取</p><h3 id="记录的存储结构">记录的存储结构</h3><h4 id="物理表示">物理表示</h4><p>记录分为若干的字段、每个字段有一个域、有定长和变长的区别，大致有是那种：</p><ol type="1"><li>定位法</li><li>相对法 — 变长</li><li>计数法 — 变长</li></ol><h4 id="物理块上的分配">物理块上的分配</h4><p>记录必须分配到物理块中：</p><ol type="1"><li>不跨块组织</li><li>跨块组织</li></ol><h4 id="数据压缩">数据压缩</h4><h3 id="文件结构和存取路径">文件结构和存取路径</h3><p>对数据库的操作最重要落实到对于文件的操作。文件的访问方式大致有：</p><ol type="1"><li>查询全部 or 相当多的记录 ≥15%</li><li>查询特定记录</li><li>查询某些记录 — ≤ 15%</li><li>范围查询</li><li>数据更新</li></ol><h4 id="数据库对于文件的要求">数据库对于文件的要求</h4><ol type="1"><li>需要附加信息 — 文件目录、文件描述块、物理块等部分；</li><li>传统的文件系统主要面向批处理。但数据库要求即时访问、动态修改；</li><li>传统文件都是为某一用户或某类用户服务的，用途单一；数据库文件需要被所有用户共享</li><li>采用文件管理系统 → 不利于移植</li><li>传统文件一旦建立，数据稳定；数据库的文件数据量变化大，文件结构应该能适应这样的变化。</li></ol><h4 id="文件的基本类型">文件的基本类型</h4><ol type="1"><li><p>堆文件</p><ol type="1"><li>最简单、最原始的一种文件结构</li><li>不是所有记录都物理邻接</li><li>唯一的存取路径是：顺序搜索（扫描）</li><li>排序费时、需要解决空间回收问题</li></ol></li><li><p>直接文件</p><p>记录的某一个属性用散列函数直接映射成记录的地址，散列的属性称为散列键</p><ol type="1"><li>地址空间固定</li><li>只对于散列键到记录的访问有效</li><li>不便于处理变长记录</li><li>散列函数难找</li></ol></li><li><p>索引文件</p><ol type="1"><li>如果以主键为索引键，则称该索引为主索引</li><li>与此同时更新时也用主索引做主键唯一性检查</li></ol></li></ol><p>主要分为非稠密索引、稠密索引</p><div class="note "><p><strong>索引分类</strong></p><ol type="1"><li>主索引（索引是主键）<ol type="1"><li>按主键排序-非稠密索引</li><li>不按主键排序 - 稠密索引</li></ol></li><li>次索引<ol type="1"><li>簇集索引 - 按索引键排序并簇集，稠密</li><li>非簇集索引 - 不安索引键排序，稠密</li></ol></li></ol></div><div class="note "><p><strong>优缺点</strong></p><ol type="1"><li>提高查询的效率</li><li>更新时，增加了维护的开销。 - 根据应用的要求选择。</li></ol><p>如果在文件的所有属性上都建立索引，则称为<strong>倒排文件</strong>。</p><ol type="1"><li>有利于多属性条件的查找</li><li>数据更新时开销很大</li></ol></div><div class="note "><p><strong>非稠密索引</strong></p><p>不为每个键值都设立索引项的索引称为非稠密索引。</p><p>同一时间，只能为一个索引键（一般是主键）建立非稠密索引。</p><p>当某个单元的存储区溢出，则可以放在溢出区。</p><ol type="1"><li>可以节省索引的存储空间</li><li>要求对于文件按索引键排序</li><li>溢出过多时，指针链接次数增加，性能下降</li></ol></div><div class="note "><p><strong>稠密索引</strong></p><p>记录不按索引键排序，每个键值都有一个索引项。</p><p>如果键值不唯一，那么对应的是一个地址集。</p></div><p>对于次索引，一个键值可能对应多个记录。如果它们分散在不同的物理块中，则索引带来的好处有时是有限的-- 并不能减少io。为了解决这个问题，开发了簇集索引。簇集索引的缺点如下：</p><ol type="1"><li>建立开销大、整个文件都要重新组织，建立的索引也要重建。</li><li>对于和索引键相关的查询有力，对于与簇集索引键无关的访问没有影响。</li></ol><h3 id="动态索引">动态索引</h3><ul><li>静态索引：多分树</li><li>动态索引：B-树、B+树</li></ul><p>索引集的节点结构：</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">节点类型|<span class="string">索引键数</span>|<span class="string">P0</span>|<span class="string">K0</span>|<span class="string">P1</span>|<span class="string">K1</span>|<span class="string">...</span>|<span class="string">Kn-1</span>|Pn</span><br></pre></td></tr></table></figure><p>（主索引）顺序集的节点结构</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">节点类型|<span class="string">索引键数</span>|<span class="string">前向指针</span>|<span class="string">后向指针</span>|<span class="string">K0</span>|<span class="string">tid0</span>|<span class="string">K1</span>|<span class="string">tid1</span>|<span class="string">...</span>|<span class="string">Kn</span>|tidn</span><br></pre></td></tr></table></figure><p>（次索引）顺序集节点结构</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">类型|<span class="string">块中索引键数</span>|<span class="string">前向指针</span>|<span class="string">后向指针</span>|<span class="string">K0</span>|<span class="string">P0</span>|<span class="string">...</span>|<span class="string">Kn-1</span>|<span class="string">Pn-1</span></span><br></pre></td></tr></table></figure><div class="note "><p><strong>P和tid的区别</strong></p><p>这里，由于次索引的一个键值可能对应了<strong>多个TID</strong>，数量可变，所以需要一个块来存放这些 tid（可以组成链表存储）</p></div><p>tid由<code>块号</code>和块中的<code>指针号</code>组成。这样在块中移动的时候不需要修改B+树索引的 tid，只需要修改指针号对应的块内指针。</p><p>B+树有如下的约束：</p><ol type="1"><li>秩为 k 的 B+树每个节点最多有 2k 个键值</li><li>根节点至少有一个键值、其他节点至少有 k 个键值</li><li>除了叶节点（顺序集节点）没有子女外，其他的节点，若有 J个键值，则有(J+1)个子女</li><li>所有叶节点都在树的同一级上（树保持平衡）</li></ol><div class="note "><p><strong>B+树相关计算</strong></p><p>B+树实现的索引都是稠密索引。保证其提供顺序搜索功能。</p><p>搜索 B+树所需 IO 次数取决于级数。</p><p>级数取决于 N（不同的索引键值对数-区别于记录数）。若顺序集为 L 级、秩为k，则顺序集至少有<span class="math inline">(2(k+1)^{L-2})</span>个节点。</p><p><span class="math display">[ N (k+1)^{L-2} k ]</span></p><p>那么对于 L 做估计：</p><p><span class="math display">[ L + <em>{k+1}(N/2k) + </em>{k+1} N / 2]</span></p></div></div><h2 id="查询优化">查询优化</h2><div class="story post-story"><ol start="4" type="1"><li>查询语句 → 查询结果的处理过程 — 查询处理</li><li>DBMS 需要确定一个合理有效的执行策略 — 查询优化</li></ol><p>不同方法：</p><ol type="1"><li>对查询语句本身变换 — 代数优化</li><li>对根据系统所提供的存取路径的优化，选择合理的存取策略 — 物理优化</li></ol><h3 id="代数优化">代数优化</h3><p>基本原则为：</p><ol type="1"><li>尽量所见查询过程中的中间结果</li><li>选择和投影先做 → 二元操作</li><li>连接时先做小关系的连接，再做大关系的连接</li><li>公共表表达式</li></ol><p>具体而言：</p><ol type="1"><li>以 select 子句对应投影操作、From 子句对应笛卡尔成绩、Where子句对应选择操作，生成原始查询树</li><li>应用变换规则：<ol type="1"><li><span class="math inline">\(\sigma\)</span>的交换律</li><li>$_C(RS) = _C(R)S $其中 <span class="math inline">\(Attr(C)\subseteqAttr(R)\)</span></li><li><span class="math inline">\(\sigma_{C_1 \wedge C_2}(R\times S) =\sigma_{C_1}(R)\times \sigma_{C_2}(S)\)</span>其中 <spanclass="math inline">\(Attr(C_1)\subseteq Attr(R)\)</span><spanclass="math inline">\(Attr(C_2)\subseteq Attr(S)\)</span></li><li>交、并、差运算对于 <spanclass="math inline">\(\sigma\)</span>的分配律</li><li>投影和集合并运算的分配律</li></ol></li><li>应用连接和笛卡尔积的结合律，按照小关系先做的原则，重新安排连接的次序</li><li>如果笛卡尔乘积后还需要按照按连接条件进行选择操作，可以将两者组合成连接操作</li><li>对叶节点进行必要的投影操作，消除对于查询无用的属性。</li></ol><h3 id="物理优化-依赖于存取路径的规则优化">物理优化 —依赖于存取路径的规则优化</h3><h4 id="选择操作实现和优化">选择操作实现和优化</h4><p>选择条件有等值、范围、集合之分。</p><ol type="1"><li>最原始的实现方法：<strong>顺序扫描</strong>。</li><li>B+树索引、Hash 散列</li></ol><h4 id="连接操作的实现和优化">连接操作的实现和优化</h4><ol type="1"><li>嵌套循环法：应当将物理块绍的关系作为外关系</li><li>利用索引或散列寻找匹配元组法</li><li>归并排序法：需要 RS 都按照连接属性排序</li><li>散列连接法</li></ol><h4 id="投影操作的实现">投影操作的实现</h4><p>如果在投影的属性集合中没有主键，投影结果中可能出现重复元组 →排序或散列去重</p><h4 id="集合操作的实现">集合操作的实现</h4><p>笛卡尔积一般用嵌套循环法实现 — 少用</p><h4 id="组合操作">组合操作</h4></div><h2 id="事务-1">事务</h2><div class="story post-story"><h3 id="恢复引论">恢复引论</h3><p>主要可能有四类错误：</p><ol type="1"><li><p>事务内部的故障：事务在运行至正常终点前被终止有的是可以由事务程序发现的，有些是非预期的事务终止；事务可以通过rollback修复预期之中故障，更多的故障是非预期的，如运算溢出、死锁</p></li><li><p>系统故障（软故障）：CPU 错误、系统断电等造成的系统运转停止系统故障不破坏数据库，只会造成事务的非正常终止，内存中数据库缓冲区丢失</p><p>系统故障的恢复需要：</p><ol type="1"><li>撤销（undo）所有未完成的事务（事务非正常终止）</li><li>重做（redo）所有已提交的事务（有些已完成的事务可能有部分留在缓冲区尚未写入数据库）</li></ol></li><li><p>介质故障（硬故障）：磁盘损坏、强磁场干扰造成的介质故障</p></li><li><p>计算机病毒</p></li></ol><p>两个措施：</p><ol type="1"><li>可靠性</li><li>故障恢复</li></ol><p>对于恢复：数据<strong>冗余是必须的</strong>。</p><ol type="1"><li><p>单纯以后背副本为基础的恢复技术</p></li><li><p>以<strong>后备副本</strong>和<strong>运行记录</strong>为基础的恢复技术</p><ol type="1"><li>前像 BI — 更新前的映像 — undo</li><li>后像 AI — 更新后的映像 — redo</li><li>事务状态：<ol type="1"><li>提交 commit — 成功执行标志</li><li>消除事务对数据库的影戏那个 — rollback / abort</li></ol></li></ol><p>用的最多、独立失效模式</p></li><li><p>基于多副本的恢复技术 — 独立的失效模式</p></li></ol><h3 id="运行记录的结构">运行记录的结构</h3><p>记录和数据库一般不在一张磁盘上。</p><p>运行记录一般包括：</p><ol type="1"><li>活动事务表 ATL：正在执行、未提交的事务标识符 TID</li><li>提交事务表 CTL：已经提交的事务 TID</li><li>前像文件：<code>undo(undo(..undo(x)..)) = undo(x)</code></li><li>后像文件：<code>redo(redo(..redo(x)..)) = redo(x)</code></li></ol><h3 id="更新事务的执行和恢复">更新事务的执行和恢复</h3><p>更新事务应该满足如下的原则：</p><ol type="1"><li>提交原则：后像必须在事务提交之前写入非易失存储器中</li><li>先记后写规则</li></ol><p>因此有三种可能的解决方案，都可以通过判断所在 ATL 和 CTL的位置来进行恢复。</p><h4 id="ai-在-commit-前写入">AI 在 Commit 前写入</h4><ol type="1"><li>TID→ATL</li><li>BI→log</li><li>AI→DB,log</li><li>TID→CTL</li><li>ATL 删除 TID</li></ol><h4 id="ai-在提交后写入">AI 在提交后写入</h4><ol type="1"><li>TID→ATL</li><li>AI → LOG</li><li>TID → CTL</li><li>AI → DB</li><li>从 ATL 删除 TID</li></ol><h4 id="ai-在提交前后写入">AI 在提交前后写入</h4><ol type="1"><li>TID→ATL</li><li>AI, BI → LOG</li><li>AI → DB（部分）</li><li>TID → CTL</li><li>AI → DB（继续）</li><li>ATL 删除 TID</li></ol><h3 id="消息的处理">消息的处理</h3><h3 id="失效类型和恢复对策">失效类型和恢复对策</h3><h4 id="事务失效">事务失效</h4><ol type="1"><li>事务无法执行、自行夭折（例如没有要访问的数据、输入数据类型不对、除数=0）</li><li>操作员操作失误，撤销事务</li><li>调度原因，终止事务执行（死锁等）</li></ol><p>恢复策略：</p><ol type="1"><li>丢弃事务的消息队列</li><li>如果需要 undo</li><li>从 ATL 删除事务的 TID，删除事务资源</li></ol><h4 id="系统失效">系统失效</h4><ol type="1"><li>掉电</li><li>除了储存介质故障之外的软硬件故障</li></ol><p>策略：</p><ol type="1"><li>重启 DMBS 和操作系统</li><li>恢复到一致状态</li></ol><div class="note "><p><strong>存在的问题-CP的意义</strong></p><p>因为事务可以在提交前和提交后将数据的 AI 分别写入数据库，因此，对于 CTL中的事物只能<strong>全部</strong>redo，很费时间。</p><blockquote><p>虽然可能 CTL 中的很多事务都已经写入，但是鉴别的代价很大</p></blockquote></div><blockquote><p>可以设置检查点 CP，来强制写入已提交但没有更新数据库的后像。</p></blockquote><p>取 CP 的过程一般如下：</p><ol type="1"><li>暂停事务的执行和接受新的事务</li><li>上一个 CP 之后的所有事物 AI 写入数据库</li><li>在运行记录的 CTL 中记下检查点</li><li>恢复数据库、恢复事务的正常运行</li></ol><p>好处：对于<strong>系统失效</strong>恢复，只需要对于最近的检查点之后提交的更新事务进行redo。</p><p>缺点：影响数据库的正常运行。</p><h4 id="介质失效">介质失效</h4><p>磁盘故障导致的数据库受损。</p><p>恢复如下：</p><ol type="1"><li>修复系统、磁盘</li><li>重新启动系统</li><li>加载最近的后备副本</li><li>用档案存储器内<code>运行记录</code>中的 AI，redo后备副本之后的所有更新事务</li></ol><h3 id="并发控制">并发控制</h3><h4 id="数据库系统中的并发">数据库系统中的并发</h4><h4 id="目的">目的</h4><ol type="1"><li>改善利用率和吞吐率</li><li>改善短事务的响应时间</li></ol><h4 id="问题">问题</h4><ol type="1"><li>丢失更新 — 写-写冲突</li><li>读脏数据 — 读-写冲突</li><li>读值不可复现 — 读-写冲突</li></ol><h4 id="正确性原则">正确性原则</h4><dl><dt>调度</dt><dd>对 n 个事务的安排</dd><dt><strong>目标等价</strong></dt><dd>对于同一个事务集，可能有多种调度。如果其中两个调度在任何初始状态下读出的数据相同，最终数据库状态相同，那么称两个调度是目标等价的。</dd></dl><p><strong>冲突等价</strong></p><ol type="1"><li>冲突的操作 — 冲突的操作会影响执行的结果</li><li>不冲突的操作 — 次序可以相互调换，不会影响结果</li></ol><dl><dt><strong>可串行化的</strong></dt><dd>调度和一个串行调度等价</dd></dl><p>冲突可串行化 → 目标可串行化（充分条件）</p><p>一般指冲突可串行化</p><h3 id="加锁协议">加锁协议</h3><h4 id="x-锁">X 锁</h4><p>X-排他锁</p><table><tbody><tr class="odd"><td>请求</td><td>NL</td><td>X</td></tr><tr class="even"><td>X</td><td>y</td><td>n</td></tr><tr class="odd"><td>NL</td><td>y</td><td>y</td></tr></tbody></table><div class="note "><p><strong>连锁卷回问题</strong></p><p>过早的释放了锁，导致了读值不可复现。</p><p>解决方法：锁保持到事务结束</p></div><h4 id="两段加锁">两段加锁</h4><ol type="1"><li>若加锁动作都在所有释放锁之前 — 两段事务</li><li>合式事务 Well-Formed</li></ol><p>若所有事务都是合式、两段事务 → 可串行化的</p><blockquote><p>加锁机制发展- 提高并发控制能力</p></blockquote><blockquote><p>应该规定 FCFS</p></blockquote><h4 id="sx-锁">SX 锁</h4><ul><li>S（Share Lock）用于读访问</li><li>X（eXclusive Lock）用于写访问</li></ul><table><thead><tr class="header"><th>请求</th><th>NL</th><th>S</th><th>X</th></tr></thead><tbody><tr class="odd"><td>S</td><td>y</td><td>y</td><td>n</td></tr><tr class="even"><td>X</td><td>y</td><td>n</td><td>y</td></tr><tr class="odd"><td>NL</td><td>y</td><td>y</td><td>y</td></tr></tbody></table><h4 id="sux-锁">SUX 锁</h4><table><thead><tr class="header"><th>请求</th><th>S</th><th>U</th><th>X</th><th>NL</th></tr></thead><tbody><tr class="odd"><td>S</td><td>y</td><td>y</td><td>n</td><td>y</td></tr><tr class="even"><td>U</td><td>y</td><td>n</td><td>n</td><td>y</td></tr><tr class="odd"><td>X</td><td>n</td><td>n</td><td>n</td><td>y</td></tr><tr class="even"><td>NL</td><td>y</td><td>y</td><td>y</td><td>y</td></tr></tbody></table><p>注意 U-U 是不允许的，因为会导致死锁问题。</p><div class="note "><p><strong>是否SUX锁能保证没有死锁</strong></p><p>不能，需要有正确的锁顺序。例如：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">A: <span class="constructor">X(<span class="params">a</span>)</span> -&gt; <span class="constructor">S(<span class="params">b</span>)</span></span><br><span class="line">B: <span class="constructor">X(<span class="params">b</span>)</span> -&gt; <span class="constructor">S(<span class="params">a</span>)</span></span><br></pre></td></tr></table></figure><p>发生循环等待。</p><p>可以用相同的加锁顺序来防止死锁发生。</p></div><h3 id="死锁的检测处理和防止">死锁的检测处理和防止</h3><ol type="1"><li>检测、处理<ol type="1"><li>超时法</li><li>等待图法</li></ol></li><li>防止<ol type="1"><li>等待死亡法</li><li>击伤等待法</li></ol></li></ol></div><h2 id="关系数据库规范化">关系数据库规范化</h2><div class="story post-story"><h3 id="规范化的必要性">规范化的必要性</h3><p>基本要求：</p><ol type="1"><li>满足 1NF：每一个分量必须是不可分的数据项</li><li>数据库中的数据冗余尽可能少</li><li>不能因为数据更新导致数据不一致的问题</li><li>不能在执行插入时发生插入一场</li><li>不能在执行删除时产生删除一场问题</li><li>考虑查询需求，数组组织合理</li></ol><p>可能出现的问题：</p><ol type="1"><li>数据冗余大</li><li>插入一场</li><li>删除异常</li><li>更新异常</li></ol><h3 id="关系表示法">关系表示法</h3><p>关系的简化表示法：</p><p><span class="math display">\[R\langle U,D,Dom,F\rangle\]</span></p><p>分别表示：</p><ol type="1"><li>关系属性集合<span class="math inline">\(U\)</span></li><li>属性集<span class="math inline">\(U\)</span>中属性的数据域</li><li><span class="math inline">\(Dom\)</span>为从属性到域的映射</li><li><span class="math inline">\(F\)</span> 为函数依赖集</li></ol><h3 id="范式">范式</h3><dl><dt>1NF</dt><dd>所有属性都是简单属性（每个属性都不可再分）</dd><dt>2NF</dt><dd>1NF 的前提下，每一个非主属性都完全依赖于<strong>码</strong>。</dd><dt>3NF</dt><dd>2NF 前提下，不存在这样的码 X、属性组 Y、非主属性 Z，使得 X<spanclass="math inline">\(\rightarrow\)</span>Y，Y<spanclass="math inline">\(\not\rightarrow\)</span>X，Y<spanclass="math inline">\(\rightarrow\)</span>Z。</dd><dt>BCNF</dt><dd>满足如下条件</dd></dl><ol type="1"><li>非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码是完全依赖</li><li>没有任何属性依赖于非码的任何一组属性</li></ol><h3 id="关系模式分解方法">关系模式分解方法</h3><dl><dt>函数依赖闭包</dt><dd>逻辑蕴含的函数依赖全体（从 <span class="math inline">\(F\)</span> 到<span class="math inline">\(F^+\)</span>）</dd><dt>属性集闭包</dt><dd>对<span class="math inline">\(X\)</span>，从<spanclass="math inline">\(F\)</span>中能够推出的属性集<spanclass="math inline">\(X_F^+\)</span></dd><dt>函数依赖集的等价</dt><dd>闭包相等</dd></dl><h4 id="函数依赖集的最小化">函数依赖集的最小化</h4><dl><dt>最小依赖集</dt><dd>满足如下条件</dd></dl><ol type="1"><li>F 中的任一函数依赖的右部只有 1 个属性</li><li>不存在函数依赖<span class="math inline">\(X\rightarrowA\)</span>使得<span class="math inline">\(F\sim F-\{X\rightarrowA\}\)</span></li><li>不存在函数依赖<span class="math inline">\(X\rightarrowA\)</span>，<span class="math inline">\(X\)</span>有真子集<spanclass="math inline">\(Z\)</span>使得<spanclass="math inline">\(F-\{X\rightarrow A\}\cup\{Z\rightarrow A\}\simF\)</span></li></ol><div class="note "><p><strong>最小依赖集的求法</strong></p><ol type="1"><li>检查函数依赖，对于条件 1 拆分</li><li>逐个检查函数依赖<span class="math inline">(X A)</span>，检查条件2，若<span class="math inline">(A X_{F-{XA}}^+)</span>则从 F中消除这个依赖</li><li>逐个检查函数依赖<span class="math inline">(X A)</span>，对于<spanclass="math inline">(X=B_1 B_m)</span>，若<span class="math inline">(A(X-B_i)^+_F)</span>那么用<spanclass="math inline">(X-B_i)</span>取代<spanclass="math inline">(X)</span></li></ol></div><dl><dt>码</dt><dd>设 <span class="math inline">\(R\langle A_1, ..., A_n\rangle\)</span>是一个关系模式，<span class="math inline">\(F\)</span>是一组函数依赖，如果 X 满足：（1）<spanclass="math inline">\(X\rightarrow A_1,...,A_n \inF^+\)</span>（2）真子集 Y 都不满足（1）条件；那么称 X 是 R 的码。</dd></dl><h4 id="算法">算法</h4><div class="note "><p><strong>转化为保持函数依赖的3nf</strong></p><ol type="1"><li>先求出正则覆盖 Fc</li><li>对于 Fc 里面的所有函数依赖 a-&gt;b,均转化为 Ri=ab</li><li>对于所有的模式 Ri<ol type="1"><li>如果包含候选码，进行第 4</li><li>如果都不包含候选码， 将任意一个候选码添加到模式 Ri 里面</li></ol></li><li>如果一个模式被另一个模式包含，则去掉此被包含的模式。</li></ol></div><div class="note "><p><strong>转化为无损链接、保持函数依赖的3nf</strong></p><ol type="1"><li>求出保持函数依赖的3nf分解 <span class="math inline">()</span>，设 X 是 R的码，<spanclass="math inline">(= { R ^*X, F_X})</span></li><li>观察新组成的分解模式中，是否存在包含关系，有则去掉被包含的。</li></ol></div><details ><summary> 例题 </summary>              <div class='content'>              <p>【例】关系模型R&lt; U, F&gt;，U={A，B，C，D，E}，F={A→BC，ABD→CE，E→D}</p><p><strong>算法一</strong>：将关系R转化3NF的保持函数依赖的分解</p><p>第一步：首先计算出F的最小依赖集（算法详见最小函数依赖），得到F'={A→BC，AD→E，E→D}。</p><p>第二步：观察U中是否有属性不在F'中的出现，如果有，则这个个属性组成一对关系R,并在原来的U中删除这些属性。而例子中U中的属性都出现在F中，则可以跳过这一步。</p><p>第三步：对F'中的函数依赖，把左边的相同分为一组，一组中出现的所有属性为一个关系。如F={A→B，A→C，……}，左边都为A的分为一组，出项的所有属性组为一个关系R{A，B，C，……}。例题中左边都不相同，所以一个函数依赖组为一个关系得到转化为3NF的保持依赖分解R1{A,B,C}，R2{A,D,E}，R3{E,D}。</p><p><strong>算法二</strong>：将关系R转化3NF的既有无损连接性又保持函数依赖的分解</p><p>第一步：先将R转化3NF的保持函数依赖的分解，由算法一得出R1{A,B,C}，R2{A,D,E}，R3{E,D}。</p><p>第二步：求出F的候选码（算法相见候选码算法）得出候选码X为AD和AE。</p><p>第三步：将候选码单独组成关系得R4{A,D}和R5{A,E}，然后与保持函数依赖后的分解取并集。得R1{A,B,C}，R2{A,D,E}，R3{E,D}，R4{A,D}，R5{A,E}。</p><p>第四步：观察新组成的分解模式中，是否存在包含关系，有则去掉被包含的。如R3{E,D}，R4{A,D}，R5{A,E}都包含于R2{A,D,E}，则删去，最终得到转化3NF的既有无损连接性又保持函数依赖的分解R1{A,B,C}，R2{A,D,E}。</p>              </div>            </details><div class="note "><p><strong>转换为BCNF无损分解</strong></p><ol type="1"><li>let <span class="math inline">(= RU , F )</span></li><li>检查 <span class="math inline">()</span> 是否满足BCNF</li><li>对于不满足BCNF的 Ri 分解，因为Ri中必然有 <spanclass="math inline">(XAF_i,AX)</span>且X不是Ri的码，XA是Ui的真子集。Ri分解为 <spanclass="math inline">({S_1, S _ 2})</span>，<spanclass="math inline">(U_{S_1} = XA, U_{S_2} = U_i-{A})</span>返回2</li></ol></div></div><h2 id="题目汇总">题目汇总</h2><div class="story post-story"><div class="note "><p><strong>B+树计算</strong></p><p>假设物理块的有效大小 B=492 字节，块的指针为 6 字节，Sailors 表的 sid属性 2 字节，sname 占 4 字节，rating 占 1 字节，age 占 1 字节，master 占2 字节。每个记录除属性外，还需增加一个字节作为删除标记。</p><ol type="1"><li><p>若 Sailors 表的 rating 属性上建有 B+树簇集索引，求 B+树的秩 k？（6 分）</p><p>索引集 ： 2k * 1 (K) + (2k+1)* 6 (P) ≤ 492</p><p>顺序集 ： 2k * 1 (K) + 2 * 6 (前后向指针) + 2k * 6 (P 因为是次索引) ≤492</p></li><li><p>若 Sailors 表的 sid 属性上建有 B+树的主索引，求 B+树的秩 k？（6 分）</p><p>索引集 ： 2k * 2 + (2k + 1)* 6 ≤ 492</p><p>顺序集 ： 2k * 2 (K) + 2 * 6 (前后向指针) + 2k * (6+2) (tid= P +块内偏移值 = 6+2，因为是主索引、块有效大小为 492，需要 2B作为块内偏移值) ≤ 492</p></li><li><p>数据块的块因子是指一个块能够存放的记录数目：p = B/(2+4+1+1+2+1) = 492/11= 44</p></li></ol></div><div class="note "><p><strong>触发器</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> <span class="operator">&lt;</span>trigger_name<span class="operator">&gt;</span></span><br><span class="line">&#123;before <span class="operator">|</span> after&#125; <span class="operator">&lt;</span>trigger_event<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">referencing</span> <span class="operator">&lt;</span>ref_name<span class="operator">&gt;</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> &#123;<span class="type">row</span> <span class="operator">|</span> statement&#125;</span><br><span class="line"><span class="keyword">when</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>action<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>trigger_event<span class="operator">&gt;</span>:<span class="operator">=</span> <span class="keyword">insert</span> <span class="operator">|</span> <span class="keyword">update</span> <span class="operator">|</span> <span class="keyword">delete</span> [<span class="keyword">of</span> <span class="operator">&lt;</span>attribute_list<span class="operator">&gt;</span>]</span><br><span class="line"><span class="operator">&lt;</span>ref_name<span class="operator">&gt;</span> :<span class="operator">=</span> <span class="keyword">old</span> [<span class="type">row</span>] [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br><span class="line">              <span class="keyword">new</span> [<span class="type">row</span>] [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br><span class="line">              <span class="keyword">old</span> <span class="keyword">table</span> [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br><span class="line">              <span class="keyword">old</span> <span class="keyword">table</span> [<span class="keyword">as</span>]<span class="operator">&lt;</span>name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>其中的<code>action</code>常为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span></span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ne</span><br><span class="line">    <span class="keyword">where</span> ne.grade <span class="operator">&lt;</span> <span class="number">3.0</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><p>其中的 insert 语句的语法为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">values</span> (...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line">    [<span class="keyword">SQL</span>]</span><br></pre></td></tr></table></figure><p>其中的<code>[SQL]</code>部分为一个查询语句，它导致插入可能不止一个元组。</p></div><div class="timeline"><p class='p h2'>概念题</p><div class="timenode"><div class="meta"><p><p>什么是基本表?什么是视图?两者的区别和联系是什么?</p></p></div><div class="body"><p>基本表是实际存储在数据库中的二维表，它是本身独立存在的表，在 SQL中一个关系就对应一个表。</p><p>区别:视图是从一个或几个基本表(或视图)中导出的表，是一个虚表，数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。</p><p>视图是关系数据库系统提供给用户以多种角度观察数据库中数据的重要机制。</p></div></div><div class="timenode"><div class="meta"><p><p>什么叫数据与程序的物理独立性?什么叫数据与程序的逻辑独立性?</p></p></div><div class="body"><p>数据与程序的物理独立性是指当数据库的存储结构改变，将模式 /内模式映象作相应改变，使模式保持不变，从而应用程序不必改变。</p><p>数据与程序的逻辑独立性是指当模式改变时，将外模式 /模式的映象作相应改变，使外模式保持不变，从而应用程序不用修改。</p></div></div><div class="timenode"><div class="meta"><p><p>事务所具有的 ACID 特性。</p></p></div><div class="body"><p>事务的 ACID 特性是:</p><ul><li>原子性:事务是一个不可分割的单位。</li><li>一致性:事务对数据库操作的结果是将数据库从一个一致性状态变为另一个一致性状态。</li><li>隔离性:多个事务的并发执行不互相干扰。</li><li>持续性:事务一旦提交，它对数据库中数据的改变就是永久性的。</li></ul></div></div><div class="timenode"><div class="meta"><p><p>登记日志文件时为什么必须先写日志文件，后写数据库?</p></p></div><div class="body"><p>答:把数据的修改写到数据库和把对数据的修改操作写到日志文件是两个不同的操作，在两个操作之间可能会发 生故障如果先写了数据库修改，而在日志文件中没有登记这个修改， 在恢复的时候就无法恢复这个修改了;如果先写日志，但没有修改数据库，按日志恢复时只是多执行一次撤消操作，并不影响数据库的正确性，为了安全，一定要先写日志文件。</p></div></div><div class="timenode"><div class="meta"><p><p>DBMS的完整性控制机制应具有哪些功能?</p></p></div><div class="body"><p>应具有三方面的功能:</p><ol type="1"><li>定义功能，提供定义完整性条件的机制</li><li>检查功能，检查用户发出的操作请求是否违背了完整性约束条件。</li><li>如果发现用户的操作请求违背了完整性约束条件，则采取一定的动作来保证数据的完整性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>什么是数据字典?数据字典的作用是什么?</p></p></div><div class="body"><p>数据字典是系统中各类数据描述的集合</p><p>作用:供 DBMS 在处理数据存取时快速查找有关对象的信息，供 DBA查询掌握系统的运行情况，支持数据库 设计和系统分析。</p></div></div><div class="timenode"><div class="meta"><p><p>什么样的并发调度是正确的调度?</p></p></div><div class="body"><p>多个事务的并发执行的结果与按某一次序串行的执行它们时的结果相同，我们说这样的并发调度是可串行化的调度，如果一个调度是可串行化的，那么认为它是正确的调度。</p></div></div><div class="timenode"><div class="meta"><p><p>试叙述事务的 4个性质，并结实每一个性质由DBMS的哪个子系统实现?每一个性质对DBS有什么益处?</p></p></div><div class="body"><ol type="1"><li>事务的原子性是指一个事务对 DB的所有操作，是一个不可分割的工作单位。原子性是由 DBMS的事务管理子系统实现的。事务的原子性保证了 DB 的完整性。</li><li>事务的一致性是指数据不会因事务的执行而遭受破坏。事务的一致性是由DBMS 的完整性子系统实现的。 事务的一致性保证数据库的完整性。</li><li>事务的隔离性是指事务的并发执行与这些事务单独执行时结果一样。事务的隔离性是由DBMS的并发控制子系统实现的。隔离性使并发执行的事务不必关心其他事务，如同在单用户环境下执行一样。</li><li>事务的持久性，是指事务对 DB 的更新应永久地反映在 DB 中。持久性是由DBMS 的恢复管理子系统实现的。 持久性能保证 DB 具有可恢复性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>事务的COMMIT语句和ROLLBACK语句的功能是什么?</p></p></div><div class="body"><ul><li>COMMIT 语句表示事务执行成功地接结束(提交)，此时告诉系统，DB要进入一个新的正确状态，该事务对 DB 的所有更新都已交付实施(写入磁盘)。</li><li>ROLLBACK语句表示事务执行不成功地结束(应该“回退”)此时告诉系统，已发生错误，DB可能处在不正确的状态，该事务对 DB 的所有更新必须被撤消，DB应恢复该事务到初始状态。</li></ul></div></div><div class="timenode"><div class="meta"><p><p>日志文件中记载了哪些内容?</p></p></div><div class="body"><p>答:日志文件中记载了事务开始标记、事务结束标记以及事务对 DB的插入、删除和修改的每一次操作前后的值。</p></div></div><div class="timenode"><div class="meta"><p><p>并发操作会产生几种不一致情况?用什么方法避免各种不一致的情况?</p></p></div><div class="body"><p>答:并发操作可能会产生丢失修改，不能重复读和读”脏”数据这三种不一致情况，采用封锁机制来进行并发控制，可避免各种不一致情况。一级封锁协议可以避免丢失修改，二级封锁协议可以避免丢失修改和读”脏”数据，三级封锁协议可以避免丢失修改、不能重复读和读”脏”数据。</p></div></div><div class="timenode"><div class="meta"><p><p>X封锁与S封锁有什么区别?</p></p></div><div class="body"><table><colgroup><col style="width: 38%" /><col style="width: 61%" /></colgroup><thead><tr class="header"><th>X 锁</th><th>S 锁</th></tr></thead><tbody><tr class="odd"><td>只允许一个事务独锁数据</td><td>允许多个事务并发 S 锁某一数据</td></tr><tr class="even"><td>获准 X 锁的事务可以修改数据</td><td>获准 S 锁的事务只能读取数据，但不能修改数据</td></tr><tr class="odd"><td>事务的并发度低</td><td>事务的并发度高，但增加了死锁的可能性</td></tr><tr class="even"><td>X 锁必须保留到事务终点</td><td>根据需要，可随时解除 S 锁</td></tr><tr class="odd"><td>解决“丢失更新”问题</td><td>解决“读不一致性”问题</td></tr></tbody></table></div></div><div class="timenode"><div class="meta"><p><p>为什么要设立日志文件</p></p></div><div class="body"><p>答:设立日志文件的目的，是为了记录对数库中数据的每一次更新操作，从而DBMS可以根据日志文件进行事务故障的恢复和糸统故障的恢复，并可结合后授副本进去介质故障的恢复。</p></div></div><div class="timenode"><div class="meta"><p><p>怎样进行系统故障的恢复?</p></p></div><div class="body"><p>系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤消故障发生时未完成的事务，重做已完成的事务。</p><ol type="1"><li>正向扫描日志文件(即从头扫描日志文件)，找出在故障发生前已经提交的事务(这些事务既有BEGIN TRANSACTION 记录，也有 COMMIT 记录)，将其事务标识记入重做(REDO)队列。同时找出故障发生时尚未完成的 事务(这些事务只有 BEGINTRANSACTION 记录，无相应的 COMMIT 记录)，将其事务标识记入撤消(UNDO)队列。</li><li>对撤消队列中的各个事务进行撤消 (UNDO)处理。进行 UNDO处理的方法是，反向扫描日志文件，对每个 UNDO 事务的更新操作执行逆操作，即将日志记录中 “更新前的值”写入数据库。</li><li>对重做队列中的各个事务进行重做 (REDO)处理。进行 REDO 处理的方法是:正向扫描日志文件， 对每个 REDO 事务重新执行日志文件登记的操作。即将日志记录中“更新后的值”写入数据库。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行介质故障的恢复?</p></p></div><div class="body"><p>发生介质故障后，磁盘上的物理数据和日志文件被破坏，恢复方法是重装数据库，然后重做已完成的事务。具体地说就是:</p><ol type="1"><li>装入最新的数据库后备副本 (离故障发生时刻最近的转储副本)，使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还须同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法(即REDO+UNDO)，才能将数据库恢复到一致性状态。</li><li>装入相应的日志文件副本(转储结束时刻的日志文件副本)，重做已完成的事务。即:首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>数据库在运行过程中可能产生的故障有哪几类?</p></p></div><div class="body"><ol type="1"><li><p>事物故障</p><p>事物在运行过程中由于种种原因，如输入数据的错误，运算溢出，违反了某些完整性限制，某些应用程序的错误，以及并行事物发生死锁等，使事物未能运行到正常中指点之前就被撤消了，这种情况称为“事物故障”。</p></li><li><p>系统故障</p><p>系统故障是指系统在运行过程中，由于某些原因，如 OS 和 DBMS代码错误，操作员操作事物。特定类型的硬件错误(CPU故障)，突然停电等造成系统停止运行，致使事物在执行过程中以非控方式中指。这时。内存中的信息丢失，而存储在外存储上的数据未受影响，这种情况称为“系统故障”。</p></li><li><p>介质故障</p><p>系统在运行过程中，由于某种硬件故障，如磁盘损坏，磁头碰撞，或由于 OS的某种潜在的错误。瞬间强磁场干扰，使存储在外存的数据部分损失或全部损失，称之为“介质故障”。</p></li><li><p>计算机病毒</p><p>计算机病毒是一种人为的故障和破坏，它是一种计算机程序，通过读写染有病毒的计算机系统中的程序和数据这些病毒可以迅速繁殖和传播，危害计算机系统和数据库。</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行事务故障的恢复</p></p></div><div class="body"><p>事务故障是指事务在运行至正常终止点前被中止，这时恢复子系统应利用日志文件撤消(UNDO)此事务已对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。系统的恢复步骤是:</p><ol type="1"><li>反向扫描文件日志(即从最后向前扫描日志文件)，查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。这样，如果记录中是插入操作，则相当于做删除操作(因此时“更新前的值”为空)。若记录中是删除操作，则做插入操作，若是修改操作，则相当于用修改前值代替修改后值。</li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。 (4)如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述文件系统与数据库系统的区别和联系</p></p></div><div class="body"><p>文件系统与数据库系统的区别是:</p><ol type="1"><li>文件系统面向某一应用程序，共享性差，冗余度大，数据独立性差，记录内有结构，整体无结构，由应用程序自己控制。</li><li>数据库系统面向现实世界， 共享性高， 冗余度小，具有较高的物理独立性和一定的逻辑独立性，整体结构化，用数据模型描述，由数据库管理系统提供数据的安全性、完整性、并发控制和恢复能力。</li></ol><p>文件系统与数据库系统的联系:</p><ol type="1"><li>文件系统与数据库系统都是计算机系统中管理数据中管理数据的软件。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>DBA的职责是什么?</p></p></div><div class="body"><ol type="1"><li>决定数据库中的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据的安全性要求和完整性约束条件</li><li>监控数据库的使用和运行</li><li>数据库的改进和重组重构</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述查询优化的一般步骤。</p></p></div><div class="body"><ol type="1"><li>把查询转换成某种内部表示</li><li>把语法树转换成标准(优化)形式</li><li>择低层的存取路径</li><li>生成查询计划，选择代价最小的</li></ol></div></div><div class="timenode"><div class="meta"><p><p>数据库中为什么要有恢复子系统?它的功能是什么?</p></p></div><div class="body"><p>因为计算机系统中硬件的故障、软件的错误、操作员的失误以及恶意的破坏是不可避免的，这些故障轻则造成运行事务非正常中断，影响数据库中数据的正确性，重则破坏数据库，使数据库中全部或部分数据丢失。</p><p>功能:</p><ul><li>是把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)，这就是数据库的恢复。</li></ul></div></div><div class="timenode"><div class="meta"><p><p>数据库转储的意义是什么?常用的有几种方法?</p></p></div><div class="body"><p>数据转储是数据库恢复中采用的基本技术，所谓转储即 DBA定期将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本或后援副本。当数据库遭到破坏后可以将后备副本重新载入，将数据库恢复到转储时的状态。</p><p>转储可分为静态转储和动态转储。静态转储是在系统中无运行事务时进行的转储操作。动态转储是指转储期间允许对数据库进行存取或修改。即转储和用户事务可以并发执行。转储还可分为海量转储和增量转储两种方式。</p></div></div><div class="timenode"><div class="meta"><p><p>试述使用检查点方法进行恢复的步骤。</p></p></div><div class="body"><ol type="1"><li><p>从重新开始文件中找到追后一个检查点记录在日志文件中的地址，由该地址在体制文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列:</p><ol type="1"><li>UNDO-LIST:需要执行 undo 操作的事务集合;</li><li>REDO-LIST 需要执行 redo 操作的事务集合。</li></ol><p>把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列， REDO 队列暂时为空。</p></li><li><p>检查点开始正向扫描日志文件:</p><ol type="1"><li>如果有新开始的事务 Ti ，把 Ti 暂时放入 UNDO-LIST 队列;</li><li>如有提交的事务 T j ，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST队列，直到日志文件结束;</li></ol></li><li><p>对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST中的每个事务执行 REDO 操作。</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>什么是数据库镜像?它有什么用途?</p></p></div><div class="body"><p>根据 DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS 自动把更新后的数据恢复过去，即 DBMS自动保证镜像数据与主数据的一致性。 用途:</p><ol type="1"><li>一旦出现介质故障， 可由镜像磁盘继续提供使用， 同时 DBMS自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本。</li><li>在没有出现故障时，数据库镜像还可以并发操作。提高数据库的可用性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>请给出预防死锁的若干方法。</p></p></div><div class="body"><p>在数据库中，产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。</p><p>预防死锁通常有两种方法:</p><ol type="1"><li>一次封锁法。一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。</li><li>顺序封锁法。顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>请给出检测死锁发生的方法，当发生死锁后如何解决死锁?答:一般使用超时法或事务等待图法。</p></p></div><div class="body"><ol type="1"><li>超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显。一是有可能误判死锁，事务因为其他原因使等待时间超过时限， 系统会误认为发生了死锁。二是时限若设置得太长， 死锁发生后不能及时发现。</li><li>等待图法：事务等待图是一个有向图 G=(T,U) 。 T为结点的集合，每个结点表示正运行的事务; U 为边的集合，每条边表示事务等待的情况。若 T1 等待 T2 , 则 T1、T2 之间划一条有向边，从 T1指向 T2。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地(比如每隔 1分钟)检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。</li></ol><p>DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务得以继续运行下去。当然，对撤消的事务所执行的数据修改操作必须加以恢复。</p></div></div><div class="timenode"><div class="meta"><p><p>试述两段锁协议的概念。</p></p></div><div class="body"><p>所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。</p><ol type="1"><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁;</li><li>在释放一个封锁之后，事务不再申请和获得对该数据的封锁。</li></ol><p>所谓“两段”锁的含义是，事务分为两个阶段，第一阶段是获得封锁，也称为扩展阶段。在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这个阶段，事务可以释放任何数据项上的任何类型锁，但是不能再申请任何锁。</p></div></div><div class="timenode"><div class="meta"><p><p>什么是数据库的完整性约束条件?</p></p></div><div class="body"><p>答:完整性约束条件是指数据库中的数据应满足的语义约束条件。一般可以分为六类:</p><ol type="1"><li>静态列级约束</li><li>静态元组约束</li><li>静态关系约束</li><li>动态列级约束</li><li>动态元组约束</li><li>动态关系约束</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试说明数据、数据库、数据库管理系统和数据库系统的概念以及它们之间的关系。</p></p></div><div class="body"><ol type="1"><li>数据(Data)：描述事物的符号记录称为数据。数据的种类有数字、文字、图形、图像、声音、正文等。数据与其语义是不可分的。</li><li>数据库(Database, 简称DB)：数据库是长期储存在计算机内的、有组织的、可共享的数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。</li><li>数据库系统(Database System，简称DBS)：数据库系统是指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统(及其开发工具) 、应用系统、数据库管理员构成。</li><li>数据库管理系统（ Database Management System，简称 DBMS)：数据库管理系统是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据、高效地获取和维护数据。DBMS的主要功能包括数据库的建立和维护功能、数据定义功能、数据组织存储和管理功能、数据操作功能、事务的管理和运行功能。</li></ol><p>它们之间的联系：数据库系统包括数据库、数据库管理系统、应用系统、数据库管理员，所以数据库系统是个大的概念。数据库是长期存储在计算机内的有组织、可共享的大量的数据集合，数据库管理系统是由管理员操作管理数据库的查询、更新、删除等操作的，数据库应用系统是用来操作数据库的。</p></div></div><div class="timenode"><div class="meta"><p><p>比较用文件管理和用数据库管理数据的主要区别。</p></p></div><div class="body"><p>数据库系统与文件系统相比实际上是在应用程序和存储数据的数据库之间增加了一个系统软件，即数据库管理系统，使得以前在应用程序中由开发人员实现的很多繁琐的操作和功能，都可以由这个系统软件完成，这样应用程序不再需要关心数据的存储方式，而且数据的存储方式的变化也不再影响应用程序。而在文件系统中，应用程序和数据的存储是紧密相关的，数据的存储方式的任何变化都会影响到应用程序，因此不利于应用程序的维护。</p></div></div><div class="timenode"><div class="meta"><p><p>解释数据模型的概念，为什么要将数据模型分成两个层次？</p></p></div><div class="body"><p>数据模型是对现实世界数据特征的抽象。数据模型一般要满足三个条件：第一是数据模型要能够比较真实地模拟现实世界；第二是数据模型要容易被人们理解；第三是数据模型要能够很方便地在计算机上实现。由于用一种模型同时很好地满足这三方面的要求在目前是比较困难的，因此在数据库系统中就可以针对不同的使用对象和应用目的，采用不同的数据模型。根据模型应用的不同目的，将这些模型分为概念层数据模型和组织层数据模型两大类，以方便对信息的描述。</p></div></div><div class="timenode"><div class="meta"><p><p>数据库系统包含哪三级模式？试分别说明每一级模式的作用？</p></p></div><div class="body"><p>数据库系统包含的三级模式为：内模式、模式和外模式。外模式是对现实系统中用户感兴趣的整体数据结构的局部描述，用于满足不同数据库用户需求的数据视图，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是对数据库整体数据结构的子集或局部重构。模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。内模式是对整个数据库的底层表示，它描述了数据的存储结构。</p></div></div><div class="timenode"><div class="meta"><p><p>数据库系统的两级映像的功能是什么？它带来了哪些功能？</p></p></div><div class="body"><p>数据库系统的两级映像是外模式／模式映像和模式／内模式映像。模式／内模式映像定义了概念视图和存储的数据库的对应关系，它说明了概念层的记录和字段在内部层次怎样表示。如果数据库的存储结构改变了，那么，必须对模式／内模式映像进行必要的调整，使模式能够保持不变。外模式／模式映像定义了特定的外部视图和概念视图之间的对应关系，当概念模式的结构可发生改变时，也可以通过调整外模式／模式映像间的映像关系，使外模式可以保持不变。</p></div></div><div class="timenode"><div class="meta"><p><p>什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？</p></p></div><div class="body"><p>数据与程序的物理独立性是指当数据库的存储结构改变，将模式/内模式映象作相应改变，使模式保持不变，从而应用程序不必改变。数据与程序的逻辑独立性是指当模式改变时，将外模式/模式的映象作相应改变，使外模式保持不变，从而应用程序不用修改。</p></div></div><div class="timenode"><div class="meta"><p><p>数据库三级模式划分的优点是什么？它能带来哪些数据独立性？</p></p></div><div class="body"><p>数据库的三级模式的划分实际上将用户、逻辑数据库与物理数据库进行了划分，使彼此之间的相互干扰减到最少。这三个模式的划分实际上带来了两个数据独立性，即物理独立性和逻辑独立性。这使得底层的修改和变化尽量不影响到上层。</p></div></div><div class="timenode"><div class="meta"><p><p>试说明使用视图的好处。</p></p></div><div class="body"><ol type="1"><li>简化数据查询语句</li><li>使用户能从多角度看待同一数据</li><li>提高了数据的安全性</li><li>提供了一定程度的逻辑独立性</li><li></li></ol></div></div><div class="timenode"><div class="meta"><p><p>使用视图可以加快数据的查询速度，这句话对吗？为什么？</p></p></div><div class="body"><p>不对。因为数据库管理系统在对视图进行查询时，首先检查要查询的视图是否存在，如果存在，则从数据字典中提取视图的定义，把视图的定义语句对视图语句结合起来，转换成等价的对基本表的查询，然后再执行转换后的查询，所以使用视图不可以加快数据的查询速度。</p></div></div><div class="timenode"><div class="meta"><p><p>登记日志文件时为什么必须先写日志文件，后写数据库？</p></p></div><div class="body"><p>把数据的修改写到数据库和把对数据的修改操作写到日志文件是两个不同的操作，在两个操作之间可能会发生故障如果先写了数据库修改，而在日志文件中没有登记这个修改，在恢复的时候就无法恢复这个修改了；如果先写日志，但没有修改数据库，按日志恢复时只是多执行一次撤消操作，并不影响数据库的正确性，为了安全，一定要先写日志文件。</p></div></div><div class="timenode"><div class="meta"><p><p>试叙述事务的4个性质，并结合每一个性质由DBMS的哪个子系统实现？每一个性质对DBS有什么益处？</p></p></div><div class="body"><ol type="1"><li>事务的原子性是指一个事务对 DB的所以操作，是一个不可分割的工作单位。原子性是由 DBMS的事务管理子系统实现的。事务的原子性保证了 DBS 的完整性。</li><li>事务的一致性是指数据不会因事务的执行而遭受破坏。事务的一致性是由DBMS 的完整性子系统实现的。事务的一致性保证数据库的完整性。</li><li>事务的隔离性是指事务的并发执行与这些事务单独执行时结果一样。事务的隔离性是由DBMS的并发控制子系统实现的。隔离性使并发执行的事务不必关心其他事务，如同在单用户环境下执行一样。</li><li>事务的持久性，是指事务对 DB 的更新应永久地反映在 DB 中。持久性是由DBMS 的恢复管理子系统实现的。持久性能保证 DB 具有可恢复性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>在数据库中为什么要有并发控制机制？</p></p></div><div class="body"><p>数据库系统一个明显的特点是多个用户共享数据库资源，尤其是多个用户可以同时存取相同数据。在这样的系统中，在同一时刻同时运行的事务可达数百个。若对多用户的并发操作不加控制，就会造成数据库存、取的错误，破坏数据的一致性和完整性。所以数据库中要有并发控制机制。</p></div></div><div class="timenode"><div class="meta"><p><p>怎样进行系统故障的恢复?</p></p></div><div class="body"><p>系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤消故障发生时未完成的事务，重做已完成的事务。</p><ol type="1"><li>正向扫描日志文件（即从头扫描日志文件），找出在故障发生前已经提交的事务（这些事务既有 BEGIN TRANSACTION记录，也有 COMMIT记录），将其事务标识记入重做（REDO）队列。同时找出故障发生时尚未完成的事务（这些事务只有BEGIN TRANSACTION 记录，无相应的 COMMIT记录），将其事务标识记入撤消(UNDO)队列。</li><li>对撤消队列中的各个事务进行撤消(UNDO)处理。进行 UNDO 处理的方法是，反向扫描日志文件， 对每个 UNDO 事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。</li><li>对重做队列中的各个事务进行重做(REDO)处理。进行 REDO 处理的方法是：正向扫描日志文件， 对每个 REDO事务重新执行日志文件登记的操作。即将日志记录中“更新后的值”写入数据库</li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行介质故障的恢复?</p></p></div><div class="body"><p>发生介质故障后，磁盘上的物理数据和日志文件被破坏，恢复方法是重装数据库，然后重做已完成的事务。具体地说就是：</p><ol type="1"><li>装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还须同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。</li><li>装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务。即：首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>怎样进行事务故障的恢复</p></p></div><div class="body"><p>事务故障是指事务在运行至正常终止点前被中止，这时恢复子系统应利用日志文件撤消（UNDO）此事务已对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。系统的恢复步骤是：</p><ol type="1"><li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。这样，如果记录中是插入操作，则相当于做删除操作（因此时“更新前的值”为空）。若记录中是删除操作，则做插入操作，若是修改操作，则相当于用修改前值代替修改后值</li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li><li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述使用检查点方法进行恢复的步骤。</p></p></div><div class="body"><ol type="1"><li><p>从重新开始文件中找到追后一个检查点记录在日志文件中的地址，由该地址在体制文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST 。 这里建立两个事务队列：</p><ol type="1"><li>UNDO-LIST：需要执行 undo 操作的事务集合；</li><li>REDO-LIST 需要执行 redo 操作的事务集合。把 ACTIVE-LIST 暂时放入UNDO-LIST 队列，REDO 队列暂时为空。</li></ol></li><li><p>检查点开始正向扫描日志文件：</p><ol type="1"><li>如果有新开始的事务 Ti ，把 Ti 暂时放入 UNDO-LIST 队列；</li><li>如有提交的事务 Tj ，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST队列，直到日志文件结束；</li></ol></li><li><p>对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST中的每个事务执行 REDO 操作。</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>什么是数据库镜像？它有什么用途？</p></p></div><div class="body"><p>根据 DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS 自动把更新后的数据恢复过去，即 DBMS自动保证镜像数据与主数据的一致性。用途：</p><ol type="1"><li>一旦出现介质故障， 可由镜像磁盘继续提供使用， 同时 DBMS自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本。</li><li>没有出现故障时，数据库镜像还可以并发操作。提高数据库的可用性。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>试述两段锁协议的概念。</p></p></div><div class="body"><p>所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。</p><ol type="1"><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；</li><li>在释放一个封锁之后，事务不再申请和获得对该数据的封锁。</li></ol><p>所谓“两段”锁的含义是，事务分为两个阶段，第一阶段是获得封锁，也称为扩展阶段。在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这个阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。</p></div></div><div class="timenode"><div class="meta"><p><p>数据模型的优化包含哪些方法？</p></p></div><div class="body"><ol type="1"><li>确定各属性间的函数依赖关系。根据需要分析阶段得出的语义，分别写出每个关系模式的各属性之间的函数依赖以及不同关系模式中各属性之间的数据依赖关系。</li><li>对各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</li><li>判断每个关系模式的范式，根据实际需要确定最合适的范式。</li><li>根据需要分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行分解或合并。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>B-树为代表的树形索引成为当前数据库系统主流索引具有必然性?</p></p></div><div class="body"><p>索引文件是一种适应面比较广的文件结构，因此在数据库系统中得到了广泛的应用。对于经常变动的文件，静态索引的性能会随时间变化而变坏，所以目前在数据库系统中应用更多的是动态索引。而B-数就是为了磁盘或其它存储设备而设计的一种平衡多分树，能很好地进行动态索引。B-树提供了三种存取路径:</p><ol type="1"><li>通过索引集进行树形搜索;</li><li>通过顺序集进行顺序搜索;</li><li>先通过索引找到入口，再沿顺序集顺序搜索。</li></ol><p>B-树不仅提供了灵活的存取路径，而且能够自动保持平衡，不须定期重组，因此B-树为代表的树索引系列在数据库系统中应用甚广，成为数据库主流具有必然性。</p></div></div><div class="timenode"><div class="meta"><p><p>SUX锁是否能保证死锁不发生</p></p></div><div class="body"><p>不能解决并发事务中的死锁问题。当一个事物 A 占用数据对象 a 的 X锁，事务 B 占用数据 对象 b 的 X 锁，事务 A 和事务 B 又分别申请数据对象 b和数据对象 a 的锁，在(S,X)和(S,U,X)锁中，均无法获准，需要等待对方事务释放锁，而进入等待状态则无法释放自己所占用的锁，从而陷入循环等待，即死锁。</p><p>解决方法：资源按相同的顺序上锁来避免死锁。</p></div></div></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库原理复习提纲。&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="数据库" scheme="http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论复习</title>
    <link href="http://adversarr.github.io/2021/12/22/study/ComputerScience/fragments/AI2021/"/>
    <id>http://adversarr.github.io/2021/12/22/study/ComputerScience/fragments/AI2021/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2022-03-28T03:37:15.043Z</updated>
    
    <content type="html"><![CDATA[<p>🐔寄！人工智能导论复习</p><span id="more"></span><h1 id="人工智能导论">人工智能导论</h1><h2 id="第-1-章-绪论">第 1 章 绪论</h2><div class="story post-story"><ul><li>分数：5 分。</li><li>题目范围：<ol type="1"><li>您认为什么是人工智能？</li></ol></li></ul><div class="note "><p><strong>答题重点</strong></p><p>从两个角度：</p><ol type="1"><li><code>像人一样</code> 还是 <code>理性</code></li><li><code>思考</code> 还是 <code>行动</code></li></ol><blockquote><p>不同人会对 AI 有不同的思考。要问的两个重要问题是:你关心的是思考还是行为?你是想模拟人还是按照理想标准工作?</p></blockquote><p>例如：</p><p>我认为 AI 是像人一样行动的系统：</p><blockquote><p>“创造能执行一些功能的机器的技艺,当由人来执行这些功能时需要智能”(Kurzweil,1990)</p><p>“研究如何使计算机能做那些目前人比计算机更擅长的事情”(Rich 和Knight,1991)</p></blockquote></div><h3 id="什么是人工智能">什么是人工智能</h3><dl><dt><strong>人工智能</strong></dt><dd>用人工的方法在机器(计算机)上实现的智能;或者说是人们使机器具有类似于人的智能。</dd></dl><blockquote><ol type="1"><li>定义一:像人一样思考的系统(评价:计算机从定义开始)像人一样思考:认知建模的途径</li><li>定义二:理性地思考的系统 合理地思考:“思维法则”的途径</li><li>定义三:像人一样行动的系统 合理地行动:合理 Agent 的途径</li><li>定义四:理性地行动的系统</li></ol></blockquote><dl><dt>图灵测试(Turing test)</dt><dd>1950 年图灵发表的《计算机与智能》中设计了一个测试，用以说明人工智能的概念。</dd></dl><ol type="1"><li>目的是为智能提供一个满足可操作要求的定义。</li><li>与其提出一个长长的、可能有争议的清单来列举智能所需要的能力,不如采用一项基于人类这种无可置疑的智能实体的辨别能力的测试。如果人类询问者在提出一些书面问题后,无法判断答案是否由人写出,那么计算机就通过了测试。</li></ol><p>需要的能力：</p><ol type="1"><li>自然语言处理</li><li>知识表示</li><li>自动推理</li><li>机器学习</li></ol></div><h2 id="第-2-章-智能化-agent">第 2 章 智能化 Agent</h2><div class="story post-story"><ul><li>分数：5 分。</li><li>题目范围：<ul><li>Agent 的架构，尤其是基于模型和效用的 Agent 架构。</li><li>准确理解基于模型和效用 Agent 的任务、环境、评价标准等。</li><li>!基于学习 Agent 的一般模型。</li></ul></li></ul><div class="note "><p><strong>考试内容</strong></p><p>画出架构图</p></div><h3 id="peasagent-的任务环境评价标准">PEAS：Agent的任务、环境、评价标准</h3><p>根据首字母缩写,我们称之为 PEAS 描述( Performance(性能),Environment(环境), Actuators(执行器), Sensors (传感器))。设计 Agent时,第一步就是尽可能完整地详细说明任务环境</p><h3 id="agent-架构">Agent 架构</h3><dl><dt>智能体(Agent)</dt><dd>某种能够行动的东西。不同于简单程序,它可以实现:自主控制的操作、感知环境、持续能力、适应变化、以及有能力承担其它Agent 的目标。</dd><dt>理性智能体(Rational Agent)</dt><dd>可以通过自己的行动获得最佳结果。或者在不确定的情况下,获得最佳期望的结果。</dd></dl><p>在任何给定时间，什么是<strong>理性</strong>取决于四件事：</p><ul><li>定义成功标准的绩效衡量标准。</li><li>代理对环境的先验知识。</li><li>代理可以执行的操作。</li><li>代理迄今为止的感知序列。</li></ul><p>For each possible percept sequence, a rational agent should select anaction that is expected to maximize its performance measure, given theevidence provided by the percept sequence and whatever built-inknowledge the agent has.</p><blockquote><p>对于每个可能的感知序列，考虑到感知序列提供的证据以及智能体拥有的任何内置知识，理性智能体应该选择一个预期能够最大化其性能度量的动作。</p></blockquote><p><strong><em>agent = architecture + program</em></strong></p><h4 id="简单反射-agent">简单反射 Agent</h4><p><img src="image-20211220143334629.png" class="lazyload" data-srcset="image-20211220143334629.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于模型的-agent">基于模型的 Agent</h4><p><img src="image-20211220143752397.png" class="lazyload" data-srcset="image-20211220143752397.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于目标的-agent">基于目标的 Agent</h4><p><img src="image-20211220143820462.png" class="lazyload" data-srcset="image-20211220143820462.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于效用的-agent">基于效用的 Agent</h4><p><img src="image-20211220143846402.png" class="lazyload" data-srcset="image-20211220143846402.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="基于学习的-agent">基于学习的 Agent</h4><p><img src="image-20211220144250626.png" class="lazyload" data-srcset="image-20211220144250626.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>学习 Agent 可以被划分为 4 个概念上的组件,如图 2.15所示。最重要的区别体现在学习元件和性能元件之间,学习元件负责改进提高,而性能元件负责选择外部行动。性能元件是我们前面考虑的整个Agent:它接受感知信息并决策。学习元件利用来自评判元件的反馈评价Agent.做得如何,并确定应该如何修改性能元件以便将来做得更好。</p></div><h2 id="第-7-章-逻辑-agent">第 7 章 逻辑 Agent</h2><div class="story post-story"><ul><li>分数：5 分。</li><li>题目范围：<ol type="1"><li>命题逻辑的语法、命题逻辑的推理模式或推理方法</li><li>理解书中怪兽世界任务的推理，包括 𝑹𝟏~𝑹𝟏𝟎 的证明，以及 𝑹𝟏𝟏~𝑹𝟏𝟓的将句子转换成合取范式</li><li>基于归结或反证法的证明。</li><li>理解推理规则及公理，以便用于命题逻辑的推理。</li><li>!命题逻辑的连接符及其语义</li></ol></li></ul><div class="note "><p><strong>往年题目</strong></p><p>推导 R1-R10，R11-R15</p></div><h3 id="命题逻辑">命题逻辑</h3><dl><dt>Knowledge base (KB)</dt><dd>A set of <strong>sentences</strong></dd><dt>Sentence</dt><dd>Represents some assertion about the world</dd><dt>Axiom</dt><dd>Not derived from other sentences</dd></dl><p>经典问题为：</p><figure><img src="image-20211220144803757.png" class="lazyload" data-srcset="image-20211220144803757.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="魔兽世界问题" /><figcaption aria-hidden="true">魔兽世界问题</figcaption></figure><h4 id="语法">语法</h4><p>对于命题：</p><p><span class="math display">\[\alpha |= \beta\quad \iff\quad M(\alpha)\subseteq M(\beta)\]</span></p><p>对于命题逻辑：</p><ol type="1"><li><spanclass="math inline">\(\neg,\wedge,\vee,\implies,\iff\)</span></li><li>True, False</li></ol><h4 id="语义">语义</h4><p>注意 <span class="math inline">\(\implies\)</span> 的语义</p><h4 id="命题推理">命题推理</h4><p>命题推理的目标： <span class="math inline">\(KB|=\alpha\)</span></p><h5 id="简单推理过程">简单推理过程</h5><ol type="1"><li>逻辑推理：用蕴含关系来证明</li><li>模型检验：枚举所有的可能</li></ol><h5 id="定理证明">定理证明</h5><blockquote><p>Applying inference <strong>rules</strong> without models.</p><p>利用逻辑等价的命题逻辑。</p></blockquote><p><strong>单调性</strong>：随着信息添加到知识库中，所包含的句子集只会增加。</p><blockquote><p>产生了 R6-R10</p></blockquote><p>使用搜索算法证明</p><ul><li>INITIAL STATE：The initial knowledge base</li><li>ACTIONS：Match the top half of the inference rule</li><li>RESULT：Add the sentence in the bottom half of the inference</li><li>GOAL：The sentence to prove</li></ul><p>使用如下的方法：</p><p><span class="math display">\[\begin{aligned}\alpha \implies \beta,\quad \alpha\\-----------\\\beta\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\alpha \wedge \beta\\-----------\\\beta\end{aligned}\]</span></p><p>逻辑等价</p><p><span class="math display">\[\begin{aligned}\alpha \iff \beta\\-----------\\(\alpha\implies \beta)\wedge (\beta\implies\alpha)\\\\(\alpha\implies \beta)\wedge (\beta\implies\alpha)\\-----------\\\alpha \iff \beta\end{aligned}\]</span></p><h5 id="消解法归结法">消解法（归结法）</h5><p>消解规则：</p><p><span class="math display">\[\begin{aligned}l_1 \vee l_2\quad \neg l_2\vee l_3\\----------\\l_1\vee l_3\end{aligned}\]</span></p><p><strong>思路</strong></p><ul><li>要证明：<span class="math inline">\(KB|=\alpha\)</span>即证明：<spanclass="math inline">\(KB\wedge\neg\alpha\)</span>不可满足的</li></ul><p><strong>方法</strong>：</p><ol type="1"><li><p>转换<span class="math inline">\(KB\wedge \neg\alpha\)</span>为<strong>合取范式</strong></p></li><li><p>消解</p></li><li><p>如果新子句尚不存在，则将其添加到集合中</p><p>该过程一直持续到：</p><ol type="1"><li>不能添加新的条款</li><li>产生了空条款 -- 不可满足</li></ol></li></ol><blockquote><p>产生了 R11-R15</p></blockquote></div><h2 id="第-10-章-知识表示">第 10 章 知识表示</h2><div class="story post-story"><ul><li>分数：6 分。</li><li>题目范围：<ol type="1"><li>情景演算、情景、流、前提条件公理、效应公理等概念。</li><li>!本体论、类别、对象，并举例说明</li></ol></li></ul><h3 id="本体论相关">本体论相关</h3><h4 id="本体">本体</h4><dl><dt>本体</dt><dd>Organize everything in the world into a hierarchy of categories</dd></dl><ul><li>主要着重于一些在许多不同领域都会出现的通用概念例如事件、时间、物理对象以及信念。表示这些抽象概念有时被称为本体论工程（ontologicalengineering）。</li><li>念的通用框架被称为上位本体论( upperontology),因为按照画图惯例，更一般概念在上面而更具体的概念在它们的下面。如图</li></ul><figure><img src="image-20211220161459787.png"alt="Upper ontology: the general framework of concepts" /><figcaption aria-hidden="true">Upper ontology: the general framework ofconcepts</figcaption></figure><ul><li>Concentrate on general concepts in differentdomains：专注于不同领域的一般概念<ul><li><em>Events, Time, Physical Objects</em>, and <em>Beliefs</em></li></ul></li></ul><blockquote><p>本体（ontology）的几个代表性定义： (1)本体是对于“概念化”的某一部分的明确的总结或表达[2]。 (2)本体在不同的场合分别指“概念化”或“本体理论”[3]。 (3)本体是对于“概念化”的明确表达[4]。 (4)本体是用于描述或表达某一领域知识的一组概念或术语。它可以用来组织知识库较高层次的知识抽象，也可以用来描述特定领域的知识[5]。(5) 本体属于人工智能领域中的内容理论（contenttheories），它研究特定领域知识的对象分类、对象属性和对象间的关系，它为领域知识的描述提供术语[6]。从以上定义我们可以知道，本体通过对于概念、术语及其相互关系的规范化描述，勾画出某一领域的基本知识体系和描述语言。其中定义1、2 和 3 以“概念化”的定义为基础，概念化（以及定义 2中的“本体理论”）的定义见下文。 与本体相关的概念和术语：本体论（Ontology，o 大写）：特指哲学的分支学科[3]。</p></blockquote><h4 id="类别和对象">类别和对象</h4><dl><dt>类别、对象</dt><dd>用一阶逻辑表示类别有两种选择: 谓词和对象。就是说,我们可以使用谓词Basketball(b),或者可以将类别物化(reify)为一个对象,Basketball。然后,我们可以用 Member(b, Basketballs)(我们将它缩写为b∈Basketballs)来说明 b 是篮球类别的一个成员。 我们用 Subset(Basketball,Bals)(缩写为 Basketballs c Balls)来说明 Basketball.s 是Ball.s的一个子类(subcategory)。我们将交替使用术语子类(subcategory)和子集(subclass,subset)。</dd></dl><ul><li>将对象组织成类别是知识表示的重要组成部分。很多推理发生在<strong>类别</strong>层面。<ol type="1"><li>一种是从感知输入推断某些对象的存在，从对象的感知属性推断类别成员资格，然后使用类别信息对对象进行预测。</li><li>一种是通过<strong>继承</strong>来组织和简化知识库，子类关系构成一个层次结构</li></ol></li></ul><dl><dt>（部分关系、a 组成了 b）Partof</dt><dd>一个对象可以是另一个对象的一部分</dd></dl><ul><li><em>PartOf</em> is transitive（传递） and reflexive（自反）</li><li>反之有：BunchOf: define composite objects with definiteparts（定义一个物体由有限个 Part 组成）</li></ul><dl><dt>事物</dt><dd>现实中有相当一部分对象没有明显的个性化(<strong>individuation</strong>)。即划分成独特对象—事物</dd></dl><ul><li>现实世界可以视为由原始对象(粒子)和由其构成的复合对象组成的、</li><li>事物和物体(<strong>thing</strong>)的最大区别：（如果将一只土豚切成两半，不会得到两只土豚。）</li><li>对象=事物</li></ul><p>stuff-物质、thing-物体</p><dl><dt>测度</dt><dd>Objects have height, mass, cost, and so on. The values that we assignfor these properties are called <strong>measures.</strong></dd></dl><h3 id="情景演算">情景演算</h3><dl><dt>Event calculus</dt><dd>Based on points of time rather than on situations</dd><dt>Predicate <strong><em>T</em></strong></dt><dd>断言 <em>流体</em> 在某个时间点是正确的</dd></dl><figure><img src="image-20211220212336898.png" class="lazyload" data-srcset="image-20211220212336898.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="谓词" /><figcaption aria-hidden="true">谓词</figcaption></figure><h4 id="过程">过程</h4><dl><dt>过程（process / <strong>liquid event</strong>)</dt><dd>具有这种属性的事件类别被称为过程( process)类别或者流事件( liquidevent)类别。发生在一个时间区间的任何过程 e 也在任何子区间里发生。</dd></dl><ul><li>如果 fluent 是由过去某个时间的事件启动并且没有被中间事件变为false（剪切），则 fluent 在某个时间点成立。</li><li>流(<strong>fluent</strong>)指的是使情景从一个变换到下一个的函数和谓词。</li></ul><dl><dt>一个特殊的事件-<strong><em>Start</em></strong></dt><dd>通过说明在开始时间启动或终止哪些流来描述初始状态。</dd></dl><p>一个物理对象是一块时空</p><ul><li>Physical objects can be viewed as generalized events</li></ul></div><h2 id="第-14-章-概率推理">第 14 章 概率推理</h2><div class="story post-story"><ul><li>分数：8 分。</li><li>题目范围：<ol type="1"><li>贝叶斯网络的定义、贝叶斯网络的语义。</li><li>给定贝叶斯网络，要求能够写出相应的联合概率分布。</li><li>针对书中的盗贼警报任务，理解贝叶斯网络的精确推理，并且能够在给定证据的情况下进行推理。</li></ol></li></ul><h3 id="定义语义">定义/语义</h3><blockquote><p>Represent the dependencies among variables</p></blockquote><dl><dt>贝叶斯网络</dt><dd>贝叶斯网络是一个有向图,其中每个结点都标注了定量的概率信息。其完整的说明如下:</dd></dl><ol type="1"><li>每个结点对应一个随机变量,这个变量可以是离散的或者连续的。</li><li>一组有向边或箭头连接结点对。如果有从结点 X 指向结点 Y 的箭头,则称 X是 Y 的一个父结点。图中没有有向回路(因此被称为有向无环图,或简写为DAG)。</li><li>每个结点 X 有一个条件概率分布 P( K|Parents(X)),量化其父结点对该结点的影响。</li></ol><p><img src="image-20211222103056286.png" class="lazyload" data-srcset="image-20211222103056286.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><blockquote><p>有两种方式可以理解贝叶斯网络的语义。</p><ol type="1"><li>第一种是将贝叶斯网络视为对联合概率分布的表示。</li><li>第二种则将其视为是对一组条件依赖性语句的编码。</li></ol><p>这两种观点是等价的,但是前者可以帮助我们理解如何构造网络,而后者则可以帮助我们设计推理过程</p></blockquote><h3 id="如何计算联合概率">如何计算联合概率？</h3><figure><img src="image-20211222104003250.png" class="lazyload" data-srcset="image-20211222104003250.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="遍历DAG" /><figcaption aria-hidden="true">遍历DAG</figcaption></figure><blockquote><p>如何构造贝叶斯网络：链式法则</p></blockquote><h3 id="如何进行精确推理">如何进行精确推理</h3><p><strong>原理</strong>：精确推理就是<strong>计算后验概率</strong>：随机变量：<spanclass="math inline">\(X\)</span>，条件<spanclass="math inline">\(e\)</span>，隐藏的节点<spanclass="math inline">\(y\)</span>：</p><p><spanclass="math display">\[P(X|e)=\frac{P(X,e)}{P(e)}\mathop{=}^{\alpha:=P(e)^{-1}}\alpha\sum_yP(x,y,e)\]</span></p><p><strong>计算方法</strong>：</p><blockquote><p>重点：<span class="math inline">\(\alpha\)</span>不计算，通过求出 X不同取值下的联合概率，然后归一化得到</p></blockquote><ol type="1"><li>求随机变量各个取值的联合概率</li><li>归一化得到结果</li></ol><h4 id="例题">例题</h4><figure><img src="image-20211222105523724.png"alt="注意其中的B是大写的变量，而jmea都是取值！" /><figcaptionaria-hidden="true">注意其中的B是大写的变量，而jmea都是取值！</figcaption></figure><p>最暴力的方法：</p><table><thead><tr class="header"><th>Scene</th><th>Probability</th><th>Result</th></tr></thead><tbody><tr class="odd"><td>b,e,a</td><td>0.001 0.002 0.95 0.9 0.7</td><td>1.197*10^-6</td></tr><tr class="even"><td>b,e,-a</td><td>0.001 0.002 0.05 0.05 0.01</td><td>5.*10^-11</td></tr><tr class="odd"><td>b,-e,a</td><td>0.001 0.998 0.94 0.90 0.70</td><td>0.000591016</td></tr><tr class="even"><td>b,-e,-a</td><td>0.001 0.998 0.06 0.05 0.01</td><td>2.994*10^-8</td></tr><tr class="odd"><td>-b,e,a</td><td>0.999 0.002 0.29 0.9 0.7</td><td>0.000365035</td></tr><tr class="even"><td>-b,e,-a</td><td>0.999 0.002 0.71 0.05 0.01</td><td>7.0929*10^-7</td></tr><tr class="odd"><td>-b,-e,a</td><td>0.999 0.998 0.001 0.9 0.7</td><td>0.000628111</td></tr><tr class="even"><td>-b,-e,-a</td><td>0.999 0.998 0.999 0.05 0.01</td><td>0.000498002</td></tr></tbody></table><p>所以</p><ul><li><span class="math inline">\(P(b|j, m)=0.000592243\alpha\)</span></li><li><span class="math inline">\(P(\negb|j,m)=0.00149186\alpha\)</span></li></ul><p>归一化后：（实际上<span class="math inline">\(\alpha=1/(0.000592243+0.00149186)\)</span>）</p><ul><li><span class="math inline">\(P(b|j, m)=0.000592243\alpha=0.284172\)</span></li><li><span class="math inline">\(P(\negb|j,m)=0.00149186\alpha=0.715828\)</span></li></ul><p>从而：</p><p><spanclass="math display">\[P(B|j,m)=\langle0.283172,0.715828\rangle\]</span></p></div><h2 id="第-16-章-制定简单决策">第 16 章 制定简单决策</h2><div class="story post-story"><ul><li>分数：8 分。</li><li>题目范围：<ol type="1"><li>理解什么是最大期望效用原则。</li><li>理解决策网络，尤其是决策网络中的节点类型。</li><li>给定一个决策网络，能够计算不同动作的期望效用，并选择具有最大期望效用的动作。</li><li>!偏好、效用</li></ol></li></ul><h3 id="最大期望效用原则">最大期望效用原则</h3><p><strong>最大期望效用(MEU)原则</strong>：理性 Agent应该选择能<strong>最大化</strong>该 Agent的<strong>期望效用</strong>的那个动作。</p><p><strong>效用函数</strong>：效用是从状态映射到实数的函数。</p><h3 id="决策网络">决策网络</h3><p><img src="image-20211222171626214.png" class="lazyload" data-srcset="image-20211222171626214.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><ul><li><strong>机会结点(Chancenode)(椭圆)代表随机变量</strong>,就像它们在贝叶斯网中所表示的一样。关于建设费用、空中交通级别和诉讼可能性以及Deaths、 Noise 和总体 Cosr 变量一其中每一个又依赖于选址一 Agent可能是不确定的。每个机会结点关联着一个以父结点的状态为索引的条件分布。在决策网络中,父结点既可以包括决策结点也可以包括机会结点。注意到为了评估建设费用、空中交通级别或者诉讼可能性,每个当前状态机会结点都可能是一个大的贝叶斯网络的部分。</li><li><strong>决策结点(decisionnode)(矩形)代表在该结点上决策制定者有一个对行动的选择</strong>。在这个案例中,Airport site行动可以对考虑中的每个位置呈现不同的值。选择影响到费用、安全以及会产生的噪音。在本章中,我们假设我们处理的是单一决策结点。第17 章将处理必须制定多于一个决策的情况效用结点(utility node)(菱形)代表Agent 的效用函数'。</li><li><strong>效用结点把所有那些描述直接影响效用的结果状态的变量作为父结点</strong>。与效用结点关联的是一个描述,它将Agent 效用描述为对父结点属性的一个函数。这个描述可能只是函数的表格形式,或者它可能是参数化的属性值的加法或线性函数。</li></ul><h3id="给定决策网络计算不同动作的期望效用">给定决策网络，计算不同动作的期望效用</h3><p>行动的选择是通过对决策结点的每种可能设定的决策网络进行评价而完成的。一旦决策结点被设定,它的行为表现完全像一个被设定为证据变量的机会结点。评价决策网络的算法如下:</p><ol type="1"><li>为当前状态设定证据变量。</li><li>对于决策结点的每个可能值;<ol type="1"><li>把决策结点设为该值。</li><li>对该效用结点的父结点,使用一个标准的概率推理算法计算其后验概率。</li><li>为该行动计算结果效用。</li></ol></li><li>返回有最高效用的行动这是贝叶斯网络算法的一个直接扩展,可以直接结合到图13.1 给出的 Agent T 设计中去。</li></ol><blockquote><p>依次执行几个行动的可能性使问题变得有趣得多</p></blockquote><h3 id="偏好和效用">偏好和效用</h3><p>下面六条约束被称为<strong>效用理论公理</strong>。它们指定附加在偏好和彩票上的明显的语义约束。</p><ol type="1"><li>有序性(Orderability)。给定任意两个状态,一个理性 Agent必须偏好一个状态甚于另一个。或者认为偏好两者的程度一样。也就是说,该Agent 不能逃避决策。拒绝打赌就如同拒绝时间逝去一样。</li><li>传递性(Transitivity)。给定任意三个状态,如果一个理性 Agent 偏好 A甚于 B,偏好 B 甚于 C,则该 Agent 一定偏好 A 甚于 C。</li><li>连续性(Continuity)。如果某个状态 B 在偏好上处于 A 和 C之间,那么一定存在概率 p,使得该理性 Agent 在【肯定得到 B】、【以概率得到A,并以概率 1 − p 得到 C】的彩票之间无偏向。</li><li>可替换性(Substituitability)。如果一个 Agent 在两个彩票 A 和 B之间无偏向,则该 Agent在更复杂的两个彩票之间也是无偏向的。这样的两个彩票,除了一个彩票中的 A 被B 替换以外是一样的。这是成立的,而不用考虑彩票中的概率和其它结果。</li><li>单调性( Monotonicity)。假设存在两个彩票有两个结果 A 和 B,如果一个Agent 偏好 A 甚于 B,那么该 Agent 一定偏好 A的概率高的彩票。反之亦然。</li><li>可分解性(Decomposability)。复合彩票可以通过概率法则被简化为简单一些的彩票。由于两个相继的彩票能够被压缩成个等价的单个彩票,这曾被称为“赌博无乐趣”规则。</li></ol><blockquote><p>注意:效用理论的公理没有提到任何关于效用的内容：它们只谈论了<strong>偏好</strong>。<strong>偏好被假定为理性Agent 的一个基本属性。</strong>一个效用函数的存在遵循下列效用公理:</p><ol type="1"><li>效用原则(Existence of Utility Function)。如果一个 Agent的偏好遵循效用公理，则存在一个在状态上进行运算的实值函数 U,使得U(A)&gt;U(B),当且仅当 Agent 偏好 A 甚于 B 时。并且 U(A)=U(B),当且仅当该Agent 在 A 和 B 之间无偏向时。</li><li>最大期望效用原则(Expected Utility of aLottery)。一个彩票的效用是把每个结果的概率乘以每个结果的效用的乘积，然后求和。</li></ol><p>换句话说,一旦可能结果状态的概率和效用被指定,涉及到那些状态的复合彩票的效用就被完全确定了。一个非确定性动作的结果是一个彩票,这将提供根据公式(16.1)得到的MEU 决策规则。</p></blockquote><blockquote><p><strong>效用函数刻画的是偏好关系</strong>，假如你相比梨来说更偏好苹果，那么苹果给你带来的效用就应当大于梨所带来的效用。但<strong>注意效用函数虽然是一个数学函数，但在本例中它仅表示不同消费组合之间效用的排序关系</strong>，而非真正的，可以用数字来刻画的“效用量”。换言之，你可以说你相对梨来说更偏好苹果，但绝对没办法说“苹果大于梨n个效用单位”。当然，在某些特定的领域也有用基数效用方程的，比如在期望效用理论中。</p><p>作者：徐惟能链接：https://www.zhihu.com/question/22310615/answer/20962418 来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;🐔寄！人工智能导论复习&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="人工智能" scheme="http://adversarr.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="http://adversarr.github.io/2021/12/13/study/ComputerScience/fragments/CP2021/"/>
    <id>http://adversarr.github.io/2021/12/13/study/ComputerScience/fragments/CP2021/</id>
    <published>2021-12-12T16:00:00.000Z</published>
    <updated>2022-03-03T04:30:41.727Z</updated>
    
    <content type="html"><![CDATA[<p>编译原理期末复习</p><span id="more"></span><h1 id="编译原理习题集">编译原理习题集</h1><h2 id="chapter-2语言和文法">Chapter 2：语言和文法</h2><div class="story post-story"><h3id="构造无e产生式的上下文无关文法">构造无e产生式的上下文无关文法</h3><h4 id="取模相关奇偶性整除性">取模相关：奇偶性、整除性</h4><ol type="1"><li>{w| w <span class="math inline">\(\in\)</span> (a,b,c)* and thenumbers of a’s and b’s and c’s occurred in w are even}</li><li>{w| w <span class="math inline">\(\in\)</span> (a,b,c)* and thenumbers of a’s and b’s occurred in w are odd}</li><li>{w| w <span class="math inline">\(\in\)</span> (a,b,c)* , w is leadby a and the numbers of a’s and b’s occurred in w are even}</li></ol><p>方法：构造有穷自动机，然后转换为CFG。</p><h4 id="个数相关">个数相关</h4><ol type="1"><li>{ <span class="math inline">\(a^i b^j\)</span> |i≥(2j+1) andj≥0}</li><li>{ <span class="math inline">\(a^ib^jc^k\)</span>|j≥(i+k+1) and i≥0,k≥1}</li></ol><p>方法：进行合理的拆分，例如：</p><p><span class="math display">\[a^i b^j (i\ge 2j + 1, j\ge 0) = a^k(aab)^j(k \ge 1, j \ge 0)\]</span></p><p>消除相关的不等式即可。</p></div><h2 id="chapter-3词法分析">Chapter 3：词法分析</h2><div class="story post-story"><p>从RegEx构造（最小化）DFA：</p><ol type="1"><li>aa*(bab*a)*(a|b)b*</li><li>a(bab*a)*(a|b)b*</li><li>((ba*)*a)*(a|b)</li></ol><p>直接用书上的算法做就行。</p><p>这一章的定义、算法有：</p><ol type="1"><li><strong>定义</strong>：DFA、NFA、正则表达式（RegularExpression）、线性文法、正规定义（Regular Definition）</li><li><strong>算法</strong>：<ol type="1"><li>NFA到DFA<ol type="1"><li>子集法</li><li>DFA到NFA是没有意义的</li></ol></li><li>DFA最小化<ol type="1"><li>划分法</li></ol></li><li>RegEx-NFA<ol type="1"><li>正向：反复使用Thompson法则</li><li>反向：一样用Thompson法则，但是需要注意其中的一些路径组合</li></ol></li><li>右线性文法-NFA<ol type="1"><li>-&gt;：增加新的终态、根据产生式设置move函数</li><li>&lt;-：分别考虑出边和终态来构造</li></ol></li><li>左线性文法-NFA<ol type="1"><li>-&gt;：识别符号S设置为终态、设置Q0为新的初态、根据产生式考虑三种情况即可。</li><li>&lt;-：</li></ol></li></ol></li></ol></div><h2 id="chapter-4语法分析">Chapter 4：语法分析</h2><div class="story post-story"><p>主要内容：</p><ol type="1"><li>消除<span class="math inline">\(\varepsilon\)</span>产生式</li><li>消除（直接和间接）左递归<ol type="1"><li>注意使用范围</li></ol></li><li>提取左公因子</li><li>First 和 Follow 集</li><li>LL文法<ol type="1"><li>构造LL1分析表</li><li>LL1文法的判断方法</li></ol></li><li>LR文法<ol type="1"><li><p>LR0</p></li><li><p>SLR</p></li><li><p>LR1</p></li><li><p>LALR</p><blockquote><p>真的烦人！</p></blockquote></li></ol></li></ol><h3id="消除左递归提取左公因子并构造ll1">消除左递归、提取左公因子并构造LL1</h3><p><span class="math display">\[S \rightarrow iCtS|iCtSeS|a\\C \rightarrow C \text{ or } D | D\\D \rightarrow D \text{ or } E | E\\E \rightarrow (C) | b\]</span></p><h3 id="构造lr1">构造LR1</h3><p><span class="math display">\[S \rightarrow \text{ if } S \text{ else } S\\S \rightarrow \text{ if } S\\S \rightarrow S~;S\\S \rightarrow a\]</span></p><h3 id="带有二义性的文法构造lr1">（带有二义性的文法）构造LR1</h3><p>优先级：<span class="math inline">\(; &gt; \text{do} &gt;\text{or}\)</span></p><p><span class="math display">\[S\rightarrow \text{ do } S \text{ or }\\S\rightarrow \text{ do } S\\S\rightarrow S~;S\\S\rightarrow a\]</span></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;编译原理期末复习&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="编译原理" scheme="http://adversarr.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++ 编程规范</title>
    <link href="http://adversarr.github.io/2021/11/30/study/ComputerScience/fragments/Google_C_programming_specification/"/>
    <id>http://adversarr.github.io/2021/11/30/study/ComputerScience/fragments/Google_C_programming_specification/</id>
    <published>2021-11-30T03:10:09.769Z</published>
    <updated>2022-04-06T03:31:16.162Z</updated>
    
    <content type="html"><![CDATA[<p>Google C/C++ 规范文档。</p><span id="more"></span><h1 id="c编程规范">c++编程规范</h1><h2 id="扉页">0. 扉页</h2><div class="story post-story"><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>版本:</th><th>4.45</th></tr></thead><tbody><tr class="odd"><td>原作者:</td><td>Benjy WeinbergerCraig SilversteinGregory EitzmannMarkMentovaiTashana Landray</td></tr><tr class="even"><td>翻译:</td><td><a href="http://www.yulefox.com/">YuleFox</a><ahref="https://github.com/yangyubo">Yang.Y</a><ahref="http://acgtyrant.com/">acgtyrant</a><ahref="http://github.com/lilinsanity">lilinsanity</a></td></tr><tr class="odd"><td>项目主页:</td><td><a href="http://google-styleguide.googlecode.com/">Google StyleGuide</a><ahref="http://github.com/zh-google-styleguide/zh-google-styleguide">Google开源项目风格指南 - 中文版</a></td></tr></tbody></table><h3 id="译者前言">0.1 译者前言</h3><p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码.但是如果代码贡献者的编程风格与 Google 的不一致,会给代码阅读者和其他代码提交者造成不小的困扰. Google因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google的编程风格.</p><p>翻译初衷:</p><blockquote><p>规则的作用就是避免混乱. 但规则本身一定要权威, 有说服力, 并且是理性的.我们所见过的大部分编程规范, 其内容或不够严谨, 或阐述过于简单,或带有一定的武断性.</p><p>Google 保持其一贯的严谨精神, 5 万汉字的指南涉及广泛, 论证严密.我们翻译该系列指南的主因也正是其严谨性.严谨意味着指南的价值不仅仅局限于它罗列出的规范,更具参考意义的是它为了列出规范而做的谨慎权衡过程.</p><p>指南不仅列出你要怎么做, 还告诉你为什么要这么做,哪些情况下可以不这么做, 以及如何权衡其利弊.其他团队未必要完全遵照指南亦步亦趋, 如前面所说, 这份指南是 Google根据自身实际情况打造的, 适用于其主导的开源项目. 其他团队可以参照该指南,或从中汲取灵感, 建立适合自身实际情况的规范.</p><p>我们在翻译的过程中, 收获颇多.希望本系列指南中文版对你同样能有所帮助.</p></blockquote><p>我们翻译时也是尽力保持严谨, 但水平所限, bug 在所难免.有任何意见或建议, 可与我们取得联系.</p><p>中文版和英文版一样, 使用 <code>Artistic License/GPL</code>开源许可.</p><p>中文版修订历史:</p><blockquote><ul><li><p>2015-08 : 热心的清华大学同学 <span class="citation"data-cites="lilinsanity">@lilinsanity</span>完善了「类」章节以及其它一些小章节。至此，对 Google CPP Style Guide 4.45的翻译正式竣工。</p></li><li><p>2015-07 4.45 : acgtyrant 为了学习 C++ 的规范，顺便重新翻译了本C++ 风格指南，特别是 C++11的全新内容。排版大幅度优化，翻译措辞更地道，添加了新译者笔记。Google总部 C++ 工程师 innocentim,清华大学不愿意透露姓名的唐马儒先生，大阪大学大学院情报科学研究科计算机科学专攻博士farseerfc 和其它 Arch Linux 中文社区众帮了译者不少忙，谢谢他们。因为 C++Primer 尚未完全入门，暂时没有翻译「类」章节和其它一些小章节。</p></li><li><p>2009-06 3.133 : YuleFox 的 1.0 版已经相当完善,但原版在近一年的时间里, 其规范也发生了一些变化.</p></li></ul><blockquote><p>Yang.Y 与 YuleFox 一拍即合, 以项目的形式来延续中文版 : <ahref="http://github.com/yangyubo/zh-google-styleguide">Google开源项目风格指南 - 中文版项目</a>.</p><p>主要变化是同步到 3.133 最新英文版本,做部分勘误和改善可读性方面的修改, 并改进排版效果. Yang.Y 重新翻修,YuleFox 做后续评审.</p></blockquote><ul><li>2008-07 1.0 : 出自 <a href="http://www.yulefox.com/?p=207">YuleFox的 Blog</a>, 很多地方摘录的也是该版本.</li></ul></blockquote><h3 id="背景">0.2 背景</h3><p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++程序员都知道的, C++ 有很多强大的特性,但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug,难以阅读和维护.</p><p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性.这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p><p><em>风格</em>, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语"风格" 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p><p>使代码易于管理的方法之一是加强代码一致性.让任何程序员都可以快速读懂你的代码这点非常重要.保持统一编程风格并遵守约定意味着可以很容易根据 "模式匹配"规则来推断各种标识符的含义. 创建通用,必需的习惯用语和模式可以使代码更容易理解.在一些情况下可能有充分的理由改变某些编程风格,但我们还是应该遵循一致性原则，尽量不这么做.</p><p>本指南的另一个观点是 C++ 特性的臃肿. C++是一门包含大量高级特性的庞大语言. 某些情况下,我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽,避免这些特性可能导致的各种问题. 指南中列举了这类特性,并解释为什么这些特性被限制使用.</p><p>Google 主导的开源项目均符合本指南的规定.</p><p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p></div><h2 id="头文件">1. 头文件</h2><div class="story post-story"><p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件.也有一些常见例外, 如单元测试代码和只包含 <code>main()</code> 函数的<code>.cc</code> 文件.</p><p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p><p>下面的规则将引导你规避使用头文件时的各种陷阱.</p><h3 id="self-contained-头文件">1.1. Self-contained 头文件</h3><p>Tip</p><p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以<code>.h</code>结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以<code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code>头文件的做法.</p><p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">1.2.##define 保护</a>，统统包含它所需要的其它头文件，也不要求定义任何特别symbols.</p><p>不过有一个例外，即一个文件并不是 self-contained的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用<code>.inc</code> 文件扩展名。</p><p>如果 <code>.h</code>文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的<code>.cc</code>文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的<code>-inl.h</code> 文件里（译者注：过去该规范曾提倡把定义放到 -inl.h里过）。</p><p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的<code>.cc</code> 文件里。</p><h3 id="define-保护">1.2. ##define 保护</h3><blockquote><p>[!TIP]</p><p>1</p></blockquote><p>所有头文件都应该使用 <code>##define</code> 来防止头文件被多重包含,命名格式当是: <code>___H_</code> .</p><p>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如,项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code>可按如下方式保护:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></table></figure><h3 id="前置声明">1.3. 前置声明</h3><p>尽可能地避免使用前置声明。使用 <code>#include</code>包含需要的头文件即可。</p><p><strong>定义：</strong></p><blockquote><p>所谓「前置声明」（forwarddeclaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p></blockquote><p><strong>优点：</strong></p><blockquote><ul><li>前置声明能够节省编译时间，多余的 <code>#include</code>会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code>使代码因为头文件中无关的改动而被重新编译多次。</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li><p>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</p></li><li><p>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</p></li><li><p>前置声明来自命名空间 <code>std::</code> 的 symbol时，其行为未定义。</p></li><li><p>很难判断什么时候该用前置声明，什么时候该用 <code>#include</code>。极端情况下，用前置声明代替 <code>includes</code>甚至都会暗暗地改变代码的含义：</p><blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; <span class="built_in">f</span>(x); &#125;  <span class="comment">// calls f(B*)</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>如果 <code>#include</code> 被 <code>B</code> 和 <code>D</code>的前置声明替代， <code>test()</code> 就会调用 <code>f(void*)</code>.</p></blockquote><ul><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的<code>include</code> 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li></ul></blockquote><p><strong>结论：</strong></p><blockquote><ul><li>尽量避免前置声明那些定义在其他项目中的实体.</li><li>函数：总是使用 <code>#include</code>.</li><li>类模板：优先使用 <code>#include</code>.</li></ul></blockquote><p>至于什么时候包含头文件，参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##name-and-order-of-includes">1.5.<code>#include</code> 的路径及顺序</a> 。</p><h3 id="内联函数">1.4. 内联函数</h3><p>Tip</p><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p><p><strong>定义:</strong></p><blockquote><p>当函数被声明为内联函数之后, 编译器会将其内联展开,而不是按通常的函数调用机制进行调用.</p></blockquote><p><strong>优点:</strong></p><blockquote><p>只要内联的函数体较小, 内联该函数可以令目标代码更加高效.对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减,这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小,但内联一个相当大的函数将戏剧性的增加代码大小.现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p></blockquote><p><strong>结论:</strong></p><blockquote><p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数,析构函数往往比其表面看起来要更长,因为有隐含的成员和基类析构函数被调用!</p><p>另一个实用的经验准则: 内联那些包含循环或 <code>switch</code>语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或<code>switch</code> 语句从不被执行).</p><p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要;比如虚函数和递归函数就不会被正常内联. 通常,递归函数不应该声明成内联函数.（YuleFox 注:递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的,大多数编译器都不支持内联递归函数).虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便,抑或是当作文档描述其行为, 比如精短的存取函数.</p></blockquote><h3 id="include-的路径及顺序">1.5. <code>#include</code>的路径及顺序</h3><p>Tip</p><p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库,C++ 库, 其他库的 .h, 本项目内的 .h.</p><p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录).例如, <code>google-awesome-project/src/base/logging.h</code>应该按如下方式包含:</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/logging.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>又如, <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code>的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能,<code>foo.cc</code> 中包含头文件的次序如下:</p><blockquote><ol type="1"><li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 <code>.h</code> 文件</li><li>本项目内 <code>.h</code> 文件</li></ol></blockquote><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code>遗漏某些必要的库时， <code>dir/foo.cc</code> 或<code>dir/foo_test.cc</code>的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code>通常位于同一目录下 (如 <code>base/basictypes_unittest.cc</code> 和<code>base/basictypes.h</code>), 但也可以放在不同目录下.</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p><p>您所依赖的符号 (symbols)被哪些头文件所定义，您就应该包含（include）哪些头文件，<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##forward-declarations">前置声明</a>(forward declarations) 情况除外。比如您要用到 <code>bar.h</code>中的某个符号, 哪怕您所包含的 <code>foo.h</code> 已经包含了<code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非<code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的symbol. 不过，凡是 cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code>就够了，不用再管后者所包含的其它内容。</p><p>举例来说,<code>google-awesome-project/src/foo/internal/fooserver.cc</code>的包含次序如下:</p><blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/fooserver.h&quot;</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/basictypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/commandlineflags.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/bar.h&quot;</span></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>例外：</strong></p><p>有时，平台特定（system-specific）代码需要条件编译（conditionalincludes），这些代码可以放到其它 includes之后。当然，您的平台特定代码也要够简练且独立，比如：</p><blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/fooserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/port.h&quot;</span>  <span class="comment">// For LANG_CXX11.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LANG_CXX11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// LANG_CXX11</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="译者-yulefox-笔记">译者 (YuleFox) 笔记</h3><ol type="1"><li>避免多重包含是学编程时最基本的要求;</li><li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li><li>内联函数的合理使用可提高代码执行效率;</li><li><code>-inl.h</code> 可提高代码可读性 (一般用不到吧:D);</li><li>标准化函数参数顺序可以提高可读性和易维护性(对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li><li>包含文件的名称使用 <code>.</code> 和 <code>..</code>虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理,包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在“最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后,这样出错先是项目内的文件, 头文件都放在对应源文件的最前面,这一点足以保证内部错误的及时发现了.</li></ol><h3 id="译者acgtyrant笔记">译者（acgtyrant）笔记</h3><ol type="1"><li>原来还真有项目用 <code>##includes</code> 来插入文本，且其文件扩展名<code>.inc</code> 看上去也很科学。</li><li>Google 已经不再提倡 <code>-inl.h</code> 用法。</li><li>注意，前置声明的类是不完全类型（incompletetype），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li><li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的<code>.cc</code>文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li><li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库,其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li></ol></div><h2 id="作用域">2. 作用域</h2><div class="story post-story"><h3 id="命名空间">2.1. 命名空间</h3><p>Tip</p><p>鼓励在 <code>.cc</code> 文件内使用匿名命名空间或 <code>static</code>声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p><p><strong>定义:</strong></p><blockquote><p>命名空间将全局作用域细分为独立的, 具名的作用域,可有效防止全局作用域的命名冲突.</p></blockquote><p><strong>优点:</strong></p><blockquote><p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注:将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.</p><p>举例来说, 两个不同项目的全局作用域都有一个类 <code>Foo</code>,这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中,<code>project1::Foo</code> 和 <code>project2::Foo</code>作为不同符号自然不会冲突.</p><p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace Y</span></span><br><span class="line">&#125;  <span class="comment">// namespace X</span></span><br></pre></td></tr></table></figure><p><code>X::Y::foo()</code> 与 <code>X::foo()</code>彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>命名空间具有迷惑性,因为它们使得区分两个相同命名所指代的定义更加困难。</p><p>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p><p>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</p><p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One DefinitionRule (ODR)).</p></blockquote><p><strong>结论:</strong></p><blockquote><p>根据下文将要提到的策略合理使用命名空间.</p><ul><li><p>遵守 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/naming.html##namespace-names">命名空间命名</a>中的规则。</p></li><li><p>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</p></li><li><p>用命名空间把文件包含, <ahref="https://gflags.github.io/gflags/">gflags</a> 的声明/定义,以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><p>更复杂的 <code>.cc</code> 文件包含更多, 更复杂的细节, 比如 gflags 或using 声明。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="built_in">DEFINE_FLAG</span>(<span class="type">bool</span>, someflag, <span class="literal">false</span>, <span class="string">&quot;dummy flag&quot;</span>);</span><br><span class="line"><span class="keyword">namespace</span> a &#123;</span><br><span class="line"></span><br><span class="line">...code <span class="keyword">for</span> a...                <span class="comment">// 左对齐</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace a</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>不要在命名空间 <code>std</code> 内声明任何东西,包括标准库的类前置声明. 在 <code>std</code>命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体,需要包含对应的头文件.</p></li><li><p>不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止 —— 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>不要在头文件中使用 <em>命名空间别名</em>除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .cc 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .h 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> librarian &#123;</span><br><span class="line"><span class="keyword">namespace</span> impl &#123;  <span class="comment">// 仅限内部使用</span></span><br><span class="line"><span class="keyword">namespace</span> sidetable = ::pipeline_diagnostics::sidetable;</span><br><span class="line">&#125;  <span class="comment">// namespace impl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 限制在一个函数中的命名空间别名</span></span><br><span class="line">  <span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace librarian</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>禁止用内联命名空间</p></li></ul></blockquote><h3 id="匿名命名空间和静态变量">2.2. 匿名命名空间和静态变量</h3><p>Tip</p><p>在 <code>.cc</code>文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为<code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p><p><strong>定义:</strong></p><blockquote><p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为<code>static</code>拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p></blockquote><p><strong>结论:</strong></p><blockquote><p>推荐、鼓励在 <code>.cc</code>中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在<code>.h</code> 中使用。</p><p>匿名命名空间的声明和具名的格式相同，在最后注释上<code>namespace</code> :</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="非成员函数静态成员函数和全局函数">2.3.非成员函数、静态成员函数和全局函数</h3><p>Tip</p><p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数.将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p><p><strong>优点:</strong></p><blockquote><p>某些情况下, 非成员函数和静态成员函数是非常有用的,将非成员函数放在命名空间内可避免污染全局作用域.</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>将非成员函数和静态成员函数作为新类的成员或许更有意义,当它们需要访问外部资源或具有重要的依赖关系时更是如此.</p></blockquote><p><strong>结论:</strong></p><blockquote><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的.这样的函数可以被定义成静态成员, 或是非成员函数.非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内.相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">2.1.命名空间</a> 。举例而言，对于头文件 <code>myproject/foo_bar.h</code> ,应当使用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p>而非</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p>定义在同一编译单元的函数,被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖;静态成员函数对此尤其敏感. 可以考虑提取到新类中,或者将函数置于独立库的命名空间内.</p><p>如果你必须定义非成员函数, 又只是在 <code>.cc</code> 文件中使用它,可使用匿名 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">2.1.命名空间</a> 或 <code>static</code> 链接关键字 (如<code>static int Foo() &#123;...&#125;</code>) 限定其作用域.</p></blockquote><h3 id="局部变量">2.4. 局部变量</h3><p>Tip</p><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p><p>C++ 允许在函数的任何位置声明变量.我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好.这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值.特别是，应使用初始化的方式替代声明再赋值, 比如:</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 好——初始化时声明</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 好——v 一开始就初始化</span></span><br></pre></td></tr></table></figure></blockquote><p>属于 <code>if</code>, <code>while</code> 和 <code>for</code>语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></blockquote><p>Warning</p><p>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数,每次退出作用域都要调用其析构函数. 这会导致效率降低.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环作用域外面声明这类变量要高效的多:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态和全局变量">2.5. 静态和全局变量</h3><p>Tip</p><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p><p>禁止使用类的 <ahref="http://zh.cppreference.com/w/cpp/language/storage_duration##.E5.AD.98.E5.82.A8.E6.9C.9F">静态储存周期</a>变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug。不过 <code>constexpr</code>变量除外，毕竟它们又不涉及动态初始化或析构。</p><p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型(POD : Plain Old Data): 即 int, char 和 float, 以及 POD类型的指针、数组和结构体。</p><p>静态变量的构造函数、析构函数和初始化的顺序在 C++中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug.所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD变量，除非该函数（比如 <code>getenv()</code> 或 <code>getpid()</code>）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p><p>Note</p><p>Xris 译注:</p><p>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为(unspecified behaviour)。</p><p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从<code>main()</code> 返回还是对 <code>exit()</code>的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p><p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替<code>exit()</code>并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行<code>atexit()</code> 所绑定的任何 handlers. 如果您想在执行<code>quick_exit()</code> 来中断时执行某 handler（比如刷新log），您可以把它绑定到 <code>_at_quick_exit()</code>. 如果您想在<code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler,都绑定上去。</p><p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用<code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用<code>const char []</code>)。</p><p>如果您确实需要一个 <code>class</code>类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或<code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p><p>Note</p><p>Yang.Y 译注:</p><p>上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量,静态类成员变量, 以及函数静态变量.</p><h3 id="译者-yulefox-笔记-1">译者 (YuleFox) 笔记</h3><ol type="1"><li><code>cc</code> 中的匿名命名空间可避免命名冲突, 限定作用域,避免直接使用 <code>using</code> 关键字污染命名空间;</li><li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要<code>public</code>;</li><li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制,尽量单独形成编译单元;</li><li>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型(含 STL 容器), 避免不明确行为导致的 bug.</li><li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合,提高编译/执行效率.</li></ol><h3 id="译者acgtyrant笔记-1">译者（acgtyrant）笔记</h3><ol type="1"><li>注意「using 指示（using-directive）」和「using声明（using-declaration）」的区别。</li><li>匿名命名空间说白了就是文件作用域，就像 C static声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li><li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li><li>注意别在循环犯大量构造和析构的低级错误。</li></ol></div><h2 id="类">3. 类</h2><div class="story post-story"><p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用.本节列举了在写一个类时的主要注意事项.</p><h3 id="构造函数的职责">3.1. 构造函数的职责</h3><p><strong>总述</strong></p><p>不要在构造函数中调用虚函数,也不要在无法报出错误时进行可能失败的初始化.</p><p><strong>定义</strong></p><p>在构造函数中可以进行各种初始化操作.</p><p><strong>优点</strong></p><ul><li>无需考虑类是否被初始化.</li><li>经过构造函数完全初始化后的对象可以为 <code>const</code> 类型,也能更方便地被标准容器或算法使用.</li></ul><p><strong>缺点</strong></p><ul><li>如果在构造函数内调用了自身的虚函数,这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现,将来仍是隐患.</li><li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常(因为已经被 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##exceptions">禁用</a>了) 等方法的条件下, 构造函数很难上报错误</li><li>如果执行失败, 会得到一个初始化失败的对象,这个对象有可能进入不正常的状态, 必须使用 <code>bool IsValid()</code>或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.</li><li>构造函数的地址是无法被取得的, 因此, 举例来说,由构造函数完成的工作是无法以简单的方式交给其他线程的.</li></ul><p><strong>结论</strong></p><p>构造函数不允许调用虚函数. 如果代码允许,直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 <code>Init()</code>方法或工厂函数.</p><p>构造函数不得调用虚函数, 或尝试报告一个非致命错误.如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init()方法或使用工厂模式. Avoid <code>Init()</code> methods on objects with noother states that affect which public methods may be called(此类形式的半构造对象有时无法正确工作).</p><h3 id="隐式类型转换">3.2. 隐式类型转换</h3><p><strong>总述</strong></p><p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用<code>explicit</code> 关键字.</p><p><strong>定义</strong></p><p>隐式类型转换允许一个某种类型 (称作 <em>源类型</em>)的对象被用于需要另一种类型 (称作 <em>目的类型</em>) 的位置, 例如, 将一个<code>int</code> 类型的参数传递给需要 <code>double</code>类型的函数.</p><p>除了语言所定义的隐式类型转换,用户还可以通过在类定义中添加合适的成员定义自己需要的转换.在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如<code>operator bool()</code>). 在目的类型中定义隐式类型转换,则通过以源类型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现.</p><p><code>explicit</code> 关键字可以用于构造函数或 (在 C++11 引入)类型转换运算符,以保证只有当目的类型在调用点被显式写明时才能进行类型转换, 例如使用<code>cast</code>. 这不仅作用于隐式类型转换, 还能作用于 C++11的列表初始化语法:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Foo f)</span></span>;</span><br></pre></td></tr></table></figure><p>此时下面的代码是不允许的:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Func</span>(&#123;<span class="number">42</span>, <span class="number">3.14</span>&#125;);  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是<code>explicit</code> 应当限制的行为.</p><p><strong>优点</strong></p><ul><li>有时目的类型名是一目了然的, 通过避免显式地写出类型名,隐式类型转换可以让一个类型的可用性和表达性更强.</li><li>隐式类型转换可以简单地取代函数重载.</li><li>在初始化对象时, 列表初始化语法是一种简洁明了的写法.</li></ul><p><strong>缺点</strong></p><ul><li>隐式类型转换会隐藏类型不匹配的错误. 有时,目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li><li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候,因为这时很难判断到底是哪个函数被调用.</li><li>单参数构造函数有可能会被无意地用作隐式类型转换.</li><li>如果单参数构造函数没有加上 <code>explicit</code> 关键字,读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上<code>explicit</code> 标记.</li><li>并没有明确的方法用来判断哪个类应该提供类型转换,这会使得代码变得含糊不清.</li><li>如果目的类型是隐式指定的,那么列表初始化会出现和隐式类型转换一样的问题,尤其是在列表中只有一个元素的时候.</li></ul><p><strong>结论</strong></p><p>在类型定义中, 类型转换运算符和单参数构造函数都应当用<code>explicit</code> 进行标记. 一个例外是,拷贝和移动构造函数不应当被标记为 <code>explicit</code>,因为它们并不执行类型转换.对于设计目的就是用于对其他类型进行透明包装的类来说,隐式类型转换有时是必要且合适的. 这时应当联系项目组长并说明特殊情况.</p><p>不能以一个参数进行调用的构造函数不应当加上 <code>explicit</code>.接受一个 <code>std::initializer_list</code> 作为参数的构造函数也应当省略<code>explicit</code>, 以便支持拷贝初始化 (例如<code>MyType m = &#123;1, 2&#125;;)</code> .</p><h3 id="可拷贝类型和可移动类型">3.3. 可拷贝类型和可移动类型</h3><p><strong>总述</strong></p><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则,就把隐式产生的拷贝和移动函数禁用.</p><p><strong>定义</strong></p><p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值,或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值.对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义.<code>string</code> 类型就是一个可拷贝类型的例子.</p><p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值,或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的).<code>std::unique_ptr</code> 就是一个可移动但不可复制的对象的例子.对于用户定义的类型,移动操作一般是通过移动构造函数和移动赋值操作符实现的.</p><p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如,通过传值的方式传递对象.</p><p><strong>优点</strong></p><p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得API 更简单, 更安全也更通用. 与传指针和引用不同,这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱,也就没必要在协议中予以明确.这同时也防止了客户端与实现在非作用域内的交互,使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API一起使用, 例如大多数容器.</p><p>拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如<code>Clone()</code>, <code>CopyFrom()</code> or <code>Swap()</code>,更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过<code>= default</code>. 这种方式很简洁, 也保证所有数据成员都会被复制.拷贝与移动构造函数一般也更高效,因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 <ahref="http://en.cppreference.com/w/cpp/language/copy_elision">省略不必要的拷贝</a>这样的优化它们也更加合适.</p><p>移动操作允许隐式且高效地将源数据转移出右值对象.这有时能让代码风格更加清晰.</p><p><strong>缺点</strong></p><p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑,也显得荒谬而不合理. 单件类型 (<code>Registerer</code>),与特定的作用域相关的类型 (<code>Cleanup</code>),与其他对象实体紧耦合的类型 (<code>Mutex</code>)从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的,因为在使用它们时会造成 <ahref="https://en.wikipedia.org/wiki/Object_slicing">对象切割</a> .默认的或者随意的拷贝操作实现可能是不正确的,这往往导致令人困惑并且难以诊断出的错误.</p><p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略.这会让人迷惑,尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时,这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.</p><p><strong>结论</strong></p><p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则,如果对于你的用户来说这个拷贝操作不是一眼就能看出来的,那就不要把类型设置为可拷贝. 如果让类型可拷贝,一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝,同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作(移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝,但是移动操作的正确性对用户显然可见,那么把这个类型设置为只可移动并定义移动的两个操作.</p><p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的.记得时刻检查默认操作的正确性,并且在文档中说明类是可拷贝的且/或可移动的.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>(Foo&amp;&amp; other) : <span class="built_in">field_</span>(other.field) &#123;&#125;</span><br><span class="line">  <span class="comment">// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Field field_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于存在对象切割的风险,不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数(当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性,请提供一个 <code>public virtual Clone()</code> 和一个<code>protected</code> 的拷贝构造函数以供派生类实现.</p><p>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code>public</code>域中使用 <code>= delete</code> 或其他手段禁用之.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp;) = delee;</span><br></pre></td></tr></table></figure><h3 id="结构体-vs.-类">3.4. 结构体 VS. 类</h3><p><strong>总述</strong></p><p>仅当只有数据成员时使用 <code>struct</code>, 其它一概使用<code>class</code>.</p><p><strong>说明</strong></p><p>在 C++ 中 <code>struct</code> 和 <code>class</code>关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解,以便为定义的数据类型选择合适的关键字.</p><p><code>struct</code> 用来定义包含数据的被动式对象,也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能.并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数,<code>Initialize()</code>, <code>Reset()</code>, <code>Validate()</code>等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.</p><p>如果需要更多的函数功能, <code>class</code> 更适合. 如果拿不准, 就用<code>class</code>.</p><p>为了和 STL 保持一致, 对于仿函数等特性可以不用 <code>class</code>而是使用 <code>struct</code>.</p><p>注意: 类和结构体的成员变量使用不同的 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##variable-names">命名规则</a>.</p><h3 id="继承">3.5. 继承</h3><p><strong>总述</strong></p><p>使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;<Design Patterns>&gt;里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为<code>public</code> 继承.</p><p><strong>定义</strong></p><p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中,继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">接口继承</a>,子类仅继承父类的方法名称.</p><p><strong>优点</strong></p><p>实现继承通过原封不动的复用基类代码减少了代码量.由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误.从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API中某个必须的方法时, 编译器同样会发现并报告错误.</p><p><strong>缺点</strong></p><p>对于实现继承, 由于子类的实现代码散布在父类和子类间之间,要理解其实现变得更加困难. 子类不能重写父类的非虚函数,当然也就不能修改其实现. 基类也可能定义了一些数据成员,因此还必须区分基类的实际布局.</p><p><strong>结论</strong></p><p>所有继承必须是 <code>public</code> 的. 如果你想使用私有继承,你应该替换成把基类的实例作为成员对象的方式.</p><p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个”(“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承:如果 <code>Bar</code> 的确 “是一种” <code>Foo</code>, <code>Bar</code>才能继承 <code>Foo</code>.</p><p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数,则析构函数也应该为虚函数.</p><p>对于可能被子类访问的成员函数, 不要过度使用 <code>protected</code>关键字. 注意, 数据成员都必须是 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##access-control">私有的</a>.</p><p>对于重载的虚函数或虚析构函数, 使用 <code>override</code>, 或(较不常用的) <code>final</code> 关键字显式地进行标记. 较早 (早于 C++11)的代码可能会使用 <code>virtual</code> 关键字作为不得已的选项. 因此,在声明重载时, 请使用 <code>override</code>, <code>final</code> 或<code>virtual</code> 的其中之一进行标记. 标记为 <code>override</code> 或<code>final</code> 的析构函数如果不是对基类虚函数的重载的话, 编译会报错,这有助于捕获常见的错误. 这些标记起到了文档的作用,因为如果省略这些关键字, 代码阅读者不得不检查所有父类,以判断该函数是否是虚函数.</p><h3 id="多重继承">3.6. 多重继承</h3><p><strong>总述</strong></p><p>真正需要用到多重实现继承的情况少之又少.只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类;其它基类都是以 <code>Interface</code> 为后缀的 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">纯接口类</a>.</p><p><strong>定义</strong></p><p>多重继承允许子类拥有多个基类. 要将作为 <em>纯接口</em> 的基类和具有<em>实现</em> 的基类区别开来.</p><p><strong>优点</strong></p><p>相比单继承 (见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##inheritance">继承</a>),多重实现继承可以复用更多的代码.</p><p><strong>缺点</strong></p><p>真正需要用到多重 <em>实现</em> 继承的情况少之又少.有时多重实现继承看上去是不错的解决方案,但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.</p><p><strong>结论</strong></p><p>只有当所有父类除第一个外都是 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">纯接口类</a>时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以<code>Interface</code> 为后缀.</p><p><strong>注意</strong></p><p>关于该规则, Windows 下有个 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/exceptions/##windows-code">特例</a>.</p><h3 id="接口">3.7. 接口</h3><p><strong>总述</strong></p><p>接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀(不强制).</p><p><strong>定义</strong></p><p>当一个类满足以下要求时, 称之为纯接口:</p><ul><li>只有纯虚函数 (“<code>=0</code>”) 和静态函数(除了下文提到的析构函数).</li><li>没有非静态数据成员.</li><li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为<code>protected</code>.</li><li>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code>为后缀的类继承.</li></ul><p>接口类不能被直接实例化, 因为它声明了纯虚函数.为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的<em>The C++ Programming Language, 3rd edition</em> 第 12.4 节.</p><p><strong>优点</strong></p><p>以 <code>Interface</code>为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员.这一点对于 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##multiple-inheritance">多重继承</a>尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p><p><strong>缺点</strong></p><p><code>Interface</code> 后缀增加了类名长度, 为阅读和理解带来不便.同时, 接口属性作为实现细节不应暴露给用户.</p><p><strong>结论</strong></p><p>只有在满足上述条件时, 类才以 <code>Interface</code> 结尾, 但反过来,满足上述需要的类未必一定以 <code>Interface</code> 结尾.</p><h3 id="运算符重载">3.8. 运算符重载</h3><p><strong>总述</strong></p><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p><p><strong>定义</strong></p><p>C++ 允许用户通过使用 <code>operator</code> 关键字 <ahref="http://en.cppreference.com/w/cpp/language/operators">对内建运算符进行重载定义</a>, 只要其中一个参数是用户定义的类型. <code>operator</code>关键字还允许用户使用 <code>operator""</code> 定义新的字面运算符,并且定义类型转换函数, 例如 <code>operator bool()</code>.</p><p><strong>优点</strong></p><p>重载运算符可以让代码更简洁易懂,也使得用户定义的类型和内建类型拥有相似的行为.重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如<code>==</code>, <code>&lt;</code>, <code>=</code>,<code>&lt;&lt;</code>), 遵循这些语言约定可以让用户定义的类型更易读,也能更好地和需要这些重载运算符的函数库进行交互操作.</p><p>对于创建用户定义的类型的对象来说,用户定义字面量是一种非常简洁的标记.</p><p><strong>缺点</strong></p><ul><li>要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力,而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.</li><li>过度使用运算符会带来难以理解的代码,尤其是在重载的操作符的语义与通常的约定不符合时.</li><li>函数重载有多少弊端, 运算符重载就至少有多少.</li><li>运算符重载会混淆视听,让你误以为一些耗时的操作和操作内建类型一样轻巧.</li><li>对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了,这时需要能够理解 C++ 语法的搜索工具.</li><li>如果重载运算符的参数写错,此时得到的可能是一个完全不同的重载而非编译错误. 例如:<code>foo &lt; bar</code> 执行的是一个行为, 而<code>&amp;foo &lt; &amp;bar</code>执行的就是完全不同的另一个行为了.</li><li>重载某些运算符本身就是有害的. 例如, 重载一元运算符<code>&amp;</code> 会导致同样的代码有完全不同的含义,这取决于重载的声明对某段代码而言是否是可见的. 重载诸如<code>&amp;&amp;</code>, <code>||</code> 和 <code>,</code>会导致运算顺序和内建运算的顺序不一致.</li><li>运算符从通常定义在类的外部, 所以对于同一运算,可能出现不同的文件引入了不同的定义的风险.如果两种定义都链接到同一二进制文件, 就会导致未定义的行为,有可能表现为难以发现的运行时错误.</li><li>用户定义字面量所创建的语义形式对于某些有经验的 C++程序员来说都是很陌生的.</li></ul><p><strong>结论</strong></p><p>只有在意义明显,不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符.例如, <code>|</code> 要作为位或或逻辑或来使用, 而不是作为 shell中的管道.</p><p>只有对用户自己定义的类型重载运算符. 更准确地说,将它们和它们所操作的类型定义在同一个头文件中, <code>.cc</code>中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符,并且最大程度上避免了多重定义的风险. 如果可能的话,请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用.如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义,并且保证这些定义的语义是一致的. 例如, 如果你重载了 <code>&lt;</code>,那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数,<code>&lt;</code> 和 <code>&gt;</code> 不会同时返回<code>true</code>.</p><p>建议不要将不进行修改的二元运算符定义为成员函数.如果一个二元运算符被定义为类成员,这时隐式转换会作用域右侧的参数却不会作用于左侧. 这时会出现<code>a &lt; b</code> 能够通过编译而 <code>b &lt; a</code> 不能的情况,这是很让人迷惑的.</p><p>不要为了避免重载操作符而走极端. 比如说, 应当定义 <code>==</code>,<code>=</code>, 和 <code>&lt;&lt;</code> 而不是 <code>Equals()</code>,<code>CopyFrom()</code> 和 <code>PrintTo()</code>. 反过来说,不要只是为了满足函数库需要而去定义运算符重载. 比如说,如果你的类型没有自然顺序, 而你要将它们存入 <code>std::set</code> 中,最好还是定义一个自定义的比较运算符而不是重载 <code>&lt;</code>.</p><p>不要重载 <code>&amp;&amp;</code>, <code>||</code>, <code>,</code>或一元运算符 <code>&amp;</code>. 不要重载 <code>operator""</code>,也就是说, 不要引入用户定义字面量.</p><p>类型转换运算符在 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##implicit-conversions">隐式类型转换</a>一节有提及. <code>=</code> 运算符在 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##copyable-and-movable-types">可拷贝类型和可移动类型</a>一节有提及. 运算符 <code>&lt;&lt;</code> 在 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##streams">流</a>一节有提及. 同时请参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">函数重载</a>一节, 其中提到的的规则对运算符重载同样适用.</p><h3 id="存取控制">3.9. 存取控制</h3><p><strong>总述</strong></p><p>将 <em>所有</em> 数据成员声明为 <code>private</code>, 除非是<code>static const</code> 类型成员 (遵循 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量命名规则</a>).处于技术上的原因, 在使用 <ahref="https://github.com/google/googletest">Google Test</a>时我们允许测试固件类中的数据成员为 <code>protected</code>.</p><h3 id="声明顺序">3.10. 声明顺序</h3><p><strong>总述</strong></p><p>将相似的声明放在一起, 将 <code>public</code> 部分放在最前.</p><p><strong>说明</strong></p><p>类定义一般应以 <code>public:</code> 开始, 后跟<code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p><p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型(包括 <code>typedef</code>, <code>using</code> 和嵌套的结构体与类),常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</p><p>不要将大段的函数定义内联在类定义中. 通常，只有那些普通的,或性能关键且短小的函数可以内联在类定义中. 参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##inline-functions">内联函数</a>一节.</p><h3 id="译者-yulefox-笔记-2">译者 (YuleFox) 笔记</h3><ol type="1"><li>不在构造函数中做太多逻辑相关的初始化;</li><li>编译器提供的默认构造函数不会对变量进行初始化,如果定义了其他构造函数, 编译器不再提供,需要编码者自行提供默认构造函数;</li><li>为避免隐式转换, 需将单参数构造函数声明为 <code>explicit</code>;</li><li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为<code>private</code> 且无需实现;</li><li>仅在作为数据集合时使用 <code>struct</code>;</li><li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承,子类重载的虚函数也要声明 <code>virtual</code> 关键字,虽然编译器允许不这样做;</li><li>避免使用多重继承, 使用时, 除一个基类含有实现外,其他基类均为纯接口;</li><li>接口类类名以 <code>Interface</code> 为后缀,除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数,不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为<code>protected</code>;</li><li>为降低复杂性, 尽量不重载操作符, 模板,标准类中使用时提供文档说明;</li><li>存取函数一般内联在头文件中;</li><li>声明次序: <code>public</code> -&gt; <code>protected</code> -&gt;<code>private</code>;</li><li>函数体尽量短小, 紧凑, 功能单一;</li></ol></div><h2 id="函数">4. 函数</h2><div class="story post-story"><h3 id="参数顺序">4.1. 参数顺序</h3><p><strong>总述</strong></p><p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p><p><strong>说明</strong></p><p>C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之.输入参数通常是值参或 <code>const</code> 引用,输出参数或输入/输出参数则一般为非 <code>const</code> 指针.在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意,在加入新参数时不要因为它们是新参数就置于参数列表最后,而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p><p>这并非一个硬性规定. 输入/输出参数 (通常是类或结构体)让这个问题变得复杂. 并且, 有时候为了其他函数保持一致,你可能不得不有所变通.</p><h3 id="编写简短函数">4.2. 编写简短函数</h3><p><strong>总述</strong></p><p>我们倾向于编写简短, 凝练的函数.</p><p><strong>说明</strong></p><p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p><p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题,甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p><p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码:如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码,考虑将其分割为更加简短并易于管理的若干函数.</p><h3 id="引用参数">4.3. 引用参数</h3><p><strong>总述</strong></p><p>所有按引用传递的参数必须加上 <code>const</code>.</p><p><strong>定义</strong></p><p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明为引用参数:<code>int foo(int &amp;val)</code>.</p><p><strong>优点</strong></p><p>定义引用参数可以防止出现 <code>(*pval)++</code> 这样丑陋的代码.引用参数对于拷贝构造函数这样的应用也是必需的.同时也更明确地不接受空指针.</p><p><strong>缺点</strong></p><p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p><p><strong>结论</strong></p><p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">in</span>, <span class="built_in">string</span> *<span class="keyword">out</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或<code>const</code> 引用, 输出参数为指针. 输入参数可以是<code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数,除非特殊要求, 比如 <code>swap()</code>.</p><p>有时候, 在输入形参中用 <code>const T*</code> 指针比<code>const T&amp;</code> 更明智. 比如:</p><ul><li>可能会传递空指针.</li><li>函数要把指针或对地址的引用赋值给输入形参.</li></ul><p>总而言之, 大多时候输入形参往往是 <code>const T&amp;</code>. 若用<code>const T*</code> 则说明输入另有处理. 所以若要使用<code>const T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p><h3 id="函数重载">4.4. 函数重载</h3><p><strong>总述</strong></p><p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,而不用花心思猜测调用的重载函数到底是哪一种.这一规则也适用于构造函数.</p><p><strong>定义</strong></p><p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数,然后用另一个参数类型为 <code>const char*</code> 的函数对其进行重载:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><p>通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载,这同时也能为使用者带来便利.</p><p><strong>缺点</strong></p><p>如果函数单靠不同的参数类型而重载 (acgtyrant注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则,以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体,继承语义就容易令人困惑.</p><p><strong>结论</strong></p><p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用<code>AppendString()</code> 和 <code>AppendInt()</code> 等,而不是一口气重载多个 <code>Append()</code>.如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用<code>std::vector</code> 以便使用者可以用 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##braced-initializer-list">列表初始化</a>指定参数.</p><h3 id="缺省参数">4.5. 缺省参数</h3><p><strong>总述</strong></p><p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致.缺省参数与 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">函数重载</a>遵循同样的规则. 一般情况下建议使用函数重载,尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p><p><strong>优点</strong></p><p>有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数.缺省参数为这样的情形提供了便利,使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比,缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了“必要参数” 和 “可选参数”.</p><p><strong>缺点</strong></p><p>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">不应当使用函数重载的理由</a>也都适用于缺省参数.</p><p>虚函数调用的缺省参数取决于目标对象的静态类型,此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p><p>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀.作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了,而不是在每次调用时都可能会有不同的取值.</p><p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致.而函数重载不会导致这样的问题.</p><p><strong>结论</strong></p><p>对于虚函数, 不允许使用缺省参数,因为在虚函数中缺省参数不一定能正常工作.如果在每个调用点缺省参数的值都有可能不同,在这种情况下缺省函数也不允许使用. (例如, 不要写像<code>void f(int n = counter++);</code> 这样的代码.)</p><p>在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话,可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p><h3 id="函数返回类型后置语法">4.6. 函数返回类型后置语法</h3><p><strong>总述</strong></p><p>只有在常规写法 (返回类型前置)不便于书写或不便于阅读时使用返回类型后置语法.</p><p><strong>定义</strong></p><p>C++ 现在允许两种不同的函数声明方式.以往的写法是将返回类型置于函数名之前. 例如:</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>C++11 引入了这一新的形式. 现在可以在函数名前使用 <code>auto</code>关键字, 在参数列表之后后置返回类型. 例如:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span> foo(<span class="built_in">int</span> x) -&gt; <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure><p>后置返回类型为函数作用域. 对于像 <code>int</code> 这样简单的类型,两种写法没有区别. 但对于复杂的情况,例如类域中的类型声明或者以函数参数的形式书写的类型,写法的不同会造成区别.</p><p><strong>优点</strong></p><p>后置返回类型是显式地指定 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##lambda-expressions">Lambda表达式</a> 的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda表达式的返回类型, 但并不是在所有的情况下都能实现.即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p><p>有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单,也更易读, 尤其是在返回类型依赖于模板参数时. 例如:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; auto add<span class="function"><span class="params">(T t, U u)</span> -&gt;</span> decltype(t + u);</span><br></pre></td></tr></table></figure><p>对比下面的例子:</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">template</span> &lt;class <span class="type">T</span>, class <span class="type">U</span>&gt; decl<span class="keyword">type</span>(declval&lt;<span class="type">T</span>&amp;&gt;() + declval&lt;<span class="type">U</span>&amp;&gt;()) add(<span class="type">T</span> t, <span class="type">U</span> u);</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><p>后置返回类型相对来说是非常新的语法, 而且在 C 和 Java中都没有相似的写法, 因此可能对读者来说比较陌生.</p><p>在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍.因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下,只使用一种版本是相对来说更规整的形式.</p><p><strong>结论</strong></p><p>在大部分情况下, 应当继续使用以往的函数声明写法,即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式)或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法.但是后一种情况一般来说是很少见的,大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##template-metaprogramming">复杂的模板代码</a>.</p></div><h2 id="来自-google-的奇技">5. 来自 Google 的奇技</h2><div class="story post-story"><p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++的方式可能和你在其它地方见到的有所不同.</p><h3 id="所有权与智能指针">5.1. 所有权与智能指针</h3><p>==总述==</p><p>动态分配出的对象最好有单一且固定的所有主,并通过智能指针传递所有权.</p><p>==定义==</p><p>所有权是一种登记／管理动态内存和其它资源的技术.动态分配对象的所有主是一个对象或函数,后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享,此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享,在代码中直接把所有权传递给其它对象.</p><p>智能指针是一个通过重载 <code>*</code> 和 <code>-&gt;</code>运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作,来确保执行销毁义务到位. <ahref="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>是 C++11 新推出的一种智能指针类型,用来表示动态分配出的对象的独一无二的所有权; 当<code>std::unique_ptr</code> 离开作用域时, 对象就会被销毁.<code>std::unique_ptr</code> 不能被复制,但可以把它移动（move）给新所有主. <ahref="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制;对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时,对象也会随着被销毁.</p><p>==优点==</p><ul><li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li><li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li><li>传递所有权也比”借用”指针或引用来得简单,毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li><li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li><li>可以不用手动完成所有权的登记工作, 大大简化了代码,也免去了一大波错误之恼.</li><li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li></ul><p>==缺点==</p><ul><li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权.指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权,还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li><li>其实值语义的开销经常被高估,所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li><li>如果 API 依赖所有权的传递,就会害得客户端不得不用单一的内存管理模型.</li><li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li><li><code>std::unique_ptr</code> 的所有权传递原理是 C++11 的 move 语法,后者毕竟是刚刚推出的, 容易迷惑程序员.</li><li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制,可能不得不重构整个系统.</li><li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li><li>某些极端情况下 (例如循环引用),所有权被共享的对象永远不会被销毁.</li><li>智能指针并不能够完全代替原生指针.</li></ul><p>==结论==</p><p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中.如果其他地方要使用这个对象, 最好传递它的拷贝,或者传递一个不用改变所有权的指针或引用. 倾向于使用<code>std::unique_ptr</code> 来明确所有权传递, 例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FooConsumer</span><span class="params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>如果没有很好的理由, 则不要使用共享所有权.这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显,并且操作的对象是不可变的（比如说 <code>std::shared_ptr</code> ）时候,才能这么做. 如果确实要使用共享所有权, 建议于使用<code>std::shared_ptr</code> .</p><p>不要使用 <code>std::auto_ptr</code>, 使用<code>std::unique_ptr</code> 代替它.</p><h3 id="cpplint">5.2. Cpplint</h3><p><strong>&gt; 总述</strong></p><p>使用 <code>cpplint.py</code> 检查风格错误.</p><p><strong>&gt; 说明</strong></p><p><code>cpplint.py</code> 是一个用来分析源文件,能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报,但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>,或在上一行加 <code>// NOLINTNEXTLINE</code>, 可以忽略报错.</p><p>某些项目会指导你如何使用他们的项目工具运行 <code>cpplint.py</code>.如果你参与的项目没有提供, 你可以单独下载 <ahref="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p><h3 id="译者acgtyrant笔记-2">译者（acgtyrant）笔记</h3><ol type="1"><li>把智能指针当成对象来看待的话,就很好领会它与所指对象之间的关系了.</li><li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li><li><code>scoped_ptr</code> 和 <code>auto_ptr</code> 已过时. 现在是<code>shared_ptr</code> 和 <code>uniqued_ptr</code> 的天下了.</li><li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li><li>Arch Linux 用户注意了, AUR 有对 cpplint 打包.</li></ol></div><h2 id="其他-c-特性">6. 其他 C++ 特性</h2><div class="story post-story"><h3 id="引用参数-1">6.1. 引用参数</h3><p>==Tip==</p><p>所有按引用传递的参数必须加上 <code>const</code>.</p><p>==定义:==</p><blockquote><p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数:<code>int foo(int &amp;val)</code>.</p></blockquote><p>==优点:==</p><blockquote><p>定义引用参数防止出现 <code>(*pval)++</code> 这样丑陋的代码.像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <code>NULL</code>指针.</p></blockquote><p>==缺点:==</p><blockquote><p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p></blockquote><p>==结论:==</p><blockquote><p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> string &amp;in, string *out)</span></span>;</span><br></pre></td></tr></table></figure></blockquote><p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或<code>const</code> 引用, 输出参数为指针. 输入参数可以是<code>const</code> 指针, 但决不能是非 <code>const</code>的引用参数，除非用于交换，比如 <code>swap()</code>.</p><p>有时候，在输入形参中用 <code>const T*</code> 指针比<code>const T&amp;</code> 更明智。比如：</p><ul><li>您会传 null 指针。</li><li>函数要把指针或对地址的引用赋值给输入形参。</li></ul><p>总之大多时候输入形参往往是 <code>const T&amp;</code>. 若用<code>const T*</code> 说明输入另有处理。所以若您要用<code>const T*</code>, 则应有理有据，否则会害得读者误解。</p></blockquote><h3 id="右值引用">6.2. 右值引用</h3><p>==Tip==</p><p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用<code>std::forward</code>.</p><p>==定义:==</p><blockquote><p>右值引用是一种只能绑定到临时对象的引用的一种,其语法与传统的引用语法相似. 例如,<code>void f(string&amp;&amp; s)</code>;声明了一个其参数是一个字符串的右值引用的函数.</p></blockquote><p>==优点:==</p><blockquote><p>用于定义移动构造函数 (使用类的右值引用进行构造的函数)使得移动一个值而非拷贝之成为可能. 例如, 如果 <code>v1</code> 是一个<code>vector</code>, 则 <code>auto v2(std::move(v1))</code>将很可能不再进行大量的数据复制而只是简单地进行指针操作,在某些情况下这将带来大幅度的性能提升.</p><p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能,无论其参数是否是临时对象都能正常工作.</p><p>右值引用能实现可移动但不可拷贝的类型,这一特性对那些在拷贝方面没有实际需求,但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p><p>要高效率地使用某些标准库类型, 例如 <code>std::unique_ptr</code>,<code>std::move</code> 是必需的.</p></blockquote><p>==缺点:==</p><blockquote><p>右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解.类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</p></blockquote><p>==结论:==</p><blockquote><p>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用<code>std::forward</code> 功能函数. 你可能会使用 <code>std::move</code>来表示将值从一个对象移动而不是复制到另一个对象.</p></blockquote><h3 id="函数重载-1">6.3. 函数重载</h3><p>==Tip==</p><p>若要用好函数重载，最好能让读者一看调用点（callsite）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p><p>==定义:==</p><blockquote><p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数,然后用另一个参数类型为 <code>const char*</code> 的函数重载它:</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>==优点:==</p><blockquote><p>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载,同时为使用者带来便利.</p></blockquote><p>==缺点:==</p><blockquote><p>如果函数单单靠不同的参数类型而重载（acgtyrant注：这意味着参数数量不变），读者就得十分熟悉 C++五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</p></blockquote><p>==结论:==</p><blockquote><p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用<code>AppendString()</code> 和 <code>AppendInt()</code> 等，而不是一口气重载多个 <code>Append()</code>.</p></blockquote><h3 id="缺省参数-1">6.4. 缺省参数</h3><p>==Tip==</p><p>我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p><p>==优点:==</p><blockquote><p>当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</p></blockquote><p>==缺点:==</p><blockquote><p>缺省参数会干扰函数指针，害得后者的函数签名（functionsignature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（callsite）都有重复（acgtyrant注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</p></blockquote><p>==结论:==</p><blockquote><p>由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant注：即不能再通过缺省参数来省略参数了）。</p><p>其一，位于 <code>.cc</code>文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p><p>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p><p>其三，可以用来模拟变长数组。</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过空 AlphaNum 以支持四个形参</span></span><br><span class="line"><span class="function">string <span class="title">StrCat</span><span class="params">(<span class="type">const</span> AlphaNum &amp;a,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> AlphaNum &amp;b = gEmptyAlphaNum,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> AlphaNum &amp;c = gEmptyAlphaNum,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> AlphaNum &amp;d = gEmptyAlphaNum)</span></span>;</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="变长数组和-alloca">6.5. 变长数组和 alloca()</h3><p>==Tip==</p><p>我们不允许使用变长数组和 <code>alloca()</code>.</p><p>==优点:==</p><blockquote><p>变长数组具有浑然天成的语法. 变长数组和 <code>alloca()</code>也都很高效.</p></blockquote><p>==缺点:==</p><blockquote><p>变长数组和 <code>alloca()</code> 不是标准 C++ 的组成部分. 更重要的是,它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs:“在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</p></blockquote><p>==结论:==</p><blockquote><p>改用更安全的分配器（allocator），就像 <code>std::vector</code> 或<code>std::unique_ptr</code>.</p></blockquote><h3 id="友元">6.6. 友元</h3><p>==Tip==</p><p>我们允许合理的使用友元类及友元函数.</p><p>通常友元应该定义在同一文件内,避免代码读者跑到其它文件查找使用该私有成员的类.经常用到友元的一个地方是将 <code>FooBuilder</code> 声明为<code>Foo</code> 的友元, 以便 <code>FooBuilder</code> 正确构造<code>Foo</code> 的内部状态, 而无需将该状态暴露出来. 某些情况下,将一个单元测试类声明成待测类的友元会很方便.</p><p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下,相对于将类成员声明为 <code>public</code>, 使用友元是更好的选择,尤其是如果你只允许另一个类访问该类的私有成员时. 当然,大多数类都只应该通过其提供的公有成员进行互操作.</p><h3 id="异常">6.7. 异常</h3><p>==Tip==</p><p>我们不使用 C++ 异常.</p><p>==优点:==</p><blockquote><ul><li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li><li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类C++ 的语言更一脉相承。</li><li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li><li>异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或<code>Init()</code> 方法代替异常,但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“状态。</li><li>在测试框架里很好用。</li></ul></blockquote><p>==缺点:==</p><blockquote><ul><li>在现有函数中添加 <code>throw</code>语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，<code>f()</code>调用 <code>g()</code>, <code>g()</code> 又调用 <code>h()</code>, 且<code>h</code> 抛出的异常被 <code>f</code> 捕获。当心 <code>g</code>,否则会没妥善清理好。</li><li>还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li><li>异常安全需要RAII和不同的编码实践.要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说,为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交”状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码).如果允许使用异常, 我们就不得不时刻关注这样的弊端,即使有时它们并不值得.</li><li>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。</li><li>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li></ul></blockquote><p>==结论:==</p><blockquote><p>从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码,引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散,在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p><p>鉴于 Google 现有代码不接受异常,在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢,也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码,断言等会造成严重负担.</p><p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上.我们希望在 Google 使用我们自己的开源项目,但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p><p>对于 Windows 代码来说, 有个 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/exceptions/##windows-code">特例</a>.</p></blockquote><p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的,以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理,Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了,无非是基于软件管理成本上, 实际使用中还是自己决定)</p><h3 id="运行时类型识别">6.8. 运行时类型识别</h3><p>==Tip==</p><p>我们禁止使用 RTTI.</p><p>==定义:==</p><blockquote><p>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用<code>typeid</code> 或者 <code>dynamic_cast</code> 完成.</p></blockquote><p>==优点:==</p><blockquote><p>RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构.有时这样的修改并不是我们所想要的, 甚至是不可取的,尤其是在一个已经广泛使用的或者成熟的代码中.</p><p>RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时,用来验证一个新建对象是否为期望的动态类型. RTTI对于管理对象和派生对象的关系也很有用.</p><p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Base::Equal</span><span class="params">(Base* other)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Derived::Equal</span><span class="params">(Base* other)</span> </span>&#123;</span><br><span class="line">  Derived* that = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(other);</span><br><span class="line">  <span class="keyword">if</span> (that == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>==缺点:==</p><blockquote><p>在运行时判断类型通常意味着设计问题.如果你需要在运行期间确定一个对象的类型,这通常说明你需要考虑重新设计你的类.</p><p>随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p></blockquote><p>==结论:==</p><blockquote><p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意.在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中,使用 RTTI 前务必三思.如果你的代码需要根据不同的对象类型执行不同的行为的话,请考虑用以下的两种替代方案之一查询类型:</p><p>虚函数可以根据子类类型的不同而执行不同代码.这是把工作交给了对象本身去处理.</p><p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案,例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p><p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例,那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast也是一种替代方案.</p><p>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了.不要像下面这样:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D1)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D2)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D3)) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且,一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p><p>不要去手工实现一个类似 RTTI 的方案. 反对 RTTI的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且,这些方案会掩盖你的真实意图.</p></blockquote><h3 id="类型转换">6.9. 类型转换</h3><p>==Tip==</p><p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用<code>int y = (int)x</code> 或 <code>int y = int(x)</code>等转换方式;</p><p>==定义:==</p><blockquote><p>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</p></blockquote><p>==优点:==</p><blockquote><p>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如<code>(int)3.5</code>), 有时是在做类型转换 (如<code>(int)"hello"</code>). 另外, C++ 的类型转换在查找时更醒目.</p></blockquote><p>==缺点:==</p><blockquote><p>恶心的语法.</p></blockquote><p>==结论:==</p><blockquote><p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p><blockquote><ul><li>用 <code>static_cast</code> 替代 C 风格的值转换,或某个类指针需要明确的向上转换为父类指针时.</li><li>用 <code>const_cast</code> 去掉 <code>const</code> 限定符.</li><li>用 <code>reinterpret_cast</code>指针类型和整型或其它指针之间进行不安全的相互转换.仅在你对所做一切了然于心时使用.</li></ul></blockquote><p>至于 <code>dynamic_cast</code> 参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##rtti">6.8.运行时类型识别</a>.</p></blockquote><h3 id="流">6.10. 流</h3><p>==Tip==</p><p>只在记录日志时使用流.</p><p>==定义:==</p><blockquote><p>流用来替代 <code>printf()</code> 和 <code>scanf()</code>.</p></blockquote><p>==优点:==</p><blockquote><p>有了流, 在打印时不需要关心对象的类型.不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用<code>printf</code> 也不存在这个问题).流的构造和析构函数会自动打开和关闭对应的文件.</p></blockquote><p>==缺点:==</p><blockquote><p>流使得 <code>pread()</code> 等功能函数很难执行. 如果不使用<code>printf</code> 风格的格式化字符串, 某些格式化操作(尤其是常用的格式字符串 <code>%.*s</code>) 用流处理性能是很低的.流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</p></blockquote><p>==结论:==</p><blockquote><p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code>之类的代替.</p><p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p></blockquote><p>==拓展讨论:==</p><blockquote><p>对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则(Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型,使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是<code>printf + read/write</code>. 相反, 我们应该决定到底用哪一种方式.把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p><p>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力.他们指出的流的每个优势也都是其劣势.流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时,也是一个不足: 你很容易用错类型, 而编译器不会报警.使用流时容易造成的这类错误:</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="keyword">this</span>;   <span class="comment">// 输出地址</span></span><br><span class="line">cout &lt;&lt; *<span class="keyword">this</span>;  <span class="comment">// 输出值</span></span><br></pre></td></tr></table></figure></blockquote><p>由于 <code>&lt;&lt;</code> 被重载, 编译器不会报错.就因为这一点我们反对使用操作符重载.</p><p>有人说 <code>printf</code> 的格式化丑陋不堪, 易读性差,但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p><blockquote><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">cerr &lt;&lt; <span class="string">&quot;Error connecting to &#x27;&quot;</span> &lt;&lt; foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.first</span><br><span class="line">     &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.second &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; strerror(errno);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">&quot;Error connecting to &#x27;%s:%u: %s&quot;</span>,</span><br><span class="line">        foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.first, foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.second,</span><br><span class="line">        strerror(errno));</span><br></pre></td></tr></table></figure></blockquote><p>你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢?而且不要忘了, 我们的目标是使语言更紧凑,而不是添加一些别人需要学习的新装备.</p><p>每一种方式都是各有利弊, “没有最好, 只有更适合”.简单性原则告诫我们必须从中选择其一, 最后大多数决定采用<code>printf + read/write</code>.</p></blockquote><h3 id="前置自增和自减">6.11. 前置自增和自减</h3><p>==Tip==</p><p>对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增,自减运算符.</p><p>==定义:==</p><blockquote><p>对于变量在自增 (<code>++i</code> 或 <code>i++</code>) 或自减(<code>--i</code> 或 <code>i--</code>) 后表达式的值又没有没用到的情况下,需要确定到底是使用前置还是后置的自增 (自减).</p></blockquote><p>==优点:==</p><blockquote><p>不考虑返回值的话, 前置自增 (<code>++i</code>) 通常要比后置自增(<code>i++</code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值<code>i</code> 进行一次拷贝. 如果 <code>i</code>是迭代器或其他非数值类型, 拷贝的代价是比较大的.既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</p></blockquote><p>==缺点:==</p><blockquote><p>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增,特别是在 <code>for</code> 循环中. 有些人觉得后置自增更加易懂,因为这很像自然语言, 主语 (<code>i</code>) 在谓语动词 (<code>++</code>)前.</p></blockquote><p>==结论:==</p><blockquote><p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增(自减).</p></blockquote><h3 id="const-用法">6.12. <code>const</code> 用法</h3><p>==Tip==</p><p>我们强烈建议你在任何可能的情况下都要使用 <code>const</code>.此外有时改用 C++11 推出的 constexpr 更好。</p><p>==定义:==</p><blockquote><p>在声明的变量或参数前加上关键字 <code>const</code>用于指明变量值不可被篡改 (如 <code>const int foo</code> ).为类中的函数加上 <code>const</code>限定符表明该函数不会修改类成员变量的状态 (如<code>class Foo &#123; int Bar(char c) const; &#125;;</code>).</p></blockquote><p>==优点:==</p><blockquote><p>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地,也能生成更好的代码. 人们对编写正确的代码更加自信,因为他们知道所调用的函数被限定了能或不能修改变量值.即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</p></blockquote><p>==缺点:==</p><blockquote><p><code>const</code> 是入侵性的: 如果你向一个函数传入<code>const</code> 变量, 函数原型声明中也必须对应 <code>const</code>参数 (否则变量需要 <code>const_cast</code> 类型转换),在调用库函数时显得尤其麻烦.</p></blockquote><p>==结论:==</p><blockquote><p><code>const</code> 变量, 数据成员,函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此,我们强烈建议在任何可能的情况下使用 <code>const</code>:</p><blockquote><ul><li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为<code>const</code>.</li><li>尽可能将函数声明为 <code>const</code>. 访问函数应该总是<code>const</code>. 其他不会修改任何数据成员, 未调用非<code>const</code> 函数, 不会返回数据成员非 <code>const</code>指针或引用的函数也应该声明成 <code>const</code>.</li><li>如果数据成员在对象构造之后不再发生变化, 可将其定义为<code>const</code>.</li></ul></blockquote><p>然而, 也不要发了疯似的使用 <code>const</code>. 像<code>const int * const * const x;</code> 就有些过了,虽然它非常精确的描述了常量 <code>x</code>. 关注真正有帮助意义的信息:前面的例子写成 <code>const int** x</code> 就够了.</p><p>关键字 <code>mutable</code> 可以使用, 但是在多线程中是不安全的,使用时首先要考虑线程安全.</p></blockquote><p><code>const</code> 的位置:</p><blockquote><p>有人喜欢 <code>int const *foo</code> 形式, 不喜欢<code>const int* foo</code>, 他们认为前者更一致因此可读性也更好: 遵循了<code>const</code> 总位于其描述的对象之后的原则.但是一致性原则不适用于此, “不要过度使用”的声明可以取消大部分你原本想保持的一致性. 将 <code>const</code>放在前面才更易读, 因为在自然语言中形容词 (<code>const</code>) 是在名词(<code>int</code>) 之前.</p><p>这是说, 我们提倡但不强制 <code>const</code> 在前.但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把<code>const</code> 写在类型前面, 在其他地方又写在后面, 确定一种写法,然后保持一致.)</p></blockquote><h3 id="constexpr-用法">6.13. <code>constexpr</code> 用法</h3><p>==Tip==</p><p>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><p>==定义:==</p><blockquote><p>变量可以被声明成 constexpr以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成constexpr, 以用来定义 constexpr 变量。</p></blockquote><p>==优点:==</p><blockquote><p>如今 constexpr就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p></blockquote><p>==缺点:==</p><blockquote><p>若过早把变量优化成 constexpr变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</p></blockquote><p>==结论:==</p><blockquote><p>靠 constexpr 特性，方才实现了 C++在接口上打造真正常量机制的可能。好好用 constexpr来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</p></blockquote><h3 id="整型">6.14. 整型</h3><p>==Tip==</p><p>C++ 内建整型中, 仅使用 <code>int</code>.如果程序中需要不同大小的变量, 可以使用`<code>中长度精确的整型, 如</code>int16_t<code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如</code>int64_t`.此外要留意，哪怕您的值并不会超出 int所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p><p>==定义:==</p><blockquote><p>C++ 没有指定整型的大小. 通常人们假定 <code>short</code> 是 16 位,<code>int</code> 是 32 位, <code>long</code> 是 32 位,<code>long long</code> 是 64 位.</p></blockquote><p>==优点:==</p><blockquote><p>保持声明统一.</p></blockquote><p>==缺点:==</p><blockquote><p>C++ 中整型大小因编译器和体系结构的不同而不同.</p></blockquote><p>==结论:==</p><blockquote><p>`<code>定义了</code>int16_t<code>,</code>uint32_t<code>,</code>int64_t<code>等整型, 在需要确保整型大小时可以使用它们代替</code>short<code>,</code>unsignedlonglong<code>等. 在 C 整型中, 只使用</code>int<code>. 在合适的情况下, 推荐使用标准类型如</code>size_t<code>和</code>ptrdiff_t`.</p><p>如果已知整数不会太大, 我们常常会使用 <code>int</code>, 如循环计数.在类似的情况下使用原生类型 <code>int</code>. 你可以认为 <code>int</code>至少为 32 位, 但不要认为它会多于 <code>32</code> 位. 如果需要 64 位整型,用 <code>int64_t</code> 或 <code>uint64_t</code>.</p><p>对于大整数, 使用 <code>int64_t</code>.</p><p>不要使用 <code>uint32_t</code> 等无符号整型,除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出.尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反,你应该使用断言来保护数据.</p><p>如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p><p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如<code>int</code> 与 <code>unsigned int</code> 运算时，前者被提升为<code>unsigned int</code> 而有可能溢出），总有意想不到的后果。</p></blockquote><p>关于无符号整数:</p><blockquote><p>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数.这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug所淹没. 看看下面的例子:</p><blockquote><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">for <span class="params">(unsigned int <span class="attr">i</span> = foo.Length()</span>-1; i &gt;= 0; <span class="params">--i</span>) <span class="string">...</span></span><br></pre></td></tr></table></figure></blockquote><p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警,但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时.主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p><p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p></blockquote><h3 id="位下的可移植性">6.15. 64 位下的可移植性</h3><p>==Tip==</p><p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较,结构体对齐时应切记:</p><ul><li><p>对于某些类型, <code>printf()</code> 的指示符在 32 位和 64位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符.不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏,所以有时我们不得不自己定义一个丑陋的版本 (头文件 <code>inttypes.h</code>仿标准风格):</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// printf macros for size_t, in the style of inttypes.h</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> _LP64</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> __PRIS_PREFIX <span class="string">&quot;z&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> __PRIS_PREFIX</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use these macros after a % in a printf format string</span></span><br><span class="line"><span class="comment">// to get correct 32/64 bit behavior, like this:</span></span><br><span class="line"><span class="comment">// size_t size = records.size();</span></span><br><span class="line"><span class="comment">// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIdS __PRIS_PREFIX <span class="string">&quot;d&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIxS __PRIS_PREFIX <span class="string">&quot;x&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIuS __PRIS_PREFIX <span class="string">&quot;u&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIXS __PRIS_PREFIX <span class="string">&quot;X&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> PRIoS __PRIS_PREFIX <span class="string">&quot;o&quot;</span></span></span><br></pre></td></tr></table></figure><table><colgroup><col style="width: 32%" /><col style="width: 21%" /><col style="width: 28%" /><col style="width: 17%" /></colgroup><thead><tr class="header"><th>类型</th><th>不要使用</th><th>使用</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><code>void *</code> (或其他指针类型)</td><td><code>%lx</code></td><td><code>%p</code></td><td></td></tr><tr class="even"><td><code>int64_t</code></td><td><code>%qd, %lld</code></td><td><code>%"PRId64"</code></td><td></td></tr><tr class="odd"><td><code>uint64_t</code></td><td><code>%qu, %llu, %llx</code></td><td><code>%"PRIu64", %"PRIx64"</code></td><td></td></tr><tr class="even"><td><code>size_t</code></td><td><code>%u</code></td><td><code>%"PRIuS", %"PRIxS"</code></td><td>C99 规定 <code>%zu</code></td></tr><tr class="odd"><td><code>ptrdiff_t</code></td><td><code>%d</code></td><td><code>%"PRIdS"</code></td><td>C99 规定 <code>%zd</code></td></tr></tbody></table><p>注意 <code>PRI*</code> 宏会被编译器扩展为独立字符串.因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用<code>PRI*</code> 宏同样可以在 <code>%</code> 后包含长度指示符. 例如,<code>printf("x = %30"PRIuS"\n", x)</code> 在 32 位 Linux 上将被展开为<code>printf("x = %30" "u" "\n", x)</code>, 编译器当成<code>printf("x = %30u\n", x)</code> 处理 (Yang.Y 注: 这在 MSVC 6.0上行不通, VC 6编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p></blockquote></li><li><p>记住 <code>sizeof(void *) != sizeof(int)</code>.如果需要一个指针大小的整数要用 <code>intptr_t</code>.</p></li><li><p>你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体(Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64位系统中, 任何含有 <code>int64_t</code>/<code>uint64_t</code>成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致.大多数编译器都允许调整结构体对齐. gcc 中可使用<code>__attribute__((packed))</code>. MSVC 则提供了<code>##pragma pack()</code> 和 <code>__declspec(align())</code>(YuleFox 注, 解决方案的项目属性里也可以直接设置).</p></li><li><p>创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int64_t</span> my_value = <span class="number">0x123456789</span>LL;</span><br><span class="line"><span class="type">uint64_t</span> my_mask = <span class="number">3ULL</span> &lt;&lt; <span class="number">48</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用<code>##ifdef _LP64</code> 指令来切分 32/64 位代码. (尽量不要这么做,如果非用不可, 尽量使修改局部化)</p></li></ul><h3 id="预处理宏">6.16. 预处理宏</h3><p>==Tip==</p><p>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p><p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为,尤其因为宏具有全局作用域.</p><p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少.以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被<code>const</code> 变量代替. 用宏 “缩写” 长变量名可被引用代替.用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦(<code>##define</code> 防止头文件重包含当然是个特例).</p><p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中)可以看到宏的某些特性 (如用 <code>##</code> 字符串化, 用 <code>###</code>连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p><p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏,尽可能遵守:</p><blockquote><ul><li>不要在 <code>.h</code> 文件中定义宏.</li><li>在马上要使用时才进行 <code>##define</code>, 使用后要立即<code>##undef</code>.</li><li>不要只是对已经存在的宏使用##undef，选择一个不会冲突的名称；</li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏,不然也至少要附上文档说明其行为.</li><li>不要用 <code>###</code> 处理函数，类和变量的名字。</li></ul></blockquote><h3 id="nullptr-和-null">6.17. 0, <code>nullptr</code> 和<code>NULL</code></h3><p>==Tip==</p><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用<code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用<code>'\0'</code>.</p><p>整数用 <code>0</code>, 实数用 <code>0.0</code>,这一点是毫无争议的.</p><p>对于指针 (地址值), 到底是用 <code>0</code>, <code>NULL</code> 还是<code>nullptr</code>. C++11 项目用 <code>nullptr</code>; C++03 项目则用<code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对<code>NULL</code> 的定义比较特殊，可以输出有用的警告，特别是<code>sizeof(NULL)</code> 就和 <code>sizeof(0)</code> 不一样。</p><p>字符 (串) 用 <code>'\0'</code>, 不仅类型正确而且可读性好.</p><h3 id="sizeof">6.18. sizeof</h3><p>==Tip==</p><p>尽可能用 <code>sizeof(varname)</code> 代替<code>sizeof(type)</code>.</p><p>使用 <code>sizeof(varname)</code>是因为当代码中变量类型改变时会自动更新. 您或许会用<code>sizeof(type)</code>处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Struct data;</span><br><span class="line">Struct data; <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));</span><br></pre></td></tr></table></figure><p>==Warning==</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(Struct));</span><br><span class="line"><span class="keyword">if</span> (raw_size &lt; <span class="built_in">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;compressed record not big enough for count: &quot;</span> &lt;&lt; raw_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="auto">6.19. auto</h3><p>==Tip==</p><p>用 <code>auto</code>绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p><p>==定义：==</p><blockquote><p>C++11 中，若变量被声明成 <code>auto</code>,那它的类型就会被自动匹配成初始化表达式的类型。您可以用 <code>auto</code>来复制初始化或绑定引用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>];  <span class="comment">// 创建一份 v[0] 的拷贝。</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>];  <span class="comment">// s2 是 v[0] 的一个引用。</span></span><br></pre></td></tr></table></figure></blockquote><p>==优点：==</p><blockquote><p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sparse_hash_map&lt;string, <span class="type">int</span>&gt;::iterator iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure><p>返回类型好难读，代码目的也不够一目了然。重构其：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure><p>好多了。</p><p>没有 <code>auto</code>的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br></pre></td></tr></table></figure><p>有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p></blockquote><p>==缺点：==</p><blockquote><p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = x.<span class="built_in">Lookup</span>(key);</span><br></pre></td></tr></table></figure><p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p><p>程序员必须会区分 <code>auto</code> 和 <code>const auto&amp;</code>的不同之处，否则会复制错东西。</p><p>auto 和 C++11 列表初始化的合体令人摸不着头脑：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 圆括号。</span></span><br><span class="line"><span class="keyword">auto</span> y&#123;<span class="number">3</span>&#125;;  <span class="comment">// 大括号。</span></span><br></pre></td></tr></table></figure><p>它们不是同一回事——<code>x</code> 是 <code>int</code>, <code>y</code>则是 <code>std::initializer_list</code>.其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types,它涉及到 C++ 鲜为人知的坑：<ahref="http://stackoverflow.com/a/17794965/1546088">Why is vector not aSTL container?</a>）也有大同小异的陷阱。</p><p>如果在接口里用 <code>auto</code>,比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API要翻天覆地了。</p></blockquote><p>结论：</p><blockquote><p><code>auto</code>只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化<code>auto</code> 变量。</p><p><code>auto</code> 还可以和 C++11 特性「尾置返回类型（trailing returntype）」一起用，不过后者只能用在 lambda 表达式里。</p></blockquote><h3 id="列表初始化">6.20. 列表初始化</h3><p>==Tip==</p><p>你可以用列表初始化。</p><p>早在 C++03 里，聚合类型（aggregatetypes）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line">Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>C++11中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector 接收了一个初始化列表。</span></span><br><span class="line">vector&lt;string&gt; v&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不考虑细节上的微妙差别，大致上相同。</span></span><br><span class="line"><span class="comment">// 您可以任选其一。</span></span><br><span class="line">vector&lt;string&gt; v = &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以配合 new 一起用。</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> vector&lt;string&gt;&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 接收了一些 pair, 列表初始化大显神威。</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表也可以用在返回类型上的隐式转换。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表可迭代。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用里用列表初始化。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">TestFunction2</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>用户自定义类型也可以定义接收 <code>std::initializer_list</code>的构造函数和赋值运算符，以自动列表初始化：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// std::initializer_list 专门接收 init 列表。</span></span><br><span class="line">  <span class="comment">// 得以值传递。</span></span><br><span class="line">  <span class="built_in">MyType</span>(std::initializer_list&lt;<span class="type">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  MyType&amp; <span class="keyword">operator</span>=(std::initializer_list&lt;<span class="type">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyType m&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收<code>std::initializer_list</code> 的构造函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="comment">// MyOtherType 没有 std::initializer_list 构造函数，</span></span><br><span class="line"> <span class="comment">// 直接上接收常规类型的构造函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOtherType</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyOtherType</span><span class="params">(string)</span></span>;</span><br><span class="line">  <span class="built_in">MyOtherType</span>(<span class="type">int</span>, string);</span><br><span class="line">&#125;;</span><br><span class="line">MyOtherType m = &#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。</span></span><br><span class="line">MyOtherType m&#123;<span class="string">&quot;b&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p><p>==Warning==</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;        <span class="comment">// d 即是 std::initializer_list&lt;double&gt;</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="type">double</span>&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// 善哉 -- d 即为 double, 并非 std::initializer_list.</span></span><br></pre></td></tr></table></figure><p>至于格式化，参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##braced-initializer-list-format">9.7.列表初始化格式</a>.</p><h3 id="lambda-表达式">6.21. Lambda 表达式</h3><p>==Tip==</p><p>适当使用 lambda 表达式。别用默认 lambda捕获，所有捕获都要显式写出来。</p><p>==定义：==</p><blockquote><p>Lambda表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Weight</span>(x) &lt; <span class="built_in">Weight</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>C++11 首次提出 Lambdas,还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper）<code>std::function</code>.</p></blockquote><p>==优点：==</p><blockquote><ul><li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li><li>Lambdas, <code>std::functions</code> 和 <code>std::bind</code>可以搭配成通用回调机制（general purpose callbackmechanism）；写接收有界函数为参数的函数也很容易了。</li></ul></blockquote><p>==缺点：==</p><blockquote><ul><li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li><li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li></ul></blockquote><p>==结论：==</p><blockquote><ul><li>按 format 小用 lambda 表达式怡情。</li><li>禁用默认捕获，捕获都要显式写出来。打比方，比起<code>[=](int x) &#123;return x + n;&#125;</code>, 您该写成<code>[n](int x) &#123;return x + n;&#125;</code> 才对，这样读者也好一眼看出<code>n</code> 是被捕获的值。</li><li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant注：即把 lambda 表达式赋值给对象），或改用函数。</li><li>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</li></ul></blockquote><h3 id="模板编程">6.22. 模板编程</h3><p>==Tip==</p><p>不要使用复杂的模板编程</p><p>==定义:==</p><blockquote><p>模板编程指的是利用c++ 模板实例化机制是图灵完备性,可以被用来实现编译时刻的类型判断的一系列编程技巧</p></blockquote><p>==优点:==</p><blockquote><p>模板编程能够实现非常灵活的类型安全的接口和极好的性能,一些常见的工具比如Google Test, std::tuple, std::function 和Boost.Spirit. 这些工具如果没有模板是实现不了的</p></blockquote><p>==缺点:==</p><blockquote><ul><li>模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩, 难懂的.在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和维护起来都很麻烦</li><li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候,即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示.导致这个编译出错信息看起来非常难以理解.</li><li>大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor forC++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来,所以很难确认重构对所有的这些展开的代码有用,其次有些重构工具只对已经做过模板类型替换的代码的AST 有用.因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li></ul></blockquote><p>==结论:==</p><blockquote><ul><li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反.因此模板编程最好只用在少量的基础组件, 基础数据结构上,因为模板带来的额外的维护成本会被大量的使用给分担掉</li><li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下.考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非c++程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程.如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板,或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载,那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</li><li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化,并且尽量不要让模板对外暴漏. 你最好只在实现里面使用模板,然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性.并且你应该在这些使用模板的代码上写尽可能详细的注释.你的注释里面应该详细的包含这些代码是怎么用的,这些模板生成出来的代码大概是什么样子的.还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息.因为这些出错信息也是你的接口的一部分,所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解,并且用户很容易知道如何修改这些错误</li></ul></blockquote><h3 id="boost-库">6.23. Boost 库</h3><p>==Tip==</p><p>只使用 Boost 中被认可的库.</p><p>==定义:==</p><blockquote><p><a href="http://www.boost.org/">Boost 库集</a> 是一个广受欢迎,经过同行鉴定, 免费开源的 C++ 库集.</p></blockquote><p>==优点:==</p><blockquote><p>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白,如型别的特性, 更完善的绑定器, 更好的智能指针。</p></blockquote><p>==缺点:==</p><blockquote><p>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术,以及过度 “函数化” 的编程风格.</p></blockquote><p>==结论:==</p><blockquote><p>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost一部分经认可的特性子集. 目前允许使用以下库:</p><blockquote><ul><li><ahref="http://www.boost.org/doc/libs/1_58_0/libs/utility/call_traits.htm">CallTraits</a> : <code>boost/call_traits.hpp</code></li><li><ahref="http://www.boost.org/libs/utility/compressed_pair.htm">CompressedPair</a> : <code>boost/compressed_pair.hpp</code></li><li>[ : <code>boost/graph</code>, except serialization(<code>adj_list_serialize.hpp</code>) and parallel/distributedalgorithms and data structures(<code>boost/graph/parallel/*</code> and<code>boost/graph/distributed/*</code>)</li><li><a href="http://www.boost.org/libs/property_map/">Property Map</a> :<code>boost/property_map.hpp</code></li><li>The part of <ahref="http://www.boost.org/libs/iterator/">Iterator</a> that deals withdefining iterators: <code>boost/iterator/iterator_adaptor.hpp</code>,<code>boost/iterator/iterator_facade.hpp</code>, and<code>boost/function_output_iterator.hpp</code></li><li>The part of <a href="http://www.boost.org/libs/polygon/">Polygon</a>that deals with Voronoi diagram construction and doesn’t depend on therest of Polygon: <code>boost/polygon/voronoi_builder.hpp</code>,<code>boost/polygon/voronoi_diagram.hpp</code>, and<code>boost/polygon/voronoi_geometry_type.hpp</code></li><li><a href="http://www.boost.org/libs/bimap/">Bimap</a> :<code>boost/bimap</code></li><li><ahref="http://www.boost.org/libs/math/doc/html/dist.html">StatisticalDistributions and Functions</a> :<code>boost/math/distributions</code></li><li><a href="http://www.boost.org/libs/multi_index/">Multi-index</a> :<code>boost/multi_index</code></li><li><a href="http://www.boost.org/libs/heap/">Heap</a> :<code>boost/heap</code></li><li>The flat containers from <ahref="http://www.boost.org/libs/container/">Container</a>:<code>boost/container/flat_map</code>, and<code>boost/container/flat_set</code></li></ul></blockquote><p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p><p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p><blockquote><ul><li><a href="http://www.boost.org/libs/ptr_container/">PointerContainer</a> : <code>boost/ptr_container</code>, 改用 <ahref="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></li><li><a href="http://www.boost.org/libs/array/">Array</a> :<code>boost/array.hpp</code>, 改用 <ahref="http://en.cppreference.com/w/cpp/container/array">std::array</a></li></ul></blockquote></blockquote><h3 id="c11">6.24. C++11</h3><p>==Tip==</p><p>适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11特性前三思可移植性。</p><p>==定义：==</p><blockquote><p>C++11有众多语言和库上的<code>变革 &lt;https://en.wikipedia.org/wiki/C%2B%2B11&gt;</code>_。</p></blockquote><p>==优点：==</p><blockquote><p>在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++编译器支持。它标准化很多我们早先就在用的 C++扩展，简化了不少操作，大大改善了性能和安全。</p></blockquote><p>==缺点：==</p><blockquote><p>C++11 相对于前身，复杂极了：1300 页 vs 800页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p><p>和 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##boost">6.23.Boost 库</a> 一样，有些 C++11扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p></blockquote><p>==缺点：==</p><blockquote><p>C++11特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11特性之外，以下特性最好不要用：</p><ul><li>尾置返回类型，比如用 <code>auto foo() -&gt; int</code> 代替<code>int foo()</code>. 为了兼容于现有代码的声明风格。</li><li>编译时合数 ``, 因为它涉及一个重模板的接口风格。</li><li><code>和</code> 头文件，因为编译器尚不支持。</li><li>默认 lambda 捕获。</li></ul></blockquote><h3 id="译者acgtyrant笔记-3">译者（acgtyrant）笔记</h3><ol type="1"><li>实际上，<ahref="http://www.zhihu.com/question/24439516/answer/27858964">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把<code>void a()</code> 改成 <code>void a(int b = 0)</code>,开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选int参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li><li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li><li>我还发现 <ahref="http://www.zhihu.com/question/24439516/answer/27896004">滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。</a></li><li><code>friend</code>实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的<code>.cc</code> 文件加以定义。</li><li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li><li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考<ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##declaration-order">声明顺序</a>。</li><li><a href="http://www.zhihu.com/question/22889420">对使用 C++异常处理应具有怎样的态度？</a> 非常值得一读。</li><li>注意初始化 const 对象时，必须在初始化的同时值初始化。</li><li>用断言代替无符号整型类型，深有启发。</li><li>auto 在涉及迭代器的循环语句里挺常用。</li><li><ahref="http://stackoverflow.com/questions/11215227/should-the-trailing-return-type-syntax-style-become-the-default-for-new-c11-pr">Shouldthe trailing return type syntax style become the default for new C++11programs?</a> 讨论了 auto与尾置返回类型一起用的全新编码风格，值得一看。</li></ol></div><h2 id="命名约定">7. 命名约定</h2><div class="story post-story"><p>最重要的一致性规则是命名管理.命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义:类型, 变量, 函数, 常量, 宏, 等等, 甚至.我们大脑中的模式匹配引擎非常依赖这些命名规则.</p><p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要,所以无论你认为它们是否重要, 规则总归是规则.</p><h3 id="通用命名规则">7.1. 通用命名规则</h3><p><strong>总述</strong></p><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p><p><strong>说明</strong></p><p>尽可能使用描述性的命名, 别心疼空间,毕竟相比之下让代码易于新读者理解更重要.不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="type">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br><span class="line"><span class="type">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="type">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="type">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="type">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure><p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code>表示迭代变量和用 <code>T</code> 表示模板参数.</p><p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##type-names">类型命名</a>的规则, 而非类型模板应当遵循 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##variable-names">变量命名</a>的规则.</p><h3 id="文件命名">7.2. 文件命名</h3><p><strong>总述</strong></p><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符(<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>”更好.</p><p><strong>说明</strong></p><p>可接受的文件命名示例:</p><ul><li><code>my_useful_class.cc</code></li><li><code>my-useful-class.cc</code></li><li><code>myusefulclass.cc</code></li><li><code>myusefulclass_test.cc</code> // <code>_unittest</code> 和<code>_regtest</code> 已弃用.</li></ul><p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾.专门插入文本的文件则以 <code>.inc</code> 结尾, 参见 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##self-contained-headers">头文件自足</a>.</p><p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注:即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p><p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比<code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如<code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类<code>FooBar</code>.</p><p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短,就直接放在 <code>.h</code> 中.</p><h3 id="类型命名">7.3. 类型命名</h3><p><strong>总述</strong></p><p>类型名称的每个单词首字母均大写, 不包含下划线:<code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p><p><strong>说明</strong></p><p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举,类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写,不包含下划线. 例如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTable</span> &#123; ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTableTester</span> &#123; ...</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123; ...</span><br></pre></td></tr></table></figure><h3 id="变量命名">7.4. 变量命名</h3><p><strong>总述</strong></p><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接.类的成员变量以下划线结尾, 但结构体的就不用, 如:<code>a_local_variable</code>, <code>a_struct_data_member</code>,<code>a_class_data_member_</code>.</p><p><strong>说明</strong></p><h6 id="普通变量命名">普通变量命名</h6><p>举例:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line">string tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line">string tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure><h6 id="类数据成员">类数据成员</h6><p>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样,但要接下划线.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  string tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="type">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="结构体变量">结构体变量</h6><p>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样,不用像类那样接下划线:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> num_entries;</span><br><span class="line">  <span class="type">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体与类的使用讨论, 参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##structs-vs-classes">结构体vs. 类</a>.</p><h3 id="常量命名">7.5. 常量命名</h3><p><strong>总述</strong></p><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量,或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合.例如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 <ahref="http://en.cppreference.com/w/cpp/language/storage_duration##Storage_duration">存储类型</a>)都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等,这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p><h3 id="函数命名">7.6. 函数命名</h3><p><strong>总述</strong></p><p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配:<code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>,<code>my_exciting_member_variable()</code>,<code>set_my_exciting_member_variable()</code>.</p><p><strong>说明</strong></p><p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或“帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词,更倾向于将它们视作一个单词进行首字母大写 (例如, 写作<code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AddTableEntry</span>()</span><br><span class="line"><span class="built_in">DeleteUrl</span>()</span><br><span class="line"><span class="built_in">OpenFileOrDie</span>()</span><br></pre></td></tr></table></figure><p>(同样的命名规则同时适用于类作用域与命名空间作用域的常量,因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数,因为在这时,它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p><p>取值和设值函数的命名与变量一致.一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如<code>int count()</code> 与 <code>void set_count(int count)</code>.</p><h3 id="命名空间命名">7.7. 命名空间命名</h3><p><strong>总述</strong></p><p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称.要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p><p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字.命名空间中的代码,应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p><p>注意 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##general-naming-rules">不使用缩写作为名称</a>的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称,因此没有必要在命名空间中使用缩写.</p><p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突.由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败.尤其是, 不要创建嵌套的 <code>std</code> 命名空间.建议使用更独特的项目标识符 (<code>websearch::index</code>,<code>websearch::index_util</code>) 而非常见的极易发生冲突的名称 (比如<code>websearch::util</code>).</p><p>对于 <code>internal</code> 命名空间, 要当心加入到同一<code>internal</code> 命名空间的代码之间发生冲突(由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下,请使用文件名以使得内部名称独一无二 (例如对于 <code>frobber.h</code>,使用 <code>websearch::index::frobber_internal</code>).</p><h3 id="枚举命名">7.8. 枚举命名</h3><p><strong>总述</strong></p><p>枚举的命名应当和 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量</a>或 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a>一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p><p><strong>说明</strong></p><p>单独的枚举值应该优先采用 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量</a>的命名方式. 但 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a>方式的命名也可以接受. 枚举名 <code>UrlTableErrors</code> (以及<code>AlternateUrlTableErrors</code>) 是类型,所以要用大小写混合的方式.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123;</span><br><span class="line">    kOK = <span class="number">0</span>,</span><br><span class="line">    kErrorOutOfMemory,</span><br><span class="line">    kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AlternateUrlTableErrors</span> &#123;</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2009 年 1 月之前, 我们一直建议采用 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a>的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题.由此, 这里改为优先选择常量风格的命名方式.新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格,除非宏风格确实会产生编译期问题.</p><h3 id="宏命名">7.9. 宏命名</h3><p><strong>总述</strong></p><p>你并不打算 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##preprocessor-macros">使用宏</a>,对吧? 如果你一定要用, 像这样命名:<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p><p><strong>说明</strong></p><p>参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##preprocessor-macros">预处理宏</a>;通常 <em>不应该</em> 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写,使用下划线:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROUND(x) ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure><h3 id="命名规则的特例">7.10. 命名规则的特例</h3><p><strong>总述</strong></p><p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p><p><code>bigopen()</code>: 函数名, 参照 <code>open()</code> 的形式</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint`: `<span class="keyword">typedef</span></span><br></pre></td></tr></table></figure><p><code>bigpos</code>: <code>struct</code> 或 <code>class</code>, 参照<code>pos</code> 的形式</p><p><code>sparse_hash_map</code>: STL 型实体; 参照 STL 命名约定</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LONGLONG_MAX`: 常量, 如同 `INT_MAX</span><br></pre></td></tr></table></figure><h3 id="译者acgtyrant笔记-4">译者（acgtyrant）笔记</h3><ol type="1"><li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult,接着又可以直接定义一个变量 query_result, 区分度很好; 再次,类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如<code>TextQuery::TextQuery(std::string word) : word_(word) &#123;&#125;</code> ,其中 <code>word_</code> 自然是类内私有成员.</li></ol></div><h2 id="注释">8. 注释</h2><div class="story post-story"><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要.下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要,但最好的代码应当本身就是文档. 有意义的类型名和变量名,要远胜过要用注释解释的含糊不清的名字.</p><p>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人.所以慷慨些吧, 下一个读者可能就是你!</p><h3 id="注释风格">8.1. 注释风格</h3><p><strong>总述</strong></p><p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p><p><strong>说明</strong></p><p><code>//</code> 或 <code>/* */</code> 都可以; 但 <code>//</code><em>更</em> 常用. 要在如何注释及注释风格上确保统一.</p><h3 id="文件注释">8.2. 文件注释</h3><p><strong>总述</strong></p><p>在每一个文件开头加入版权公告.</p><p>文件注释描述了该文件的内容. 如果一个文件只声明, 或实现,或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释,那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释.</p><p><strong>说明</strong></p><h6 id="法律公告和作者信息">法律公告和作者信息</h6><p>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如,Apache 2.0, BSD, LGPL, GPL)</p><p>如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p><h6 id="文件内容">文件内容</h6><p>如果一个 <code>.h</code> 文件声明了多个概念,则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系.一个一到两行的文件注释就足够了,对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中.</p><p>不要在 <code>.h</code> 和 <code>.cc</code> 之间复制注释,这样的注释偏离了注释的实际意义.</p><h3 id="类注释">8.3. 类注释</h3><p><strong>总述</strong></p><p>每个类的定义都要附带一份注释, 描述类的功能和用法,除非它的功能相当明显.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></span><br><span class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    delete iter;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GargantuanTableIterator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>类注释应当为读者理解如何使用与何时使用类提供足够的信息,同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提,请用文档说明. 如果该类的实例可被多线程访问,要特别注意文档说明多线程环境下相关的规则和常量使用.</p><p>如果你想用一小段代码演示这个类的基本用法或通常用法,放在类注释里也非常合适.</p><p>如果类的声明和定义分开了(例如分别放在了 <code>.h</code> 和<code>.cc</code> 文件中), 此时, 描述类用法的注释应当和接口定义放在一起,描述类的操作和实现的注释应当和实现放在一起.</p><h3 id="函数注释">8.4. 函数注释</h3><p><strong>总述</strong></p><p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p><p><strong>说明</strong></p><h6 id="函数声明">函数声明</h6><p>基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途.只有在函数的功能简单而明显时才能省略这些注释(例如,简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式(“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常,注释不会描述函数如何工作. 那是函数定义部分的事情.</p><p>函数声明处注释的内容:</p><ul><li>函数的输入输出.</li><li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数,是否会释放这些参数.</li><li>函数是否分配了必须由调用者释放的空间.</li><li>参数是否可以为空指针.</li><li>是否存在函数使用上的性能隐患.</li><li>如果函数是可重入的, 其同步前提是什么?</li></ul><p>举例如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table.  It is the client&#x27;s</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    iter-&gt;Seek(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明.下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>注释函数重载时, 注释的重点应该是函数中被重载的部分,而不是简单的重复被重载的函数的注释. 多数情况下,函数重载不需要额外的文档, 因此也没有必要加上注释.</p><p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以“销毁这一对象” 这样的注释是没有意义的.你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权)以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释.析构函数前没有注释是很正常的.</p><h6 id="函数定义">函数定义</h6><p>如果函数的实现过程中用到了很巧妙的方式,那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧,实现的大致步骤, 或解释如此实现的理由. 举个例子,你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p><p><em>不要</em> 从 <code>.h</code>文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的,但注释重点要放在如何实现上.</p><h3 id="变量注释">8.5. 变量注释</h3><p><strong>总述</strong></p><p>通常变量名本身足以很好说明变量用途. 某些情况下,也需要额外的注释说明.</p><p><strong>说明</strong></p><h6 id="类数据成员-1">类数据成员</h6><p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途.如果有非变量的参数(例如特殊值, 数据成员之间的关系,生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而,如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p><p>特别地, 如果变量可以接受 <code>NULL</code> 或 <code>-1</code>等警戒值, 须加以说明. 比如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Used to bounds-check table accesses. -1 means</span></span><br><span class="line"> <span class="comment">// that we don&#x27;t yet know how many entries the table has.</span></span><br><span class="line"> <span class="type">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure><h6 id="全局变量">全局变量</h6><p>和数据成员一样, 所有全局变量也要注释说明含义及用途,以及作为全局变量的原因. 比如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kNumTestCases = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="实现注释">8.6. 实现注释</h3><p><strong>总述</strong></p><p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p><p><strong>说明</strong></p><h6 id="代码前注释">代码前注释</h6><p>巧妙或复杂的代码段前要加注释. 比如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Divide result by two, taking into account that x</span></span><br><span class="line"><span class="comment">// contains the carry from the add.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result-&gt;<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">  (*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="行注释">行注释</h6><p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></span><br><span class="line">mmap_budget = <span class="built_in">max</span>&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;<span class="built_in">length</span>());</span><br><span class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !<span class="built_in">MmapData</span>(mmap_chunk_bytes, mlock))</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></span><br></pre></td></tr></table></figure><p>注意, 这里用了两段注释分别描述这段代码的作用,和提示函数返回时错误已经被记入日志.</p><p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DoSomething</span>();                  <span class="comment">// Comment here so the comments line up.</span></span><br><span class="line"><span class="built_in">DoSomethingElseThatIsLonger</span>();  <span class="comment">// Two spaces between the code and the comment.</span></span><br><span class="line">&#123; <span class="comment">// One space before comment when opening a new scope is allowed,</span></span><br><span class="line">  <span class="comment">// thus the comment lines up with the following comments and code.</span></span><br><span class="line">  <span class="built_in">DoSomethingElse</span>();  <span class="comment">// Two spaces before line comments normally.</span></span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;string&gt; list&#123;</span><br><span class="line">                    <span class="comment">// Comments in braced lists describe the next element...</span></span><br><span class="line">                    <span class="string">&quot;First item&quot;</span>,</span><br><span class="line">                    <span class="comment">// .. and should be aligned appropriately.</span></span><br><span class="line"><span class="string">&quot;Second item&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">DoSomething</span>(); <span class="comment">/* For trailing block comments, one space is fine. */</span></span><br></pre></td></tr></table></figure><h6 id="函数参数注释">函数参数注释</h6><p>如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p><ul><li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用,用以推断它们一致, 你应当用一个常量名让这一约定变得更明显,并且保证这一约定不会被打破.</li><li>考虑更改函数的签名, 让某个 <code>bool</code> 类型的参数变为<code>enum</code> 类型, 这样可以让这个参数的值表达其意义.</li><li>如果某个函数有多个配置选项,你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例.这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用,这样就能清晰地表明其意义. 同时也减少了函数参数的数量,使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项,就无需对调用点进行更改.</li><li>用具名变量代替大段而复杂的嵌套表达式.</li><li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li></ul><p>比如下面的示例的对比:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// What are these arguments?</span></span><br><span class="line"><span class="type">const</span> DecimalNumber product = <span class="built_in">CalculateProduct</span>(values, <span class="number">7</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ProductOptions options;</span><br><span class="line">options.<span class="built_in">set_precision_decimals</span>(<span class="number">7</span>);</span><br><span class="line">options.<span class="built_in">set_use_cache</span>(ProductOptions::kDontUseCache);</span><br><span class="line"><span class="type">const</span> DecimalNumber product =</span><br><span class="line">    <span class="built_in">CalculateProduct</span>(values, options, <span class="comment">/*completion_callback=*/</span><span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>哪个更清晰一目了然.</p><h6 id="不允许的行为">不允许的行为</h6><p>不要描述显而易见的现象, <em>永远不要</em> 用自然语言翻译代码作为注释,除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的.要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p><p>你所提供的注释应当解释代码 <em>为什么</em> 要这么做和代码的目的,或者最好是让代码自文档化.</p><p>比较这样的注释:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和这样的注释:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Process &quot;element&quot; unless it was already processed.</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自文档化的代码根本就不需要注释.上面例子中的注释对下面的代码来说就是毫无必要的:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsAlreadyProcessed</span>(element)) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标点-拼写和语法">8.7. 标点, 拼写和语法</h3><p><strong>总述</strong></p><p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p><p><strong>说明</strong></p><p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句.大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释,比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p><p>虽然被别人指出该用分号时却用了逗号多少有些尴尬,但清晰易读的代码还是很重要的. 正确的标点,拼写和语法对此会有很大帮助.</p><h3 id="todo-注释">8.8. TODO 注释</h3><p><strong>总述</strong></p><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用<code>TODO</code> 注释.</p><p><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>,在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一<code>TODO</code> 相关的 issue. 主要目的是让添加注释的人(也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code>格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正,因此当你加上带有姓名的 <code>TODO</code> 时, 一般都是写上自己的名字.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span></span><br></pre></td></tr></table></figure><p>如果加 <code>TODO</code> 是为了在 “将来某一天做某事”,可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项(“Remove this code when all clients can handle XML responses.”).</p><h3 id="弃用注释">8.9. 弃用注释</h3><p><strong>总述</strong></p><p>通过弃用注释（<code>DEPRECATED</code>comments）以标记某接口点已弃用.</p><p>您可以写上包含全大写的 <code>DEPRECATED</code> 的注释,以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p><p>在 <code>DEPRECATED</code> 一词后, 在括号中留下您的名字,邮箱地址以及其他身份标识.</p><p>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点. 在 C++中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口.</p><p>仅仅标记接口为 <code>DEPRECATED</code> 并不会让大家不约而同地弃用,您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p><p>修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点.如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p><h3 id="译者-yulefox-笔记-3">译者 (YuleFox) 笔记</h3><ol type="1"><li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li><li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li><li>注释要言简意赅, 不要拖沓冗余,复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li><li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem,但不管怎样, 注释是为了让别人看懂,难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li><li>注释不要太乱, 适当的缩进才会让人乐意看.但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样),UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li><li>TODO 很不错, 有时候,注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索,就知道还有哪些活要干, 日志都省了.</li></ol></div><h2 id="格式">9. 格式</h2><div class="story post-story"><p>每个人都可能有自己的代码风格和格式,但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行.每个人未必能同意下述的每一处格式规则,而且其中的不少规则需要一定时间的适应,但整个项目服从统一的编程风格是很重要的,只有这样才能让所有人轻松地阅读和理解代码.</p><p>为了帮助你正确的格式化代码, 我们写了一个 <ahref="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs配置文件</a>.</p><h3 id="行长度">9.1. 行长度</h3><p><strong>总述</strong></p><p>每一行代码字符数不超过 80.</p><p>我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则,因此我们感觉一致性更重要.</p><p><strong>优点</strong></p><p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为.很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口.大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准.那么为什么要改变呢?</p><p><strong>缺点</strong></p><p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60年代的大型机的古板缺陷; 现代设备具有更宽的显示屏,可以很轻松地显示更多代码.</p><p><strong>结论</strong></p><p>80 个字符是最大值.</p><p>如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符,这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80个字符.</p><p>包含长路径的 <code>#include</code> 语句可以超出80列.</p><p><ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">头文件保护</a>可以无视该原则.</p><h3 id="非-ascii-字符">9.2. 非 ASCII 字符</h3><p><strong>总述</strong></p><p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p><p><strong>说明</strong></p><p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如,代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串.此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8编码.</p><p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如<code>"\xEF\xBB\xBF"</code>, 或者更简洁地写作 <code>u8"\uFEFF"</code>,在 Unicode 中是 <em>零宽度 无间断</em> 的间隔符号,如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p><p>(Yang.Y 注: <code>"\xEF\xBB\xBF"</code> 通常用作 UTF-8 with BOM编码标记)</p><p>使用 <code>u8</code> 前缀把带 <code>uXXXX</code>转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8,输出就会出错.</p><p>别用 C++11 的 <code>char16_t</code> 和 <code>char32_t</code>, 它们和UTF-8 文本没有关系, <code>wchar_t</code> 同理, 除非你写的代码要调用Windows API, 后者广泛使用了 <code>wchar_t</code>.</p><h3 id="空格还是制表位">9.3. 空格还是制表位</h3><p><strong>总述</strong></p><p>只使用空格, 每次缩进 2 个空格.</p><p><strong>说明</strong></p><p>我们使用空格缩进. 不要在代码中使用制表符.你应该设置编辑器将制表符转为空格.</p><h3 id="函数声明与定义">9.4. 函数声明与定义</h3><p><strong>总述</strong></p><p>返回类型和函数名在同一行, 参数也尽量放在同一行,如果放不下就对形参分行, 分行方式与 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##function-calls">函数调用</a>一致.</p><p><strong>说明</strong></p><p>函数看上去像这样:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同一行文本太多, 放不下所有参数:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至连第一个参数都放不下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name1,  <span class="comment">// 4 space indent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以下几点:</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li><li>如果返回类型和函数名在一行放不下, 分行.</li><li>如果返回类型与函数声明或定义分行了, 不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li><li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为 2 个空格.</li><li>换行后的参数保持 4 个空格的缩进.</li></ul><p>未被使用的参数, 或者根据上下文很容易看出其用途的参数,可以省略参数名:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>(Foo&amp;&amp;);</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(Foo&amp;&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 差 - 如果将来有人要实现, 很难猜出变量的作用.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>属性, 和展开为属性的宏, 写在函数声明或定义的最前面,即返回类型之前:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">MUST_USE_RESULT <span class="type">bool</span> <span class="title">IsOK</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="lambda-表达式-1">9.5. Lambda 表达式</h3><p><strong>总述</strong></p><p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理,表项用逗号隔开.</p><p><strong>说明</strong></p><p>若用引用捕获, 在变量名和 <code>&amp;</code> 之间不留空格.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="type">int</span> n) &#123; x += n; &#125;;</span><br></pre></td></tr></table></figure><p>短 lambda 就写得和内联函数一样.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">digits.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">end</span>(), [&amp;blacklist](<span class="type">int</span> i) &#123;</span><br><span class="line">               <span class="keyword">return</span> blacklist.<span class="built_in">find</span>(i) != blacklist.<span class="built_in">end</span>();</span><br><span class="line">             &#125;),</span><br><span class="line">             digits.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="函数调用">9.6. 函数调用</h3><p><strong>总述</strong></p><p>要么一行写完函数调用, 要么在圆括号里对参数分行,要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数,比如把多个参数适当地放在同一行里.</p><p><strong>说明</strong></p><p>函数调用遵循如下形式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(argument1, argument2, argument3);</span><br></pre></td></tr></table></figure><p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐,左圆括号后和右圆括号前不要留空格：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br></pre></td></tr></table></figure><p>参数也可以放在次行, 缩进四格：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>(</span><br><span class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        argument3, argument4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性.有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过,比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p><p>如果一些参数本身就是略复杂的表达式, 且降低了可读性,那么可以直接创建临时变量描述该表达式, 并传递给函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> my_heuristic = scores[x] * y + bases[x];</span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(my_heuristic, x, y, z);</span><br></pre></td></tr></table></figure><p>或者放着不管, 补充上注释：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure><p>如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做.参数的格式处理应当以可读性而非其他作为最重要的原则.</p><p>此外, 如果一系列参数本身就有一定的结构,可以酌情地按其结构来决定参数格式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.<span class="built_in">Transform</span>(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure><h3 id="列表初始化格式">9.7. 列表初始化格式</h3><p><strong>总述</strong></p><p>您平时怎么格式化函数调用, 就怎么格式化 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##braced-initializer-list">列表初始化</a>.</p><p><strong>说明</strong></p><p>如果列表初始化伴随着名字, 比如类型或变量名,格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字,就视作名字长度为零.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一行列表初始化示范.</span></span><br><span class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</span><br><span class="line"><span class="built_in">functioncall</span>(&#123;foo, bar&#125;);</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p&#123;foo, bar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不得不断行时.</span></span><br><span class="line"><span class="built_in">SomeFunction</span>(</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    some_other_function_parameter);</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    some, other, values,</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    SomeOtherType&#123;</span><br><span class="line">        <span class="string">&quot;Very long string requiring the surrounding breaks.&quot;</span>,  <span class="comment">// 非常长的字符串, 前后都需要断行.</span></span><br><span class="line">        some, other values&#125;,</span><br><span class="line">    SomeOtherType&#123;<span class="string">&quot;Slightly shorter string&quot;</span>,  <span class="comment">// 稍短的字符串.</span></span><br><span class="line">                  some, other, values&#125;&#125;;</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    <span class="string">&quot;This is too long to fit all in one line&quot;</span>&#125;;  <span class="comment">// 字符串过长, 因此无法放在同一行.</span></span><br><span class="line">MyType m = &#123;  <span class="comment">// 注意了, 您可以在 &#123; 前断行.</span></span><br><span class="line">    superlongvariablename1,</span><br><span class="line">    superlongvariablename2,</span><br><span class="line">    &#123;<span class="type">short</span>, interior, list&#125;,</span><br><span class="line">    &#123;interiorwrappinglist,</span><br><span class="line">     interiorwrappinglist2&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="条件语句">9.8. 条件语句</h3><p><strong>总述</strong></p><p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和<code>else</code> 另起一行.</p><p><strong>说明</strong></p><p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格,另一种没有.</p><p>最常见的是没有空格的格式. 哪一种都可以, 最重要的是 <em>保持一致</em>.如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码,参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你更喜欢在圆括号内部加空格:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格.右圆括号和左大括号之间也要有个空格:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格.</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格.</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 好 - IF 和 &#123; 都与空格紧邻.</span></span><br></pre></td></tr></table></figure><p>如果能增强可读性, 简短的条件语句允许写在同一行.只有当语句简单并且没有使用 <code>else</code> 子句时使用:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bar</span>();</span><br></pre></td></tr></table></figure><p>如果语句有 <code>else</code> 分支则不允许:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) <span class="built_in">DoThis</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">DoThat</span>();</span><br></pre></td></tr></table></figure><p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题;复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求<code>if</code> 必须总是使用大括号:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果语句中某个 <code>if-else</code> 分支使用了大括号的话,其它分支也必须使用:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环和开关选择语句">9.9. 循环和开关选择语句</h3><p><strong>总述</strong></p><p><code>switch</code> 语句可以使用大括号分段, 以表明 cases之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用<code>&#123;&#125;</code> 或 <code>continue</code>.</p><p><strong>说明</strong></p><p><code>switch</code> 语句中的 <code>case</code>块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话,要按照下文所述的方法.</p><p>如果有不满足 <code>case</code> 条件的枚举值, <code>switch</code>应该总是包含一个 <code>default</code> 匹配 (如果有输入值没有 case去处理, 编译器将给出 warning). 如果 <code>default</code>应该永远执行不到, 简单的加条 <code>assert</code>:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单语句循环里, 括号可用可不用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I love you\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I take it back\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空循环体应使用 <code>&#123;&#125;</code> 或 <code>continue</code>,而不是一个简单的分号.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br><span class="line"><span class="keyword">while</span> (condition);  <span class="comment">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span></span><br></pre></td></tr></table></figure><h3 id="指针和引用表达式">9.10. 指针和引用表达式</h3><p><strong>总述</strong></p><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>)之后不能有空格.</p><p><strong>说明</strong></p><p>下面是指针和引用表达式的正确使用范例:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>在访问成员时, 句点或箭头前后没有空格.</li><li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li></ul><p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="type">char</span> *c;</span><br><span class="line"><span class="type">const</span> string &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="type">char</span>* c;</span><br><span class="line"><span class="type">const</span> string&amp; str;</span><br><span class="line"><span class="type">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="type">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="type">const</span> string &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure><p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件,要遵照该文件的风格.</p><h3 id="布尔表达式">9.11. 布尔表达式</h3><p><strong>总述</strong></p><p>如果一个布尔表达式超过 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##line-length">标准行宽</a>,断行方式要统一一下.</p><p><strong>说明</strong></p><p>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</span><br><span class="line">    a_third_thing == a_fourth_thing &amp;&amp;</span><br><span class="line">    yet_another &amp;&amp; last_one) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, 上例的逻辑与 (<code>&amp;&amp;</code>) 操作符均位于行尾.这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以.可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外,直接用符号形式的操作符, 比如 <code>&amp;&amp;</code> 和 <code>~</code>,不要用词语形式的 <code>and</code> 和 <code>compl</code>.</p><h3 id="函数返回值">9.12. 函数返回值</h3><p><strong>总述</strong></p><p>不要在 <code>return</code> 表达式里加上非必须的圆括号.</p><p><strong>说明</strong></p><p>只有在写 <code>x = expr</code> 要加上括号的时候才在<code>return expr;</code> 里使用括号.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单, 没有圆括号.</span></span><br><span class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span></span><br><span class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</span><br><span class="line">        another_condition);</span><br><span class="line"><span class="keyword">return</span> (value);                <span class="comment">// 毕竟您从来不会写 var = (value);</span></span><br><span class="line"><span class="keyword">return</span>(result);                <span class="comment">// return 可不是函数！</span></span><br></pre></td></tr></table></figure><h3 id="变量及数组初始化">9.13. 变量及数组初始化</h3><p><strong>总述</strong></p><p>用 <code>=</code>, <code>()</code> 和 <code>&#123;&#125;</code> 均可.</p><p><strong>说明</strong></p><p>您可以用 <code>=</code>, <code>()</code> 和 <code>&#123;&#125;</code>,以下的例子都是正确的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;Some Name&quot;</span>)</span></span>;</span><br><span class="line">string name = <span class="string">&quot;Some Name&quot;</span>;</span><br><span class="line">string name&#123;<span class="string">&quot;Some Name&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>请务必小心列表初始化 <code>&#123;...&#125;</code> 用<code>std::initializer_list</code> 构造函数初始化出的类型.非空列表初始化就会优先调用 <code>std::initializer_list</code>,不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用<code>std::initializer_list</code> 构造函数, 请改用括号.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure><p>此外, 列表初始化不允许整型类型的四舍五入,这可以用来避免一些类型上的编程失误.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 好 - pi == 3.</span></span><br><span class="line"><span class="type">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// 编译错误: 缩窄转换.</span></span><br></pre></td></tr></table></figure><h3 id="预处理指令">9.14. 预处理指令</h3><p><strong>总述</strong></p><p>预处理指令不要缩进, 从行首开始.</p><p><strong>说明</strong></p><p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好 - 指令从行首开始</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">#<span class="meta"># <span class="keyword">if</span> NOTIFY               <span class="comment">// 非必要 - ## 后跟空格</span></span></span><br><span class="line">    <span class="built_in">NotifyClient</span>();</span><br><span class="line">#<span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 差 - 指令缩进</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> DISASTER_PENDING  <span class="comment">// 差 - &quot;#if&quot; 应该放在行开头</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">    #<span class="meta">#<span class="keyword">endif</span>                <span class="comment">// 差 - &quot;##endif&quot; 不要缩进</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="类格式">9.15. 类格式</h3><p><strong>总述</strong></p><p>访问控制块的声明依次序是 <code>public:</code>,<code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p><p><strong>说明</strong></p><p>类声明 (下面的代码中缺少注释, 参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/comments/##class-comments">类注释</a>)的基本格式如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  <span class="built_in">MyClass</span>();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> var)</span></span>;</span><br><span class="line">  ~<span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_some_var</span><span class="params">(<span class="type">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> some_var_;</span><br><span class="line">  <span class="type">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意事项:</p><ul><li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li><li>关键词 <code>public:</code>, <code>protected:</code>,<code>private:</code> 要缩进 1 个空格.</li><li>除第一个关键词 (一般是 <code>public</code>) 外,其他关键词前要空一行. 如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li><code>public</code> 放在最前面, 然后是 <code>protected</code>,最后是 <code>private</code>.</li><li>关于声明顺序的规则请参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##declaration-order">声明顺序</a>一节.</li></ul><h3 id="构造函数初始值列表">9.16. 构造函数初始值列表</h3><p><strong>总述</strong></p><p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p><p><strong>说明</strong></p><p>下面两种初始值列表方式都可以接受:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var) : <span class="built_in">some_var_</span>(var) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var), <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间格式化">9.17. 命名空间格式化</h3><p><strong>总述</strong></p><p>命名空间内容不缩进.</p><p><strong>说明</strong></p><p><ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">命名空间</a>不要增加额外的缩进层次, 例如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>不要在命名空间内缩进:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>声明嵌套命名空间时, 每个命名空间都独立成行.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">namespace</span> bar &#123;</span><br></pre></td></tr></table></figure><h3 id="水平留白">9.19. 水平留白</h3><p><strong>总述</strong></p><p>水平留白的使用根据在代码中的位置决定.永远不要在行尾添加没意义的留白.</p><p><strong>说明</strong></p><h6 id="通用">通用</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="type">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> b) : <span class="built_in">Bar</span>(), <span class="built_in">baz_</span>(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格.如果确定一行代码已经修改完毕, 将多余的空格去掉;或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格,如果不支持, 考虑换一款编辑器或 IDE)</p><h6 id="循环和条件语句">循环和条件语句</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure><h6 id="操作符">操作符</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h6 id="模板和转换">模板和转换</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line">vector&lt;string&gt; x;</span><br><span class="line">y = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line">vector&lt;<span class="type">char</span> *&gt; x;</span><br></pre></td></tr></table></figure><h3 id="垂直留白">9.19. 垂直留白</h3><p><strong>总述</strong></p><p>垂直留白越少越好.</p><p><strong>说明</strong></p><p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是:两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行,函数体中也不要随意添加空行.</p><p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然,过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断.但通常是垂直留白越少越好.</p><p>下面的规则可以让加入的空行更有效:</p><ul><li>函数体内开头或结尾的空行可读性微乎其微.</li><li>在多重 if-else 块里加空行或许有点可读性.</li></ul><h3 id="译者-yulefox-笔记-4">译者 (YuleFox) 笔记</h3><ol type="1"><li>对于代码格式, 因人, 系统而异各有优缺点,但同一个项目中遵循同一标准还是有必要的;</li><li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li><li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是UNIX/Linux 下, Windows 下可以考虑宽字符),尽量不将字符串常量耦合到代码中, 比如独立出资源文件,这不仅仅是风格问题了;</li><li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li><li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行,要么所有参数并排分行;</li><li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明,各种语句的左大括号置于行尾, 所有右大括号独立成行;</li><li><code>.</code>/<code>-&gt;</code> 操作符前后不留空格,<code>*</code>/<code>&amp;</code> 不要前后都留, 一个就可,靠左靠右依各人喜好;</li><li>预处理指令/命名空间不使用额外缩进,类/结构体/枚举/函数/语句使用缩进;</li><li>初始化用 <code>=</code> 还是 <code>()</code> 依个人喜好,统一就好;</li><li><code>return</code> 不要加 <code>()</code>;</li><li>水平/垂直留白不要滥用, 怎么易读怎么来.</li><li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (<code>.cc</code>文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约,想想行首除了函数体被一对大括号封在一起之外,只有右大括号的代码看上去确实也舒服; Windows风格将左大括号置于行首的优点是匹配情况一目了然.</li></ol><h3 id="译者acgtyrant笔记-5">译者（acgtyrant）笔记</h3><ol type="1"><li>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块,超多重函数调用等等.</li><li>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码,不像奇葩的 Windows.</li><li>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号. Apple正好 <a href="http://coolshell.cn/articles/11112.html">有栽过跟头</a>.</li><li>其实我主张指针／地址操作符与变量名紧邻, <code>int* a, b</code> vs<code>int *a, b</code>, 新手会误以为前者的 <code>b</code> 是<code>int *</code> 变量, 但后者就不一样了, 高下立判.</li><li>在这风格指南里我才刚知道 C++ 原来还有所谓的 <ahref="http://en.cppreference.com/w/cpp/language/operator_alternative">Alternativeoperator representations</a>, 大概没人用吧.</li><li>注意构造函数初始值列表（Constructer InitializerList）与列表初始化（Initializer List）是两码事,我就差点混淆了它们的翻译.</li><li>事实上, 如果您熟悉英语本身的书写规则,就会发现该风格指南在格式上的规定与英语语法相当一脉相承.比如普通标点符号和单词后面还有文本的话, 总会留一个空格;特殊符号与单词之间就不用留了, 比如 <code>if (true)</code> 中的圆括号与<code>true</code>.</li><li>本风格指南没有明确规定 void 函数里要不要用 return 语句, 不过就Google 开源项目 leveldb 并没有写; 此外从 <ahref="http://stackoverflow.com/questions/9316717/is-a-blank-return-statement-at-the-end-of-a-function-whos-return-type-is-void-ne">Isa blank return statement at the end of a function whos return type isvoid necessary?</a> 来看, <code>return;</code> 比 <code>return ;</code>更约定俗成（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）,且可用来提前跳出函数栈.</li></ol></div><h2 id="规则特例">10. 规则特例</h2><div class="story post-story"><p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外,这里就是探讨这些特例.</p><h3 id="现有不合规范的代码">10.1. 现有不合规范的代码</h3><p><strong>总述</strong></p><p>对于现有不符合既定编程风格的代码可以网开一面.</p><p><strong>说明</strong></p><p>当你修改使用其他风格的代码时,为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心,可以与代码原作者或现在的负责人员商讨. 记住, <em>一致性</em>也包括原有的一致性.</p><h3 id="windows-代码">10.2. Windows 代码</h3><p><strong>总述</strong></p><p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的C++ 编程只给出一个单独的指南.</p><p><strong>说明</strong></p><p>如果你习惯使用 Windows 编码风格,这儿有必要重申一下某些你可能会忘记的指南:</p><ul><li>不要使用匈牙利命名法 (比如把整型变量命名成 <code>iNum</code>). 使用Google 命名约定, 包括对源文件使用 <code>.cc</code> 扩展名.</li><li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感),如 <code>DWORD</code>, <code>HANDLE</code> 等等. 在调用 Windows API时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型,例如使用 <code>const TCHAR *</code> 而不是 <code>LPCTSTR</code>.</li><li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高,并将所有警告(warnings)当作错误(errors)处理.</li><li>不要使用 <code>##pragma once</code>; 而应该使用 Google的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如<code>##ifndef SRC_DIR_BAR_H_</code>, 参考 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">##define保护</a> 一节).</li><li>除非万不得已, 不要使用任何非标准的扩展, 如 <code>##pragma</code> 和<code>__declspec</code>. 使用 <code>__declspec(dllimport)</code> 和<code>__declspec(dllexport)</code> 是允许的, 但必须通过宏来使用, 比如<code>DLLIMPORT</code> 和 <code>DLLEXPORT</code>,这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li></ul><p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p><ul><li>通常我们 <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##multiple-inheritance">禁止使用多重继承</a>,但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL类/接口, 你可能不得不使用多重实现继承.</li><li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的STL) 中异常被广泛使用. 使用 ATL 时, 应定义<code>_ATL_NO_EXCEPTIONS</code> 以禁用异常. 你需要研究一下是否能够禁用STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL,自己的代码里仍然不应当包含异常处理).</li><li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为<code>StdAfx.h</code> 或 <code>precompile.h</code> 的文件.为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在<code>precompile.cc</code> 中), 使用 <code>/FI</code>编译器选项以自动包含该文件.</li><li>资源头文件通常命名为 <code>resource.h</code> 且只包含宏,这一文件不需要遵守本风格指南.</li></ul></div><h2 id="结束语">11. 结束语</h2><div class="story post-story"><p>运用常识和判断力, 并且 <em>保持一致</em>.</p><p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格.如果其它代码中 <code>if</code> 语句使用空格, 那么你也要使用.如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.</p><p>风格指南的重点在于提供一个通用的编程规范,这样大家可以把精力集中在实现内容而不是表现形式上.我们展示的是一个总体的的风格规范, 但局部风格也很重要,如果你在一个文件中新加的代码和原有代码风格相去甚远,这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏,所以要尽量避免.</p><p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Google C/C++ 规范文档。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="编程" scheme="http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://adversarr.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-引言</title>
    <link href="http://adversarr.github.io/2021/11/30/study/Math/NumericRecipies/Chapter-1-Introduction/"/>
    <id>http://adversarr.github.io/2021/11/30/study/Math/NumericRecipies/Chapter-1-Introduction/</id>
    <published>2021-11-30T03:10:09.766Z</published>
    <updated>2022-03-03T04:30:41.764Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 ch 1 - 引言</p><span id="more"></span><h1 id="chapter-1-introduction">Chapter-1-Introduction</h1><ol type="1"><li><p>绪论</p></li><li><p>非线性方程求根</p></li><li><p>线性方程组的数值解</p></li><li><p>插值和逼近</p></li><li><p>数值积分和数值微分</p></li><li><p>常微分方程的数值解</p></li><li><p>偏微分方程的数值解</p></li></ol><h1 id="绪论">绪论</h1><p>主要内容：</p><ol type="1"><li><p><strong>科学计算的内容</strong>：科学模拟的过程、一般策略</p></li><li><p><strong>误差的概念</strong>：绝对误差、相对误差、向前/向后误差、有效数字及它们之间的关系</p></li><li><p><strong>数据误差对函数值的影响</strong>：讨论函数的误差与自变量误差之间的关系</p></li><li><p><strong>算法的数值稳定性</strong>：讨论初始数据的误差对计算结果的影响</p></li><li><p><strong>实际计算中应该注意的问题</strong></p></li></ol><h2 id="科学计算">科学计算</h2><div class="story post-story"><h3 id="计算模拟解决问题的过程">计算模拟解决问题的过程</h3><ol type="1"><li><p>建立数学模型</p></li><li><p>给出数值算法</p></li><li><p>计算机软件实现算法</p></li><li><p>运行、进行数值模拟</p></li><li><p>表示计算结果</p></li><li><p>解释计算结果</p></li></ol><h3 id="一般策略">一般策略</h3><ol type="1"><li><p>有限维空间代替无限维空间</p></li><li><p>用有限过程代替无限过程</p></li><li><p>用线性方程代替微分方程</p></li><li><p>用低阶方程组代替高阶方程组</p></li><li><p>用简单函数代替复杂函数</p></li><li><p>用简单结构矩阵代替一般矩阵</p></li></ol></div><h2 id="机器数系">机器数系</h2><div class="story post-story"><ol type="1"><li>计算机中的实数（浮点数）<span class="math inline">\(x = \pm \beta^p\times (0.\alpha _ 1\alpha _ 2\cdots)\)</span></li><li>特点：<ol type="1"><li>有限的离散集</li><li>有最大、（非零非负）最小数</li><li>溢出错误（<span class="math inline">\(\infty\)</span> 和 <spanclass="math inline">\(0\)</span>）</li></ol></li><li>计算机对于数的接收</li></ol></div><h2 id="误差的基本概念">误差的基本概念</h2><div class="story post-story"><h3 id="误差的来源">误差的来源</h3><ol type="1"><li><p><strong>模型误差</strong>：对实际情况的简化和近似</p></li><li><p><strong>观测误差</strong>：测量误差等等</p></li><li><p><strong>截断误差</strong>：计算中的无限过程，使用了有限的近似，例如级数求和</p></li><li><p><strong>舍入误差</strong>：四舍五入</p></li></ol><p>例1：<span class="math inline">\(A=4\pi r^2\)</span>中，包含了各种误差</p><p>例2：Taylor 展开：<span class="math inline">\(e^{-x} = 1-x+\frac 12{x^2} -\frac{1}{6}x^3+E_r(x)\)</span> ，其中略去 <spanclass="math inline">\(E_r\)</span> 项，产生了截断误差</p><h3 id="绝对误差">绝对误差</h3><ul><li><strong>绝对误差</strong>：设<spanclass="math inline">\(x^*\)</span>是准确值，<spanclass="math inline">\(x\)</span>是近似值，则：</li></ul><p><span class="math display">\[e(x)=x^*-x\]</span></p><p>为近似值<spanclass="math inline">\(x\)</span>的<strong>绝对误差</strong>，简称<strong>误差</strong>。在实际计算中，绝对误差无法求出，但只需要知道误差的一个范围，从而有<strong>绝对误差限</strong><span class="math inline">\(\varepsilon\)</span>：</p><p><span class="math display">\[|e(x)|\le \varepsilon\]</span></p><h3 id="相对误差">相对误差</h3><p><span class="math display">\[e_r(x)=\frac{x^*-x}{x^*}\]</span></p><p>若 <span class="math inline">\(x^*\)</span> 无法确定，也用：</p><p><span class="math display">\[e_r(x)=\frac{x^*-x}{x}\]</span></p><p>相应的，有相对误差限：</p><p><span class="math display">\[|e_r(x)|\le \varepsilon\]</span></p><h3 id="有效数">有效数</h3><p>若 <span class="math inline">\(x\)</span> 为 <spanclass="math inline">\(x^*\)</span> 的近似值，若 <spanclass="math inline">\(|e(x)|\)</span>是其某个数位的半个单位，从左起第一个非零数到这一位有 n 位，则称 n个数字为其有效数字。</p><p>在实际情况中：n 位有效数字通常表示为：</p><p><span class="math display">\[x = \pm 0.\alpha_1\alpha_2\alpha_3....\times10^{m}\]</span></p><p>则其误差（的绝对值）为：<spanclass="math inline">\(|e(x)|\le\displaystyle \frac 1 2 \times10^{m-n}\)</span>，误差限为：</p><p><span class="math display">\[\varepsilon = \frac 1 2 \times 10^{m-n}\]</span></p><p>例如：<span class="math inline">\(\pi=3.14159.....\)</span>，3.14有3位有效数字，3.1416有5位有效数字，3.1415只有4位有效数字。</p><blockquote><p>对应作业部分：<ahref="https://www.wolai.com/vSwxZPkgTHNmW7WT1uygWa">Week1</a></p></blockquote><h3 id="数据误差和计算误差">数据误差和计算误差</h3><p>→ <span class="math inline">\(x\)</span>表示输入的真值，<spanclass="math inline">\(f(x)\)</span>为所求的真实结果，假设所用的输入值不是精确值，即为<spanclass="math inline">\(\hat x\)</span>，得到的近似值为<spanclass="math inline">\(\hat f\)</span>则：</p><p><span class="math display">\[总误差=(\hat f(\hat x) -f(\hat x)) + (f(\hatx)-f(x))=计算误差+数据传播误差\]</span></p><p>例如：</p><ul><li><span class="math inline">\(\sin x\approx x-\frac 1{3!}x^3\Rightarrow f\approx \hat x\)</span>l</li></ul><h3 id="向前误差和向后误差">向前误差和向后误差</h3><p><span class="math inline">\(x,f\)</span>表示输入值和函数，<spanclass="math inline">\(\hat f\)</span>表示实际计算的函数，<spanclass="math inline">\(x\)</span>表示能精确地得出计算值的输入，则：<spanclass="math inline">\(\hat f(x)=f(\hat x)\)</span></p><p>则：</p><ul><li><p>绝对向前误差：<span class="math inline">\(|\hatf(x)-f(x)|\)</span></p></li><li><p>绝对向后误差：<span class="math inline">\(|\hatx-x|\)</span></p></li></ul><p>条件数：<span class="math inline">\(\displaystyle\frac {|(f(\hat x) -f(x))/f(x)|} { |(\hat x-x)/x|}\)</span>→ 相对误差的放大倍数</p></div><h2 id="数据误差对函数值的影响">数据误差对函数值的影响</h2><div class="story post-story"><p>对于单变量函数而言：</p><p><span class="math display">\[y=f(x)\rightarrow e(y)=y^*-y=f(x^*)-f(x)\]</span></p><p>若使用Taylor展开<span class="math inline">\(e(y)\approxf&#39;(x)(x^*-x)=f&#39;(x)e(x),\quade_r(y)=\frac{xf&#39;(x)}{f(x)}e_r(x)\)</span></p><p>对于多变量函数而言：</p><p><span class="math display">\[\begin{aligned}e(y)&amp;=f(x_1^*,x_2^*)-f(x_1,x_2)\\&amp;\approx \frac{\partial f(x_1,x_2)}{\partialx_1}e(x_1)+\frac{\partial f(x_1,x_2)}{\partial x_2}e(x_2)\\e_r(y)&amp;=e(y)/y\\&amp;\approx\frac{\partial f(x_1,x_2)}{\partialx_1}\frac{x_1}{f(x_1,x_2)}e_r(x_1)+\frac{\partial f(x_1,x_2)}{\partialx_2}\frac{x_2}{f(x_1,x_2)}e(x_2)\end{aligned}\]</span></p><p>和差积商的误差计算方法：</p><ol type="1"><li><p><span class="math inline">\(e(x_1\pm x_2)=e(x_1)\pme(x_2)\)</span></p></li><li><p><span class="math inline">\(e(x_1x_2)=x_2e(x_1)+x_1e(x_2)\)</span></p></li><li><p><span class="math inline">\(e(x_1/x_2)\approx\displaystyle\frac{1}{x_2}e(x_1)-\frac{x_1}{x_2^2}e(x_2)\)</span></p></li></ol></div><h2 id="算法的数值稳定性">算法的数值稳定性</h2><div class="story post-story"><h3 id="数值稳定性">数值稳定性</h3><blockquote><p>对于某一种算法，如果初始数据有很小的误差，仅仅使结果产生很小的误差，则称这个算法时（数值）稳定的，否则称为（数值）不稳定的。</p></blockquote><p>例如：<span class="math inline">\(I_n=\int_0^1\frac {x^n}{x+5}\mathrmdx\)</span></p><ul><li><p><span class="math inline">\(I_n=\frac 1 n -5I_{n-1}\)</span>→<span class="math inline">\(|e_n|=5^n|e_0|\)</span>（误差传播）→不稳定</p></li><li><p><span class="math inline">\(I_{n-1}=\frac 1 5(1/n -I_n)\)</span>利用 <span class="math inline">\(I_{10}\)</span>推算</p></li></ul><h3 id="病态问题ill-posed">病态问题（ill-posed）</h3><blockquote><p>多项式求根时一个病态问题！</p></blockquote></div><h2 id="实际问题中应该注意的问题">实际问题中应该注意的问题</h2><div class="story post-story"><ol type="1"><li><p>避免除数远小于被除数</p></li><li><p>避免两个相近的数详见</p></li><li><p>防止大数“吃”小数</p></li><li><p>简化计算次数，减少计算次数：例如：快速幂算法，多项式计算的秦九韶算法</p></li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 ch 1 - 引言&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数值分析-线性方程组的数值解</title>
    <link href="http://adversarr.github.io/2021/11/30/study/Math/NumericRecipies/Chapter%203%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3/"/>
    <id>http://adversarr.github.io/2021/11/30/study/Math/NumericRecipies/Chapter%203%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3/</id>
    <published>2021-11-30T03:10:09.765Z</published>
    <updated>2022-03-03T04:30:41.763Z</updated>
    
    <content type="html"><![CDATA[<p>数值分析 ch 3 - 线性方程组的数值解</p><span id="more"></span><h1 id="chapter-3-线性方程组的数值解">Chapter 3 线性方程组的数值解</h1><p>Content：</p><ol type="1"><li><p>Gauss 消去法，Gauss列主元消去法</p></li><li><p>向量和矩阵的范数、方程组性态和误差估计</p></li><li><p>Jacobi迭代，Gauss-Seidel迭代格式，收敛性的判别</p></li><li><p>幂法和反幂法</p></li></ol><hr /><p>迭代解法描述：</p><p><span class="math display">\[\begin{aligned}A\vec x=\vec b\iff\vec x&amp;=B\vec x+\vec c\\\vecx_{n+1}&amp;=B\vec x_n+\vec c\\if~x_n~converge,~\vec x_n&amp;\rightarrow \vec x^*\end{aligned}\]</span></p><p>Today's outline:</p><ol type="1"><li><p>解线性方程组的可操作的解法</p></li><li><p>直接法：不考虑舍入误差，通过有限步运算一定能得到<strong>精确解</strong></p></li></ol><p>例如：Kramer's law</p><pre><code>- $A=(\vec a_1, \vec a_2,\cdots)$$A_i = (\vec a_1,\cdots,\vec a_&#123;i-1&#125;,\vec b,\vec a_&#123;i+1&#125;,\cdots,\vec a_n)$$x_i = |A_i|/|A|$</code></pre><ol start="2" type="1"><li><p>消元法：Gauss</p></li><li><p>间接法：通过有限次运算得到近似解→如何刻画</p></li><li><p>矩阵/向量的范数 误差估计</p></li><li><p>迭代法求解（近似解）</p></li><li><p>恒等变形：</p></li></ol><p><span class="math display">\[Ax=b\iff x = Bx+f\]</span></p><ol start="2" type="1"><li>构造迭代序列：（由 <span class="math inline">\(B\)</span>和 <spanclass="math inline">\(x_0\)</span>完全决定）</li></ol><p><span class="math display">\[x_{k+1}=Bx_k+f\]</span></p><ol start="3" type="1"><li>如果序列收敛，则：</li></ol><p><span class="math display">\[x^*=Bx^*+f\]</span></p><ol start="4" type="1"><li><p>对于充分大的<span class="math inline">\(k\)</span>，有 <spanclass="math inline">\(x_k\approx x^*\)</span></p></li><li><p>计算矩阵A的最大（小）特征值</p></li></ol><h2 id="gauss-消元法">Gauss 消元法</h2><div class="story post-story"><blockquote><p>思想：利用线性代数中学过的初等行变换，将方程组化为等价的三角形方程组</p></blockquote><h3 id="三角形方程组的回代法">三角形方程组的回代法</h3><p><span class="math display">\[\begin{aligned}u_{11}x_1+\cdots +u_{1n}x_n=y_1&amp;\\\cdots&amp;\\u_{nn}x_n=y_n&amp;\end{aligned}\]</span></p><p><span class="math display">\[\begin{cases}x_n=y_n/u _{nn}\\x_i = (y_{n-1}-\sum _{j=i+1}^n u_{ij}x_j)/u_{ii}\end{cases}\]</span></p><h3 id="gauss-消去法">Gauss 消去法</h3><ol type="1"><li>将 <span class="math inline">\(Ax=b\)</span>化为增广矩阵：<spanclass="math inline">\(\overline A^{(1)}\)</span></li></ol><blockquote><p>同解变换：非零数乘一个方程两边，互换位置，一个方程乘常数+另一个方程</p></blockquote><ol start="2" type="1"><li>下面用n-1步消元，将<span class="math inline">\(\overlineA^{(1)}\)</span>转化为上三角矩阵</li></ol><p><span class="math inline">\(\bar A^{(1)}\rightarrow \barA^{(2)}\rightarrow\cdots\rightarrow \bar A^{(n)}\)</span></p><ol start="3" type="1"><li>三角形方程组回代</li></ol><p>→<span class="math inline">\(O(n^3)\)</span></p><p><strong>Thm</strong>：（充分条件）若 A的各阶顺序主子式非零，则Gauss消去法中各<strong>主元</strong><spanclass="math inline">\(a_{kk}^{(k)}\)</span>均非零。</p><h3 id="三对角方程组的追赶法">三对角方程组的追赶法</h3><p><span class="math display">\[\left[\begin{matrix}b_1&amp;c_1\\a_2&amp;b_2&amp;c_2\\&amp;a_3&amp;b_3&amp;c_3\\&amp;&amp;&amp;\cdots\end{matrix}\right]x = d\]</span></p><p>且对角占优：<spanclass="math inline">\(|b_i|&gt;|a_i|+|c_i|\)</span></p><p>消元过程如下：</p><p><span class="math inline">\(\beta_1=b_1,y_1=d_1,l_i=\frac {a_i}{\beta _{i-1}},\beta_i=b_i-l_ic_{i-1},y_i=d_i-l_iy_{i-1}\)</span></p><h3 id="列主元gauss消元">列主元Gauss消元</h3><p>→ <span class="math inline">\(|a_{tk}^{(k)}|=\max_{k\le i\len}|a_{ik}^{(k)}|\)</span></p><h3 id="lu分解法">LU分解法</h3><p>Gauss消元→行变换L→<spanclass="math inline">\(L=(L_k^{-1}L_{k-1}^{-1}\cdotsL_1^{-1})\)</span>→<span class="math inline">\(LUx=b\)</span>→<spanclass="math inline">\(Ly=b,Ux=y\)</span></p><p><strong>Thm</strong>A的各阶顺序主子式均不为0，则对A可做唯一的LU分解</p><p><strong>Thm</strong>若A是对称矩阵，且各阶顺序主子式不为0，则A可以做LU分解，且</p><p><span class="math display">\[l_{ik}=\frac {u_{ki}}{u_{kk}}\]</span></p><h2 id="方程组的性态和误差分析-important">方程组的性态和误差分析#IMPORTANT</h2><p>如何刻画一个矩阵A的性态→矩阵的条件数（与矩阵的模有关）</p><h3 id="向量范数">向量范数</h3><p><strong>Def</strong>（范数）一个函数，满足：非负性、齐次性、三角不等式</p><ul><li><p>常用的：</p><ol type="1"><li><p>1-范数</p></li><li><p>∞-范数</p></li><li><p>2-范数←内积</p></li></ol></li></ul><p><strong>Thm</strong>：<strong>有限维空间所有的模都是</strong>等价<strong>的</strong>（<spanclass="math inline">\(\exists c_1,c_2\forall x\in R^n,c_1||x||_p\le||x||_q\le c_2||x||_p\)</span>)</p><blockquote><p>定性描述为：两个范数等价是指在一个范数顶一下的向量，在另一个范数下也小</p></blockquote><p>借助这样的理论：我们研究 两个向量之间的绝对误差和相对误差：</p><blockquote><p>设<span class="math inline">\(x^*\)</span>和<spanclass="math inline">\(\tilde x\)</span>是方程组<spanclass="math inline">\(Ax=b\)</span>的精确解和近似解，则<spanclass="math inline">\(||x^*-\tilde x||, ||x^*-\tilde x||/||\tildex||\)</span>可以表示其误差</p></blockquote><h3 id="矩阵范数">矩阵范数</h3><p>借助向量模定义矩阵模</p><p><strong>Def</strong>（矩阵范数）一个函数，满足</p><ol type="1"><li><p>非负性<span class="math inline">\(||A||\ge0 且||A||=0\iffA=0\)</span></p></li><li><p>齐次性<span class="math inline">\(||\alphaA||=|\alpha|||A||\)</span></p></li><li><p>三角不等式<span class="math inline">\(||A+B||\le||A||+||B||\)</span></p></li><li><p><span class="math inline">\(||AB||\le||A||~||B||\)</span></p></li><li><p>相容性<span class="math inline">\(||Ax||\le||A||~||x||\)</span></p></li></ol><blockquote><p>矩阵的行列式<strong>不可以</strong>作为范数</p></blockquote><p><strong>Def</strong>（向量范数导出的算子范数） 设 <spanclass="math inline">\(||\cdot||\)</span>是一个范数，称<spanclass="math inline">\(\max_{x\in R^n} \frac{||Ax||}{||x||}=\max_{x\inR^n,||x||=1}||Ax||\)</span>为A的向量范数导出的算子范数<spanclass="math inline">\(|||A|||\)</span></p><p><strong>Def</strong>（谱Spectrum半径）设<spanclass="math inline">\(B\in R^{n\times n}\)</span>，<spanclass="math inline">\(\lambda_1,...,\lambda_n\)</span>为特征值，谱半径为：</p><p><span class="math display">\[\rho(B)=\max \{\lambda_i\}\]</span></p><p><strong>Thm</strong>：常用矩阵范数计算</p><ol type="1"><li><p><span class="math inline">\(||A||_1=\max_{1\le j\len}\sum_{i=1}^n\)</span>=最大列绝对值和</p></li><li><p><spanclass="math inline">\(||A||_\infty\)</span>=最大行绝对值和</p></li><li><p><spanclass="math inline">\(||A||_2=\sqrt{\rho(A^TA)}\)</span></p></li><li><p><spanclass="math inline">\(||A|_F=\sqrt{\sum_{i,j=1}^na_{ij}^2}\)</span>→注意！不是算子范数！例如 <span class="math inline">\(||I||\ne1\)</span></p></li></ol><p><strong>Thm</strong>：对于对称矩阵，<spanclass="math inline">\(\rho(A)=||A||_2\)</span></p><p><strong>Thm</strong>：对于<strong>任意</strong>范数<spanclass="math inline">\(\rho(A)\le ||A||\)</span></p><blockquote><p>可用于证明迭代法收敛！</p></blockquote><p><strong>Thm</strong>： <span class="math inline">\(R^{n\timesn}\)</span> 中的任意两个矩阵范数是等价的</p><blockquote><p>【推广】有限维空间中的两个范数是等价的。</p></blockquote><p><strong>Thm</strong>：对于两个矩阵范数，存在常数<spanclass="math inline">\(d_1\)</span>和<spanclass="math inline">\(d_2\)</span>满足：</p><p><span class="math display">\[d_1||A||_p\le ||A||_q\le d_2||A||_p\]</span></p><p><strong>Def</strong>（矩阵之间的距离）<spanclass="math inline">\(||A-B||\)</span></p><p><strong>Def</strong>（矩阵收敛）<spanclass="math inline">\(\lim_{k\rightarrow \infty} ||A^{(k)}-A||=0\iff\lim_{k\rightarrow \infty} A^{(k)}=A\)</span></p><p><strong>Thm</strong>：<span class="math inline">\(\lim_{k\rightarrow\infty} B^k=0\iff \rho(B)&lt;1\)</span></p><p>例如：</p><p><span class="math display">\[\begin{aligned}\frac 1{1-q}&amp;=1+q+q^2+\cdots\\(I-A)^{-1}&amp;=I+A+A^2+\cdots\end{aligned}\]</span></p><h3 id="方程组的性态和条件数">方程组的性态和条件数</h3><blockquote><p>矩阵的行列式可以一定程度上的表示误差大小，而用条件数进行精确刻画。</p></blockquote><ol type="1"><li><p>设<span class="math inline">\(b\)</span>有一个小的扰动<spanclass="math inline">\(\delta b\)</span>，此时解变为<spanclass="math inline">\(x^*+\delta^*\)</span></p></li><li><p>则有<span class="math inline">\(A\delta x^*=\deltab\)</span>，也就是<span class="math inline">\(\delta x^*=A^{-1}\deltab\)</span></p></li><li><p>取范数：</p></li></ol><p><span class="math display">\[\frac{||\delta x^*||}{||x^*||}\le ||A^{-1}||~||A||\frac{||\deltab||}{||b||}\]</span></p><ol type="1"><li><p>设<span class="math inline">\(A\)</span>有微小变化<spanclass="math inline">\(\delta A\)</span></p></li><li><p>则<span class="math inline">\(\delta x^*=-A^{-1} \deltaA(x^*+\delta x^*)\)</span></p></li><li><p>取范数：</p></li></ol><p><span class="math display">\[\frac{||\delta x^*||}{||x^*+\delta x^*||}\le ||A^{-1}||~||A||~\frac{||\delta A||}{||A||}\]</span></p><p><strong>Def</strong>（条件数<span class="math inline">\(\mathrm{cond}A\)</span>）<spanclass="math inline">\(A\)</span>为非奇异矩阵，则称 <spanclass="math inline">\(||A^{-1}||~||A||\)</span>为条件数</p><p><strong>Def</strong>（好的方程组）对于Ax=b而言，若</p><ol type="1"><li><p>A的条件数很大，则为<strong>病态方程组</strong>（误差不一定大）</p></li><li><p>A的条件数很小，则为<strong>良态方程组</strong>（误差一定小）</p></li></ol><p>常用的判断方法：</p><ol type="1"><li><p>列主元Gauss消去法出现绝对值很小的pivot</p></li><li><p>系数矩阵中，某些行（列）近似线性相关</p></li><li><p>系数矩阵元素间，数量级差距很大，且没有一定的规律</p></li></ol><p>一般的解决方案：</p><ol type="1"><li><p>提高计算精度</p></li><li><p><strong>预处理</strong>：选择合理的非奇异矩阵<spanclass="math inline">\(D,C\)</span>，将方程组化为等价的方程组，<spanclass="math inline">\(DAC[C^{-1}]=Db\)</span>且使得<spanclass="math inline">\(\mathrm{cond} DAC\)</span>较小</p></li></ol><p>例如：正则化方法：<span class="math inline">\(Ax=b,|A|\approx0\)</span>→<span class="math inline">\(x=(\alphaI+A^TA)^{-1}A^Tb\)</span></p><h2id="迭代法jacobi迭代gauss-seidel迭代">迭代法（Jacobi迭代，Gauss-Seidel迭代）</h2><h3 id="迭代格式的构造">迭代格式的构造</h3><p>将方程组改写为等价的方程：</p><p><span class="math display">\[x=Bx+f\]</span></p><p>通过该格式进行迭代，若迭代格式对于任意初始向量产生的迭代序列 <spanclass="math inline">\(\{x^{(k)}\}\)</span>都收敛，则<strong>迭代收敛</strong></p><blockquote><p>对于线性方程组而言，迭代收敛只与<spanclass="math inline">\(B\)</span>有关；对于非线性方程组而言，和 <spanclass="math inline">\(B,x\)</span> 都有关。</p></blockquote><h3 id="三种常用的迭代格式">三种常用的迭代格式</h3><h4 id="jacobi迭代法">Jacobi迭代法</h4><p>假设对角线元素都非零，则可以通过该公式得到：</p><p><span class="math display">\[\begin{aligned}x_1 = (b_1-a_{12}x_2-\cdots - a_{1n}x_n)/a_{11}\\\cdots\\x_n = (b_n - a _ {n1} x_1 - \cdots - a_{n,n-1}x_{n-1})/a_{nn}\end{aligned}\]</span></p><p>若将原矩阵进行重写：</p><p>$$ A=L+D+U</p><p>$$</p><ul><li><p><span class="math inline">\(J = -D^{-1}(L+U)\)</span></p></li><li><p><span class="math inline">\(f_J=D^{-1}b\)</span></p></li></ul><h4 id="gauss-seidel迭代">Gauss-Seidel迭代</h4><p>我们用已经求出的 <spanclass="math inline">\(x^{(k)}_{i}\)</span>代入后续所有计算，即为Gauss-Seidel格式：</p><p><span class="math display">\[x^{(k+1)}=D^{-1}(b-Lx^{(k+1)}-Ux^{(k)})\]</span></p><p>最终的迭代格式为：</p><p><span class="math display">\[x^{(k+1)}=Gx^{(k)}+f_G\]</span></p><ul><li><p><span class="math inline">\(G=-(D+L)^{-1}U\)</span></p></li><li><p><span class="math inline">\(f_G=(D+L)^{-1}b\)</span></p></li></ul><h4 id="sor逐次超松弛迭代格式">SOR（逐次超松弛）迭代格式</h4><p><span class="math display">\[x^{(k+1)}=(1-\omega )x^{(k)}+\omega D^{-1}(b-Lx^{(k+1)}-Ux^{(k)})\]</span></p><p><span class="math inline">\(\omega\)</span>称为松弛因子，当 <spanclass="math inline">\(\omega =1\)</span>时，即为Gauss-Seidel迭代。</p><p>最终格式为：</p><p><span class="math display">\[x^{(k+1)}=S_\omega x^{(k)}+f_\omega\]</span></p><ul><li><p><span class="math inline">\(S_\omega =(D+\omegaL)^{-1}[(1-\omega)D-\omega U]\)</span></p></li><li><p><span class="math inline">\(f_\omega =\omega (D+\omegaL)^{-1}b\)</span></p></li></ul><h3 id="迭代格式的收敛性">迭代格式的收敛性</h3><h4 id="迭代法基本定理">迭代法基本定理</h4><p><strong>Thm</strong>：迭代格式 <spanclass="math inline">\(x^{(k+1)}=Bx^{(k)}+f\)</span>收敛的充分必要条件是<span class="math inline">\(\rho(B)&lt;1\)</span></p><p><strong>Thm</strong>：若迭代格式 <spanclass="math inline">\(||B||&lt;1\)</span>，则<spanclass="math inline">\(x^{(k+1)}=Bx^{(k)}+f\)</span>收敛。「<ahref="https://www.wolai.com/4bZTUKfKuKiHhhaEUmhhDC">Thm：对于任意范数(A)||A||</a>」同时：（误差的先验估计和后验估计）</p><ol type="1"><li><p><span class="math inline">\(||x^*-x^{(k+1)}||\le||B||~||x^*-x^{(k)}||\)</span></p></li><li><p><span class="math inline">\(||x^*-x^{(k)}||\le \frac{||B||}{1-||B||} ||x^{(k)} - x^{(k-1)}||\)</span></p></li><li><p><span class="math inline">\(||x^*-x^{(k)}||\le \frac{||B||^k}{1-||B||} ||x^{(1)} - x^{(0)}||\)</span></p></li></ol><h4id="jacobi迭代和gauss-seidel迭代的收敛性">Jacobi迭代和Gauss-Seidel迭代的收敛性</h4><ol type="1"><li><p>Jacobi迭代法收敛<spanclass="math inline">\(\iff\rho(J)&lt;1\)</span></p></li><li><p>Gauss-Seidel迭代法收敛<span class="math inline">\(\iff\rho(G)&lt;1\)</span></p></li></ol><blockquote><p>严格行对角占优： <span class="math inline">\(|a_{ii}|\ge\sum_{j,i\nej}|a_{ij}|\)</span></p></blockquote><blockquote><p>严格列对角占优：<span class="math inline">\(|a_{jj}|\ge\sum_{i,i\nej}|a_{ij}|\)</span></p></blockquote><p><strong>引理</strong> 若A是严格对角占优的，则 <spanclass="math inline">\(|A|\ne0\)</span></p><p><strong>Thm</strong> 如果对于矩阵 <spanclass="math inline">\(Ax=b\)</span>是严格对角占优的，则Jacobi迭代和Gauss-Seidel迭代收敛。</p><h4 id="sor迭代法的收敛性">SOR迭代法的收敛性</h4><p><strong>Thm</strong> SOR迭代收敛的必要条件是 <spanclass="math inline">\(0&lt;\omega&lt;2\)</span></p><p><strong>Thm</strong> 若A对称正定，且 <spanclass="math inline">\(0&lt;\omega&lt;2\)</span>则SOR迭代法收敛</p><blockquote><p><strong>Thm</strong> 若A对称正定，则Gauss-Seidel迭代法收敛</p></blockquote><blockquote><p>Homework ：P124:28 30 32(1,2) 34</p></blockquote></div><h2 id="幂法和反幂法">幂法和反幂法</h2><div class="story post-story"><h3 id="求主特征值的方法">求主特征值的方法</h3><p><strong>Def</strong>（主特征值）若将<spanclass="math inline">\(A\)</span>线性无关的特征向量对应的特征值<spanclass="math inline">\(\lambda_j\)</span>按模大小排列，有<spanclass="math inline">\(\max{|\lambda_j|}=|\lambda_1|\)</span>为主特征值。</p><p><strong>Thm</strong> 幂法：</p><p><span class="math display">\[\begin{cases} u_0=v_0\\v_k=Au_{k-1}\\m_k=\max(v_k)\\u_k=v_k/m_k\end{cases}\]</span></p><p><strong>Thm</strong> 若满足<spanclass="math inline">\(|\lambda_1|&gt;|\lambda_2|\ge\cdots\)</span>，则通过幂法得到的序列有如下极限：</p><p><span class="math display">\[\begin{cases} m_k\rightarrow \lambda_1\\u_k\rightarrow \frac{x_1}{\maxx_1} \end{cases}\]</span></p><h3 id="反幂法">反幂法</h3><p>求最小特征值：用<span class="math inline">\(A^{-1}\)</span>代替<spanclass="math inline">\(A\)</span>计算</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;数值分析 ch 3 - 线性方程组的数值解&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数值分析" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
