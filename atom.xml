<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逆版本战士の部落格</title>
  
  
  <link href="http://adversarr.github.io/atom.xml" rel="self"/>
  
  <link href="http://adversarr.github.io/"/>
  <updated>2022-04-21T02:44:10.543Z</updated>
  <id>http://adversarr.github.io/</id>
  
  <author>
    <name>Adversarr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>201-03-拉格朗日视角2</title>
    <link href="http://adversarr.github.io/2022/04/21/CG/GAMES/g201-03/"/>
    <id>http://adversarr.github.io/2022/04/21/CG/GAMES/g201-03/</id>
    <published>2022-04-20T16:00:00.000Z</published>
    <updated>2022-04-21T02:44:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 201 -高级物理引擎实战 - 4 - 拉格朗日视角</p><span id="more"></span><h2 id="变形-deformation">变形 – Deformation</h2><div class="story post-story"><blockquote><p>Reading：</p><ol type="1"><li>The classical FEM method and discretization methodology</li><li>The MPM for simulating continuous …</li></ol></blockquote><p>形变就是一个单对单的映射： <span class="math display">\[\phi : \mathbb R^3 \rightarrow \mathbb R^3\]</span> 从而形变梯度为： <span class="math display">\[\mathbf F = \frac{\partial \mathbf x_{deformed}}{\partial \mathbfx_{rest}}\]</span> 不难发现到<span class="math inline">\(\mathbfF\)</span>是平移不变的。</p><p>体积变化即为：<span class="math inline">\(J = \det \mathbfF\)</span></p></div><h2 id="弹性">弹性</h2><div class="story post-story"><dl><dt>弹性</dt><dd>材料有恢复原始状态的性质</dd></dl><ul><li>我们只观察超形变物体（有strain能量函数<spanclass="math inline">\(\Psi\)</span>）的</li></ul><p>注意区别：</p><ol type="1"><li>stress</li><li>strain – 直接替换为 <span class="math inline">\(\mathbfF\)</span></li></ol><h3 id="stress-tensor">Stress Tensor</h3><p>表明了材料微元和其他材料微元的相互作用：</p><p>有不同的stress tensor</p><ul><li>PK1：<span class="math inline">\(\mathbf P(\mathbf F) = \partial\Psi (\mathbf F) /\partial \mathbf F\)</span> –容易计算，但在restspace</li><li>Kirchhoff stress：<span class="math inline">\(\tau\)</span></li><li>Cauchy Stress：<span class="math inline">\(\sigma\)</span></li></ul><p>相互关系为： <span class="math display">\[\tau = J \sigma = \mathbf P\mathbf F^T\]</span></p><ul><li>Traction = <span class="math inline">\(\mathbf t = \sigma^T \mathbfn\)</span></li></ul><h4 id="常用属性">常用属性</h4><ol type="1"><li>杨氏模量 – <span class="math inline">\(E = \sigma /\varepsilon\)</span></li><li>Bulk modulus</li><li>泊松比</li></ol><p>考虑 Lame Parameters：</p><ul><li><span class="math inline">\(\mu\)</span></li><li><span class="math inline">\(\lambda\)</span></li></ul><p>可以相互转换，只要指定泊松比和杨氏模量</p><h4 id="常用超弹性模型">常用超弹性模型</h4><ol type="1"><li>Linear elsaticity – 小形变下可以，但对于旋转没有惩罚</li><li>Neo-Hookean</li><li>Fixed Corotated</li></ol><p><img src="g201-03/image-20220421102323599.png" class="lazyload" data-srcset="g201-03/image-20220421102323599.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div><h2 id="fem">FEM</h2><div class="story post-story"><p>对于形变物体： <span class="math display">\[\mathbf x_{def} = \mathbf F \mathbf x _{rest} + \mathbf b\]</span> 对于每一个元素： <span class="math display">\[U(e)=\int_e \psi(\mathbf F(\mathbf x))\mathbf x = V_e \psi (\mathbf F_e)\]</span> 求出力： <span class="math display">\[f_{t, i} = - \frac{\partial U}{\partial \mathbf x_i}= - \sum_e V_e\mathbf P(\mathbf F_e)\frac{\partial \mathbf F_e}{\partial \mathbf x_i}\]</span></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 201 -高级物理引擎实战 - 4 - 拉格朗日视角&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-05-B样条曲线</title>
    <link href="http://adversarr.github.io/2022/04/20/CG/GAMES/g102-05/"/>
    <id>http://adversarr.github.io/2022/04/20/CG/GAMES/g102-05/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-21T15:47:23.923Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 102 -- 5 B样条曲线</p><span id="more"></span><h2 id="b-样条曲线">B 样条曲线</h2><div class="story post-story"><h3 id="建模的两种形式">建模的两种形式</h3><ol type="1"><li>重建 – 形状已经有了，猜出来– 基函数组合</li><li>设计 – 产生 – 自行组合权系数</li></ol><h3 id="如果用-bernstein-基函数">如果用 Bernstein 基函数？</h3><p>顶点和曲线的关联性强，具有较高的几何意义</p><p><span class="math inline">\(n\)</span> 次Bernstein基函数 <spanclass="math display">\[B_i ^{(n)} (t) = C_n ^ i t ^ i ( 1- t ) ^{n - i}\]</span> 从而： <span class="math display">\[\mathbf f ( t ) = \sum_{i = 1} ^ n b_i ( t )\mathbf p_i, \quad t \in [0,1]\]</span> 我们使用Bernstein基函数替代权函数： <spanclass="math display">\[x(t) = \sum_{i=0}^n B_i^n(t) b_i\]</span> <img src="g102-05/image-20220421233511284.png"alt="使用 Bernstein 基函数构造的曲线" /></p></div><h2 id="b曲线的性质">B曲线的性质</h2><div class="story post-story"><p>观察基函数：</p><ol type="1"><li>具有对称性（关于 <span class="math inline">\(i\)</span>）</li><li>当 <span class="math inline">\(t = i/n\)</span> 最大</li><li>非负性 + 权性（加和为1）— 具有凸包性<ol type="1"><li>曲线始终在凸包内</li></ol></li><li>基性 – 是<span class="math inline">\(n\)</span>次多项式空间的基</li><li>递推公式（从组合系数证明）</li><li>端点差值 – 经过始末顶点</li><li>端点性质 –<ol type="1"><li>插值</li><li>切线方向和边相同</li></ol></li><li>升阶 — 通过递推公式来推导</li></ol></div><h2 id="de-casteljau-算法">de Casteljau 算法</h2><div class="story post-story"><p>输入：点</p><p>输出：在 <span class="math inline">\(t\)</span> 位置的值</p><p>思想：反复用 <span class="math inline">\(t \mathbf x + (1-t)\mathbfy\)</span> 作用在相邻点上</p><p>复杂度 – <span class="math inline">\(O(n^2)\)</span></p><p>算法只有线性运算，计算稳定</p><p>应用：离散、求根</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 102 -- 5 B样条曲线&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-04-B样条曲线</title>
    <link href="http://adversarr.github.io/2022/04/20/CG/GAMES/g102-06/"/>
    <id>http://adversarr.github.io/2022/04/20/CG/GAMES/g102-06/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-21T15:26:11.764Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">

</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Programming</title>
    <link href="http://adversarr.github.io/2022/04/19/study/ComputerScience/fragments/WhyProgramming/"/>
    <id>http://adversarr.github.io/2022/04/19/study/ComputerScience/fragments/WhyProgramming/</id>
    <published>2022-04-19T15:25:31.924Z</published>
    <updated>2022-04-21T14:54:19.222Z</updated>
    
    <content type="html"><![CDATA[<p>占坑</p><span id="more"></span><h2 id="为什么要研究语言">为什么要研究语言</h2><div class="story post-story"><p>很多时候，我们会在网络上看到一些没有意义的问题：</p><blockquote><p>Q: 什么是世界上最好的语言？</p></blockquote><details ><summary> anwser </summary>              <div class='content'>              <p>肯定不是php。</p>              </div>            </details><p>这类问题是怎么产生的呢？我们日常开发中经常见到的一个场景是：</p><div class="note "><p><strong>Why????</strong></p><ol type="1"><li>写 C++：<ol type="1"><li>为什么这个文件无法通过编译！</li><li>为什么别人的代码无法在我的机器上运行！</li><li>为什么别人的代码和我学过的完全不是一个东西！</li><li>xxxx……</li></ol></li><li>写 Python：<ol type="1"><li>为什么这个变量传递进去就是错的！</li><li>为什么没有自动补全</li><li>为什么这么慢！</li><li>这是个什么神奇的语法？</li><li>为什么这个变量不变/变了！！！</li></ol></li><li>写函数式：<ol type="1"><li>为什么我要写/学这个东西？！</li></ol></li><li>写 Java / C#：<ol type="1"><li>为什么能够有人不用ide就开发！</li></ol></li><li>写 Swift：<ol type="1"><li>为什么这个语法如此的丑陋！</li></ol></li></ol></div><p>诸如此类，这些乱七八糟问题都会促使工程师们（码农们）去想要用别的语言来处理当前/原有的业务。</p><p>回到最开始的那个问题，为什么人们会孜孜不倦的讨论世界上最好的语言这个问题？实际上问题在于，对于一个极其复杂的业务，一种编程语言，或者说一种编程范式，其始终无法满足需求。而当一个新的语言，在当前的业务逻辑上，相交于之前的语言的实现上更加简单且高效的时候，程序员一定会破口大骂，为什么自己没有早点发现/学习这个语言。</p><blockquote><p>最经典的场景莫过于绝大多数的同学，在大二开始接触Python/Java的时候，疯狂抱怨自己为什么要学习C/C++，为什么学校还要墨守陈规得继续教授C++。</p></blockquote><p>从上面的问题中，我们不难看到几个关键词：</p><ol type="1"><li>编程范式：什么是面向对象/数据/过程/函数式</li><li>效率：简单、高效的实现/程序加速</li></ol><p>这些东西我们分开来一个个谈吧。</p><h3 id="到底程序是个啥">到底程序是个啥</h3><blockquote><p>程序 = 方法 + 数据</p><p>（一般在设计 Class的时候，人们更倾向于把成员函数称为一个<code>方法</code>，而对于一些其他的函数，我们就叫做<code>函数</code>。Anyway，如果你和我一样只是把函数和方法都看作数据上的操作的话，实际上也没有必要特别区分方法和函数，因此在我考虑问题、设计程序算法的时候，我通常不区分<code>方法</code>和<code>函数</code>）</p></blockquote><p>这几乎就是我们进行所谓的<strong>程序设计</strong>的一个起点！很大程度上，我在程序设计的起点，我需要搞明白的很少的一些东西：</p><ol type="1"><li>这个程序的输入是什么</li><li>这个程序的输出是什么</li><li>这个程序会对外部（例如操作系统状态）产生什么影响</li></ol><p>举一些🌰：</p><ol type="1"><li>一个矩阵乘法程序，就是拿到两个矩阵的数据，对它们进行矩阵乘法这个方法，然后吐出来一个矩阵</li><li>一个计算器，就是监听用户的输入，并记录下来，使用内置的一些固定的方法，在记录的数据上做操作，然后给用户一个输出</li><li>……（你也可以再想想自己写过的啥程序）</li></ol><p>对于其中的<code>数据</code>我们再熟悉不过了，在你见到的几乎所有的语言中，他们就是你直接操作的常/变量。对于这些量而言，在<strong>设计</strong>算法的初期，我们几乎不考虑它具体的值，我们更加关心的是它的类型！（有关类型，会在后面进行介绍）但是对于程序而言，一个运行时的程序，通常更加关注它的值。</p><p>正如SICP中对于程序设计的描述上，其关键点有：</p><ol type="1"><li>定义出这个程序的<strong>输入</strong>和<strong>输出</strong></li><li>定义出这个程序所需要的数据，例如<code>Point&#123; int x; int y; &#125;</code></li><li>根据我们拿到的数据、输入，来设计我们程序的大体框架（画流程图、伪代码等等）</li><li>设计函数：把上面的框架做拆解，通常我习惯于类似于做一个广度遍历，逐步把上面流程图中涉及的一些方法做一个实现。</li><li>开始你的实现。</li></ol><h3 id="语言逻辑表达能力">语言逻辑、表达能力</h3><p>好吧，我们这里根本不考虑所谓<strong>程序</strong>，因为我们绝大多数人从来都不是直接写二进制程序的！因此我们这里考虑的是语言的<strong>表达能力</strong>。（虽然我们在后文中不太考虑程序和代码的区别）</p><p>实际上我们已经知道答案了 —— <strong>图灵完备</strong>：</p><blockquote><p>In computability theory, a system of data-manipulation rules (such asa computer's instruction set, a programming language, or a cellularautomaton) is said to be Turing-complete or computationally universal ifit can be used to simulate any Turing machine (devised by Englishmathematician and computer scientist Alan Turing). This means that thissystem is able to recognize or decide other data-manipulation rule sets.Turing completeness is used as a way to express the power of such adata-manipulation rule set. Virtually all programming languages todayare Turing-complete.</p></blockquote><p>TLDR：从理论上说，我们使用的所有语言都有相同的表达能力！</p><p>那么问题是，为什么我们还需要考虑一个编程语言的表达能力呢？从我的理解来看，回答这个问题就和Hello World 一样简单：</p><p>对于 Python：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello World&quot;</span>  <span class="comment"># py2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>) <span class="comment"># py3</span></span><br></pre></td></tr></table></figure><p>对于 C：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 C++： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 Racket（一种函数式编程语言）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(print &quot;Hello World&quot;)</span><br></pre></td></tr></table></figure><p>从这里我们就能看出问题了，为了实现相同的功能，三种语言体现出完全不同的复杂、直观程度。</p><ol type="1"><li>Python：直观的、简单 -- 很简单</li><li>C：直观的、不简单 -- 至少函数叫做 <code>print</code></li><li>C++：不直观的、不简单 -- 什么是 <code>cout</code>？什么是<code>&lt;&lt;</code>？为什么是 <code>&lt;&lt;</code>？</li><li>Racket：不直观、简单 -- 问题在于为什么需要这个括号？</li></ol><!-- TODO --><h3 id="程序数据函数">程序=数据+函数</h3><h3 id="范式">范式</h3><p>函数是第一公民</p><p>ASYNC</p><h3 id="词法语法解析与执行">词法、语法、解析与执行</h3><h3 id="nfl">NFL</h3><ol type="1"><li>简单 + 舒适</li><li>复杂 + 舒适</li><li>简单 + 难受</li><li>复杂 + 难受</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;占坑&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>102-04-三次样条函数</title>
    <link href="http://adversarr.github.io/2022/04/19/CG/GAMES/g102-04/"/>
    <id>http://adversarr.github.io/2022/04/19/CG/GAMES/g102-04/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-19T07:52:10.194Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES 102 – 几何建模与处理</p><span id="more"></span><h2 id="三次样条函数">三次样条函数</h2><div class="story post-story"><h3 id="力学解释">力学解释</h3><ul><li><p>曲线：弹性梁 — 弹性模量为 <spanclass="math inline">\(E\)</span></p></li><li><p>利用贝努利-欧拉方程，得到近似为分段三次函数</p></li><li><p>2次 — 无法表达拐点、三次 — <spanclass="math inline">\(C^2\)</span>，四次 — 误差大</p></li></ul><p>如何求？满足什么条件？</p><h3 id="思路">思路</h3><p>分段三次多项式，四个变量待定 <span class="math display">\[y_{i}(x) = a_i + b_i x. + c_i x ^ 2 + d_i x ^ 3\]</span> 从而有 <span class="math inline">\(4n-2\)</span>个约束条件，加上两个边界条件。</p><p>列出三弯矩方程组（对称、三对角、对角占优），可以使用追赶法来计算。</p><h3 id="边界条件">边界条件</h3><ul><li>自由端 — 指定二阶导数</li><li>夹持端 — 指定一阶导数</li></ul><h3 id="三次基样条">三次基样条</h3><p>使用三次基函数，计算在基函数下的“坐标”</p></div><h2 id="三次样条曲线">三次样条曲线</h2><div class="story post-story"><ul><li>取 <span class="math inline">\(x,y,z\)</span></li><li>参数化</li></ul></div><h2 id="曲线的连续性">曲线的连续性</h2><div class="story post-story"><p>参数连续性：<span class="math inline">\(C^2\)</span>连续 —和参数有关</p><p>几何连续性：设 <span class="math inline">\(\phi(t)\)</span>是给定曲线的参数方程，存在参数变换，可以达到的连续性是几何连续性。记为<spanclass="math inline">\(G^n\)</span></p><p>具体：</p><ul><li><span class="math inline">\(G^0\)</span>，连续</li><li><span class="math inline">\(G^1\)</span> 切线相同</li><li><span class="math inline">\(G^2\)</span> 曲率相同</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;GAMES 102 – 几何建模与处理&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>102-03-参数曲线拟合</title>
    <link href="http://adversarr.github.io/2022/04/19/CG/GAMES/g102-03/"/>
    <id>http://adversarr.github.io/2022/04/19/CG/GAMES/g102-03/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-19T03:40:08.873Z</updated>
    
    <content type="html"><![CDATA[<p>几何建模与处理</p><span id="more"></span><h2 id="多元函数">多元函数</h2><div class="story post-story"><p><span class="math display">\[f:\R ^n \rightarrow \R\]</span></p><h3 id="二元函数基函数构造">二元函数基函数构造</h3><p>方法：<strong>张量积</strong>（两两相乘）</p><figure><img src="g102-03/image-20220419111126729.png" class="lazyload" data-srcset="g102-03/image-20220419111126729.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="张量基函数" /><figcaption aria-hidden="true">张量基函数</figcaption></figure><p>优点：定义简单，多个一元基函数的乘积形式</p><p>不足：</p><ul><li>维数增加 – 基函数个数 <span class="math inline">\(n^2\)</span> –变量（参数数量）增加</li></ul><h3 id="神经网络表达">神经网络表达</h3><ul><li>用单变量函数 <span class="math inline">\(\sigma(x)\)</span>和不同的仿射变换来构造基函数。</li></ul></div><h2 id="向量值函数">向量值函数</h2><div class="story post-story"><p><span class="math display">\[f:\R^m \rightarrow \R^n\]</span></p><ul><li>看成多个单变量函数，各个函数独立无关。</li><li>共享基函数</li></ul><p>几何上：</p><ul><li>对于<span class="math inline">\(m=1\)</span> – 轨迹为曲线 —本质维度=1</li><li>对于 <span class="math inline">\(\R^2 \rightarrow \R^3\)</span> —参数曲面 — 本质维度=2 —</li><li><span class="math inline">\(3\rightarrow3\)</span> — 变形 –应用：有限元、图像变形</li><li><span class="math inline">\(3\rightarrow 2\)</span> — 降维映射 —例如 AutoEncoder</li></ul><figure><img src="g102-03/image-20220419112717602.png" class="lazyload" data-srcset="g102-03/image-20220419112717602.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="总结" /><figcaption aria-hidden="true">总结</figcaption></figure></div><h2 id="曲线拟合">曲线拟合</h2><div class="story post-story"><h3 id="曲线拟合问题">曲线拟合问题</h3><ul><li>输入：给定平面上的点</li><li>输出：一条参数曲线，拟合这些点</li></ul><p><span class="math display">\[f:\R \rightarrow \R^2\]</span></p><p>参数化 — <span class="math display">\[\begin{cases}x = x(t)\\y = y(t)\end{cases}\]</span></p><ul><li><p>问题转化为：对数据点 <spanclass="math inline">\((x_i,y_i)\)</span>，对应哪个参数<spanclass="math inline">\(t_i\)</span>？</p></li><li><p><span class="math inline">\(E = \sum\|\mathbf p (t_i) - \mathbfp_i\|\)</span></p></li></ul><p>如何确定 <span class="math inline">\(t\)</span></p><ul><li><p>均匀参数化（Equidistant Parameterization）</p></li><li><p>弦长参数化 <span class="math inline">\(t_{i+1} - t_i =\|\mathbfb_{i+1} -\mathbf b\|\)</span></p></li><li><p>中心参数化</p></li></ul><blockquote><p><strong>需要好的参数化</strong></p><p>目的：保持原有结构！</p></blockquote><h3 id="曲面参数化">曲面参数化</h3><ul><li>三维点找二维的参数 — 降维问题</li></ul><p>例如：</p><ul><li>纹理映射</li><li>世界地图</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;几何建模与处理&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>实时布料仿真</title>
    <link href="http://adversarr.github.io/2022/04/14/CG/ContactDetection/ClothSimu/"/>
    <id>http://adversarr.github.io/2022/04/14/CG/ContactDetection/ClothSimu/</id>
    <published>2022-04-14T12:58:15.554Z</published>
    <updated>2022-04-14T14:07:32.651Z</updated>
    
    <content type="html"><![CDATA[<p>Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021</p><span id="more"></span><h2 id="introduction">Introduction</h2><div class="story post-story"><p>Dynamic Solver：</p><ul><li>High resolution</li><li>High nonlinearity</li><li>High stiffness — 多次迭代、计算量</li></ul><p>Collision:</p><ul><li>Collision detection</li><li>Collision Response.</li></ul><h3 id="problem-definitions">Problem Definitions</h3><h4 id="terms">Terms</h4><p>Position Vector: <span class="math display">\[\mathbf x = [\mathbf x_0 \mathbf x_1 \cdots \mathbf x_N]&#39;\]</span> Velocity: <span class="math display">\[\mathbf v = \dot {\mathbf x}\quad \mathbf M = diag(m_0, \dots, m_N)\]</span> Energy – Holonomic(Position only): <spanclass="math display">\[E(\mathbf x)\]</span> 例如：</p><ol type="1"><li>重力势能</li><li>弹簧能量</li><li>Fixing Energy — <span class="math inline">\(\frac{\sigma}2 (\mathbfx_i -\mathbf y_i)^2\)</span></li></ol><h4 id="time-integration">Time Integration</h4><p>常用：隐式欧拉法</p><p>求解方法：</p><ol type="1"><li>消去 <span class="math inline">\(\mathbf v^{t + \Deltat}\)</span></li><li>转化为非线性优化问题</li></ol><p>从而，整个问题都变为： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x)\]</span> 其中 <span class="math inline">\(F\)</span>由动能和势能组成。</p><h4 id="碰撞">碰撞</h4><p>作为约束项出现： <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad \mathbf x^{t + \Delta t} \in \Omega\]</span> <img src="ClothSimu/image-20220414210701587.png"alt="image-20220414210701587" /></p><p>上式存在隧穿问题(Tunnel)。故采用CCD。 <span class="math display">\[\mathbf x^{t + \Delta t} = \arg\min_{\mathbf x} F(\mathbf x) \\s.t.\quad s \mathbf x^t + (1-s)  \mathbf x^{t + \Delta t} \in \Omega\forall s\in [0,1]\]</span></p></div><h2 id="dynamics">Dynamics</h2><div class="story post-story"><p>非线性优化通常有如下的形式： <span class="math display">\[\mathbf x ^{k+1} = \mathbf x^k - \alpha^{k + 1}\left(A^{k+1}\right)^{-1} \mathrm{grad}\]</span></p><h3 id="newton-法">Newton 法</h3><p>优点</p><ul><li>2 阶方法</li><li>Hessian Matrix</li></ul><p>问题</p><ul><li>如何求解 <span class="math inline">\(A^{-1}f\)</span> —计算量大</li><li>不一定收敛<ul><li>减小 <span class="math inline">\(\alpha\)</span></li><li>要求 Hessian 正定</li></ul></li></ul><h3 id="梯度下降">梯度下降</h3><p><span class="math display">\[A = \mathrm{id}\]</span></p><p>优点</p><ul><li>GPU++</li><li>简单</li></ul><p>缺点</p><ul><li>1阶收敛 – 慢</li><li>没有任何实时模拟器使用</li></ul><h3 id="projective-dynamics">Projective Dynamics</h3><p>用常矩阵代替 <span class="math inline">\(A\)</span></p><p>优点：</p><ul><li>CPU++，（C 可以被预分解）</li><li>收敛快 — smoother</li></ul><p>缺点</p><ul><li>GPU不友好</li><li>1阶收敛速度（总体上很慢）</li></ul><h3 id="diagonal-hessian">Diagonal Hessian</h3><p><span class="math display">\[\mathbf A^{k+1} = \mathrm{diag\ grad}\]</span></p><p>优点</p><ul><li>收敛快于GD</li><li>GPU++</li></ul><p>缺点</p><ul><li>速度仍然差于牛顿</li></ul><h3 id="lower-hessian">Lower Hessian</h3><p>使用hessian的下三角</p><p>优缺点同 Diag Hess</p><figure><img src="ClothSimu/image-20220414212056199.png" class="lazyload" data-srcset="ClothSimu/image-20220414212056199.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="总结对比" /><figcaption aria-hidden="true">总结对比</figcaption></figure><h3 id="acceleration">Acceleration</h3><ul><li>Chebyshev — GPU Firendly</li><li>Multiscale Acceleration</li></ul><h3 id="conclusion">Conclusion</h3><p>CPU：Projective Dynamics + Newton-Raphson</p><p>GPU：Chebyshev + Diagonal Hessian / Newton + PCG</p><h3 id="more">More</h3><h4 id="pbd-position-based-dynamics">PBD — Position-Based Dynamics</h4><p><strong>NVCLOTH</strong></p><h4 id="regular-grid-mesh">Regular Grid Mesh</h4><ul><li>Avoid Topology info</li><li>mem access</li><li>more suitable for high resolution</li></ul></div><h2 id="碰撞-1">碰撞</h2><div class="story post-story"><p>两部分：碰撞检测 + 碰撞响应 具体看综述</p><h3 id="检测">检测</h3><p>mesh -&gt; pair -&gt; collision</p><h3 id="response">Response</h3><ol type="1"><li>Iterative Position-Based Repulsion</li><li>Impact Zone Method</li><li>Untangling</li></ol></div><h2 id="other-topics">Other Topics</h2><div class="story post-story"><ul><li>Friction</li><li>Nonelastic</li><li>Locking</li><li>Physical model and measurement</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="仿真模拟" scheme="http://adversarr.github.io/tags/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="布料" scheme="http://adversarr.github.io/tags/%E5%B8%83%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 6 - 综述</title>
    <link href="http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/"/>
    <id>http://adversarr.github.io/2022/04/12/CG/ContactDetection/Survey/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-15T04:13:25.291Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测 学习笔记</p><span id="more"></span><p>[toc]</p><h2 id="碰撞处理简述">碰撞处理简述</h2><div class="story post-story"><p>碰撞处理的难度是不大的，主要问题是如何进行快速、准确的碰撞检测。碰撞检测主要算法执行流程如下图：</p><figure><img src="2022-04-05-17-32-22.png" class="lazyload" data-srcset="2022-04-05-17-32-22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GAMES-103-Wang" /><figcaption aria-hidden="true">GAMES-103-Wang</figcaption></figure></div><h2 id="碰撞检测----introduction">碰撞检测 -- Introduction</h2><div class="story post-story"><p>首先再次引一下 PhyX 里面的内容，这也是这篇文章整体的一个思路。</p><blockquote><p><strong>Overview of Collision in PhysX</strong></p><ul><li>Broad Phase<ul><li>AABB vs AABB, 3 axis sweep and prune</li></ul></li><li>Mid Phase<ul><li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABBtree</li></ul></li></ul><p>对于 Narrow Phase：</p><ul><li><p>流体-SPH Fluids (CCD)</p><ul><li>Particles vs static triangle mesh • Particles vs dynamicprimitives</li></ul></li><li><p>布料-Cloth (CCD)</p><ul><li>Vertices vs static triangle mesh • Vertices vs dynamicprimitives</li></ul></li><li><p>刚体-Rigid body (Discrete) – GJK or SAT</p><ul><li><p>Convex mesh and primitives vs static triangle mesh</p></li><li><p>Convex, primitives vs Convex, primitives</p></li></ul></li></ul></blockquote><p>解释一些事情：</p><ol type="1"><li><p>对于<strong>大多数</strong>情况下的碰撞，我们只考虑<strong>物体之间</strong>的情况，而不是物体内部。</p></li><li><p>Broad-Phase做的实际上是<em>生成式</em>的，而非<em>筛选式</em>的，Mid-Phase对于Broad-Phase进行筛选，Narrow-Phase是筛选结果来精确计算是否真正发生了碰撞。</p><blockquote><p>很多研究认为 Narrow-Phase的效率并不需要太多考虑，而前两个筛选的效率大大影响了结果</p></blockquote></li><li><p>对于Narrow-Phase中的三类物体，它们有不同的属性：</p><ol type="1"><li>流体 -- SPH模拟假设为一个个小的水块，自相交检测策略不同</li><li>布料 -- Mass-Spring orPBD，约束为任何物体不能穿透布料表面，也适用于自身，所以需要进行自碰撞处理</li><li>刚体 -- 不可能发生自碰撞，只考虑物体之间的碰撞。</li></ol></li></ol></div><h2 id="broad-phase">Broad-Phase</h2><div class="story post-story"><p>实际上这个没啥好讲的，主要思路就是建立空间数据结构，然后加速计算。</p><ol type="1"><li>BVHs</li><li>Spatial Hashing</li></ol><h3 id="加速结构">加速结构</h3><p>就如之前提到的，Broad-Phase主要是使用<strong>空间数据结构</strong>来加速碰撞检查，这类数据结构按照欧氏空间的坐标来对于整个空间进行索引加速，从而实现快速查找近邻的目的。</p><h4 id="oct-treekdtree">OCT-tree/kdTree</h4><ul><li><p><strong>八叉树</strong>：将一个Box按照点<spanclass="math inline">\(P\)</span>和经过<spanclass="math inline">\(P\)</span>平行于<spanclass="math inline">\(xOy,yOz,zOx\)</span>的平面划分。</p></li><li><p><strong>kd树</strong>：每一次选择一个超平面划分所有点，超平面的选择依照<spanclass="math inline">\(xOy, yOz,zOx,xOy,yOz,\cdots\)</span>的顺序选择。</p></li></ul><p>可能碰撞转化为查询轨迹和物体是否相交，等价于查询是否和当前节点的覆盖范围相交，若检查到轨迹和结点覆盖范围</p><ol type="1"><li>相交：<ul><li>叶子节点，认定为可能碰撞的目标</li><li>非叶结点，继续递归查询</li></ul></li><li>不相交： 停止递归查询</li></ol><p>这样构造层次结构的问题是：</p><ol type="1"><li>过于规则：容易出现不均匀分割，从而导致内存浪费和查询效率下降。</li><li>不利于并行计算—这也是层次结构的通病</li></ol><h4 id="bvh">BVH</h4><p>BVH可以看作是OCT-Tree和kdTree的一个推广：Bounding VolumnHierarchy（BVH） 将全空间进行划分，对于维度为 1的情况，BVH与<em>线段树</em>几乎没有区别。不过，BVH和OCT-Tree等的最大的区别在于OCT-Tree 和kdTree进行划分时使用的是边界去切分整个平面，而BVH用的是<strong>有限体积的“框”</strong>去做空间细分。典型的BVH包括：</p><ul><li>AABB：轴对齐包围盒</li><li>OBB：旋转包围盒</li><li>kDOP：k边形包围盒</li><li>Bounding Sphere：包围球</li></ul><p>可以看出，各个算法不同的部分是选用的“框”的形状。另外，在构造上BVH有启发算法，可以是的其构造的层次结构尽量均匀，进一步提高BVH的加速能力。</p><h4 id="spatial-hashing-spatial-partitioning">Spatial Hashing / SpatialPartitioning</h4><p>Spatial Hashing的思想是为每一个空间一个编号。最简单的方法是均匀的使用格点来对于全空间进行划分。最基础的Spatial Hashing在为每一个格子建立列表，列表中存放所有和该格子有重合区域的物体（即一个物体可能出现在多个格子内），在查询碰撞时即对于同一列表中的不同物体进行查询即可。</p><figure><img src="image-20220409103734403.png" class="lazyload" data-srcset="image-20220409103734403.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Spatial Partitioning" /><figcaption aria-hidden="true">Spatial Partitioning</figcaption></figure><p>如图所示，其将全空间划分为16个格子。考虑到减少空间浪费的问题，将这些物体的按id进行排序，即可在不为每一个id建立表格的情况下完成筛选。</p><p>该算法的主要问题在于，现代的渲染常常物体、面元分布极不均匀，在可能在几个小的cell中包含大量物体，而产生大量的可能碰撞物体对，极大的降低了其查询效率。</p><p>但是得益于其可以轻松在并行计算环境，特别是GPU上进行实现，其在物理引擎中也得到了广泛的应用。</p><h3 id="mid-phase">Mid-Phase</h3><p>之所以把Mid-Phase放在BroadPhase中是因为它用的算法和数据结构实际上和BroadPhase几乎是一致的。</p><p>Mid-Phase会对Broad-Phase筛选出的pair进行进一步筛选，针对每一个物体，其通过细分为更小的物体块（如凸包，面元组等），然后继续应用加速结构进行筛选。</p><blockquote><p>在这个的基础上还有一些 local 的加速方法，但这也不能算是 Broad-Phase的方法，因为这个方法针对于 <em>Deformed</em>的物体进行计算的效率较高。这些方法在曲面上进行划分，相当于在曲面上定义了一个空间划分。比如通过形变能量来指导在其上的空间划分，最后精细化求解使用三次方程法求解。例如：该论文提出，可以依照形变能量，在曲面的表面上建立BVH，来指导Culling进行。</p></blockquote><figure><img src="image-20220413220403382.png"alt="Energy-based Self-Collision Culling for Arbitrary Mesh Deformations" /><figcaption aria-hidden="true">Energy-based Self-Collision Culling forArbitrary Mesh Deformations</figcaption></figure></div><h2 id="narrow-phase-1-刚体">Narrow-phase 1 刚体</h2><div class="story post-story"><h3 id="dcd">DCD</h3><h4 id="signed-distance-function">Signed Distance Function</h4><p>如果我们能为刚体定义一个连续函数，使得对于<spanclass="math inline">\(\mathbf x \in \Omega -\partial\Omega\)</span>有<span class="math inline">\(\phi(\mathbf x) &lt;0\)</span>对于所有<span class="math inline">\(x\not \in \overline\Omega\)</span>，有<span class="math inline">\(\phi(x) &gt;0\)</span>，则可以很简单的通过函数零点的存在性来判断是否碰撞。</p><p>但对于一般的网格，难以定义这样一个带符号的距离函数。</p><h4 id="凸包刚体的dcd计算">凸包/刚体的DCD计算</h4><p>对于一般的刚体之间的碰撞检测，一般采用分解为凸包的算法来进行精准的碰撞检测。因此，最基础的针对凸物体的碰撞检测算法（即凸物体之间的碰撞检测）</p><h5 id="gjk算法">GJK算法</h5><h6 id="idea">Idea</h6><p>设<span class="math inline">\(\mathcal A = \{\mathbfx\}\)</span>，<span class="math inline">\(\mathcal B = \{\mathbfx\}\)</span>是两个凸集，定义其 Minkowski 差为： <spanclass="math display">\[\mathcal A - \mathcal B :=\{\mathbf x_1 - \mathbf x_2| \mathbf x_1 \in\mathcal A, \mathbf x_2 \in \mathcal B \}\]</span> 不难证明，<span class="math inline">\(\mathcalA\)</span>和<span class="math inline">\(\mathcalB\)</span>碰撞，当且仅当<span class="math inline">\(0 \in \mathcal A -\mathcal B\)</span>。</p><p>问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于<strong>凸物体</strong>，我们可以有快速算法实现。</p><h6 id="support-函数和-simplex-单纯形">Support 函数和 Simplex单纯形</h6><p>其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski差的一个子集包含了<spanclass="math inline">\(0\)</span>，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。</p><p>为了生成这样的单纯形，我们计算 support函数来快速获取给定方向上的支撑点，如图所示[^1]。</p><p><img src="v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg" class="lazyload" data-srcset="v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h6 id="迭代求解">迭代求解</h6><p>有了如上的论述，我们可以通过如此构造单纯形：</p><ol type="1"><li>随机生成一个单纯形</li><li>假定当前的单纯形为<spanclass="math inline">\(\{v\}\)</span>则选择距离原点最远的抛弃，对于 n - 1维单纯形求法向量，求support（两个）</li><li>直到<ol type="1"><li>检查到 0 =&gt; 碰撞</li><li>如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞</li></ol></li></ol><p>可以证明，这样的算法一定在有限步内结束。</p><h5 id="sat算法">SAT算法</h5><p>一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个<spanclass="math inline">\(n - 1\)</span>维的超平面能够完全分开这两个凸集合。遍历所有的边（三维则是面），投影到其正交补空间上。若<strong>存在</strong>一个边，能使得投影完全分离，则其是不相交的，反之相交。具体实现为遍历所有的边来进行判断。</p><h5 id="凸包分解和碰撞检测">凸包分解和碰撞检测</h5><p>对于一般的刚体，我们可以选择使用<strong>凸包分解（V-HACD）</strong>，将刚体“拆分”成小的凸包。并使用适用于凸包的Collision Detect 来进行碰撞的判断。</p><h3 id="ccd">CCD</h3><p>刚体的CCD算法大致有如下几类：</p><ol type="1"><li>求解代数方程</li><li>滑动体积法（Swept Volume）</li><li>二分搜索</li><li>Conservative Advancement上述大部分都难以处理一般的多面体情况。但也有一些特殊情况。</li></ol><!-- 也可以使用分离轴定理计算CCD --><h4 id="代数方程求解">代数方程求解</h4><p>这种方法仅适用于简单而特殊的情况，例如<ahref="http://www.realtimerendering.com/intersections.html">Ref</a>：</p><ol type="1"><li>光线</li><li>平面</li><li>球体、圆柱、圆锥、视锥</li><li>AABB、OBB、kDOP</li><li>凸包</li></ol><h4 id="近似ccd">“近似CCD”</h4><p>通过减小模拟的时间步长，可以将 DCD 近似为 CCD。</p><h4 id="二分搜索">二分搜索</h4><p>这个方法仅仅用于确定 TOI</p><p>物理模拟中有时会使用二分法（二分搜索）来查找撞击时间：使用这种方案，可以非常快速地到达撞击时间，但我们不涉及Tunnel问题，因为如果在第i 帧和第 i + 1 帧没有碰撞，二分就不会开始。</p><h4 id="swept-volumn">Swept Volumn</h4><p>考察<span class="math inline">\(t\)</span>和<spanclass="math inline">\(t+1\)</span>时刻物体对应点连线（按物体形状、沿直线执行扫描）构成的体积区域，不难发现，如果有相交，则可能会出现碰撞。计算TOI（碰撞时间）后将物体移动到改时间，执行碰撞处理（如计算速度等）然后重新扫描。</p><p>在物体角速度很大的情况下会产生不精确的结果 <ahref="https://docs.unity3d.com/Manual/ContinuousCollisionDetection.html">Ref</a>：</p><figure><img src="2022-04-14-15-52-26.png" class="lazyload" data-srcset="2022-04-14-15-52-26.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Unity 3D" /><figcaption aria-hidden="true">Unity 3D</figcaption></figure><h4 id="speculative-ccd">Speculative CCD</h4><p>Speculative CCD的工作原理是根据物体的速度和角速度，计算物体的AABB，从而推测出下一个物理步骤中所有潜在的接触。然后将所有可能接触送入求解器，以确保满足所有接触约束，以便对象不会通过任何穿模（Tunnel）的情况。求解器使用速度、体积来精确计算CCD。</p><p><img src="2022-04-14-15-55-41.png" class="lazyload" data-srcset="2022-04-14-15-55-41.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>但该方法并不能完全解决所有碰撞问题。考虑如下的情况，小球因为被杆击打而获得更大的速度，先前计算的AABB并不能检测到这样的速度变化：</p><p><img src="2022-04-14-16-00-14.png" class="lazyload" data-srcset="2022-04-14-16-00-14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><h4 id="ray-cast">Ray-cast</h4><p>小而高速和大而低速物体之间的碰撞检测中可以视作光投射到低速物体上的过程，该方法在Unreal Engine中被作为试验性功能提供（支持GPU加速）。算法将光线从对象中心点投射到低速物体上，在高速物体中放置更多的采样点并投射出多条光线，可以获得更好的结果。缺点在于，由于假设了其速度差距极大，该方法不适合计算两个运动的物体的碰撞检测。</p><h4 id="conservasive-advancement">Conservasive Advancement</h4><blockquote><p>Ref:</p><ol type="1"><li>C<sup>2</sup>A: Controlled Conservative Advancement for ContinuousCollision Detection of Polygonal Models</li></ol></blockquote><p>在每次迭代中，计算两个对象的最近点（例如使用GJK）。使用此信息，计算对象可以在避免碰撞的同时移动的安全距离。仅经过几次迭代，就可以找到影响时间。</p></div><h2 id="narrow-phase-2-变形体">Narrow-Phase 2 变形体</h2><div class="story post-story"><h3 id="dcd-1">DCD</h3><p>DCD检查的是如下的方程的解的问题（考察 V-E)：</p><p><span class="math display">\[\begin{cases}   \left( ((1-t)\mathbf{x}_a + t \mathbf x _ b - \mathbf x_0 ) \quad\mathbf x _{10} \quad x_{20}\right) = 0\\   t = (\mathbf x_{0a} \mathbf x_{10}\mathbf  x_{20}) / (\mathbf x_{ba}\mathbf   x_{10} \mathbf x_{20})\\   t \in [0, 1]\\   \mathbf x(t) \text{ inside } \triangle\end{cases}\]</span></p><p>分为三步求解：</p><ol type="1"><li>求解前两行的方程</li><li>判断<span class="math inline">\(t\)</span>是否在<spanclass="math inline">\([0, 1]\)</span></li><li>判断<span class="math inline">\(\mathbfx(t)\)</span>是否在三角形内</li></ol><p>这一部分基本很少有人做，原因在于现代的模拟算法越来越追求计算效率，使用较大的时间步长来进行模拟计算。若仅仅使用DCD，容易产生“穿模”的问题。</p><h3 id="ccd-1">CCD</h3><p>对于变形体（主要是三角网格）的连续碰撞检测处理算法研究主体还是对于三次方程（即VT/EE条件求解），同时也借鉴了一些在刚体碰撞检测中常用的技巧：</p><ol type="1"><li>二分法<ol type="1"><li>IRF：interval-root-finder</li><li>UIRF：Unifromed-Interval-Root-Finder</li></ol></li><li>（针对三角网格）求解三次方程：<ol type="1"><li>FPRF：floating-point time-of-impact root finder</li><li>TightCCD(TCCD)</li><li>BSC</li></ol></li><li>光线投射<ol type="1"><li>Root Parity(RP)</li><li>Rational implementation of RP （RRP）</li></ol></li><li>分割空间微元</li></ol><h4 id="preliminaries">Preliminaries</h4><p>沿用IPC中的记号。对于碰撞检测而言，最基本的模型是假设其在两个迭代步骤之间是线性的，即</p><p><span class="math display">\[\mathbf x(t) = t \cdot \mathbf x ^{i + 1}  + (1 - t) \cdot \mathbf x^{i}\]</span></p><p>其中：</p><p>-<span class="math inline">\(t\)</span>为归一化后的时间，即<spanclass="math inline">\(t = (t - t_{i}) / (t_{i + 1} - t _i)\)</span>其中右侧的<span class="math inline">\(t\)</span>是模拟运行时间-<span class="math inline">\(\mathbfx\)</span>是坐标，是关于时间的函数。上标表示迭代代数</p><p>为了简单期间，用<span class="math inline">\(\mathcal A = \mathbfx_1\cdots \mathbf x_i\)</span>来表示一个<spanclass="math inline">\(n\)</span>维单纯形，用<spanclass="math inline">\(\mathbf x_{ij}\)</span>来表示<spanclass="math inline">\(\mathbf x_{i} - \mathbf x_{j}\)</span>。</p><p>在这样的记号下，碰撞可以用<spanclass="math inline">\(t\)</span>来描述，即：</p><p>单纯形<span class="math inline">\(\mathcal A = \{\mathbf x_1\cdots\mathbf x_n\}\)</span>和<span class="math inline">\(\mathcal B =\{\mathbf x_1 \cdots \mathbf x_m\}\)</span>碰撞，当且仅当：</p><p><span class="math display">\[\exists t\in[0, 1]\quad s.t. \  \mathcal A(t) \cap \mathcal B(t) \ne\emptyset\]</span></p><p>这个公式仅仅是一个定义，并没有很大的计算价值，因此我们需要对于这样的问题进行适当的简化。主要有几种思路：</p><ol type="1"><li>二分搜索，找可能的碰撞时间<spanclass="math inline">\(t\)</span></li><li>约束为三角网格再：<ol type="1"><li>求解重心坐标<span class="math inline">\((u,v)\)</span>和<spanclass="math inline">\(t\)</span></li><li>简化为三次方程求根</li></ol></li><li>光线投射方法</li><li></li></ol><h4 id="二分法">二分法</h4><h5 id="irf">IRF</h5><blockquote><p>Ref:</p><ol type="1"><li>Interval Analysis For Computer Graphics</li><li>Interval Methods for Multi-Point Collisions between Time-DependentCurved Surfaces</li></ol></blockquote><p>逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p><p>优点：</p><ol type="1"><li>不会有遗漏的碰撞情况，并且每一步都保证包含 <spanclass="math inline">\(0\)</span>，所以能够确保检查到碰撞</li><li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li></ol><p>缺点：</p><ol type="1"><li>基于二分查找 — 太慢</li><li>难以实施编译优化</li></ol><h5 id="uirf">UIRF</h5><p>差不多的思路，但是是用二分法求的是单变量的方程根。</p><blockquote><p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p><p>与此同时，它不能满足控制求解器的运行精度</p></blockquote><h4id="针对三角网格的三次方程求解方法">针对三角网格的三次方程求解方法</h4><blockquote><p>Ref:</p><ol type="1"><li>Collision and self-collision handling in cloth model dedicated todesign garments</li></ol></blockquote><p>针对于三角网格，上文提出：</p><dl><dt>Theorem</dt><dd>碰撞发生，当且仅当至少发生以下一种碰撞：</dd></dl><ol type="1"><li>Vertex-Triangle</li><li>Edge-Edge</li></ol><p>在这篇论文中，还提出了这两类条件的符号语言描述：</p><p><span class="math display">\[VT\iff \exists t\in [0, 1]\quad \begin{cases}\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\\mathbf x_4 \in \left\{ x_1 x_2 x_3 \right\}\end{cases}\]</span></p><p>其中：<span class="math inline">\(1,2,3\)</span>为三角形顶点，<spanclass="math inline">\(4\)</span>为顶点</p><p><span class="math display">\[EE\iff \exists t\in [0, 1] \quad \begin{cases}\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\\left\{\mathbf x_1 \mathbf x_2\right\} \cap \left\{\mathbf x_3 \mathbfx_4\right\} \ne \emptyset\end{cases}\]</span></p><p>对于上述两种做法，我们观察到条件中都有一个关于<spanclass="math inline">\(t\)</span>的三次方程（因为每一个<spanclass="math inline">\(\mathbf x_i\)</span>都是关于<spanclass="math inline">\(t\)</span>仿射），因此我们的解决思路就是：</p><ol type="1"><li>求三次方程在<span class="math inline">\([0, 1]\)</span>内的根</li><li>检查这个根是否满足第二个条件</li></ol><p>其中的<strong>数值精度</strong>问题体现在：</p><ol type="1"><li>三次方程求解：<ol type="1"><li>不能使用求根公式（误差放大几个数量级） -- 只能用牛顿法求</li><li>何时停止迭代</li></ol></li><li>判断是否碰撞时的误差上界？</li></ol><h5 id="fprf">FPRF</h5><p>最老、最经典的一篇论文</p><blockquote><p>Ref:</p><ol type="1"><li>Collision and self-collision handling in cloth model dedicated todesign garments</li></ol></blockquote><p>思想：解三次方程，解出来的解对应函数值是小于一常数，则判断为碰撞。</p><p>主要问题：</p><ol type="1"><li>FN太多，即有很多碰撞点不被检测到。</li><li>当平行时无法处理 EE 的情况。</li></ol><p>优点：</p><ol type="1"><li>速度</li></ol><h5 id="tightccd">TightCCD</h5><blockquote><p>Ref:</p><ol type="1"><li>TightCCD: Efﬁcient and Robust Continuous Collision Detection usingTight Error Bounds</li></ol></blockquote><p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算，观察的是</p><p><span class="math display">\[Y(0),Y&#39;(0),Y&#39;(1),Y&#39;&#39;(0),Y&#39;&#39;(1)\]</span></p><p><img src="2022-04-14-19-56-39.png" class="lazyload" data-srcset="2022-04-14-19-56-39.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>优点：</p><ol type="1"><li>速度快，准确率也高，几乎是最好的算法</li><li>完全没有检测不出的碰撞</li></ol><p>问题：</p><ol type="1"><li>为了 FN == 0，牺牲了 FP</li><li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li></ol><h5 id="bsc">BSC</h5><blockquote><p>Ref:</p><ol type="1"><li>Fast and exact continuous collision detection with bernstein signclassification</li></ol></blockquote><p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p><p>缺点：</p><ol type="1"><li>False Positive + False Negative</li></ol><blockquote><p>实际上这两个思路和我一开始想的是一致的：</p><p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p><p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p></blockquote><p>原理上：给定一个三次函数 <span class="math inline">\(Y(t)\)</span>用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p><p><img src="image-20220412105920274.png" class="lazyload" data-srcset="image-20220412105920274.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><p>从而通过观察：</p><p><span class="math display">\[Y(0), Y(1/3), Y(2/3), Y(1)\]</span></p><p>（其中 <span class="math inline">\(Y\)</span>即为三次方程对应的函数）的值来减少计算开销并提升精度。</p><h4 id="光线投射-rp-rrp">光线投射 RP / RRP</h4><p>转化为光线投射问题：设 <span class="math inline">\(\partial\Omega\)</span>是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p><p>问题：</p><ol type="1"><li>实际上只能做DCD – 小TS</li><li>容易出现漏报的问题：在 <span class="math inline">\([t,t+\Deltat]\)</span> 内有 2 解</li></ol><p>原理：</p><blockquote><p>根据 Brouwer topological degree theory：</p><p>假设 <span class="math inline">\(\Omega\)</span> 是一个 <spanclass="math inline">\(n\)</span> 多面体，设 <spanclass="math inline">\(F:\Omega \rightarrow \mathbb R^{n}\)</span>满足<spanclass="math inline">\(C^2\)</span>，且有有限多个根，且没有在边界<spanclass="math inline">\(\Gamma=\partial \Omega\)</span>上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <spanclass="math inline">\(0\)</span> 出发，记交点数为 <spanclass="math inline">\(q\)</span> ，<spanclass="math inline">\(F\)</span> 在交点处光滑且不相切于光线，那么 <spanclass="math inline">\(p,q\)</span> 有相同的奇偶性。</p></blockquote><p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p><h3 id="碰撞处理">碰撞处理</h3><blockquote><p>在这里假设在上一步已经获取了碰撞的时刻（TOI）</p><p>Ref:</p><ol type="1"><li>Robust Treatment of Collisions, Contact and Friction for ClothAnimation</li></ol></blockquote><p>根据王老师在GAMES103和2021图形学大会讲的内容（Real-Time ClothSimulation on GPUs），其程序流程如下：</p><figure><img src="image-20220414221444102.png" class="lazyload" data-srcset="image-20220414221444102.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="A Practical System" /><figcaption aria-hidden="true">A Practical System</figcaption></figure><p>前两种方法都是基于如下公式： <span class="math display">\[\mathbf x^{k+1} = \arg\min \|\mathbf x - \mathbf x ^ *\|\]</span> 而Untangle Cloth不基于上式直接进行解除相交问题。</p><h4 id="interior-point-method-内点法">Interior Point Method 内点法</h4><p>思想：添加<spanclass="math inline">\(\log\)</span>边界函数，保持在可行域内，逐步迭代：</p><p>优点</p><ul><li>Always succeed</li></ul><p>缺点：</p><ul><li>可能达到局部最优解</li><li>需要计算所有的顶点来迭代</li><li>小步长 — 速度慢</li></ul><figure><img src="image-20220414221940838.png" class="lazyload" data-srcset="image-20220414221940838.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Interior Point Method" /><figcaption aria-hidden="true">Interior Point Method</figcaption></figure><h4 id="impact-zone-optimization">Impact Zone Optimization</h4><p>思想：直接从 <span class="math inline">\(\mathbf x^*\)</span>开始迭代，逐步逼进可行域，如下图</p><figure><img src="image-20220414222918767.png" class="lazyload" data-srcset="image-20220414222918767.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Impact Zone Optimization" /><figcaption aria-hidden="true">Impact Zone Optimization</figcaption></figure><p>优点：</p><ul><li>很容易得到一个可能的解。</li><li>只需要对不满足约束的点处理</li><li>可以使用大步长</li></ul><p>缺点：</p><ul><li>可能不收敛到可行域内</li></ul><h4 id="相交解除-untangle-cloth">相交解除 — Untangle Cloth</h4><blockquote><p>Ref</p><ol type="1"><li>Untangle Cloth</li><li>Resolving Surface Collisions through Intersection ContourMinimization</li></ol></blockquote><p>当拿到碰撞点后，使用“注水”法，可以直接求出交叉的区域。对于这两个交叉的边界，假设为“紧密贴合”。</p><p>优点：</p><ol type="1"><li>保证在绝大部分情况下能够处理</li></ol><p>缺点：</p><ol type="1"><li>原文中之处理了相交的闭区域，对于边界交叉处理不方便。</li><li>物理上不真实</li><li>难以在GPU上实现</li></ol><h4 id="rigid-impact-zone">Rigid Impact Zone</h4><p>如果上述方法都失败了，那么就考虑使用该方法，其对于不满足要求的点，直接回退到上一模拟步的状态（无相交的状态）。</p></div><h2 id="非接触方法">非接触方法</h2><div class="story post-story"><p>这一类方法都将原有的碰撞条件增强为保持一些点/面之间的距离大于一定值，从而避免CCD 过程。正如zhihu上所说：</p><blockquote><p>之前大家试过很多方法，比如定义物体表面距离很近的“点-三角”对和“边-边”对（接触元对）组成的四面体的有符号体积要恒大于0；或者在每个时间歩开始时，找到距离近的每个接触元对上距离最近的点对，限定这些点对的距离大于0等。这些定义的问题在于，如果物体在某个时间歩移动比较多，他们可能无法正确描述无穿透这件事。另外这类方法大多基于sequentialquadraticprogramming优化方法，没法像无约束条件时的牛顿迭代那样方便地通过linesearch保证稳定收敛。</p><p>By Minchen Li.</p></blockquote><h3 id="ipc">IPC</h3><blockquote><p>Ref:</p><ol type="1"><li>Incremental potential contact: intersection-and inversion-free,large-deformation dynamics</li><li>Medial IPC: accelerated incremental potential contact with medialelastics</li><li>Codimensional incremental potential contact</li><li>BFEMP: Interpenetration-Free MPM-FEM Coupling with BarrierContact</li></ol></blockquote><p>主要思路：迭代的每一步，都把所有 primitive pair 分成两类：</p><ol type="1"><li><span class="math inline">\(0&lt;\min \mathrm{distance} \le \hatd\)</span>：设置 <span class="math inline">\(\log\)</span>-barrier函数，防止直接碰撞</li><li><span class="math inline">\(\min \mathrm{distance} &gt; \hatd\)</span>：设置迭代最大步长，避免距离在迭代路径上碰撞（穿透）</li></ol><p>依据这两个基本假设来避免 CCD。</p><p>首先，其主要处理的是如何<strong>避免连续碰撞检测</strong>，在论文中，其提出：</p><blockquote><p>我们称一个状态是可接受的，当且仅当存在一条可行路径，到达该状态，或以该状态为极限。</p><p>一个迭代路径是可接受的，当且仅当其可以作为上述的极限过程中的状态序列</p></blockquote><p><span class="math display">\[\mathbf x \in \Omega \iff \exists \mathbf x_i \in \Omega.\\lim_{i\rightarrow \infty} = \mathbf x\]</span></p><p>那么，基于以上假设，我们完全可以不去度量是否<strong>产生了</strong>碰撞，而把约束换成</p><p><span class="math display">\[\|\mathbf x - \mathbf x&#39;\| &gt; 0,\quad \forall \mathbf x&#39; \in\partial \Omega\]</span></p><p>这样，我们可以将问题转化为：</p><p><span class="math display">\[\|\mathbf x - \mathbf y\| \ge \epsilon, \forall \mathbf x ,\mathbfy\text{ from different primitives}\]</span></p><p>那么，可以将动力学方程和约束放在一起求解即：</p><p><span class="math display">\[\begin{aligned}\min_{\mathbf x}\quad &amp;F(\mathbf x) + G(\min\mathrm{distance}(\mathbf x))\\\text{s.t.}\quad &amp;\mathbf x \text{ is feasible}\end{aligned}\]</span></p><p>其中：</p><ul><li><span class="math inline">\(F\)</span> 为动力学方程中的能量</li><li><span class="math inline">\(G\)</span> 为障碍函数</li></ul><p>这是一个几乎没有约束的优化问题：因为原来的碰撞处理的全套流程转化为在迭代求解过程中，保证迭代路径是可接受的！</p><p>具体而言，Log函数为了避免在不充分接近时也出现“抵抗力”，其在保证<spanclass="math inline">\(C^2\)</span>的情况下，构造了如下的“log-barrier”：</p><p><img src="2022-04-15-08-56-06.png" class="lazyload" data-srcset="2022-04-15-08-56-06.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p><blockquote><p>该方法可以看作是一个“内点法”</p></blockquote><h4 id="如何计算-距离">如何计算 “距离”</h4><p>IPC方法中并不限于三角网格等具体的空间结构，因此距离的计算并不需要依赖于物体表示的维数。基本思路是通过重心坐标构造两个primitive 上的点<span class="math inline">\(\mathbf x\)</span>和<spanclass="math inline">\(\mathbf y\)</span>，从而计算</p><p><span class="math display">\[d(\mathbf x, \mathbf y) = \min \|\mathbf x - \mathbf y\|\]</span></p><p>来得到距离。</p><h4 id="constraint-set">Constraint Set</h4><p>通过 Spatial Hashing 算法来加速 Constraint Set 计算，定义为：</p><p><span class="math display">\[\{\langle i , j \rangle | d(\mathbf x_i, \mathbf x_j) \le \hat d \}\]</span></p><h4 id="迭代过程中如何保证约束">迭代过程中如何保证约束</h4><p>算法使用 Intersection-AwareLine-Search（回溯线搜索）来进行迭代。并且在每次执行搜索之前，重新计算Constraint Set。而观察到对于：</p><ol type="1"><li>Constraint Set中的元素对：一定出现在优化的能量函数中，通过barrier函数避免碰撞</li><li>不在其中的元素对：初始距离<span class="math inline">\(&gt;\hatd\)</span></li></ol><p>从而可以通过 <span class="math inline">\(\hat d\)</span>指导迭代的最大步长。</p><p>从而将原本难以解决的CCD问题避免。</p><h4 id="总结">总结</h4><p>优点：</p><ol type="1"><li>不需要繁琐的 CCD -- 速度、精度都有保证</li><li>嵌入到 Dynamic Solver 迭代过程中</li><li>容易在GPU上实现</li></ol><p>缺点：</p><ol type="1"><li>非接触方法，摩擦难以解决</li></ol><h3 id="siggraph-2021----repulsion-method">SIGGRAPH 2021 -- RepulsionMethod</h3><blockquote><p>Ref:</p><ol type="1"><li>A Safe and Fast Repulsion Method for GPU-based Cloth SelfCollisions</li></ol></blockquote><p>思路：找到使不产生VT/EE碰撞的充分条件，且该充分条件仅需要考虑顶点之间的距离，而和三角网格无关。</p><p><span class="math display">\[\min d(\mathbf v_i, \mathbf v_j) \ge \hat d = L / 2\]</span></p><p>其中<span class="math inline">\(L\)</span>为三角网格的最大边长。</p><p>求解过程分为两部分：</p><ol type="1"><li>Soft-Phase</li><li>Hard-Phase</li></ol><p>并且为了避免约束过强，使用了自适应的重采样方法。</p><h4 id="soft-phase">Soft-Phase</h4><p><span class="math display">\[\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm{init}} \| − \rho \min \left\{c_{ij} (\mathbf x) − \varepsilon_{slack} ,0  \right\}\right\}\]</span></p><h4 id="hard-phase">Hard-Phase</h4><p><span class="math display">\[\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm{init}} \| − \mu \sum {\log (f(c_{ij}(x), \varepsilon_{slack}))}\right\}\]</span></p><p>其中的 <span class="math inline">\(f\)</span> 是满足 <spanclass="math inline">\(C^1\)</span> 的分段函数：</p><p><span class="math display">\[f = \begin{cases}   x &amp; x\le 0\\   ax^3 + bx^2 + cx + d &amp; 0 &lt;x \le \varepsilon\\   \varepsilon&amp; \text{otherwise}\end{cases}\]</span></p><h4 id="adaptive-resampling">Adaptive Resampling</h4><p>由于要求所有距离大于 <span class="math inline">\(L /2\)</span>，为了使得这个条件不是过于充分的，要求最小边长和最大边长<spanclass="math inline">\(l\)</span>与<spanclass="math inline">\(L\)</span>的比例大于一定值。</p><p><img src="2022-04-15-11-19-43.png" class="lazyload" data-srcset="2022-04-15-11-19-43.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测 学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 5 - 2021 A large scale benchmark and an Inclusion-based Algorithm</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/ContactDetection/Benchmark/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:32.603Z</updated>
    
    <content type="html"><![CDATA[<p>Collision Detection 整理5 – CCD 算法对比</p><span id="more"></span><p>准确说，这篇blog是一篇论文的整理emmm，但由于老板的任务就是做 collsion的汇总，这篇论文的涉及面也算是相对 Broad 的了。</p><p>论文主要用了：</p><ol type="1"><li>IRF：interval-root-finder</li><li>UIRF：Unifromed-Interval-Root-Finder</li><li>FPRF：floating-point time-of-impact root finder</li><li>TightCCD(TCCD)</li><li>Root Parity(RP)</li><li>Rational implementation of RP</li><li>MSRF：minimum seperation floating-point time-of-impact rootfinder</li></ol><h2 id="预备知识">预备知识</h2><div class="story post-story"><p>首先论文对于 CCD的数学背景进行了简要的介绍：考虑三角网格，每一个时间步长内都以线性轨迹运动。那么CCD可以简化为VT和EE检查。</p><h3 id="multivariate-ccd-formulation">Multivariate CCD Formulation</h3><p>最简单的方法是直接对于CCD条件参数化，转化为关于 <spanclass="math inline">\(u,v,t\)</span> 的方程求解即可。</p><h3 id="univariate-ccd-单变量ccd">Univariate CCD 单变量CCD</h3><p>实际上上面一种求解方法一步到位解出了 <spanclass="math inline">\(u,v,t\)</span>但没有注意到在接触时，四点共面的事实，所以，在[Provot 97]中，改为先求解三次方程，然后检查是否满足条件的问题</p></div><h2 id="方法介绍">方法介绍</h2><div class="story post-story"><h3 id="irf">IRF</h3><p>类似于计算 Minkowski差，逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p><p>优点：</p><ol type="1"><li>保守估计，每一步都保证包含 <spanclass="math inline">\(0\)</span>，所以能够确保检查到碰撞</li><li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li></ol><p>缺点：</p><ol type="1"><li>基于二分查找 — 慢</li><li>难以实施编译优化</li></ol><h3 id="uirf">UIRF</h3><p>差不多的思路，但是是用二分法求的是单变量的方程根。</p><blockquote><p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p><p>与此同时，它不能满足控制求解器的运行精度</p></blockquote><h3 id="fprf">FPRF</h3><blockquote><p>Robust treatment of simultaneous collisions.</p></blockquote><p>主要问题：</p><ol type="1"><li>FN太多，即有很多碰撞点不被检测到。</li><li>当平行时无法处理 EE 的情况。</li></ol><p>优点：</p><ol type="1"><li>速度</li></ol><h3 id="tightccd">TightCCD</h3><p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算。</p><p>优点：</p><ol type="1"><li>速度快</li><li>完全没有检测不出的点</li></ol><p>问题：</p><ol type="1"><li>为了 FN == 0，牺牲了 FP</li><li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li></ol><h3 id="rp-rrp">RP / RRP</h3><p>转化为光线投射问题：设 <span class="math inline">\(\partial\Omega\)</span>是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p><p>问题：</p><ol type="1"><li>实际上只能做DCD – 小TS</li><li>容易出现漏报的问题：在 <span class="math inline">\([t,t+\Deltat]\)</span> 内有 2 解</li></ol><p>原理：</p><blockquote><p>根据 Brouwer topological degree theory：</p><p>假设 <span class="math inline">\(\Omega\)</span> 是一个 <spanclass="math inline">\(n\)</span> 多面体，设 <spanclass="math inline">\(F:\Omega \rarr \mathbb R^{n}\)</span>满足 <spanclass="math inline">\(C^2\)</span>，且有有限多个根，且没有在边界<spanclass="math inline">\(\Gamma=\partial \Omega\)</span>上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <spanclass="math inline">\(0\)</span> 出发，记交点数为 <spanclass="math inline">\(q\)</span> ，<spanclass="math inline">\(F\)</span> 在交点处光滑且不相切于光线，那么 <spanclass="math inline">\(p,q\)</span> 有相同的奇偶性。</p></blockquote><p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p><h3 id="bsc">BSC</h3><blockquote><p>Fast and exact continuous collision detection with bernstein signclassification</p></blockquote><p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p><p>缺点：</p><ol type="1"><li>False Positive + False Negative</li></ol><blockquote><p>实际上这个思路和我一开始想的是几乎一致的：</p><p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p><p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p></blockquote><p>原理上：给定一个三次函数 <span class="math inline">\(Y(t)\)</span>用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p><p><img src="image-20220412105920274.png" class="lazyload" data-srcset="image-20220412105920274.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p></div><h2 id="其他思路">其他思路</h2><div class="story post-story"><h3 id="bridson-2009">Bridson 2009</h3><p>添加一个时间维度，通过在四维空间中的相交检测来实现碰撞检测。</p><p>问题：</p><ol type="1"><li>不直观、不常用</li><li>导致了 FP 的出现 — 平行的两个三角形认定为碰撞。</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Collision Detection 整理5 – CCD 算法对比&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>201-02-拉格朗日视角1</title>
    <link href="http://adversarr.github.io/2022/04/11/CG/GAMES/g201-02/"/>
    <id>http://adversarr.github.io/2022/04/11/CG/GAMES/g201-02/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-13T05:59:19.797Z</updated>
    
    <content type="html"><![CDATA[<p>games201 拉格朗日视角</p><span id="more"></span><h2 id="拉格朗日视角简介">拉格朗日视角简介</h2><div class="story post-story"><p>两种视角：</p><ol type="1"><li>拉格朗日视角 – 粒子，携带位置、速度等<ol type="1"><li>MPM、弹簧质点模型……</li></ol></li><li>欧拉视角 – 通过固定的“传感器”来表示<ol type="1"><li>烟雾模拟</li></ol></li></ol><h2 id="弹簧质点模型-mass-spring-system">弹簧质点模型 Mass-SpringSystem</h2><ul><li>Extremely example</li><li>But very useful. – cloth/hair</li></ul><h3 id="基本原理">基本原理</h3><p>利用 <strong>胡克定律</strong> 和 <strong>牛顿第二定律</strong>来计算 加速度-速度-位置</p><ul><li><span class="math inline">\(k\)</span> — stiffness — 刚度</li></ul><h3 id="时间积分">时间积分</h3><h4 id="forward-euler-前向欧啦">Forward Euler 前向欧啦</h4><p><span class="math display">\[v_{t+1} = v_t + \frac{f_t}{m}\Delta t\]</span></p><h4 id="半隐式欧拉法">半隐式欧拉法</h4><p>用 <span class="math inline">\(t+1\)</span> 时刻的 <spanclass="math inline">\(v\)</span> 计算 <spanclass="math inline">\(x\)</span> 的更新。</p><h4 id="implementation">Implementation</h4><ul><li>使用 substep — 保证小步长</li></ul><h3 id="积分器对比">积分器对比</h3><blockquote><p><strong>数值分析</strong></p></blockquote><h4 id="显式积分器">显式积分器</h4><ol type="1"><li>未来仅仅基于过去</li><li>简单</li><li>容易出现数值爆炸问题 — 前向欧拉</li><li>对于 <span class="math inline">\(stiff \gg 1\)</span>效果很差。</li></ol><h4 id="隐式积分器">隐式积分器</h4><ol type="1"><li>未来需要基于自己和过去</li><li>复杂！难以实现、难以优化、GPU……</li><li>Timestep 更大，但是计算更加昂贵</li><li>Numerical damping</li></ol><h3 id="弹簧质点的隐式积分器">弹簧质点的隐式积分器</h3><p>假设： <span class="math display">\[\begin{cases}\mathbf x_{t+1} = \mathbf x_t + \Delta t \mathbf v_{t+1}\\\mathbf v_{t+1} = \mathbf v_t + \Delta t \mathbf M ^{-1}\mathbf f_{t+1}\end{cases}\]</span> 在上式中消除 <span class="math inline">\(\mathbfx_{t+1}\)</span>，使用泰勒公式： <span class="math display">\[\left[I - \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbf f}{\partial\mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbf v_t + \Delta t\mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span> 在这一节课中，仅仅使用 Jacobbi 迭代解上述方程。</p><h3 id="在显式和隐式之间转换">在显式和隐式之间转换</h3><p><span class="math display">\[\left[I - \beta \Delta t^2 \mathbf M^{-1} \frac{\partial \mathbff}{\partial \mathbf x} (\mathbf x_t)\right] \mathbf v_{t+1} = \mathbfv_t + \Delta t \mathbf M^{-1} \mathbf f(\mathbf x_t)\]</span></p><p>其中 <span class="math inline">\(\beta\)</span>控制了在显式、隐式之间的“比例”</p><ul><li><span class="math inline">\(\beta = 1\)</span> — Explicit</li><li><span class="math inline">\(\beta = .5\)</span> — Semi-Implicit</li><li><span class="math inline">\(\beta = 0\)</span> — Implicit</li></ul><h3 id="大规模情况">大规模情况</h3><ol type="1"><li>稀疏矩阵</li><li>共轭梯度法</li><li>Preconditioning</li><li>PBD</li></ol></div><h2 id="拉格朗日法流体模拟-sph">拉格朗日法流体模拟 — SPH</h2><div class="story post-story"><p>用一些粒子（并附带物理量）以及一个核函数去模拟一个物理场。</p><p>优点：</p><ol type="1"><li>不需要 Mesh、适合自由表面物体</li><li>容易理解</li></ol><h3 id="wcsph">WCSPH</h3><blockquote><p>可压缩物体模拟</p></blockquote><p>Momentum Equation: <span class="math display">\[\frac{D\mathbf v}{D t} = - 1/\rho \nabla p + \mathbf g,\quad p =B\left(\left( \frac{\rho}{\rho_0}\right)^\gamma - 1\right)\]</span></p><ol type="1"><li>表面张力、粘滞力</li></ol><h3 id="sph-simulation-cycle">SPH simulation Cycle</h3><p>通过半隐式欧拉法计算</p><h3 id="sph-变种">SPH 变种</h3><h3 id="cfl条件">CFL条件</h3><p>对于显式积分，<span class="math inline">\(dt\)</span> 具有上界：<span class="math display">\[C = \frac{u\Delta t}{\Delta x} \le C_\max \sim ~\]</span></p><ol type="1"><li><span class="math inline">\(C\)</span>: CFL number</li></ol><p>Application</p><ol type="1"><li>SPH: <span class="math inline">\(C_\max\sim 0.4\)</span></li><li>MPM:<span class="math inline">\(C_\max -0.3\sim1\)</span></li></ol><h3 id="加速-sph">加速 SPH</h3><p>通过 Neighbour search with hashing（空间数据结构）</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;games201 拉格朗日视角&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>libigl 简述</title>
    <link href="http://adversarr.github.io/2022/04/10/CG/Libigl/"/>
    <id>http://adversarr.github.io/2022/04/10/CG/Libigl/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-12T12:42:19.081Z</updated>
    
    <content type="html"><![CDATA[<p>TODO: Libigl 教程（翻译和解释）</p><p>现挖个坑，后面补上。 <span id="more"></span></p><h1 id="libigl-tutorial">libigl Tutorial</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;TODO: Libigl 教程（翻译和解释）&lt;/p&gt;
&lt;p&gt;现挖个坑，后面补上。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>102-08-离散微分几何</title>
    <link href="http://adversarr.github.io/2022/04/09/CG/GAMES/g102-08/"/>
    <id>http://adversarr.github.io/2022/04/09/CG/GAMES/g102-08/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-04-13T05:59:16.345Z</updated>
    
    <content type="html"><![CDATA[<p>Games 102 - 离散微分几何</p><span id="more"></span><h2 id="三角网格存储">三角网格存储</h2><div class="story post-story"><p>常用的是<strong>半边数据结构</strong>（Half-Edge）数据结构</p><ul><li>将网络连接关系存储在边上，表达为两条半边</li><li>目的：提高点线面和查找效率</li></ul></div><h2 id="曲线曲面微分几何">曲线、曲面微分几何</h2><div class="story post-story"><h3 id="曲线的微分几何学">曲线的微分几何学</h3><ul><li><p>Frenet标架</p></li><li><p>Curvature <span class="math inline">\(\kappa\)</span> 和密切圆</p></li><li><p>与参数选择无关 — 本征量</p></li></ul><h3 id="曲面的微分几何学">曲面的微分几何学</h3><ul><li>关于 <span class="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 的偏导 — 切平面</li><li>切平面的法向 — <span class="math inline">\(r_u\timesr_v\)</span></li><li>法平面和曲面求交线，可以定义出一个空间曲线，可以定义其曲率 –方向曲率（法曲率）— 描述曲面沿着方向的弯曲程度</li></ul><h3 id="曲面的曲率">曲面的曲率</h3><p>观察法曲率：</p><ol type="1"><li>有两个正交的方向，使得其能够取最大 <spanclass="math inline">\(\kappa_1\)</span> 和最小<spanclass="math inline">\(\kappa_2\)</span></li></ol><p>有 Euler's Equation 成立： <span class="math display">\[\kappa = \kappa_1 \cos^2\theta +  \kappa_2 \sin^2\theta\]</span> 高斯曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \kappa_1\kappa_2\)</span></li><li><strong>等距变换的不变量</strong></li><li>处处为 0 的曲面 — 可展曲面</li><li><strong>可展曲面</strong>可以分类为：<ul><li>柱面</li><li>锥面</li><li>切线面</li></ul></li></ol><p>平均曲率：</p><ol type="1"><li><span class="math inline">\(\kappa = \frac {\kappa_1 +\kappa_2}{2}\)</span></li><li>处处平均曲率为 0 的曲面 — 极小曲面 — 所有点都是鞍点</li></ol></div><h2 id="离散微分几何">离散微分几何</h2><div class="story post-story"><p>考虑到三角网格只有 <span class="math inline">\(C^0\)</span>，使用采样的点来估计原有曲面属性。</p><h3 id="方法">方法</h3><h4 id="连续逼近">连续逼近</h4><p>考虑使用一个简单的曲面来拟合曲面的局部。从而就能计算出</p><h4 id="离散估计">离散估计</h4><p>用面积/角度等特征来进行计算</p><h3 id="例子">例子</h3><h4 id="平均曲率计算">平均曲率计算</h4><p>由 Laplace-Beltrami 定理： <span class="math display">\[\mathbf K (\mathbf x_i) = \frac{1}{2\mathcal A_M} \sum_{j\in N_1(i)}(\cot \alpha_{ij}+ \cot \beta_{ij})(\mathbf x_i - \mathbf x_j)\]</span></p><h4 id="高斯曲率计算">高斯曲率计算</h4><p>由 Gauss-Bonnet 定理： <span class="math display">\[\kappa(\mathbf x_i) = (2\pi - \sum_{j = 1}^{\#f} \theta_j) / \mathcalA_M\]</span></p><blockquote><p>Discrete differential-geometry operators for trangulated 2-manifolds.– 2003</p></blockquote><h3 id="极小曲面">极小曲面</h3></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Games 102 - 离散微分几何&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="GAMES 在线课" scheme="http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的微分几何整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/DiffGeometry/</id>
    <published>2022-03-28T03:44:29.465Z</published>
    <updated>2022-04-19T09:30:53.580Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p><h2 id="测地曲率和测地线">测地曲率和测地线</h2><div class="story post-story"><p>根据 Gauss 绝妙定理，<span class="math inline">\(K\)</span>只决定于曲面的第一基本形式，在保长对应下不变，是曲面的内蕴性质。在这里继续研究曲面内蕴几何的主要研究对象。</p><h3 id="测地曲率和测地线-1">测地曲率和测地线</h3><p>我们考虑正则曲面<span class="math inline">\(S:\mathbf r = \mathbfr(u^1, u^2)\)</span>，设有曲线<span class="math inline">\(u^\alpha =u^\alpha (s)\)</span> 是一条弧长参数曲线。其作为空间中的曲线参数方程为：<span class="math display">\[\mathbf r = \mathbf r(s) = \mathbf r (u^1, u^2)\]</span> 建立新的正交标架： <span class="math display">\[\begin{aligned}\mathbf e_1  &amp;= \frac {d\mathbf r(s)}{ds} = \alpha(s)\\\mathbf e_2 &amp;= \mathbf n(s)\times \alpha(s) \\\mathbf  e_3 &amp;= \mathbf n(s)\end{aligned}\]</span> 对于该曲线来考察原曲面的性质： <span class="math display">\[\begin{cases}\frac{d\mathbf r}{ds} &amp;= \mathbf e_1&amp;\\\frac{d\mathbf e_1}{ds} &amp;= &amp; +\kappa _g\mathbf e_2 &amp; +\kappa_n\mathbf e_3\\\frac{d\mathbf e_2}{ds} &amp;= -\kappa_g\mathbf e_1 &amp;&amp;+\tau_g\mathbf e_3 \\\frac{d\mathbf e_3}{ds} &amp;= -\kappa_n \mathbf e_1 &amp; +\tau_g\mathbf e_2\\\end{cases}\]</span> 显然，式中的：</p><ul><li><span class="math inline">\(\kappa_n\)</span> 就是曲面<spanclass="math inline">\(S\)</span>沿着曲线<spanclass="math inline">\(C\)</span>的切方向的法曲率；</li></ul><p>而也可以求解出其他的参数： <span class="math display">\[\kappa_g = \left( \mathbf n, \mathbf r&#39;, \mathbf r&#39;&#39; \right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地曲率</strong>； <span class="math display">\[\tau_g = \left( \mathbf n, \mathbf n&#39;,\mathbf r&#39;\right)\]</span> 是曲面上曲线 <span class="math inline">\(C\)</span>的<strong>测地挠率</strong>。</p><p>下面的定理描述了测地曲率和测地挠率的几何意义：</p><dl><dt><strong>Theo</strong></dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条正则曲线，其在 <spanclass="math inline">\(p\)</span>处的测地曲率等于将其投影到切平面上的曲线的相对曲率，其平面的正向由曲面<span class="math inline">\(S\)</span> 在点 <spanclass="math inline">\(p\)</span> 的法向量给出。</dd><dt><strong>Theo</strong></dt><dd>曲面<span class="math inline">\(S\)</span>上任一条曲线<spanclass="math inline">\(C\)</span>的测地曲率是保长对应的不变量，即：<strong>测地曲率是内蕴量</strong>。</dd></dl><p>在取正交参数系的情况下，计算测地曲率有如下的<strong>Liouville公式</strong>：</p><dl><dt><strong>Theo</strong></dt><dd>设<span class="math inline">\((u,v)\)</span>是<spanclass="math inline">\(S\)</span>上的正交参数系，从而<spanclass="math inline">\(S\)</span>的第一基本形式为 <spanclass="math display">\[I = E(du)^2 + G(dv)^2\]</span> 假设<span class="math inline">\(C\)</span>与<spanclass="math inline">\(u\)</span>曲线的夹角为<spanclass="math inline">\(\theta\)</span>，那么其测地曲率是 <spanclass="math display">\[\kappa_g = \frac{d\theta}{ds} - \frac{1}{2\sqrt G} \frac{\partial \logE}{\partial v} \cos \theta + \frac{1}{2\sqrt E} \frac{\partial \logG}{\partial u}\sin \theta\]</span></dd></dl><p>最后我们讨论测地挠率，从自然标架的运动公式可以得出： <spanclass="math display">\[\tau _ g = \frac{1} {\sqrt g}\begin{vmatrix}&amp;\left(\frac{du^2}{ds} \right)^2 &amp; - \frac{du^1du^2}{dsds} &amp;\left(\frac{du^1}{ds} \right)^2 \\&amp;g_{11} &amp;g_{12} &amp; g_{22}\\&amp;b_{11} &amp;b_{22} &amp; b_{22}\end{vmatrix}\]</span> 故测地挠率和测地曲率一样，是<spanclass="math inline">\(S\)</span>上切方向的函数，反映的是曲面<spanclass="math inline">\(S\)</span>本身的性质，但其不是内蕴量。</p><p>对比主方向的方程，主方向恰好是测地挠率为 0的切方向。同时也有如下定理成立：</p><dl><dt>Theo</dt><dd>在曲面上非直线的渐进曲线<span class="math inline">\(C\)</span>的挠率是<span class="math inline">\(S\)</span>沿着曲面<spanclass="math inline">\(C\)</span>的切方向的测地挠率。</dd></dl><h3 id="测地线">测地线</h3><p>观察到测地曲率是内蕴量，从而要观察曲面上测地曲率为 0的曲线（测地线）</p><dl><dt>Theo</dt><dd>曲面上曲线<spanclass="math inline">\(C\)</span>是测地线，当且仅当，它或是一条直线，或者其主法向量处处是曲面的法向量</dd></dl><blockquote><p>例如：</p><ol type="1"><li>旋转面上的经线是测地线</li><li>若曲面上运动的质点 <span class="math inline">\(p\)</span>只受到将它约束在曲面上的力的作用，而不受到任何其他外力作用，则<spanclass="math inline">\(p\)</span>的轨迹是测地线</li></ol></blockquote><dl><dt>Theo</dt><dd>对于曲面上任意一点<span class="math inline">\(p\)</span>和曲面在<spanclass="math inline">\(p\)</span>的任意单位切向量<spanclass="math inline">\(v\)</span>，在曲面上存在唯一的一条弧长参数测地线通过<spanclass="math inline">\(p\)</span>且以<spanclass="math inline">\(v\)</span>为切向量</dd></dl><blockquote><p>平面 – 直线</p><p>曲面 – 测地线</p></blockquote><dl><dt>Theo</dt><dd>设 <span class="math inline">\(C\)</span> 是曲面 <spanclass="math inline">\(S\)</span> 上的一条曲线，则<spanclass="math inline">\(C\)</span>的弧长在任意一个有固定端点的变分<spanclass="math inline">\(C_t\)</span>中达到临界值的充分必要条件是<spanclass="math inline">\(C\)</span>是<spanclass="math inline">\(S\)</span>的测地线。</dd></dl><p>从而我们有：若曲线<span class="math inline">\(C\)</span>是连接<spanclass="math inline">\(p,q\)</span>的最短线，则<spanclass="math inline">\(C\)</span>是测地线。</p><h3 id="测地坐标系和法坐标系">测地坐标系和法坐标系</h3><h4 id="测地线族">测地线族</h4><p>在研究了测地线的性质后，我们研究测地线族的性质。</p><dl><dt>Theo</dt><dd>设<span class="math inline">\(\Sigma\)</span>是曲面<spanclass="math inline">\(S\)</span>上覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族，<spanclass="math inline">\(\Sigma_1\)</span>是由在区域<spanclass="math inline">\(D\)</span>内与<spanclass="math inline">\(\Sigma\)</span>中的曲线正交的轨线构成的曲线组，则其中任意两条曲线在<spanclass="math inline">\(\Sigma\)</span>中各条测地线上截出的曲线段长度相等。</dd></dl><blockquote><p>也就是说，测地线族的任意两条正交轨线之间的距离是处处相等的。</p><p>即：测地线族的任意两条正交轨线是<strong>测地平行</strong>的</p></blockquote><dl><dt>Theo</dt><dd>设<span class="math inline">\(C\)</span>是曲面<spanclass="math inline">\(S\)</span>上连接了<spanclass="math inline">\(p,q\)</span>两点的一条测地线，若曲线<spanclass="math inline">\(C\)</span>能够潜入到覆盖了区域<spanclass="math inline">\(D\)</span>的测地线族<spanclass="math inline">\(\Sigma\)</span>中，且<spanclass="math inline">\(p,q\in D\)</span>，则其是区域内连接两点的最短线</dd></dl><h4 id="测地平行坐标系">测地平行坐标系</h4><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点<spanclass="math inline">\(p\)</span>的一个充分小的邻域内必定存在参数系<spanclass="math inline">\((u,v)\)</span>使得<spanclass="math inline">\(p\rightarrow (0,0)\)</span>，而第一基本形式可以写作 <span class="math display">\[I = (du)^2 + G(u,v) (dv)^2\]</span> 函数 <span class="math inline">\(G\)</span> 满足：$G(0, v)=1<span class="math inline">\(，\)</span>(0, v) =0<spanclass="math inline">\(，参数系\)</span>(u,v)$是<strong>测地平行坐标系</strong></dd></dl><h4 id="测地极坐标系">测地极坐标系</h4><p>定义指数映射： <span class="math display">\[\exp_p : T_pS \rightarrow S\quad \mathbf v\rightarrowtail\gamma(|\mathbf v|, \mathbf v_0)\]</span> <span class="math inline">\(\gamma\)</span>对于点<spanclass="math inline">\(p\)</span>处的单位切向量<spanclass="math inline">\(\mathbfv_0\)</span>，映射为弧长参数测地线上的参数为<spanclass="math inline">\(s\)</span>的位置。</p><p>显然指数映射 <span class="math inline">\(\exp_p\)</span>是连续可微的。于是有 <strong>法坐标系</strong>： <spanclass="math display">\[u^\alpha = u ^ \alpha(\exp_p(\mathbf v)) = u ^ \alpha(v^1, v^2)\]</span> 从而有<strong>测地圆</strong>（以<spanclass="math inline">\(p\)</span>为中心，<spanclass="math inline">\(s_0\)</span>为半径）</p><dl><dt>Theo 高斯引理</dt><dd>从<span class="math inline">\(p\)</span>出发的测地线与以点<spanclass="math inline">\(p\)</span>为中心的测地圆是彼此正交的。（即曲线族<spanclass="math inline">\(\Sigma_1\)</span>中的每一条曲线都是测地线族<spanclass="math inline">\(\Sigma\)</span>的正交轨线。</dd></dl><p>由此可以推导出测地极坐标系 <spanclass="math inline">\(（s,\theta)\)</span></p><dl><dt>Theo</dt><dd>在曲面<span class="math inline">\(S\)</span>的每一点的<spanclass="math inline">\(p\)</span>邻域内，出去从点<spanclass="math inline">\(p\)</span>出发的一条测地线外，也存在测地极坐标系，使得曲面第一形式为<span class="math display">\[I = (ds)^2 + G(d\theta)^2\quad \begin{cases}\lim _{s\rightarrow 0} \sqrt G = 0\\\lim_{s\rightarrow 0} \frac{\partial }{\partial S} \sqrt{G(s,\theta)} =1\end{cases}\]</span> 对应了平面上的极坐标系</dd></dl><h3 id="常曲率曲面">常曲率曲面</h3><p>高斯曲率为常数的曲面为<strong>常曲率曲面</strong>。</p><p>由于高斯曲率为内蕴量，我们不难考虑如下的定理：</p><dl><dt>Theo</dt><dd>有相同高斯曲率的任意两块常曲率曲面在局部上有保长对应。</dd></dl><blockquote><p>从现在的观点来看：</p><ol type="1"><li>常曲率曲面的第一基本形式是由其高斯曲率完全决定的</li><li>非欧几何学：将平面几何学推广到常曲率曲面</li></ol></blockquote><h3 id="平行移动">平行移动</h3><blockquote><p>考虑切向量场的协变微分和平行移动</p></blockquote><h3 id="gauss-bonnet公式">Gauss-Bonnet公式</h3><p>假定曲线是邮箱曲面上的一条分段光滑简单闭曲线，其包围的区域是曲面<span class="math inline">\(S\)</span> 的一个单连通区域，则 <spanclass="math display">\[\oint _C. \kappa _ g \mathrm d s + \iint _D K \mathrm d \sigma = 2 \pi -\sum _ {i = 1} ^ n \alpha _ i\]</span></p><ul><li><span class="math inline">\(\kappa_g\)</span>是曲线的测地曲率，</li><li><span class="math inline">\(K\)</span> 是曲面的高斯曲率</li><li>$_ i $ 表示曲线在角点<spanclass="math inline">\(i\)</span>的外角</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="微分几何" scheme="http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 2 - Broad Phase 阶段</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/BroadPhase/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T16:05:28.166Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几种在各类代码库中应用的 Broad Phase 算法</p><span id="more"></span><blockquote><p>来源包括但不限于：</p><ol type="1"><li>Unity</li><li>UE</li><li>Nvidia</li><li>PhyX</li><li>各大博客</li><li>论文</li></ol></blockquote><h2 id="broad-phase-algorithms">Broad Phase Algorithms</h2><div class="story post-story"><p>根据 Nvidia-GPU Gems 3<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>的描述，BroadPhase最主要的还是依靠一些最基础的<code>观察</code>来降低时间复杂度。主要的算法有：</p><ol type="1"><li><code>Sort and Sweep</code>：按Axis排序，然后扫描分段，认为每一个在Axis上相邻的即可能会相交。</li><li><code>Spatial Subdivision</code>：空间细分算法。可以有两种主要的形式，包括固定空间划分（每个格子尺寸一致）</li><li><code>BVH</code>（层次包围盒 –AABB/k-DOP/OBB，更基础的还有oct-tree这些数据结构）算法。实际上固定的空间划分算法和SortAnd Sweep可以互相转化。</li></ol><blockquote><p>不考虑并行的情况下，固定的空间划分算法是明显慢的。但考虑到SpatialSubdivision可以在GPU上运行，实际上这类算法也很常用。</p></blockquote><p>在实际的游戏引擎中，为了达到实时的要求，使用的算法也相对简单：</p><ol type="1"><li><code>Sweep-based</code>：考察物体运动所划过的面积，是否相互接触。计算TOI（impact产生时刻），然后重新计算。 — 会增加 CPU的负载、角速度大时会产生误差。</li><li><code>Speculative CCD</code>：计算运动过程中的AABB，然后对于覆盖到的物体进行针对性检查。– maybe cheaper，但是会出现误检为collision 的问题。</li></ol><p>其次，对于每一个物体，其也可能有针对性的优化措施，例如在UnrealEngine中，每一个物体的碰撞处理可以设置为不同的细度，从而获取不同的效果。同时其也对于输入的物体Mesh/Obj进行</p><ol type="1"><li>凸包变换（V-HACD<a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>），并使用适用于凸包的 CollisionDetect 来进行碰撞的判断</li><li>设置 k-DOP</li></ol><p>无一例外，这些算法都是BVH的变体。</p><p>其他的，例如 PhysX中，碰撞检测还可以通过光线投射（<code>Raycast</code>）算法计算得出。</p><ul><li>对于高速物体–低速物体的情形，可以考虑在每一次计算得到无碰撞位移后，通过Raycast算法得出运动路径上是否与其余物体有碰撞产生。</li></ul><blockquote><p><strong>Overview of Collision in PhysX</strong></p><ul><li>Broadphase<ul><li>AABB vs AABB, 3 axis sweep and prune</li></ul></li><li>Midphase<ul><li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABBtree</li></ul></li></ul><p>对于 Narrow Phase：</p><ul><li><p>流体-SPH Fluids (CCD)</p><ul><li>Particles vs static triangle mesh • Particles vs dynamicprimitives</li></ul></li><li><p>布料-Cloth (CCD)</p><ul><li>Vertices vs static triangle mesh • Vertices vs dynamicprimitives</li></ul></li><li><p>刚体-Rigid body (Discrete) – GJK or SAT</p><ul><li><p>Convex mesh and primitives vs static triangle mesh</p></li><li><p>Convex, primitives vs Convex, primitives</p></li></ul></li></ul></blockquote><figure><imgsrc="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/32fig01.jpg"alt="Nvidia- Sort and sweep" /><figcaption aria-hidden="true">Nvidia- Sort and sweep</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD1.gif"alt="Sweep Method 的角速度过大，导致CCD失败" /><figcaption aria-hidden="true">Sweep Method的角速度过大，导致CCD失败</figcaption></figure><figure><img src="https://docs.unity3d.com/uploads/Main/SpeculativeCCD2.png"alt="speculative ccd" /><figcaption aria-hidden="true">speculative ccd</figcaption></figure><p>考虑两种情形：</p><ol type="1"><li>只有 Rigid Body：不可能产生自交问题，这样子的话</li><li>Rigid +Deformed：Rigid肯定不会自交，但是Deformed物体可能存在自交问题、Rigid-Deformed之间可能产生相交</li></ol><p>BVH 和 Spatial Hashing 来实现</p><hr /><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"role="doc-endnote"><p>https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>https://github.com/kmammou/v-hacd<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍几种在各类代码库中应用的 Broad Phase 算法&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 4 - Deformed Object</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/Deformed/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/Deformed/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-10T06:39:13.320Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测 4 - Deformed Object</p><span id="more"></span><h2 id="初">90-00初</h2><div class="story post-story"><p>变形体和三角网格的处理的经典论文是：</p><ol type="1"><li>[Bridson02] Robust Treatment of Collisions, Contact and Friction forCloth Animation</li><li>[Provet97] Collision and self-collision handling in cloth modeldedicated to design garments</li></ol><p>其中这两篇论文几乎可以说是篇篇论文都在引了。其主要的思想在于</p><h3 id="provet-97">Provet 97</h3><h4 id="简介">简介</h4><p>这篇论文之所以重要，是因为其提出了三角网格产生碰撞一个充分必要条件：对于三角网格而言，其产生碰撞，当且仅当，存在</p><ol type="1"><li>Vertical - Triangle （原文 Point Triangle collision）碰撞</li><li>Edge - Edge 碰撞</li></ol><p>之一（或兼有）</p><p>显然的是，两个碰撞都导致了<strong>四点共面</strong>的情况。根据空间几何的知识，<spanclass="math inline">\(\mathbf x_{1}\cdots\mathbf x_4\)</span>共面，当且仅当： <span class="math display">\[(\mathbf x_{12}\quad \mathbf x_{13} \quad \mathbf x_{14}) = 0\]</span> 其中 <span class="math inline">\((\quad)\)</span>记号为混合积。因此为检测碰撞，转化为求解一个关于 <spanclass="math inline">\(t\)</span> 的三次方程，即： <spanclass="math display">\[\exists t \in [0, 1]\quad (\mathbf x_{12}\quad \mathbf x_{13} \quad\mathbf x_{14}) = 0\]</span></p><blockquote><p>其中的三次方程采用牛顿法求解。</p></blockquote><p>求解出 <span class="math inline">\(t\)</span>是不够的，因为方程可能出现 V 不处于 T 内部，或 E 和 E不交的情况，但考虑到已经共面，下一步的判断是简单的，几乎不需要计算。因此该算法主要的计算量在于三次方程的求解上。</p><h4 id="broad-phase-剔除">Broad Phase 剔除</h4><ol type="1"><li>BVH</li><li>计算曲率：根据显然的事实 —给定一个曲面局部，如果它是凸的，且有充分低的曲率，则其不可能产生自相交。</li></ol><h4 id="impact-zone">Impact Zone</h4><p>为了消除一个碰撞，可能会引入其他的碰撞，这是因为在处理碰撞的时候，我们只针对当前选出来的碰撞对进行更新，在该更新过程中是不考虑其他点的情况的。</p><p>因此，若一个 Impact Zone在充分大的时候，考虑Frozen，并通过群速度、群角速度进行整体更新。</p><h4 id="相关内容">相关内容</h4><ol type="1"><li>Fast CCD</li><li>Safe CCD</li><li><strong>Tight CCD</strong></li></ol><h3 id="bridson-02">Bridson 02</h3><p>这篇嘛是一个完整的Workflow介绍了，从文章标题也能看出来主要是为了准确和高鲁棒性来实现的。主要还是处理了自碰撞的问题。</p><h4 id="碰撞检测">碰撞检测</h4><p>Broad-Phase：AABB，自下而上构造。</p><p>Narrow-Phase：还是基于上面的共面，但是判断是否在内部改进为解线性方程组（分解到现有基底上）</p><h4 id="处理">处理</h4><p>摩擦：库伦定律（摩擦角）用于静摩擦和动摩擦。</p><p>Rigid Impact Zone：用于失败的补偿机制</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测 4 - Deformed Object&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 1 - Introduction</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/Introduction/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/Introduction/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-14T14:12:34.457Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测相关介绍</p><span id="more"></span><h1 id="碰撞检测">碰撞检测</h1><p>众所又周知啊，碰撞检测是一个老大难的问题，在很多的仿真模拟、游戏引擎中间都会用哈</p><p>碰撞检测的主要流程是 <a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>：</p><figure><img src="2022-04-05-17-32-22.png"alt="GAMES 103- Collision Handling" /><figcaption aria-hidden="true">GAMES 103- CollisionHandling</figcaption></figure><p>其中：</p><ul><li><span class="math inline">\(\{\mathbf x, \mathbf x^{new}\}\)</span>分别是更新前后的顶点位置向量</li><li>Pair Condidates 是指可能发生碰撞的 primitive pairq</li><li>Colliding Pairs 是指真实发生碰撞的 primitive pair</li></ul><blockquote><p><strong>注意</strong>：</p><p>一般而言，所谓的 primitive 是指组成这个 body (不管是 deformable 还是rigid) 的单位元素，例如：</p><ol type="1"><li>三角网格 (mass-spring 模型）中的三角面片</li><li>多边形模型（例如 FEM ）中的面片</li><li>图的顶点、边</li></ol></blockquote><p>可以看出，总体上的碰撞检测分为两个阶段：第一阶段（Broad-Phase）去除不可能出现的pairs（当然肯定使用反向计算出可能产生collision 的 pair去做的。第二阶段（Narrow-Phase）去针对每一个pair计算。</p><h2 id="broad-phase">Broad-Phase</h2><div class="story post-story"><p>碰撞剔除两种常见的方法：</p><ol type="1"><li>Spatial Hashing：空间哈希</li><li>BVH：层次包围盒</li></ol><h3 id="空间划分">空间划分</h3><h4 id="基本思想">基本思想</h4><p>将整个空间划分为各自，然后将Primitive存在单元格内。（有相交就存储，可能出现在多个格子里面）</p><p>对于每一个格子里面的所有 Primitive-Pair 输出。</p><h4 id="动态过程">动态过程</h4><p>我们将 <span class="math inline">\(x^{new}\)</span> 和 <spanclass="math inline">\(x\)</span> 都认为是其位置，再进行划分。</p><h4 id="存在的问题">存在的问题</h4><p>三维空间的格子 – 100x100x100 – 计算量大</p><p>可能出现：分布不均匀</p><ol type="1"><li>浪费存储空间</li><li>大量的三角形聚集在几个格子里</li></ol><h4 id="改进方案">改进方案</h4><h5 id="排序">排序</h5><figure><img src="image-20220409103734403.png" class="lazyload" data-srcset="image-20220409103734403.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="排序" /><figcaption aria-hidden="true">排序</figcaption></figure><p><strong>目的</strong>：所有的Pair都按照格子的编号排列（类似于稀疏矩阵压缩），从而节约内存开销。</p><h5 id="为了达到连续内存访问">为了达到连续内存访问</h5><p>使用 <code>Morton Code</code> 编码，</p><h3 id="bvh-层次包围盒">BVH 层次包围盒</h3><p>递归的建立一棵树，例如：</p><figure><img src="image-20220409104753151.png" class="lazyload" data-srcset="image-20220409104753151.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BVH" /><figcaption aria-hidden="true">BVH</figcaption></figure><p>Idea：把包围盒组合成新的包围盒</p><p>如何检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ProcessNode(A) &#123;</span><br><span class="line">for_each(B: A.child)&#123;</span><br><span class="line">ProcessNode(B);</span><br><span class="line">&#125;</span><br><span class="line">for_each([B, C]: A.childrenPair) &#123;</span><br><span class="line"><span class="keyword">if</span> B-C intersect &#123;</span><br><span class="line">ProcessPair(B, C)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessPair(B, C) &#123;</span><br><span class="line">for_each(B<span class="number">&#x27;</span>: B.child) &#123;</span><br><span class="line">for_each(C<span class="number">&#x27;</span>: C.child) &#123;</span><br><span class="line"><span class="keyword">if</span> B<span class="number">&#x27;</span>-C<span class="number">&#x27;</span> intersect &#123;</span><br><span class="line">ProcessPair(B<span class="number">&#x27;</span>, C<span class="number">&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见的包围盒">常见的包围盒</h4><ol type="1"><li><strong>AABB</strong>：intersect 当且仅当在轴上有相交</li><li>球</li><li>OBB：任意方向的包围盒</li></ol><h4 id="问题">问题</h4><p>难以处理紧邻的情况。 – 只有便利到底层才能解决</p><blockquote><p>Energy-based Self-Collision Culling for Arbitary MeshDeformations</p><ol type="1"><li>形变越大，越容易相交</li></ol></blockquote><h3 id="对比">对比</h3><p>SH =&gt; Edge-Triangle</p><ol type="1"><li>Easy to implement</li><li>GPU-Friendly</li><li>Need to recompute after updating obj.</li></ol><p>BVH =&gt; VT &amp; EE</p><ol type="1"><li>More Involved</li><li>Not GPU Friendly</li><li>To update BVH, just update BV</li></ol></div><h2 id="narrow-phase">Narrow Phase</h2><div class="story post-story"><p>进一步看是否真的有碰撞，两种：DCD和CCD</p><h3 id="dcd-相交检测">DCD — 相交检测</h3><p>只考虑是否相交（而非碰撞）</p><p>对于Triangle Mesh，只考虑 Edge-Triangle. <spanclass="math display">\[\begin{cases}((1-t) x_a+tx_b -x_0)\cdot x_{10} \times x_{20} =0\\t = \frac{x_{0a}\cdot x_{10} \times x_{20}}{x_{ba}\cdot x_{10} \timesx_{20}}\end{cases}\]</span> 若解出来的 <span class="math inline">\(t\in [0, 1]\)</span>则能够判断出在 <span class="math inline">\(t\)</span> 处相交</p><figure><img src="image-20220409111138061.png" class="lazyload" data-srcset="image-20220409111138061.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DCD" /><figcaption aria-hidden="true">DCD</figcaption></figure><h4 id="问题-1">问题</h4><p>可能会产生穿透问题（运动很快的情况）。对于大体积问题的概率低，但是如果是cloth等薄物体，容易发生。</p><ol type="1"><li>减少dt</li></ol><h3 id="ccd">CCD</h3><p>测试两个状态（之间）有无碰撞产生。</p><p>一般是做 VT 和 EE 的检测：</p><figure><img src="image-20220409111542472.png" class="lazyload" data-srcset="image-20220409111542472.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="V-T测试" /><figcaption aria-hidden="true">V-T测试</figcaption></figure><figure><img src="image-20220409111601254.png" class="lazyload" data-srcset="image-20220409111601254.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="EE测试" /><figcaption aria-hidden="true">EE测试</figcaption></figure><p>共同点：</p><ol type="1"><li>解一元三次方程。观察解的情况</li></ol><h4 id="数值问题">数值问题</h4><ol type="1"><li>公式法：开三次方的数值误差大</li><li>牛顿法：速度</li><li>GPU — 单精度</li><li>Expensive — 可以考虑加强 Broad-Phase</li></ol><blockquote><p>Bridson2002-Robust … …</p></blockquote><h1 id="碰撞处理">碰撞处理</h1><figure><img src="image-20220409112929873.png" class="lazyload" data-srcset="image-20220409112929873.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IPM / IZO" /><figcaption aria-hidden="true">IPM / IZO</figcaption></figure><h3 id="内点法">内点法</h3><blockquote><p>截断 – IPC</p></blockquote><figure><img src="image-20220409112859592.png" class="lazyload" data-srcset="image-20220409112859592.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内点法" /><figcaption aria-hidden="true">内点法</figcaption></figure><p>反复进行碰撞检测</p><blockquote><p>Robust……</p></blockquote><h3 id="impact-zone-method.">Impact Zone Method.</h3><h3 id="备选">备选</h3><ol type="1"><li>Rigid Impact Zone</li></ol><figure><img src="image-20220409113154440.png" class="lazyload" data-srcset="image-20220409113154440.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="一个常见的思路为" /><figcaption aria-hidden="true">一个常见的思路为</figcaption></figure><h1 id="相交解除">相交解除</h1><blockquote><p>碰撞不是灾难，可以在发生之后进行解除</p></blockquote><p>处理当前已有的相交情况。</p><blockquote><p>Untangling Cloth.</p></blockquote><p>改进方法：</p><p>期望相交曲线变短，直到相交解除</p><ul><li>Not always work.</li></ul><blockquote><p>Resolving Service Collisons through</p></blockquote><hr /><blockquote><p>实际上，Narrow Phase 还可以继续细分：</p><p>The narrow phase obtains the collision pair list and for every pair,using their actual geometry, it checks whether the two partners arecolliding. This phase can get arbitrarily complex, so in the context ofreal-time physics simulation, the participating colliding shapes areusually restricted to being convex. For nonconvex shapes, only theconvex hull will then be used for collision detection. In most casesthis is good enough—for example if the concavities are small orconstitute object parts where you don't want a game character to goanyway, such as the exhaust pipes of a spacecraft or other irrelevantplaces. To improve collision quality and performance, we can decomposebig or concave objects into convex pieces. A game object therefore mighthold a simplified collision geometry that is different from the onedisplayed. In this chapter we investigate a narrow-phase algorithm fordetermining the distance between two convex objects. For the two objectsin Figure 33-1b, the contact point marked with the yellow star isdetected, and its location is calculated and stored with the collisionpair.（转化为凸包，进一步简化加速）</p></blockquote><p>根据 [Provet97] <a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a> 的描述，其可以通过</p><hr /><p>UE4 中的碰撞检测：</p><ul><li>射线检测RayCasts</li><li>重叠检测Overlaps</li><li>渗透深度计算Penetration Depth</li><li>Sweeps检测</li><li>InitialOverlaps检测</li></ul><blockquote><p>https://zhuanlan.zhihu.com/p/33529865</p></blockquote><p>刚体碰撞</p><p>Penalty Method</p><p>Impulse Method</p><p>空间划分 — Spatial Hashing</p><ul><li>Easy Implement</li><li>GPU Friendly</li><li>Recompute after updating. 包围盒 AABB</li><li>More involved</li><li>Not gpu friendly</li><li>Update BVH -&gt; Update Bounding Volumes.</li></ul><p>两种碰撞检测方式：</p><p>DCD — Discrete Collision Detection</p><ul><li>当前状态下有无自相交 CCD — Continuous Collision Detection</li><li>两个状态之间是否相交</li><li>对于三角网格：<ul><li>点 - 三角</li><li>边 - 边</li></ul></li><li>Co-planar</li><li>Issues:<ul><li>误差 - 三次方程 - GPU-float32</li><li>比 DCD 慢很多</li><li>难以实现</li></ul></li></ul><p>处理方法：</p><ul><li>Interior Point Method<ul><li>每一步都是安全的</li><li>Slow - far from solution - all of vertices - cautiously by smallsteps</li><li>Log-Barrier IPM. E(x) = -log |xij| + Gradient Descent<ul><li>IPC - not GD.</li><li></li></ul></li></ul></li><li>Impact Zone Optimization<ul><li>逐步满足 Constraint</li><li>Fast - Close To solution - only vertices in collision - can takelarge steps sizes</li><li>May not succeed. (Due to large dT)</li></ul></li><li>Rigid Impact Zones.<ul><li>回到前一帧 -&gt; 没有碰撞（视为刚体） CCD -&gt; IZO -&gt; IPM orRIZ</li></ul></li></ul><p>相交解除</p><ul><li>Not always intersection free.</li></ul><p>V-V intersection C-V intersection</p><ul><li>推出即可 C-C</li><li>无法处理边界</li><li>难以在 GPU 上实现</li></ul><hr /></div><h2 id="reference">Reference</h2><div class="story post-story"><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>GAMES103 Collision Handling<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Collision and self-collision handlingin cloth model dedicated to design garments<a href="#fnref2"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测相关介绍&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Collision Detection 整理 3 - Narrow Phase 阶段</title>
    <link href="http://adversarr.github.io/2022/03/28/CG/ContactDetection/NarrowPhase/"/>
    <id>http://adversarr.github.io/2022/03/28/CG/ContactDetection/NarrowPhase/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-12T12:43:58.767Z</updated>
    
    <content type="html"><![CDATA[<p>碰撞检测笔记 3 — Narrow Phase</p><span id="more"></span><p>一般而言的 Narrow Phase是基于点线面的关系推导得到的。而且在很多情况下，我们不需要知道碰撞在两个插值点之间的具体位置，而只需要知道其是否碰撞。针对不同的物体，一可以有不同的优化策略。</p><h2 id="一般物体间的碰撞检测">一般物体间的碰撞检测</h2><div class="story post-story"><ol type="1"><li>凸物体</li><li>刚体</li><li>变形体 &amp; 三角网格</li></ol><h3 id="凸物体的碰撞检测">凸物体的碰撞检测</h3><p>一般而言，凸物体的碰撞可以通过 GJK 和 SAT 方法来判断。</p><h4 id="gilbert-johnson-keerthi-gjk-算法">Gilbert-Johnson-Keerthi (GJK)算法</h4><h5 id="idea">Idea</h5><p>设 <span class="math inline">\(\mathcal A = \{\mathbf x\}\)</span>，<span class="math inline">\(\mathcal B = \{\mathbf x\}\)</span>是两个点集，定义其 Minkowski 差为： <span class="math display">\[\mathcal A - \mathcal B :=\{\mathbf x_1 - \mathbf x_2| \mathbf x_1 \in\mathcal A, \mathbf x_2 \in \mathcal B \}\]</span> 不难证明，<span class="math inline">\(\mathcal A\)</span> 和<span class="math inline">\(\mathcal B\)</span> 碰撞，当且仅当 <spanclass="math inline">\(0 \in \mathcal A - \mathcal B\)</span>。</p><p>问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于<strong>凸物体</strong>，我们可以有快速算法实现。</p><h5 id="support-函数和-simplex-单纯形">Support 函数和 Simplex单纯形</h5><p>其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski差的一个子集包含了 <spanclass="math inline">\(0\)</span>，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。</p><p>为了生成这样的单纯形，我们计算 support函数来快速获取给定方向上的支撑点，如图所示<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w.jpg"alt="Support 函数返回的点" /><figcaption aria-hidden="true">Support 函数返回的点</figcaption></figure><h5 id="迭代求解">迭代求解</h5><p>有了如上的论述，我们可以通过如此构造单纯形：</p><ol type="1"><li>随机生成一个单纯形</li><li>假定当前的单纯形为 <span class="math inline">\(\{v\}\)</span>则选择距离原点最远的抛弃，对于 n - 1维单纯形求法向量，求support（两个）</li><li>直到<ol type="1"><li>检查到 0 =&gt; 碰撞</li><li>如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞</li></ol></li></ol><p>可以证明，这样的算法一定在有限步内结束。</p><h4 id="sat-分离轴算法">SAT 分离轴算法</h4><p>一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个<span class="math inline">\(n - 1\)</span>维的超平面能够完全分开这两个凸集合。遍历所有的边（三维则是面），投影到其正交补空间上。若<strong>存在</strong>一个边，能使得投影完全分离，则其是不相交的，反之相交。</p><h3 id="刚体碰撞检测">刚体碰撞检测</h3><p>刚体碰撞的检测正如在 <a href="BroadPhase">Broad Phase</a>里提到：</p><blockquote><p><strong>凸包变换（V-HACD）</strong>，并使用适用于凸包的 CollisionDetect 来进行碰撞的判断。</p></blockquote><p>这类方法将原来的刚体预计算处理为凸包，用户可以控制其分割的<em>粒度</em>，从而权衡其加速/精度。</p><h3 id="变形体-三角网格">变形体 &amp; 三角网格</h3><p>基本思路为：</p><ol type="1"><li>求解三次方程；</li><li>设置两个非邻接顶点/面的距离下界为一个固定/可变的非零数（可以按照siggraph2022的论文结果强化到点-点距离）</li><li>在变形体网格上建立局部 BVH 来增加一部，返回1/2求解</li></ol><hr /><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"role="doc-endnote"><p>https://zhuanlan.zhihu.com/p/127844705<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰撞检测笔记 3 — Narrow Phase&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的抽象代数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/Algebra/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/Algebra/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-03-28T03:49:07.263Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="抽象代数" scheme="http://adversarr.github.io/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的复变函数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/ComplexAnalysis/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/ComplexAnalysis/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-06T03:03:56.421Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="复变函数" scheme="http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>面向夏令营的实变函数整理</title>
    <link href="http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/RealAnalysis/"/>
    <id>http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/RealAnalysis/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-22T09:02:25.094Z</updated>
    
    <content type="html"><![CDATA[<p><em>待完善</em></p><span id="more"></span><details ><summary> 目录 </summary>              <div class='content'>              <ul><li><a href="#集合论">集合论</a><ul><li><a href="#集合">集合</a><ul><li><a href="#集合运算">集合运算：</a></li><li><a href="#上极限和下极限相关内容">上极限和下极限相关内容：</a></li></ul></li><li><a href="#映射">映射</a></li><li><a href="#rn空间">Rn空间</a><ul><li><a href="#闭集开集borel集">闭集、开集、Borel集</a></li><li><a href="#开集结构连续性">开集结构、连续性</a></li><li><a href="#基本定理">基本定理</a></li></ul></li></ul></li><li><a href="#勒贝格测度">勒贝格测度</a><ul><li><a href="#外测度可测集">外测度、可测集</a><ul><li><a href="#外测度">外测度</a></li><li><a href="#lebesgue可测集">Lebesgue可测集</a></li><li><a href="#测度空间">测度空间</a></li></ul></li><li><a href="#可测函数">可测函数</a><ul><li><a href="#基本性质">基本性质</a></li><li><a href="#测度空间上的可测函数">测度空间上的可测函数</a></li></ul></li><li><a href="#lesbegue可测函数列的收敛性">Lesbegue可测函数列的收敛性</a><ul><li><ahref="#几乎处处收敛几乎一致收敛">几乎处处收敛/几乎一致收敛</a></li><li><a href="#依测度收敛">依测度收敛</a></li><li><ahref="#可测函数和连续函数的关系">可测函数和连续函数的关系</a></li></ul></li></ul></li><li><a href="#lebesgue-积分">Lebesgue 积分</a><ul><li><a href="#lebesgue-可测函数的积分">Lebesgue 可测函数的积分</a><ul><li><a href="#非负可测函数的积分">非负可测函数的积分</a></li><li><a href="#一般可测函数">一般可测函数</a></li><li><ahref="#riemann积分和lebesgue积分的关系">Riemann积分和Lebesgue积分的关系</a></li><li><ahref="#测度空间上的可测函数积分">测度空间上的可测函数积分</a></li></ul></li><li><a href="#极限定理">极限定理</a></li></ul></li></ul>              </div>            </details><h2 id="集合论">集合论</h2><div class="story post-story"><h3 id="集合">集合</h3><h4 id="集合运算">集合运算：</h4><ol type="1"><li>代数 -- 交并补差</li><li>分析 -- 上下极限</li><li>直积</li></ol><p>上下极限可以有两种定义方式：</p><p><span class="math display">\[\lim\sup _{n\rightarrow \infty} A_n =\lim _{ n \rightarrow\infty}\bigcup_{k = n}  ^ \infty A_n  = \bigcap _ { n = 1} ^\infty\bigcup_{k = n}  ^ \infty A_n\]</span></p><p>对于下极限同样定义。</p><h4 id="上极限和下极限相关内容">上极限和下极限相关内容：</h4><p>集合的上下确界 <span class="math inline">\(\sup, \inf\)</span></p><dl><dt>Theo</dt><dd>确界存在定理</dd></dl><p>上下极限也可以通过上下界定义：</p><p><span class="math display">\[\lim \sup = \inf \sup \quad \lim \inf = \sup \inf\]</span></p><blockquote><p>类比点列、函数的上下极限定义</p></blockquote><h3 id="映射">映射</h3><ol type="1"><li>映射</li><li>集合势</li></ol><p>研究可列：</p><ol type="1"><li>任何无穷集合中包含可列的子集</li><li>可列集的无穷子集可列</li><li>可列集的交并都可列</li></ol><h3 id="rn空间">Rn空间</h3><ol type="1"><li>定义<span class="math inline">\({\mathbb R}^n\)</span></li><li>线性空间、范数、柯西不等式、距离、球</li></ol><p>考察点集：</p><ol type="1"><li>点：内点、边界点、聚点</li><li>诱导集合：闭包、边界</li><li>相互关系：稠密</li></ol><h4 id="闭集开集borel集">闭集、开集、Borel集</h4><ol type="1"><li>闭集、开集的定义</li></ol><p>极限性质： 1. 开集的并始终是开的，两个开集的交是开的 2.闭集的交始终是闭的，两个闭集的并是闭的 3. 从而定义<spanclass="math inline">\(F_\sigma\)</span>型集（可数闭集并）和<spanclass="math inline">\(G_\delta\)</span>型集（可数开集的交）</p><p>推广上述性质：<span class="math inline">\(\sigma\)</span>-代数</p><h4 id="开集结构连续性">开集结构、连续性</h4><dl><dt>Theo</dt><dd><span class="math inline">\({\mathbb R}\)</span>上任意非空开集是至多可数个开集的并</dd><dt>Theo</dt><dd><span class="math inline">\({\mathbb R}^n\)</span>上的任意非空开集是之多可数个互不相交的半开矩体的并。</dd></dl><p>通过这两个定理，我们来观察函数的连续性：</p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(f:{\mathbb R}^n \rightarrow {\mathbbR}\)</span> 则TFAE： 1. <span class="math inline">\(f\in C\)</span> 2.<span class="math inline">\(\forall \lambda, \{f &lt; \lambda\}, \{f&gt; \lambda \}\)</span> 是开的 2. <span class="math inline">\(\forall\lambda, \{f &lt;= \lambda\}, \{f &gt;= \lambda \}\)</span> 是闭的</dd></dl><h4 id="基本定理">基本定理</h4><ol type="1"><li>Cauchy-收敛原理</li><li>有限覆盖定理</li><li>闭区间套定理</li><li>魏尔斯特拉斯定理</li></ol><p>关于紧集：</p><ol type="1"><li>定义：任意开覆盖有有限子覆盖</li><li>性质：在 <span class="math inline">\({\mathbb R} ^ n\)</span>中就是有界闭集</li></ol></div><h2 id="勒贝格测度">勒贝格测度</h2><div class="story post-story"><h3 id="外测度可测集">外测度、可测集</h3><h4 id="外测度">外测度</h4><dl><dt>外测度</dt><dd>设 <span class="math inline">\(E\)</span> 是 <spanclass="math inline">\({\mathbb R} ^ n\)</span> 中的点集，若<spanclass="math inline">\(\{I_k\}\)</span>是一列开矩体，且为<spanclass="math inline">\(E\)</span>的一个开覆盖，确定了一个实数：<spanclass="math inline">\(u = \sum _{k} I_k\)</span>，令： <spanclass="math display">\[m^*(E) = \inf \{u\}\]</span> 称为其的<span class="math inline">\(Lebesgue\)</span>外测度。</dd></dl><p>关于外测度的性质： 1. 非负性 2. 单调性 3. 次可加性 4. 平移不变性</p><blockquote><ol type="1"><li>单点集、可数点集的外测度都为 0</li><li><span class="math inline">\(n-1\)</span> 维超平面测度为0</li><li>康托集外测度为0</li></ol></blockquote><details ><summary> 题目 </summary>              <div class='content'>              <ol type="1"><li>求证<span class="math inline">\(m^* = \sup / \inf\)</span> 这一类<ol type="1"><li>一般一边好证明（直接用单调性）</li><li>另一边用次可加性+<spanclass="math inline">\(\varepsilon\)</span>的任意性来描述</li></ol></li><li>求证有子集满足 xxx 条件<ol type="1"><li>设函数，利用连续性</li></ol></li></ol>              </div>            </details><h4 id="lebesgue可测集">Lebesgue可测集</h4><p>外测度不符合可加性！因此在集合上加Carathedory条件：</p><dl><dt>可测</dt><dd>设 <span class="math inline">\(E \subseteq {\mathbb R} ^ n\)</span>如果<span class="math inline">\(\forall T \subset {\mathbb R} ^n\)</span>，有 <span class="math display">\[m^*(T) = m^*(T \cap E) + m^*(T\cap E^c)\]</span> 则称之为 Lebesgue 可测，全体记为 <spanclass="math inline">\(\mathcal M\)</span> 测度即其外侧度</dd></dl><blockquote><p>上述条件中实际上只需要<spanclass="math inline">\(\ge\)</span>成立即可（另一侧自然成立）</p></blockquote><p>考虑原来的简单集合：</p><dl><dt>Theo</dt><dd><ol type="1"><li>外测度的零测集是可测的，即为零测集。</li><li>对开矩体而言，其测度为其“长度”</li></ol></dd></dl><p>对于可测集，其具有如下性质：</p><ol type="1"><li>空集可测，测度为0</li><li>可测集的交并补差都是可测集</li><li><strong>可数可加性</strong>：对于互不相交的可测集<spanclass="math inline">\(E_i\)</span>，取并和取测度可换</li><li>平移不变性</li></ol><p>进一步考察和极限的关系：</p><dl><dt>Theo</dt><dd>可测集合的可数交是可测的</dd></dl><p>考虑极限和测度交换：</p><dl><dt>Theo</dt><dd>对于递增的可测集列<spanclass="math inline">\(E_i\)</span>，则其极限可测，且有极限和测度可换</dd><dt>Theo</dt><dd>对于递减的可测集列<span class="math inline">\(E_i\)</span>，若存在<spanclass="math inline">\(m(E_i) &lt;+\infty\)</span>，则其极限可测，且有极限和测度可换</dd></dl><blockquote><p>上式要求存在一个集合测度有限：考察<span class="math inline">\(E_i =[i, \infty)\)</span>的极限的测度和其测度的极限</p></blockquote><p>下面的定理表述了可测集和 Borel 集的关系</p><dl><dt>Theo</dt><dd>若<span class="math inline">\(E\)</span>可测，则存在 Borel 集<spanclass="math inline">\(G, F\)</span>，使得<spanclass="math inline">\(F\subset E\subset G\)</span> 且 <spanclass="math inline">\(m(F) = m(E) = m(G)\)</span>换句话说，对于任意可测集，存在 Borel 集来从两侧（在测度意义上）逼近。</dd></dl><details ><summary> 题目 </summary>              <div class='content'>              <p>TODO</p>              </div>            </details><h4 id="测度空间">测度空间</h4><blockquote><p>TODO</p></blockquote><h3 id="可测函数">可测函数</h3><p>对于函数，正如我们一开始用开集闭集来表征连续性一样，考察用可测集来表述可测性。</p><dl><dt>可测函数</dt><dd>设 <span class="math inline">\(E \subseteq \mathbb R^n\)</span>可测，<span class="math inline">\(f\)</span> 是 <spanclass="math inline">\(E\)</span> 上的函数，若对于任何<spanclass="math inline">\(t\in {\mathbb R}\)</span>有 <spanclass="math display">\[E(f&gt;t) := \{x\in E| f(x) &gt; t\}\]</span> 都可测，则称函数在<spanclass="math inline">\(E\)</span>上可测，用<spanclass="math inline">\(M(E)\)</span>表示。</dd></dl><ol type="1"><li>对于上述定理中的<span class="math inline">\(t\inE\)</span>，只需要考察稠密的<span class="math inline">\(t\inE&#39;\subset E\)</span>即可</li><li>对于 <span class="math inline">\(&gt;\)</span>，可以等价替换为 <spanclass="math inline">\(\ge, \le , &lt;\)</span></li></ol><p>我们考察在这个定义下的简单函数，他们通过特征函数来定义：</p><dl><dt>简单函数</dt><dd>设有互不相交的<span class="math inline">\(E_i\)</span>是<spanclass="math inline">\(E\)</span>的一个分划，称 <spanclass="math display">\[\varphi (x) = \sum_{i = 1} ^ m \alpha _ i \chi _{E_i} (x)\]</span> 是简单函数，当<spanclass="math inline">\(E_i\)</span>是矩体时，<spanclass="math inline">\(\varphi\)</span>是阶梯函数</dd></dl><p>显然，简单函数是可测的。而下面的定理说明了简单函数能够构建出一个可测函数：</p><h4 id="基本性质">基本性质</h4><dl><dt>Theo</dt><dd>对于可测函数集， 1. 是线性空间（对非零除法也是） 2. 连续函数都可测</dd></dl><p>下面考察其极限性质：</p><dl><dt>Theo</dt><dd>对于可测函数列的 <span class="math inline">\(f_k\)</span>的上确界，下确界，上极限，下极限 都是可测函数</dd><dt>Theo</dt><dd>对于可测函数列，若<span class="math inline">\(f_k \rightarrowf\)</span>，则 <span class="math inline">\(f\)</span> 可测。</dd></dl><p>下面考虑取绝对值前后的可测性：</p><dl><dt>Theo</dt><dd>对于实值函数，可测的充要条件是正部和负部都是可测的，且若<spanclass="math inline">\(f\)</span>可测，则<spanclass="math inline">\(|f|\)</span>可测</dd></dl><p>考虑复合函数的可测性：</p><dl><dt>Theo</dt><dd>对于 <span class="math inline">\(f\in C\)</span> 和 <spanclass="math inline">\(g\in M\)</span> 有 <spanclass="math inline">\(h=f\circ g\)</span>可测</dd></dl><p>下面引入几乎处处的概念：</p><dl><dt>几乎处处</dt><dd>称E在<spanclass="math inline">\(A\)</span>几乎处处满足P(E)，是指存在一个固定的零测的<spanclass="math inline">\(Z\)</span>使得对<span class="math inline">\(A -Z\)</span>满足P(E)</dd></dl><p>从而，我们有：</p><dl><dt>Theo</dt><dd>对于实函数，若<span class="math inline">\(f = g\quada.e.\)</span>则<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>有相同的可测性。</dd></dl><p>从上面的描述中不难看出，相比于<strong>连续性</strong>，可测性在极限运算下具有良好的性质（保持、交换），这也是我们需要可测的原因。</p><h4 id="测度空间上的可测函数">测度空间上的可测函数</h4><blockquote><p>TODO</p></blockquote><h3 id="lesbegue可测函数列的收敛性">Lesbegue可测函数列的收敛性</h3><p>这一节，我们详细讨论收敛的概念。</p><h4 id="几乎处处收敛几乎一致收敛">几乎处处收敛/几乎一致收敛</h4><dl><dt>几乎处处收敛</dt><dd>（直接从几乎处处收敛的定义得到）</dd></dl><p>相对于几乎处处收敛，我们有稍弱一些的几乎一致收敛，其描述的是定义域极限意义下的收敛性。（即我们不需要得到零测集，而得到测度充分小的集合）</p><dl><dt>几乎一致收敛</dt><dd><span class="math inline">\(\forall \delta &gt; 0, \exists E_\delta\subset E\)</span> 使得（测度充分小）<spanclass="math inline">\(m(E_\delta) &lt; \delta\)</span>，且在 <spanclass="math inline">\(E - E_\delta\)</span>上满足一直收敛到<spanclass="math inline">\(f\)</span>。</dd></dl><p>下面的定理说明了这两个收敛行的关系：</p><dl><dt>叶戈罗夫定理</dt><dd>对于<strong>有限测度集</strong>上的几乎处处<strong>有限</strong>的可测函数列，若函数列几乎处处收敛，则函数列几乎一致收敛</dd></dl><p>有限和有界是不同的：<span class="math inline">\(y = 1/x\)</span>在<span class="math inline">\((0,1)\)</span>无界，但其是有限的。有界是对于区间而言，而有限是对于点（<spanclass="math inline">\(&lt; +\infty\)</span>而言）</p><h4 id="依测度收敛">依测度收敛</h4><p>条件更弱，去掉的集合甚至不一定“稳定”，即该集合只需要测度的极限为0，而不需要考虑其极限是否存在。</p><dl><dt>依测度收敛</dt><dd>对于几乎处处有限的可测函数，对于给定的<spanclass="math inline">\(\epsilon&gt;0\)</span>，其能够满足 <spanclass="math display">\[m(E(|f_k - f| &gt; \epsilon)) \rightarrow 0\]</span> 则其是在<spanclass="math inline">\(E\)</span>上依测度收敛到<spanclass="math inline">\(f\)</span>（<spanclass="math inline">\(f_k\rightarrow_m f\)</span>）</dd></dl><p>显然，几乎处处收敛和几乎一致收敛蕴含了依测度收敛。但依测度收敛给出了收敛到什么函数的本质问题。</p><dl><dt>Theo</dt><dd>若函数列 <span class="math inline">\(f_k\)</span> 依测度收敛于<spanclass="math inline">\(f, g\)</span> ，则 <span class="math inline">\(f=g \quad a.e.\)</span></dd><dt>Theo — 勒贝格定理</dt><dd>对于有限测度集上的几乎处处有限的可测函数，则其依测度收敛到该极限函数</dd></dl><blockquote><p>如果我们将几乎处处相等作为等价关系，实变函数考察的始终是这个等价关系下对于可测函数集的划分。</p></blockquote><p>考虑从依测度收敛到几乎处处收敛的条件：</p><dl><dt>Theo — Riesz 引理</dt><dd>若 <span class="math inline">\(f_k \rightarrow _mf\)</span>，则存在子列几乎处处收敛到<spanclass="math inline">\(f\)</span></dd></dl><p>依测度收敛意义下，我们可以类比柯西收敛准则：</p><dl><dt>依测度基本列</dt><dd>设有<span class="math inline">\(f_k\)</span>为<spanclass="math inline">\(E\)</span>上几乎处处有限的可测函数列，若 <spanclass="math display">\[\forall \varepsilon &gt; 0, \quad \lim_{k , j \rightarrow \infty}m(E(|f_i - f_j| &gt; \varepsilon)) = 0\]</span> 则称其为<span class="math inline">\(E\)</span>上的依测度基本列</dd></dl><p>类似柯西收敛准则：</p><dl><dt>Theo</dt><dd>对于几乎处处有限的可测函数列，依测度收敛当且仅当它是依测度基本列</dd></dl><h4 id="可测函数和连续函数的关系">可测函数和连续函数的关系</h4><p>连续函数在数学分析中具有重要的作用（特别是一致连续的函数）。因此我们考察连续和可测之间是否有一定的联系。</p><p>下面的定理描述了函数可测和连续之间的差别。</p><dl><dt>Theo — 鲁金定理</dt><dd>设<spanclass="math inline">\(f\)</span>是<strong>有限测度集</strong>上几乎处处有限的可测函数，对于任一（充分小的）<spanclass="math inline">\(\delta &gt; 0\)</span>，存在<spanclass="math inline">\(E\)</span>中的闭集<spanclass="math inline">\(F\)</span>，满足<span class="math inline">\(m(E\backslash F) &lt; \delta\)</span> 使<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(F\)</span>上连续。</dd></dl><p>下面的定理描述了如何从连续函数构造一个可测函数：</p><dl><dt>Theo</dt><dd>对于任意可测函数<spanclass="math inline">\(f\)</span>，存在连续函数列<spanclass="math inline">\(g_k\)</span>，使得<span class="math inline">\(g_k\rightarrow f\quad a.e.\)</span></dd></dl><p>上面的定理可以推广为：</p><dl><dt>Theo</dt><dd>对于几乎处处有限的函数<span class="math inline">\(f\)</span>，<spanclass="math inline">\(f\)</span>可测，当且仅当<spanclass="math inline">\(\exists g_k\in C\)</span>使得<spanclass="math inline">\(g_k \rightarrow f\quad a.e.\)</span></dd></dl></div><h2 id="lebesgue-积分">Lebesgue 积分</h2><div class="story post-story"><p>至此，我们得到了可测函数优秀的极限性质，我们开始考虑一类特殊的极限 --积分，这也是实变函数论目的：给积分 -极限之间的互换关系一个完备的解释。</p><h3 id="lebesgue-可测函数的积分">Lebesgue 可测函数的积分</h3><h4 id="非负可测函数的积分">非负可测函数的积分</h4><dl><dt>非负简单函数的积分</dt><dd>设 <span class="math inline">\(h(x)\)</span> 是可测集 <spanclass="math inline">\(E\)</span> 上的非负可测函数，定义 <spanclass="math display">\[h(x) = \sum_{j = 1} ^ m a_j m(E_j) \Longrightarrow \int _ E h(x) \mathrmdx = \sum _{j = 1} ^ m a_j m ( E _ j )\]</span> 为 <span class="math inline">\(h(x)\)</span> 在可测集<spanclass="math inline">\(E\)</span>傻姑娘的积分。</dd></dl><p>关于上面定义的积分，其满足：</p><ol type="1"><li>线性性质</li><li>对定义域的连续性： <span class="math display">\[\lim E_k = E \Rightarrow \lim \int _{E_k} h(x)\mathrm dx = \int _ E h(x)\mathrm dx\]</span></li></ol><p>其中的 <span class="math inline">\(\mathrmd\)</span>仅仅是一个记号，并不代表自变量的微元。</p><p>从而我们可以定义：</p><dl><dt>非负可测函数的积分</dt><dd>对于 <span class="math inline">\(f\in \mathcal M ( E)\)</span> 定义<span class="math display">\[\int _ E f(x) \mathrm dx = \sup \left\{ \int _ E h(x) \mathrm dx | h(x)\le f(x), h(x) 是简单函数 \right\}\]</span> 若上式有限，则称<span class="math inline">\(f\)</span>在<spanclass="math inline">\(E\)</span>上可积。</dd></dl><p>综合上面的定义可以看出：</p><ol type="1"><li>对于一个零测集，任何函数的积分都为 0（因为在实变函数中我们是中认为<span class="math inline">\(0 \cdot \infty= 0\)</span>）</li><li>对于一个非负可测函数，我们通过和特征函数内积来确定在子集上的积分：<span class="math display">\[\int _A f = \int _E f \cdot \chi _ A\]</span></li><li>积分具有保序性</li></ol><p>同时，由于上述的定义中 <strong>可积</strong>这个条件实际上非常宽泛，所以我们很容易得到这样的结论：</p><dl><dt>Theo</dt><dd>有限测度集上的几乎处处有界函数必可积。</dd></dl><p>这是区别于 Riemann 积分很大的一个地方，因为在 Riemann积分中，我们甚至连 dirichlet 函数的积分都无法定义！</p><p>下面介绍一个著名的定理，它揭示了可测函数积分在极限过程中体现出的性质：</p><dl><dt>Levi Theo</dt><dd>设<span class="math inline">\(\{ f _ k \}\)</span>是可测集<spanclass="math inline">\(E\)</span>上的非负可测函数，满足 <spanclass="math inline">\(f_1 \le f_2 \le \cdots\)</span> 且有 <spanclass="math display">\[\lim _ {k \rightarrow \infty} f_k ( x) = f(x), \quad \forall x \in E\]</span> 则有 <span class="math display">\[\lim _ {k \rightarrow \infty} \int _ E f_k (x)\mathrm dx = \int _ E f(x)\mathrm dx\]</span></dd></dl><p>这个定理说明，对于单调、收敛的可测函数，其积分的极限就是极限的积分。</p><h4 id="一般可测函数">一般可测函数</h4><p>通过非负可测函数的积分、将可测函数分为正负两部分，我们可以定义：</p><dl><dt>可测函数积分</dt><dd>设 <span class="math inline">\(f\)</span> 是可测函数，<spanclass="math inline">\(f^+\)</span>和<spanclass="math inline">\(f^-\)</span>至少有一个是可积的，则称 <spanclass="math display">\[\int_E f(x) \mathrm dx = \int _ E f ^+ (x)\mathrm dx - \int _ E f ^ -(x) \mathrm dx\]</span> 是<span class="math inline">\(f\)</span>在<spanclass="math inline">\(E\)</span>上的积分，如果右端两个积分都有限，则称该函数可积<spanclass="math inline">\(f\in \mathcal L(E)\)</span>。</dd></dl><p>显然，其具有这样的简单性质： <span class="math display">\[f\in \mathcal L ( E ) \rightarrow | \int_E f(x)\mathrm dx| \le \int _ E| f(x) | \mathrm dx\]</span></p><dl><dt>Theo Lebesgue可测函数积分性质</dt><dd>对于积分： 1. <span class="math inline">\(|f| &lt; \infty,\quada.e.\)</span> 2. 如果其中一个可积，<span class="math inline">\(f =g\quad a.e.\implies \int f = \int g\)</span> 3. （控制性）若存在 <spanclass="math inline">\(|f| &lt; |g|\in \mathcal L\)</span>，则 <spanclass="math inline">\(f\in \mathcal L\)</span>，且<spanclass="math inline">\(|\int f| \le \int |g|\)</span> 4.对于有限测度集，有界函数都可积</dd><dt>Theo</dt><dd>Lebesgue积分具有线性性</dd></dl><p>下面给出 Lebesgue 积分的等价描述</p><dl><dt>Theo 可积/积分的等价描述</dt><dd>设 <span class="math inline">\(f\)</span>是<strong>有限测度集</strong>上的<strong>有界可测</strong>函数，<spanclass="math inline">\(|f| \le M\)</span>，作<spanclass="math inline">\([-M, M]\)</span>的划分， <spanclass="math display">\[-M = \alpha_0 &lt; \cdots &lt; \alpha_k = M\]</span> 设<span class="math inline">\(E_j= E(\alpha_{j-1} &lt; f &lt;\alpha_j)\)</span>，对于任意的 <span class="math display">\[\eta_j \in [\alpha_{j - 1}, \alpha _ j]\]</span> 极限 <span class="math display">\[\lim_{\max \alpha_j - \alpha_{j-1} \rightarrow 0} \sum_{j = 1} ^ k\eta_j m(E_j)\]</span> 存在，则该极限就是Lebesgue积分。</dd></dl><p>对于Lebesgue积分，其具有绝对连续性（定义域测度充分小，则积分值充分小）：</p><dl><dt>Theo 绝对连续性</dt><dd>设<span class="math inline">\(f\in \mathcalL\)</span>，则对于任意的<span class="math inline">\(\varepsilon &gt;0\)</span>，存在<span class="math inline">\(\delta &gt;0\)</span>，使得对于<strong>任何</strong>的子集<spanclass="math inline">\(A\)</span>，当<span class="math inline">\(m(A)&lt; \delta\)</span>时， <span class="math display">\[|\int_A f(x) \mathrm dx | \le \int_A |f(x)|\mathrm dx \le \varepsilon\]</span></dd></dl><p>当然，对于Lebesgue积分，也有平移不变性。</p><p>我们之前考察了可测和连续的关系，在这里我们也有类似的结论：</p><dl><dt>Theo</dt><dd>对于任意Lebesgue可积函数，对于任意 <spanclass="math inline">\(\varepsilon &gt;0\)</span>，存在一个具有紧支集的连续函数<spanclass="math inline">\(g\)</span>使得 <span class="math display">\[\int_ E| f(x) - g(x) | \mathrm dx &lt; \varepsilon\]</span> 。因此，可以构造具有紧支集的连续函数列<spanclass="math inline">\(g_k\)</span>，使得 <span class="math display">\[\lim_{k\rightarrow \infty}\int_ E| f(x) - g_k(x) | \mathrm dx &lt;\varepsilon, \quad 即 g_k \rightarrow f\quad a.e.\]</span></dd></dl><h4id="riemann积分和lebesgue积分的关系">Riemann积分和Lebesgue积分的关系</h4><dl><dt>Theo Riemann积分和Lebesgue积分值的相等性</dt><dd>闭区间上有界函数<span class="math inline">\(f(x)\)</span> Riemann可积，则它时 Lebesgue 可积的且其积分值相等。</dd></dl><h4 id="测度空间上的可测函数积分">测度空间上的可测函数积分</h4><h3 id="极限定理">极限定理</h3><p>这一节我们考虑极限和Lebesgue积分的互换关系。</p><dl><dt>Lebesgue 基本定理</dt><dd>设<span class="math inline">\(f_n\)</span>是可测集<spanclass="math inline">\(E\)</span>上的非负可测函数列， <spanclass="math display">\[f(x) = \sum_{n = 1} ^ \infty f_n(x)\]</span> 则 <span class="math display">\[\int _ E f(x) \mathrm dx = \sum _ {n = 1} ^ \infty \int _ E f_n (x)\mathrm dx\]</span></dd></dl><blockquote><p>正函数项级数，和函数积分为积分的和。（积分与求和交换）</p></blockquote><p>从上述定理，我们可以应用到定义域上：</p><dl><dt>Col</dt><dd>设 <span class="math inline">\(E = \bigsqcup E_n\)</span>，若<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(E\)</span>上有积分时，<spanclass="math inline">\(f(x)\)</span>在每一个子集<spanclass="math inline">\(E_n\)</span>时有积分的，且 <spanclass="math display">\[\int _ E f(x) \mathrm dx = \sum _ {n = 1} ^ \infty \int _{E_n} f(x)\mathrm dx\]</span></dd></dl><p>我们始终不希望只考虑单调的函数列</p><dl><dt>Fatou 引理</dt><dd>对于非负可测函数列<span class="math inline">\(f_n\)</span>，有 <spanclass="math display">\[\int _ E \lim \inf f_n(x) \mathrm dx \le \lim \inf \int _ Ef_n(x)\mathrm dx\]</span></dd></dl></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;待完善&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="夏令营" scheme="http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    <category term="实变函数" scheme="http://adversarr.github.io/tags/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
