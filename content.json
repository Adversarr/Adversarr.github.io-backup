{"meta":{"title":"逆版本战士の部落格","subtitle":"","description":"Je pense, donc je suis","author":"Adversarr","url":"http://adversarr.github.io","root":"/"},"pages":[{"title":"Adversarr","date":"2022-08-11T02:42:38.499Z","updated":"2022-04-06T03:23:05.436Z","comments":true,"path":"about/index.html","permalink":"http://adversarr.github.io/about/index.html","excerpt":"","text":"个人简历./cv.pdf"},{"title":"逆版本战士都干了些啥？！","date":"2020-05-22T06:16:52.000Z","updated":"2021-12-19T08:58:39.986Z","comments":true,"path":"categories/index.html","permalink":"http://adversarr.github.io/categories/index.html","excerpt":"","text":""},{"title":"Chat or Leave a Message","date":"2020-05-27T07:08:23.000Z","updated":"2021-11-30T03:10:09.770Z","comments":true,"path":"chat/index.html","permalink":"http://adversarr.github.io/chat/index.html","excerpt":"","text":"快来和些些同学的小伙伴们聊天吧~ ヾ|≧_≦|〃"},{"title":"日程","date":"2020-05-26T01:57:51.000Z","updated":"2021-12-13T00:52:05.227Z","comments":true,"path":"schedule/index.html","permalink":"http://adversarr.github.io/schedule/index.html","excerpt":"","text":"并查集和图论 Dependencies# npm install hexo-renderer-pandocnpm install hexo-renderer-kramednpm install hexo-renderer-mathjaxnpm install searchdbnpm install hexo-asset-imagenpm install hexo-deployer-gitnpm i hexo-simple-mindmap 同时，更改了 Fluid 主题的部分内容 tag_plugin.styl 中：.label: font-size 100% // kramed/lib/rules/inline.jsvar inline = &#123; // escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)*?(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;([\\s\\S]*?)?&lt;\\/\\1&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, reffn: /^!?\\[\\^(inside)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ &#123;2,&#125;\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`$]| &#123;2,&#125;\\n|$)/, math: /^\\$\\$\\s*([\\s\\S]*?[^\\$])\\s*\\$\\$(?!\\$)/,&#125;; update to 1.8.6 Fluid.： in fluid/languages/zh-CN.yaml schedule: title: 日程 subtitle: 近期日程安排"},{"title":"逆版本战士都干了些啥？！","date":"2020-05-22T06:15:15.000Z","updated":"2021-12-19T08:58:12.477Z","comments":false,"path":"tags/index.html","permalink":"http://adversarr.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-11T02:42:38.497Z","updated":"2021-11-30T03:10:09.771Z","comments":true,"path":"js/mathjax.js","permalink":"http://adversarr.github.io/js/mathjax.js","excerpt":"","text":"/* * /MathJax.js * * Copyright (c) 2009-2017 The MathJax Consortium * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ if (document.getElementById && document.childNodes && document.createElement) { if (!(window.MathJax && MathJax.Hub)) { if (window.MathJax) { window.MathJax = { AuthorConfig: window.MathJax } } else { window.MathJax = {} } MathJax.isPacked = true; MathJax.version = \"2.7.1\"; MathJax.fileversion = \"2.7.1\"; MathJax.cdnVersion = \"2.7.1\"; MathJax.cdnFileVersions = {}; (function(d) { var b = window[d]; if (!b) { b = window[d] = {} } var e = []; var c = function(f) { var g = f.constructor; if (!g) { g = function() {} } for (var h in f) { if (h !== \"constructor\" && f.hasOwnProperty(h)) { g[h] = f[h] } } return g }; var a = function() { return function() { return arguments.callee.Init.call(this, arguments) } }; b.Object = c({ constructor: a(), Subclass: function(f, h) { var g = a(); g.SUPER = this; g.Init = this.Init; g.Subclass = this.Subclass; g.Augment = this.Augment; g.protoFunction = this.protoFunction; g.can = this.can; g.has = this.has; g.isa = this.isa; g.prototype = new this(e); g.prototype.constructor = g; g.Augment(f, h); return g }, Init: function(f) { var g = this; if (f.length === 1 && f[0] === e) { return g } if (!(g instanceof f.callee)) { g = new f.callee(e) } return g.Init.apply(g, f) || g }, Augment: function(f, g) { var h; if (f != null) { for (h in f) { if (f.hasOwnProperty(h)) { this.protoFunction(h, f[h]) } } if (f.toString !== this.prototype.toString && f.toString !== {}.toString) { this.protoFunction(\"toString\", f.toString) } } if (g != null) { for (h in g) { if (g.hasOwnProperty(h)) { this[h] = g[h] } } } return this }, protoFunction: function(g, f) { this.prototype[g] = f; if (typeof f === \"function\") { f.SUPER = this.SUPER.prototype } }, prototype: { Init: function() {}, SUPER: function(f) { return f.callee.SUPER }, can: function(f) { return typeof(this[f]) === \"function\" }, has: function(f) { return typeof(this[f]) !== \"undefined\" }, isa: function(f) { return (f instanceof Object) && (this instanceof f) } }, can: function(f) { return this.prototype.can.call(this, f) }, has: function(f) { return this.prototype.has.call(this, f) }, isa: function(g) { var f = this; while (f) { if (f === g) { return true } else { f = f.SUPER } } return false }, SimpleSUPER: c({ constructor: function(f) { return this.SimpleSUPER.define(f) }, define: function(f) { var h = {}; if (f != null) { for (var g in f) { if (f.hasOwnProperty(g)) { h[g] = this.wrap(g, f[g]) } } if (f.toString !== this.prototype.toString && f.toString !== {}.toString) { h.toString = this.wrap(\"toString\", f.toString) } } return h }, wrap: function(i, h) { if (typeof(h) !== \"function\" || !h.toString().match(/\\.\\s*SUPER\\s*\\(/)) { return h } var g = function() { this.SUPER = g.SUPER[i]; try { var f = h.apply(this, arguments) } catch (j) { delete this.SUPER; throw j } delete this.SUPER; return f }; g.toString = function() { return h.toString.apply(h, arguments) }; return g } }) }); b.Object.isArray = Array.isArray || function(f) { return Object.prototype.toString.call(f) === \"[object Array]\" }; b.Object.Array = Array })(\"MathJax\"); (function(BASENAME) { var BASE = window[BASENAME]; if (!BASE) { BASE = window[BASENAME] = {} } var isArray = BASE.Object.isArray; var CALLBACK = function(data) { var cb = function() { return arguments.callee.execute.apply(arguments.callee, arguments) }; for (var id in CALLBACK.prototype) { if (CALLBACK.prototype.hasOwnProperty(id)) { if (typeof(data[id]) !== \"undefined\") { cb[id] = data[id] } else { cb[id] = CALLBACK.prototype[id] } } } cb.toString = CALLBACK.prototype.toString; return cb }; CALLBACK.prototype = { isCallback: true, hook: function() {}, data: [], object: window, execute: function() { if (!this.called || this.autoReset) { this.called = !this.autoReset; return this.hook.apply(this.object, this.data.concat([].slice.call(arguments, 0))) } }, reset: function() { delete this.called }, toString: function() { return this.hook.toString.apply(this.hook, arguments) } }; var ISCALLBACK = function(f) { return (typeof(f) === \"function\" && f.isCallback) }; var EVAL = function(code) { return eval.call(window, code) }; var TESTEVAL = function() { EVAL(\"var __TeSt_VaR__ = 1\"); if (window.__TeSt_VaR__) { try { delete window.__TeSt_VaR__ } catch (error) { window.__TeSt_VaR__ = null } } else { if (window.execScript) { EVAL = function(code) { BASE.__code = code; code = \"try {\" + BASENAME + \".__result = eval(\" + BASENAME + \".__code)} catch(err) {\" + BASENAME + \".__result = err}\"; window.execScript(code); var result = BASE.__result; delete BASE.__result; delete BASE.__code; if (result instanceof Error) { throw result } return result } } else { EVAL = function(code) { BASE.__code = code; code = \"try {\" + BASENAME + \".__result = eval(\" + BASENAME + \".__code)} catch(err) {\" + BASENAME + \".__result = err}\"; var head = (document.getElementsByTagName(\"head\"))[0]; if (!head) { head = document.body } var script = document.createElement(\"script\"); script.appendChild(document.createTextNode(code)); head.appendChild(script); head.removeChild(script); var result = BASE.__result; delete BASE.__result; delete BASE.__code; if (result instanceof Error) { throw result } return result } } } TESTEVAL = null }; var USING = function(args, i) { if (arguments.length > 1) { if (arguments.length === 2 && !(typeof arguments[0] === \"function\") && arguments[0] instanceof Object && typeof arguments[1] === \"number\") { args = [].slice.call(args, i) } else { args = [].slice.call(arguments, 0) } } if (isArray(args) && args.length === 1) { args = args[0] } if (typeof args === \"function\") { if (args.execute === CALLBACK.prototype.execute) { return args } return CALLBACK({ hook: args }) } else { if (isArray(args)) { if (typeof(args[0]) === \"string\" && args[1] instanceof Object && typeof args[1][args[0]] === \"function\") { return CALLBACK({ hook: args[1][args[0]], object: args[1], data: args.slice(2) }) } else { if (typeof args[0] === \"function\") { return CALLBACK({ hook: args[0], data: args.slice(1) }) } else { if (typeof args[1] === \"function\") { return CALLBACK({ hook: args[1], object: args[0], data: args.slice(2) }) } } } } else { if (typeof(args) === \"string\") { if (TESTEVAL) { TESTEVAL() } return CALLBACK({ hook: EVAL, data: [args] }) } else { if (args instanceof Object) { return CALLBACK(args) } else { if (typeof(args) === \"undefined\") { return CALLBACK({}) } } } } } throw Error(\"Can't make callback from given data\") }; var DELAY = function(time, callback) { callback = USING(callback); callback.timeout = setTimeout(callback, time); return callback }; var WAITFOR = function(callback, signal) { callback = USING(callback); if (!callback.called) { WAITSIGNAL(callback, signal); signal.pending++ } }; var WAITEXECUTE = function() { var signals = this.signal; delete this.signal; this.execute = this.oldExecute; delete this.oldExecute; var result = this.execute.apply(this, arguments); if (ISCALLBACK(result) && !result.called) { WAITSIGNAL(result, signals) } else { for (var i = 0, m = signals.length; i < m; i++) { signals[i].pending--; if (signals[i].pending"}],"posts":[],"categories":[],"tags":[]}