{"meta":{"title":"逆版本战士の部落格","subtitle":"","description":"Je pense, donc je suis","author":"Adversarr","url":"http://adversarr.github.io","root":"/"},"pages":[{"title":"逆版本战士都干了些啥？！","date":"2020-05-22T06:16:52.000Z","updated":"2021-12-19T08:58:39.986Z","comments":true,"path":"categories/index.html","permalink":"http://adversarr.github.io/categories/index.html","excerpt":"","text":""},{"title":"Adversarr","date":"2022-04-11T09:06:47.151Z","updated":"2022-04-06T03:23:05.436Z","comments":true,"path":"about/index.html","permalink":"http://adversarr.github.io/about/index.html","excerpt":"","text":"个人简历./cv.pdf"},{"title":"Chat or Leave a Message","date":"2020-05-27T07:08:23.000Z","updated":"2021-11-30T03:10:09.770Z","comments":true,"path":"chat/index.html","permalink":"http://adversarr.github.io/chat/index.html","excerpt":"","text":"快来和些些同学的小伙伴们聊天吧~ ヾ|≧_≦|〃"},{"title":"","date":"2022-04-11T09:06:47.150Z","updated":"2021-11-30T03:10:09.771Z","comments":true,"path":"js/mathjax.js","permalink":"http://adversarr.github.io/js/mathjax.js","excerpt":"","text":"/* * /MathJax.js * * Copyright (c) 2009-2017 The MathJax Consortium * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ if (document.getElementById && document.childNodes && document.createElement) { if (!(window.MathJax && MathJax.Hub)) { if (window.MathJax) { window.MathJax = { AuthorConfig: window.MathJax } } else { window.MathJax = {} } MathJax.isPacked = true; MathJax.version = \"2.7.1\"; MathJax.fileversion = \"2.7.1\"; MathJax.cdnVersion = \"2.7.1\"; MathJax.cdnFileVersions = {}; (function(d) { var b = window[d]; if (!b) { b = window[d] = {} } var e = []; var c = function(f) { var g = f.constructor; if (!g) { g = function() {} } for (var h in f) { if (h !== \"constructor\" && f.hasOwnProperty(h)) { g[h] = f[h] } } return g }; var a = function() { return function() { return arguments.callee.Init.call(this, arguments) } }; b.Object = c({ constructor: a(), Subclass: function(f, h) { var g = a(); g.SUPER = this; g.Init = this.Init; g.Subclass = this.Subclass; g.Augment = this.Augment; g.protoFunction = this.protoFunction; g.can = this.can; g.has = this.has; g.isa = this.isa; g.prototype = new this(e); g.prototype.constructor = g; g.Augment(f, h); return g }, Init: function(f) { var g = this; if (f.length === 1 && f[0] === e) { return g } if (!(g instanceof f.callee)) { g = new f.callee(e) } return g.Init.apply(g, f) || g }, Augment: function(f, g) { var h; if (f != null) { for (h in f) { if (f.hasOwnProperty(h)) { this.protoFunction(h, f[h]) } } if (f.toString !== this.prototype.toString && f.toString !== {}.toString) { this.protoFunction(\"toString\", f.toString) } } if (g != null) { for (h in g) { if (g.hasOwnProperty(h)) { this[h] = g[h] } } } return this }, protoFunction: function(g, f) { this.prototype[g] = f; if (typeof f === \"function\") { f.SUPER = this.SUPER.prototype } }, prototype: { Init: function() {}, SUPER: function(f) { return f.callee.SUPER }, can: function(f) { return typeof(this[f]) === \"function\" }, has: function(f) { return typeof(this[f]) !== \"undefined\" }, isa: function(f) { return (f instanceof Object) && (this instanceof f) } }, can: function(f) { return this.prototype.can.call(this, f) }, has: function(f) { return this.prototype.has.call(this, f) }, isa: function(g) { var f = this; while (f) { if (f === g) { return true } else { f = f.SUPER } } return false }, SimpleSUPER: c({ constructor: function(f) { return this.SimpleSUPER.define(f) }, define: function(f) { var h = {}; if (f != null) { for (var g in f) { if (f.hasOwnProperty(g)) { h[g] = this.wrap(g, f[g]) } } if (f.toString !== this.prototype.toString && f.toString !== {}.toString) { h.toString = this.wrap(\"toString\", f.toString) } } return h }, wrap: function(i, h) { if (typeof(h) !== \"function\" || !h.toString().match(/\\.\\s*SUPER\\s*\\(/)) { return h } var g = function() { this.SUPER = g.SUPER[i]; try { var f = h.apply(this, arguments) } catch (j) { delete this.SUPER; throw j } delete this.SUPER; return f }; g.toString = function() { return h.toString.apply(h, arguments) }; return g } }) }); b.Object.isArray = Array.isArray || function(f) { return Object.prototype.toString.call(f) === \"[object Array]\" }; b.Object.Array = Array })(\"MathJax\"); (function(BASENAME) { var BASE = window[BASENAME]; if (!BASE) { BASE = window[BASENAME] = {} } var isArray = BASE.Object.isArray; var CALLBACK = function(data) { var cb = function() { return arguments.callee.execute.apply(arguments.callee, arguments) }; for (var id in CALLBACK.prototype) { if (CALLBACK.prototype.hasOwnProperty(id)) { if (typeof(data[id]) !== \"undefined\") { cb[id] = data[id] } else { cb[id] = CALLBACK.prototype[id] } } } cb.toString = CALLBACK.prototype.toString; return cb }; CALLBACK.prototype = { isCallback: true, hook: function() {}, data: [], object: window, execute: function() { if (!this.called || this.autoReset) { this.called = !this.autoReset; return this.hook.apply(this.object, this.data.concat([].slice.call(arguments, 0))) } }, reset: function() { delete this.called }, toString: function() { return this.hook.toString.apply(this.hook, arguments) } }; var ISCALLBACK = function(f) { return (typeof(f) === \"function\" && f.isCallback) }; var EVAL = function(code) { return eval.call(window, code) }; var TESTEVAL = function() { EVAL(\"var __TeSt_VaR__ = 1\"); if (window.__TeSt_VaR__) { try { delete window.__TeSt_VaR__ } catch (error) { window.__TeSt_VaR__ = null } } else { if (window.execScript) { EVAL = function(code) { BASE.__code = code; code = \"try {\" + BASENAME + \".__result = eval(\" + BASENAME + \".__code)} catch(err) {\" + BASENAME + \".__result = err}\"; window.execScript(code); var result = BASE.__result; delete BASE.__result; delete BASE.__code; if (result instanceof Error) { throw result } return result } } else { EVAL = function(code) { BASE.__code = code; code = \"try {\" + BASENAME + \".__result = eval(\" + BASENAME + \".__code)} catch(err) {\" + BASENAME + \".__result = err}\"; var head = (document.getElementsByTagName(\"head\"))[0]; if (!head) { head = document.body } var script = document.createElement(\"script\"); script.appendChild(document.createTextNode(code)); head.appendChild(script); head.removeChild(script); var result = BASE.__result; delete BASE.__result; delete BASE.__code; if (result instanceof Error) { throw result } return result } } } TESTEVAL = null }; var USING = function(args, i) { if (arguments.length > 1) { if (arguments.length === 2 && !(typeof arguments[0] === \"function\") && arguments[0] instanceof Object && typeof arguments[1] === \"number\") { args = [].slice.call(args, i) } else { args = [].slice.call(arguments, 0) } } if (isArray(args) && args.length === 1) { args = args[0] } if (typeof args === \"function\") { if (args.execute === CALLBACK.prototype.execute) { return args } return CALLBACK({ hook: args }) } else { if (isArray(args)) { if (typeof(args[0]) === \"string\" && args[1] instanceof Object && typeof args[1][args[0]] === \"function\") { return CALLBACK({ hook: args[1][args[0]], object: args[1], data: args.slice(2) }) } else { if (typeof args[0] === \"function\") { return CALLBACK({ hook: args[0], data: args.slice(1) }) } else { if (typeof args[1] === \"function\") { return CALLBACK({ hook: args[1], object: args[0], data: args.slice(2) }) } } } } else { if (typeof(args) === \"string\") { if (TESTEVAL) { TESTEVAL() } return CALLBACK({ hook: EVAL, data: [args] }) } else { if (args instanceof Object) { return CALLBACK(args) } else { if (typeof(args) === \"undefined\") { return CALLBACK({}) } } } } } throw Error(\"Can't make callback from given data\") }; var DELAY = function(time, callback) { callback = USING(callback); callback.timeout = setTimeout(callback, time); return callback }; var WAITFOR = function(callback, signal) { callback = USING(callback); if (!callback.called) { WAITSIGNAL(callback, signal); signal.pending++ } }; var WAITEXECUTE = function() { var signals = this.signal; delete this.signal; this.execute = this.oldExecute; delete this.oldExecute; var result = this.execute.apply(this, arguments); if (ISCALLBACK(result) && !result.called) { WAITSIGNAL(result, signals) } else { for (var i = 0, m = signals.length; i < m; i++) { signals[i].pending--; if (signals[i].pending"},{"title":"日程","date":"2020-05-26T01:57:51.000Z","updated":"2021-12-13T00:52:05.227Z","comments":true,"path":"schedule/index.html","permalink":"http://adversarr.github.io/schedule/index.html","excerpt":"","text":"并查集和图论 Dependencies# npm install hexo-renderer-pandocnpm install hexo-renderer-kramednpm install hexo-renderer-mathjaxnpm install searchdbnpm install hexo-asset-imagenpm install hexo-deployer-gitnpm i hexo-simple-mindmap 同时，更改了 Fluid 主题的部分内容 tag_plugin.styl 中：.label: font-size 100% // kramed/lib/rules/inline.jsvar inline = &#123; // escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)*?(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;([\\s\\S]*?)?&lt;\\/\\1&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, reffn: /^!?\\[\\^(inside)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ &#123;2,&#125;\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`$]| &#123;2,&#125;\\n|$)/, math: /^\\$\\$\\s*([\\s\\S]*?[^\\$])\\s*\\$\\$(?!\\$)/,&#125;; update to 1.8.6 Fluid.： in fluid/languages/zh-CN.yaml schedule: title: 日程 subtitle: 近期日程安排"},{"title":"逆版本战士都干了些啥？！","date":"2020-05-22T06:15:15.000Z","updated":"2021-12-19T08:58:12.477Z","comments":false,"path":"tags/index.html","permalink":"http://adversarr.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"CG/Seminar2022/2022-08-07","date":"2022-08-07T03:03:38.912Z","updated":"2022-08-07T03:03:38.912Z","comments":true,"path":"2022/08/07/CG/Seminar2022/2022-08-07/","link":"","permalink":"http://adversarr.github.io/2022/08/07/CG/Seminar2022/2022-08-07/","excerpt":"","text":"Seminar 2022-0807 1 基于PD方法，处理PD中的体积弹性体的碰撞方法。 事先知道发生碰撞的区域 碰撞区域涉及的点集应只占一小部分 背景 隐式时间积分： \\[ \\min \\frac{1}{2h^2}(x_{n+1} -y)&#39; M(x_{n+1}-y)+W(x_{n+1}) \\] 惯性势能 弹性势能 思想： local -- 固定\\(x\\)，解\\(d\\) global -- 固定 \\(d\\)，求解 \\(x\\) TODO： Local-Global https://www.youtube.com/watch?v=4Vk7Ar3COJA https://www.projectivedynamics.org/Projective_Dynamics/index.html 碰撞： 在可能发生的碰撞对上添加弹簧 方法 碰撞区域和其他区域分离（为\\(x_1, x_2\\))： \\[ \\vec x = (x_1~x_2)&#39; \\] 故碰撞更改的矩阵只存在于\\(x_2,x_2\\)部分。使用舒尔补分解。 碰撞区域local部分不影响碰撞部分。 非碰撞域的local计算在碰撞迭代前的计算。 总结 效率要求数量级较大时才能实现 实现碰撞区域较小且静态 2 裂纹仿真 无网格cdm模型，物质点法 根据材料损伤来提取裂纹表面 速度不连续 无体积损失 核心： #Voronoi图 #物理应力 运动描述（MPM） \\[ \\mathbf x = \\mathbf x(X, t) = \\phi (X, t) \\] ... 用粒子描述质量和速度等物理量，用核函数传递到网格，再在网格上计算相关物理量传递回粒子。 P2G G Update G2P P Update Fracture Dynamics 修正MPM相关应力 Enforce Discontinuity 避免穿模，做出接触处理，修正速度（接触力） 碎片裂缝 使用Voronoi图嵌入方法来近似裂纹。 断裂区域：BFS搜索所有Voronoi Cell 增强面细节 可能断面过于光滑。 通过记录材料损伤时间，来实现细节增强。 limits 仍然使用Voronoi 图提取（依赖于图结构） 不适用于薄壳材料 碎片细节增强不可控 Future work: Breaking Good: Fracture Modes for Realtime Destruction SIGGRAPH Asia 2022 IGGRAPH Asia 2022 3. An efficient B-spline Lagrangian/Eulerian Method for Compressible Flow, Shock waves, and Fracturing Solids 爆炸 -- 冲击波 -- 表现为可压缩流体团 相关工作： 不可压缩流体、MPM固体 难点： 用粒子和稀疏网格表示流体域不再可行 更加精确的advection，如WENO 隐式积分相关线性系统不保证SPD 可压缩流体公式。（参考games） 贡献：强耦合、整体的、支持破裂、破坏性 描述 （对固体用mpm） P2G Moving Interface Identification: 确定分界面上的相互作用 界面建模为反射墙、可通行通道的混合体：定义混合比 B-Spline-Based Spatial Discretization. 4. 可变形体仿真 给定模型在外力共同作用下的静平衡，作为积分的初值。 以前的缺陷： 局限于特定的仿真系统 大多数无法应对含有摩擦的接触 求解大规模的全局的非线性优化 接触和摩擦对应的约束 静摩擦模型： 压力在接触面法向上产生 静摩擦力在切向产生，大小为一不等式约束（非线性） Local 求解内力后，利用内力信息推算各个局部的松弛状态。 e.g. 用内力求弹簧原长 推广到 PBD Limitations 不能显式算出理想状态 内力约束必须线性 可拆为masses和elements Inverse Design: An Asymptotic Numerical Method for Inverse Elastic Shape Design.","categories":[],"tags":[]},{"title":"GAMES 201 - 06 - 线性弹性有限元、拓扑优化","slug":"CG/GAMES/g201-06","date":"2022-08-04T16:00:00.000Z","updated":"2022-08-05T08:01:58.699Z","comments":true,"path":"2022/08/05/CG/GAMES/g201-06/","link":"","permalink":"http://adversarr.github.io/2022/08/05/CG/GAMES/g201-06/","excerpt":"GAMES 201 - 06 - 线性弹性有限元、拓扑优化","text":"GAMES 201 - 06 - 线性弹性有限元、拓扑优化 FEM Overview Galerkin 方法的一种。将连续的PDE，转换为离散的线性系统 类似的还有物质点法（MPM）。（FEM是一种无元素的Galerkin方法） 将Strong-Form PDE转换为Weak-Form: 利用 test function \\(w\\) 分部积分，简化方程 散度定理 离散化 求解 2d-泊松方程 \\[ \\nabla \\cdot \\nabla u = 0 \\] 以及四个边界： 三个Dirichlet边界：\\(u(x) = f(x), x\\in \\partial \\Omega\\) 一个Neumann边界：\\(\\nabla u(x) \\cdot n = g(x)\\) Weak-Formulation 任取的2d-test function\\(w\\)： \\[ \\nabla \\cdot \\nabla u = 0 \\iff \\forall w, \\iint _ \\Omega w (\\nabla \\cdot \\nabla u) \\mathrm d A = 0 \\] 分部积分去除二阶导数 \\[ w\\nabla \\cdot \\nabla u + \\nabla w\\cdot \\nabla u = \\nabla (w \\nabla u) \\implies \\nabla w\\cdot \\nabla u = \\nabla (w \\nabla u) \\] 利用散度定理(RHS) \\[ \\iint _ \\Omega \\nabla w \\cdot \\nabla u \\mathrm dA = \\oint _{\\partial \\Omega} w \\nabla u \\cdot \\mathrm d\\mathbf n \\] 离散泊松方程 取定基函数，表示\\(u\\) \\[ u(x) = \\sum_j u _ j \\phi _ j (x) \\] comsol - multiphysics - fem. 并且直接用 \\(\\phi\\) 替换 \\(w\\) \\[ \\forall i, \\quad \\sum _ j (\\iint \\nabla \\phi _ i \\cdot \\nabla \\phi _ j \\mathrm dA) u_j = \\oint _ {\\partial \\Omega} \\phi _ j \\nabla u \\cdot \\mathrm dn \\] 即 \\[ Ku = f \\] \\(K\\): stiffness matrix \\(u\\): solution vector \\(f\\): load vector \\[ K_{ij} = \\iint _{\\Omega} \\nabla \\phi_i \\cdot \\nabla \\phi _ j \\mathrm dA \\] 右端： Dirichlet 边界条件：\\(u(x) = f(x)\\implies u_i = f(x_i)\\) Neumann 边界条件：\\(\\nabla u (x) \\cdot n = g(x)\\): 将 \\(g\\) 插入方程右端，作为 \\(f\\) 的非零项。 线性弹性有限元 柯西动量方程： \\[ \\frac{Dv}{Dt} = \\frac 1 \\rho \\nabla \\cdot \\sigma + g \\] 准静态（\\(v = 0\\), 常密度，无重力）情况下： \\[ \\nabla \\cdot \\sigma = 0 \\] Index Notation（参考微分几何-爱因斯坦记号） 用 \\(\\alpha,\\beta, \\gamma\\) 表示。 \\[ \\frac{Dv}{Dt} = \\frac 1 \\rho \\nabla \\cdot \\sigma + g \\iff \\frac{Dv_\\alpha}{Dt} = \\frac 1 \\rho \\sum _ \\beta \\frac{\\partial\\sigma_{\\alpha \\beta}}{\\partial x _ \\beta} + g_\\alpha \\] 拓扑优化 Minimal Compliance Topology Optimization \\[ \\begin{aligned} \\min L(\\rho) = u^TK(\\rho) u\\\\ s.t. Ku = f\\\\ \\sum_e \\rho_ e \\le cV\\\\ \\rho _ e \\in [\\rho_\\min, 1] \\end{aligned} \\] \\(L\\)：描述物质形变大小 \\(c\\)：体积系数 \\(\\rho_e\\)：0表示空，1表示填充 \\(V\\)：总体积 SIMP OC","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}],"author":"Clover"},{"title":"GAMES201-多体问题和涡方法","slug":"CG/GAMES/g201-05","date":"2022-08-03T16:00:00.000Z","updated":"2022-08-05T02:08:10.561Z","comments":true,"path":"2022/08/04/CG/GAMES/g201-05/","link":"","permalink":"http://adversarr.github.io/2022/08/04/CG/GAMES/g201-05/","excerpt":"GAMES201-多体问题和涡方法","text":"GAMES201-多体问题和涡方法 多体问题 - Introduction to Fast Simulation 例如：万有引力 \\[ f(x) = \\nabla \\phi \\] 使用快速多级展开 -- 线性时间内求解\\(n^2\\)的问题 2d-泊松方程 考察给定原点，和在\\(z\\)处的势能，使用泰勒（洛朗）展开 多极点的情况下： \\[ \\phi(z) = \\sum q_j \\log (z - z_j)= (\\sum q_j \\log z) - \\sum_{k = 1}^p \\frac {\\sum _ j q_j z_j ^ k}{z^k}\\quad Q_k = - \\sum _ j \\frac{q_j z_j^k}{k} \\] Tree Code 类似于图像金字塔，网格划分。 快速多级展开 思路：从一个Multipole到另一个Multipole直接计算，即在已经计算过的点处进行展开： \\[ \\begin{aligned} \\phi(z) = Q\\log(z - z_2) + \\sum_{k = 1} ^ p \\frac {b_k}{z^k} = Q\\log z + \\sum_{k = 1} ^ p \\frac {Q_k}{z^k} \\end{aligned} \\] 其中的 \\(b_k\\) 是对于 \\(Q_k\\) 的泛化 （M2M变换） \\[ b_k = - \\frac{Q (z_1 - z_2) ^ k}{k} + \\sum_{i = 1} ^ k Q_i (z_1-z_2)^{k-i} C^{k-1}_{i-1} \\] M2M Transform, M2L Transform ......","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}],"author":"Clover"},{"title":"MIT-微分方程-03","slug":"study/Math/ODEs/lec3","date":"2022-08-03T16:00:00.000Z","updated":"2022-08-06T12:00:23.418Z","comments":true,"path":"2022/08/04/study/Math/ODEs/lec3/","link":"","permalink":"http://adversarr.github.io/2022/08/04/study/Math/ODEs/lec3/","excerpt":"一阶线性微分方程","text":"一阶线性微分方程 一阶线性微分方程 标准形式： \\[ y&#39; + p(x) y = q(x) \\] 在建模中的应用 Temp-conc. （温度扩散） Mixing Decay, bank account. … 传导方程（Conduction）： 设\\(T\\)为温度，\\(t\\)为时间： \\[ \\frac {d T}{dt} = k(T_e - T) \\] 扩散模型（Diffusion） 设\\(C\\)为浓度，\\(C_e\\) 是环境浓度： \\[ \\frac{dC}{dt} = k (C_e - C) \\] 求解方法 积分因子法 利用 Integrating factor（积分因子） \\(u(x)\\) 同乘\\(u\\) \\[ uy&#39; + puy = qu \\] 希望： \\[ uy&#39;+puy=(...)&#39; \\] 如果\\(...=uy\\)，则要求\\(u&#39; = pu\\) 那么\\(u = e ^{\\int p\\cdot\\mathrm dx}\\) 例如：\\(xy&#39; - y = x^3\\) \\(y&#39;-y/x = x^2\\) \\(u = \\frac 1 x\\) \\((y/x)&#39; = x\\) \\(y = x ^ 3 / 2 + Cx\\) 方法总结: Standard Form 计算 \\(u = e ^{\\int p dx}\\) 积分因子 两侧同乘 \\(u\\) Linear with k constant 例如： \\[ \\frac{dT}{dt} + kT = k T_e \\] \\[ u = e ^ { k T } \\]","categories":[],"tags":[],"author":"Clover"},{"title":"0731 Seminar","slug":"CG/Seminar2022/0731","date":"2022-07-30T16:00:00.000Z","updated":"2022-07-31T02:00:23.356Z","comments":true,"path":"2022/07/31/CG/Seminar2022/0731/","link":"","permalink":"http://adversarr.github.io/2022/07/31/CG/Seminar2022/0731/","excerpt":"{random}","text":"{random} 基于粒子的流固耦合 之前问题： 时间步长较大时出现artifact（不自然的空洞） 前置知识 参考GAMES201. NS方程 4种模型 有限控制体模型 无穷小微团 连续性方程（质量守恒） \\[ \\frac {D \\rho}{Dt} + \\rho \\nabla\\cdot v = 0 \\] 利用散度方程简化。 不可压缩流体：\\(\\nabla \\cdot v = 0\\) 动量方程 \\[ m a = f_{ext} + f_{pres} + f_{visc} \\] SPH方法 耦合 在模拟上使用了两个本构方程 思路： 将固体mesh转换为粒子求解。 Go Green 建模工具","categories":[],"tags":[],"author":"Clover"},{"title":"Seminar 20220702","slug":"CG/Seminar2022/0702","date":"2022-07-27T16:00:00.000Z","updated":"2022-07-28T13:37:43.674Z","comments":true,"path":"2022/07/28/CG/Seminar2022/0702/","link":"","permalink":"http://adversarr.github.io/2022/07/28/CG/Seminar2022/0702/","excerpt":"物理仿真专题1","text":"物理仿真专题1 Adaptive Rigidification of Elastic Solids 在弹性体模拟仿真中，通过将一部分视为刚体，来加速仿真 自适应刚体化 优点：不依赖于物体的材料、适用于多种超弹性滚动模型？ 模拟 弹性FEM模拟 \\[ M \\ddot x = D \\dot x + K x + f_{ext} \\] 其中的\\(D = \\alpha _ 0 M + \\alpha _ 1 K\\) 转化为半隐式欧拉积分格式 – 和传统方法相同 刚体模拟 \\[ M_R \\Delta \\phi = h (c(\\phi) + w _ {ext}) \\] 6自由度 最终更新方法 \\[ \\begin{aligned} x_i = Rr_i + p\\\\ \\dot x_i = - (R r_i) \\times \\omega + v\\\\ \\dot x_i = [I - (Rr_i)^\\times] [v\\quad w]&#39; \\end{aligned} \\] 即： \\[ \\dot x = \\begin{bmatrix} I &amp; 0\\\\ 0 &amp; \\Gamma \\end{bmatrix} [\\dot x_A ~ \\phi]&#39; \\] 刚体化 判断准则 考虑 Green Strain Tensor： \\[ E = \\frac 1 2 (F&#39;F - I) \\] 计算变化率： \\[ \\dot E_k = \\frac {E_k - E_{k - 1}}{h} \\] 如果连续几步变化率都很小，那么当作刚体处理。 如何标定刚体的范围 BFS搜索（并查集） 弹性体化 快速求解：Imcomplete Cholesky Factorization. 优点：传递力的时候会传递到更远的点 刚度矩阵 常数近似 – constant Hessian approximation based on mesh Laplacian 引用Tiantian Liu的一个拟牛顿法 Limitations 只做了四面体网格（更高阶的没做） 单个物体、两个物体 Extra 跑两遍 – 第一遍跑出来决定哪些是刚的 A GPU-Based Multilevel Additive Schwarz Preconditioner for Cloth and Deformable Body Simulation — Style 3D Related Blogs: https://zhuanlan.zhihu.com/p/179956655 开发了很多的实时布料和课变形体仿真的MAS（Multilevel Additive Schwarz）预处理器 线性、非线性求解器 仿真的顶点数从5w提升到50w Background 布料和可变形体仿真– 无约束非线性优化问题 牛顿法 求解（例如PCG - 矩阵预处理） AS-Preconditioner 2-level Additive Schwarz Preconditioner. Overview 3部分 多层级域的构造 子域逆矩阵预计算 运行时预计算 多层级域的构造 域的拆分 基于莫顿码进行定点的重排 采用非重叠域 粗化空间构造 按排序好的节点，按顺序和层次分组为超节点 一般超节点的大小和域的大小相同 子域矩阵预计算 对每个域的子矩阵，快速求解并维护其逆矩阵 运行时与计算 在每个层级的每个域内进行计算，得到的量进行加和 多次对称矩阵和向量相乘。 Limitations 不能作为单独的求解器 对于自适应网格的处理差 定点的个数数量级增加，求解效率变化不如多重网格 非线性求解器下，每次非线性迭代中更新系统矩阵导致大量的计算 Penetration Free on GPU IPC + Projective Dynamics A-Jacobi Faster ccd 转化为最小化问题： \\[ \\arg \\min E(x, \\dot x) + \\Psi (x),\\quad E = \\frac 1 {2h^2} \\| M^{1/2} ( x - z ) \\|^2 _F \\] 结合IPC的PD 变分： \\[ ...+B(x) \\] \\(B\\)为障碍项。 还会出现CCD剪枝后不收敛的问题 A-Jacobi 在普通的Jacobi中展开更多项，减少通信开销。 Cubic CCD 快速根近似 只需要近似知道区间即可。 Quanti 量化：减少数值精度、提升FEM分辨率 自动量化： 指定最大错误率、内存占用，自动生成策略 通过偏导求出各个变量上的误差限。 The Power Partical-In-Cell Method 流体模拟： 对 Power Particle 重新表述 基于 Power Particle 和PIC重新计算传输权重 Power Diagram TODOs 超弹性模型","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"物理仿真","slug":"物理仿真","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86%E4%BB%BF%E7%9C%9F/"}],"author":"Clover"},{"title":"MIT 微分方程 01-02","slug":"study/Math/ODEs/lec1-2","date":"2022-07-26T16:00:00.000Z","updated":"2022-08-04T02:04:59.972Z","comments":true,"path":"2022/07/27/study/Math/ODEs/lec1-2/","link":"","permalink":"http://adversarr.github.io/2022/07/27/study/Math/ODEs/lec1-2/","excerpt":"{random}","text":"{random} First Order ODE 形式如下 \\[ y&#39; = f(x, y) \\] 例如： \\(y&#39; = x - y ^ 2\\) \\(y&#39; = x/y\\) 两个方程的解的难度完全不同：1没有初等函数解。 Geometry View of ODE \\[ y&#39; = f(x, y) \\] 设\\(y_1\\)是其中一个解，在微分几何中： \\(y&#39;\\) 对应到一个方向场 \\(y\\) 对应一个积分曲线 – 在方向场中，切线方向始终与该处方向向量平行。 即微分方程解的图像。 我们有： \\(y_0\\) 是解 当且仅当 \\(y_0\\) 是一个积分曲线 结论： 两个积分曲线互不相交（不能有不同的斜率） 两个积分曲线甚至不能相切：存在+唯一 数值方法 IVP：初值问题 : \\[ y&#39; = f(x, y) \\quad y(x_0) = y _ 0 \\] 使用Euler方法进行计算：（一阶方法） 根据 \\(x_0, y _0\\) 算出 \\(y&#39;_0\\) 递增\\((x_0+h, y_0+y_0&#39;\\cdot h)\\) 递推即可 例如： def f(x, y): return x**2 - y**2def euler(x0, y0, h, n): x = [x0, ] y = [y0, ] for i in range(n): x.append(x[-1] + h) y.append(y[-1] + h * f(x[-1], y[-1])) return x, yplt.plot(*euler(0, 1, 0.1, 10)); plt.show() 改进： 采用更小的步长 Having the step size, having the error. 更好的方法 龙哥库塔-RK2 Standard Method：RK4！ 数值计算中的常见问题 \\(y&#39;=y^2\\) – 存在极点。","categories":[],"tags":[],"author":"Clover"},{"title":"理论力学C","slug":"study/Physics/TheoMechanics","date":"2022-06-17T16:00:00.000Z","updated":"2022-06-24T14:19:04.593Z","comments":true,"path":"2022/06/18/study/Physics/TheoMechanics/","link":"","permalink":"http://adversarr.github.io/2022/06/18/study/Physics/TheoMechanics/","excerpt":"理论力学复习笔记","text":"理论力学复习笔记 静力学 静力学公理和受力分析 静力学公理 二力平衡原理：受靓丽作用的刚体，平衡的充要条件时两个力大小相等、方向相反、作用在同一直线； 二力构件 加减平衡力系原理：在作用域刚体的任何一个力系上，加上/减去任意多个平衡利息，不改变原力系对于刚体的效应 不适合变形体 推论 – 力的可传性：力可以沿着作用线任意移动 平行四边形法则 推论 – 三力平衡汇交定理 ：三力平衡时，如果其中两个力的作用线相交于一点，则三力必须共面且共点 作用和反作用定律（牛三） 刚化原理：变形体在力系作用下处于平衡状态时，可以假象变形体是刚体，在原力系作用下保持平衡 约束和约束力 自由体：空间中运动不受限制的物体 约束：限制物体运动的条件 约束反应 = 约束力 柔性索 不及自重，不可伸长，只能承受拉力 – 力只沿着柔索 光滑接触面 约束力：沿接触点的公法线，指向被约束的物体。 例如：齿轮传动 光滑圆柱铰链 圆柱铰链 – 约束力xy正交分解 固定铰链 – xy正交分解 滚动铰链 – 垂直于接触面 光滑球铰链 约束力过球心 – xyz正交分解 轴承 向心轴承 – xy正交分解 止推轴承 – xyz正交分解 必考链杆 – 二力杆 受力分析、受力图 确定研究对象 分析力作用 分析相互作用力 说明： 字母标注 尽可能画在力的作用点上 不能用合力代替分布载荷 受力图上不用画出内力 平面汇交力系和平面力偶系 平面汇交力系 – 力的作用线共面且汇交于一点 几何法 首尾相连 几何条件 力多边形自行封闭 平面汇交力系合成、平衡的解析法 力在坐标轴上的投影 汇交力系合成的解析法 合力投影定理：在任意轴上的投影等于分力在同一轴上投影的代数和。 平面汇交力系平衡方程 平衡的充要条件是力系的合力为0 平面内力对于点的矩 平面内力对点的矩 合理矩定理：合力对任力系中各力对该点之矩矢的矢量和。 \\[ M_O(F_R) = \\sum M_O(F_i) \\] 适用于有合力的任意力系 平面力偶系 力偶 大小相等，方向相反，不共线的两个力组成的力系\\((F, F&#39;)\\) 力偶作用面、力偶臂 力偶效应：改变刚体的转动状态 是力学中的基本量 力偶矩 度量力偶对物体转动效应的量 – \\(M= \\pm d \\cdot F\\) 力偶是滑动矢量 – 与矩心的位置无关 力偶的性质 力偶无合力 – \\(F_R &#39; = \\sum F_i = 0\\) 力偶的效应只和力偶矩有关 力偶只与力偶矩相等的另一力偶等效 力偶对其作用面上任何一点的矩等于力偶矩 静止时，力偶不能与任一力平衡 平面力偶系合成 合成的结果为： \\[ M = \\sum _ i M_i \\] 即一个合力偶，力偶矩等于原力偶系中所有力偶矩的代数和 平面力偶系的平衡方程为： \\[ \\sum _i M_i = 0 \\quad(i.e. \\sum M = 0) \\] 平面任意力系 力系简化 力的平移定理 力的平移定理 可以把刚体上一点的力向任意点平移，但要附加一个力偶，其力偶矩等于原来力对移动点（新点）的矩。 相当于在目标点作一个力，然后设法使之等效。 平面力系向面内一点简化 简化结果是： 力系主矢 \\(F_R&#39;= \\sum_{i=1}^n F_i\\) 力系主矩 \\(M_O=\\sum_{i = 1} ^ n M_O(F_i)\\) 其中 \\(O\\) 是简化中心： 力系主矢与\\(O\\)无关 力系主矩一般和\\(O\\)有关 – 注意可能最终是一个合力偶的情况 简化结果的情况 力偶 – \\(F_R&#39; = 0, M_O \\ne 0\\) 平衡 – \\(F&#39;_R = 0, M_O = 0\\) 合力 – 其他的情况 合理矩定理 合理矩定理 平面任意力系的合力对作用面任一点的矩等于力系中各力对同一点的矩的代数和 \\[ M_O(F_R) = \\sum M_O(F_i) \\] 平衡方程和平衡条件 平衡的充要条件 充要条件是主矢和主矩都为0. \\[ \\begin{cases} F_R&#39; = 0\\\\ M_O = 0 \\end{cases} \\] 则最简单的平衡方程为（一矩式） \\[ \\begin{cases} \\sum F_x = 0\\\\ \\sum F_y = 0\\\\ \\sum M_O(F) = 0 \\end{cases} \\] 三个独立方程 – 三个未知量 平衡方程的三种形式 两矩式 \\[ \\begin{cases} \\sum F_x = 0\\\\ \\sum M_A(F) = 0\\\\ \\sum M_B(F) = 0 \\end{cases} \\] 要求\\(AB\\)不垂直于\\(x\\)轴 三矩式 \\[ \\begin{cases} \\sum M_A(F) = 0\\\\ \\sum M_B(F) = 0\\\\ \\sum M_C(F) = 0 \\end{cases} \\] 要求\\(ABC\\)不共线 平衡问题 特殊情况下，平衡方程可以解的位置量减少： 汇交力系 — 两个独立方程 平行力系 — 两个独立方程 力偶系 — 一个独立方程 其中\\(x, y\\)方向选择具有一定的任意性 – 线性无关 静定问题和静不定问题 静定问题 – 平衡方程可以求解所有未知数 静不定问题 – 平衡方程无法求出所有未知数 确定方法： 未知数和方程数比较 几何分析 计算自由度 桁架 分类 平面桁架 空间桁架 工程实例与理想桁架 无余杆 – 去掉任意一根，形状可变 有余杆 内力计算方法 节点法 以节点为研究对象 平面汇交力系平衡方程 – \\(F_x = 0\\quad F_y = 0\\) 截面法 假象截面截开桁架 局部桁架平衡，直接求内力 考试题、关键点：找零力杆 截面单杆 – 截面法中如果被切断的二力杆除了一根外，其余都交于一点或互相平行，此根杆为单杆。 节点单杆 – 节点法中列平衡方程可以求出内力的杆 摩擦 滑动摩擦 滑动摩擦 力 – 两个粗糙表面的物体，接触面之间有相对滑动趋势/相对滑动时，彼此作用，阻碍相对滑动的阻力。方向 – 与相对滑动相反 最大静摩擦 \\[ F = f_s F_N \\] 摩擦角和自锁 全约束反力： \\[ F_R = F_N + F_S \\] 注意力的作用点需要按照其他力的作用线来判断 摩擦角： \\[ \\tan \\varphi _ m = f_s \\] 自锁 : 摩擦角范围内，不论主动力多大，物体都会保持平衡。 摩擦平衡 临界滑动 翻倒 滚动摩阻 点的运动学 矢量法 运动方程 \\[ r=r(t) \\] 速度 \\[ v = \\dot r \\] 加速度 \\[ a = \\dot v = \\ddot r \\] 直角坐标法 自然坐标法 考虑空间曲线的运动方程： \\[ S ::= f(t) \\] 写出标架： \\[ \\begin{matrix}\\vec t\\\\\\vec n\\\\\\vec b \\end{matrix} \\] 则：速度为 \\[ v = v_\\tau \\vec t = \\frac{ds}{dt} \\vec t \\] 加速度为： \\[ a = a_\\tau + a_n = a _ \\tau \\vec t + a_n \\vec n \\] 刚体运动学 刚体平移 平移 刚体运动过程中，其上任意直线始终平行于这一支线的初始位置 特点： 刚体上的各点有形状相同的运动轨迹 各点在瞬时有相同的速度和加速度 可以简化为其上任意一点的运动分析 定轴转动 定轴转动 刚体运动过程中，有一直线始终保持不动 特征描述 转角：通过转轴的 转动方程 ： \\(\\varphi = f(t)\\) 角速度\\(\\omega\\)：\\(\\omega = \\frac{d\\varphi}{dt} = \\dot \\varphi\\) 角加速度 \\(\\alpha= \\ddot\\varphi\\) 各点运动分析 任意一点的速度： \\[ v_P = \\omega r \\] 加速度： 法向加速度 \\(a_P^n = r \\alpha\\) 切向加速度 \\(a_P^\\tau = r \\alpha\\) 传动比 利用边缘处速度相等： \\[ v = r_1 \\omega _ 1 = r_2 \\omega _ 2\\implies \\frac{\\omega _ 1}{\\omega _ 2} = \\frac{r_2}{r_1}= \\frac{z_2}{z_1} \\] 角速度矢量、角加速度矢量 方向：右手法则 模长：\\(\\omega\\) 从而： \\[ v = \\omega \\times\\vec r \\] 角加速度矢量 – 与角加速度矢量平行 点的合成运动 绝对运动、相对运动、牵连运动 静系-动系 静系 – 固定于地球、相对地球静止的坐标系 动系 – 固定在相对地球运动的物体上的坐标系 运动 绝对运动：动点相对静系 相对运动：动点相对动系 牵连运动：动系相对静系 速度 绝对速度 \\(v_a\\) – 动点在绝对运动中的速度 相对速度 \\(v_r\\) – 动点在相对运动中的速度 牵连速度 \\(v_e\\) – 牵连点相对于静系的速度 牵连点：动系上和动点重合的点 加速度 绝对加速度 相对加速度 牵连加速度 速度合成定理 速度合成定理 速度合成就是矢量相加 \\[ v_a = v_r + v_e \\] 加速度合成定理 牵连运动是平移时： \\[ a_a = a_e + a_r \\] 牵连运动不是平移： \\[ a_a = a_e + a _ r + a _ C \\] 相对导数、绝对导数 \\[ \\frac {d A}{dt} = \\frac{\\tilde d A} {dt} + \\omega \\times A \\] 因此： \\[ a_a = a_e + a_ r + a_C\\\\a_C = 2 \\omega \\times v_r \\] 刚体的平面运动 概念 刚体的平面运动 运动时，其上同一平面内各点到一固定平面的距离不变。 可以简化为平面图形 – 不同平面上对应点具有相同的轨迹、速度、加速度 平面运动方程 – 自由度 = 3 \\[ \\begin{cases} x_A\\\\y_A\\\\\\varphi \\end{cases} \\] 其中 \\(A\\) 称为基点 平面运动分解 可以分解为： 平移：速度和加速度都和基点选取有关 定轴转动：角速度和基点选取无关 基点法 平面图形 – S 定系 – \\(Oxy\\) 基点 – \\(A\\) 平移系 – \\(Axy\\) 角速度 – \\(\\omega\\) 基点速度 – \\(v_A\\) 故：\\(v_B = v_A + v_{BA}, v_{BA} = \\omega r_B\\) 投影法 速度投影定理 平面图形任意两点的速度在两点的连线上投影相等 瞬心法 速度瞬心 – 速度为 0 的点 瞬时性 唯一性 瞬时转动 确定方法 特殊情况：已知只滚动不滑动 已知两点速度矢量方向且互不平行 已知两点速度方向相互平行 连线与速度垂直， 大小不等 – 可以找到瞬心 大小相等 – 瞬时平移 连线与速度不垂直 必然大小相等（投影），且为瞬时平移 加速度分析 – 基点法 已知一点 \\(A\\) 的加速度，和 \\(B\\)相对 \\(A\\)的加速度，则 \\[ a_a = a_e + a_r = a_A + a_{BA} = a_B \\] 进一步的： \\[ a_B = a_A + a_{BA}^t + a_{BA} ^ n \\] 动能定理 力的功 重力的功 弹性力的功 定轴转动刚体上作用力的功 力偶的功：\\(W = M \\varphi\\) 平面运动刚体： \\[ W_{12} = \\int_{\\varphi_1} ^{\\varphi _ 2} M_c d\\varphi + \\int _{C_1} ^{C_2} Fd r_c \\] 作用在某处的力，对于刚体的功等于： 力等效移动到质心得到的力偶和 力对质心做功 的和 内力的功 纯滚动时 – 滑动摩擦力不做功 质点、质点系的动能 质点的动能 – \\(T = \\frac 1 2 m v ^ 2\\) 质点系的动能 — \\(T = \\sum _ i \\frac 1 2 m_ i v _ i ^ 2\\) 柯尼希定理 — \\(T = \\frac 1 2 M v_c^2 + T_r = T_e + T_r\\) 各种形式下刚体的动能 平移 – \\(T = \\frac 1 2 mv_C^2\\) 定轴转动刚体的动能 – \\(T = \\frac 1 2 J_z \\omega ^ 2\\) 平面运动 – \\(T = \\frac 1 2 m v_C^2 + \\frac 1 2 J_C\\omega^2 = \\frac 1 2 J_P\\omega ^ 2\\) 动能定理 质点动能定理 两种形式 \\[ dT = \\delta W\\quad T_2 - T_1 = W_{12} \\] 求加速度先考虑微分、求速度先考虑积分。 质点系动能定理 直接求和即可 功率、功率方程 力的功率 – 力做的功对时间的变化率 \\[ P= \\frac {\\delta W}{dt} = F \\cdot v \\] 力矩和力偶矩的功率 — \\[ P = M \\cdot \\omega \\] 动量定理 动量和冲量 质点系的动量和冲量分别为： \\[ p = mv\\\\ p = \\sum_i m_i v_i = M v_C \\] 冲量 \\[ I = \\int F\\cdot d t \\] 动量定理 质点的动量定理 \\[ \\mathrm d (mv) = F \\mathrm dt \\] 积分形式为 \\[ mv_2 - mv_1=\\int F \\mathrm dt = I \\] 质点系的动量定理 \\[ \\frac{dp}{dt} = \\sum F_i \\] 质点系的动量矢对时间的一阶导数 = 作用在质点系上的外力主矢 积分为： \\[ p - p_0 =I \\] 质点系的动量守恒 外力主矢 = 0 质心运动定理 \\[ ma_C = \\sum F_i ^ e \\] 质点系总质量与质心加速度的积 = 作用在质点系上的外力主矢 即外力主矢确定了质点系质心运动状态变化。 动量矩定理 质点、质点动量矩 质点的动量矩 \\[ M_O(mv) = r \\times mv \\] 动量矩是定位矢量 – 与 \\(O\\) 有关。 质点系的动量矩 \\[ M_O(m _ i v _ i) = r_i \\times m_i v_i \\quad L_O = \\sum _{i = 1} ^ n M_O(m _ i v _ i) \\] 对轴的动量矩 质点： \\[ M_z ( mv ) = \\left[M_O(mv)\\right]_z \\] 质点系： 平移 – 按照质量集中在质心的质点计算。 定轴转动 – \\(L_z = J_z \\omega\\) 常见转动惯量（按质心算） 圆盘：\\(J_O = \\frac 1 2 m R^2\\) 杆：\\(J_C = \\frac{1}{12} ml ^ 2\\) 球：\\(J_z = \\frac 2 5 mR^2\\) 平行移轴定理 \\(J_z = J_{z_C} + md^2\\) 回转半径 满足 \\(J_z = m \\rho^2_z\\) 相对于定点的动量矩定理 注意要相对定点/定轴！ 质点的动量矩定理 \\[ \\frac{d L _ O}{dt} = M_O(F) \\] 动量矩的变化率 = 作用在质点上的力 质点系的动量矩定理 \\[ \\frac{d L _ O}{dt} = \\sum M_O(F) \\] 质点系对定点的动量矩的变化率 = 所有外力对同一点的主矩。 动量矩守恒 若外力系对于定点的主矩为0，则质点系对这一点的动量矩守恒。 定轴转动的微分方程 \\[ J_z \\alpha = \\sum M_z (F) \\] 质点系对质心的动量矩定理 \\[ \\frac{dL_C}{dt} = \\sum M_C^e \\] 其中： \\[ L_C = \\sum _{i} r _ i &#39; \\times m_i v_{ir} \\] 刚体平面运动微分方程 利用： \\[ L_C = J_C \\omega \\] \\[ m \\ddot x_C = \\sum F_x ^ e \\\\ m \\ddot y_C = \\sum F_y ^ e \\\\ J_C \\ddot \\phi = \\sum M_C(F^e) \\] 达朗贝尔原理 惯性力、动静法 \\[ \\sum F+ F_I = 0\\quad F_I = - m a \\] 质点系的达朗贝尔原理 \\[ \\sum F_i^e + \\sum F_{Ii} = 0\\quad \\sum M_O(F_i^e) + \\sum M_O(F_{Ii}) = 0 \\] 惯性力系简化 平移时 – 主矢大小为\\(ma_C\\) 主矩为0 定轴转动时 – 主矢为 0，主矩为\\(J_O \\alpha\\) 平面运动 – 主矢 \\(ma_C\\) 主矩 \\(J_C\\alpha\\) 方向都与 \\(a_C,\\alpha\\) 相反。 作业和复习课 静力学 受力图 隔离法各个物体单独画 列方程： \\[ \\begin{aligned} \\sum F_x = 0 &amp;\\quad ... + ... + ... =0\\\\ \\sum F_y = 0 &amp;\\quad ... + ... + ... =0\\\\ \\sum M_f = 0 &amp;\\quad ... + ... + ... =0 \\end{aligned} \\] 固定端必考 – 这次必考（作业题2） 注意约束力偶矩 – 受力图！ 这甜蜜和近代物理老师送分没啥区别。 二力构件和二力杆 – 填空题、作图题（画受力图 – 3题） – 只要受到两个力而平衡，就是二力构件。 三力汇交必考 运动学 点的合成运动 8-22 明确写出以谁为动点、以谁为动系 – 3+3分 \\(v_a\\) – 绝对 \\(v_e\\) – 牵连 \\(v_r\\) – 相对 加速度同理，\\(a_c\\) 8-29 只是求\\(a_c\\) – 相对速度 + 角速度 9- 考试 选择、填空（计算）、判断 做图 计算题 u1s1-不如报答案 判断 2个-牵连运动、牵连速度！是否和定义一致？ 质心运动定理一定要理解\\(m a_c = \\sum \\vec F\\) ，包括主动力、约束力都要考虑！ 达朗贝尔原理、惯性力系简化（平移、惯性力偶矩、合力？） 平移和瞬时平移（平面运动的一个特例）是不同的！ 单选填空作图 作图：受力图 – 明确方向！ 能够看出二力杆：受拉力还是压力？ 参考 书本P83图4-13 空间力系-求对轴的矩？力和轴平行时为0 重心 组合法 负面积法 速度顺心 – 平面运动 – 作图题 选择填空： \\(J_c \\alpha = \\sum M_c (\\vec F)\\)– 对比一下选答案 （所有外力） 平面运动的动能 \\(T = \\frac 1 2 m v_c ^ 2 + \\frac 1 2 J_c \\omega^2\\) 13-5 动量动能动量矩 p270 – 11-4 串并联、固有频率、求解方法 计算 静力学：有固定端（约束力偶矩），谁是固定端，其他很简单 要分开画受力图 协调性原则 – 方向（牛3）、标注（\\(F \\rightarrow F&#39;\\)） 桁架：零力杆（要写理由）截面法、节点法 – 送分 动力学：P184 图8-16、速度合成定理、刚体的平面运动（动点动系记得要写-3分） 基点法、投影定理、瞬心 – 求加速度只能用基点法 判断加速度方向 速度瞬心法 – 如果是又滚又滑 动力学：P413 16-24题： 达朗贝尔原理 或者用：\\(J_c \\alpha = \\sum M_c (\\vec F)\\) （对单个物体成立）和\\(Ma_c = \\sum F\\) 建立坐标系 – 放在正半轴的一般位置？ 复习个xxxxx","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"}],"author":"Clover"},{"title":"数据库机试","slug":"study/ComputerScience/fragments/dbex","date":"2022-06-15T16:00:00.000Z","updated":"2022-06-22T06:30:07.737Z","comments":true,"path":"2022/06/16/study/ComputerScience/fragments/dbex/","link":"","permalink":"http://adversarr.github.io/2022/06/16/study/ComputerScience/fragments/dbex/","excerpt":"rt.","text":"rt. RMAN 全库备份 前提： dbca创建数据库 ctest（主要是怕搞错） @?/rdbms/admin/utlsampl.sql 准备： export ORACLE_SID=ctest 准备实验数据 创建表+checkpoint(写入) RMAN: create table scott.baktest(a varchar(30));insert into scott.baktest values(&#x27;Before Backup&#x27;);commit;alter system checkpoint; 测试结果： image-20220614200507403 检查数据库情况 初始化参数文件 sqlplus: show parameter spfile; SYS@ctest&gt;show parameter spfile;NAME TYPE VALUE------------------------------------ ---------------------- ------------------------------spfile string /u01/app/oracle/product/19.3.0/dbhome_1/dbs/spfilectest.ora 记录下spfile的位置： /u01/app/oracle/product/19.3.0/dbhome_1/dbs/spfilectest.ora 查看控制文件位置 select name from v$controlfile;NAME------------------------------------------------------------------------------------------------------------------------/u01/app/oracle/oradata/CTEST/control01.ctl/u01/app/oracle/fast_recovery_area/CTEST/control02.ctl ！！查看重做日志 SYS@ctest&gt;select member from v$logfile;MEMBER------------------------------------------------------------------------------------------------------------------------/u01/app/oracle/oradata/CTEST/redo03.log/u01/app/oracle/oradata/CTEST/redo02.log/u01/app/oracle/oradata/CTEST/redo01.log 检查datafile SYS@ctest&gt;select name from v$datafile;NAME------------------------------------------------------------------------------------------------------------------------/u01/app/oracle/oradata/CTEST/system01.dbf/u01/app/oracle/oradata/CTEST/sysaux01.dbf/u01/app/oracle/oradata/CTEST/undotbs01.dbf/u01/app/oracle/oradata/CTEST/users01.dbf 查看状态 SYS@ctest&gt;select tablespace_name, status from dba_tablespaces;TABLESPACE_NAME STATUS------------------------------------------------------------ ------------------SYSTEM ONLINESYSAUX ONLINEUNDOTBS1 ONLINETEMP ONLINEUSERS ONLINE RMAN设置修改 RMAN内执行 打开控制文件备份： configure controlfile autobackup on; 创建备份目的目录： mkdir &lt;backup&gt; &amp;&amp; cd &lt;backup&gt;mkdir auto 设置 controlfile 备份目的地 configure controlfile autobackup format for device type disk to &#x27;/u01/&lt;backup&gt;/auto/%F&#x27;; 其他的设置 # show allalter system archive log current; # 归档日志# 设置 channelconfigure channel device type disk format &#x27;/u01/&lt;backup&gt;/%d_%u.bak&#x27;;# 删除之前的备份delete backup; 执行全盘备份 RMAN内执行 backup database plus archivelog; ！！！「举手示意，备份完成」 增加新数据 insert into scott.baktest values(&#x27;After Backup&#x27;);commit;select * from scott.baktest; image-20220614202258052 复制连接的日志文件 # in back directory:sql&gt; select * from v$logfile;cp &lt;...&gt; .cp &lt;...&gt; . # redo logcp &lt;...&gt; .# 或者直接 cp /u01/app/oracle/oradata/CTEST/redo0* . 破坏数据库 dbca# 如果没有 -- vim /etc/oratab 启动例程 rman target /startup nomount; # 不挂载（缺少spfile） 然后恢复启动参数文件： restore spfile from &#x27;/u01/&lt;&gt;/auto/...&#x27; image-20220614203112028 创建对应的目录 bash 查看目录： cat /u01/app/oracle/product/19.3.0/dbhome_1/dbs/spfilectest.ora 应该是： mkdir -p /u01/app/oracle/admin/CTEST/adumpmkdir -p /u01/app/oracle/oradata/CTESTmkdir -p /u01/app/oracle/fast_recovery_area/CTEST 重启例程 shutdown immediate;exitstartup nomount 还原控制文件： RMAN&gt; restore controlfile from &#x27;/u01/_backup_test1/auto/c-899807147-20220614-00&#x27;;Starting restore at 14-JUN-22using target database control file instead of recovery catalogallocated channel: ORA_DISK_1channel ORA_DISK_1: SID=261 device type=DISKchannel ORA_DISK_1: restoring control filechannel ORA_DISK_1: restore complete, elapsed time: 00:00:01output file name=/u01/app/oracle/oradata/CTEST/control01.ctloutput file name=/u01/app/oracle/fast_recovery_area/CTEST/control02.ctlFinished restore at 14-JUN-22 加载数据库 alter database mount; 或者： shutdown immediate;startup mount; 还原数据文件： restore database;Starting restore at 14-JUN-22Starting implicit crosscheck backup at 14-JUN-22allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=379 device type=DISKCrosschecked 3 objectsFinished implicit crosscheck backup at 14-JUN-22Starting implicit crosscheck copy at 14-JUN-22using channel ORA_DISK_1Finished implicit crosscheck copy at 14-JUN-22searching for all files in the recovery areacataloging files...no files catalogedusing channel ORA_DISK_1channel ORA_DISK_1: starting datafile backup set restorechannel ORA_DISK_1: specifying datafile(s) to restore from backup setchannel ORA_DISK_1: restoring datafile 00001 to /u01/app/oracle/oradata/CTEST/system01.dbfchannel ORA_DISK_1: restoring datafile 00003 to /u01/app/oracle/oradata/CTEST/sysaux01.dbfchannel ORA_DISK_1: restoring datafile 00004 to /u01/app/oracle/oradata/CTEST/undotbs01.dbfchannel ORA_DISK_1: restoring datafile 00007 to /u01/app/oracle/oradata/CTEST/users01.dbfchannel ORA_DISK_1: reading from backup piece /u01/_backup_test1/CTEST_03102deq.bakchannel ORA_DISK_1: piece handle=/u01/_backup_test1/CTEST_03102deq.bak tag=TAG20220614T201938channel ORA_DISK_1: restored backup piece 1channel ORA_DISK_1: restore complete, elapsed time: 00:00:07Finished restore at 14-JUN-22 !!! 复制RedoLog文件 cp redo* /u01/app/oracle/oradata/CTEST/ 恢复数据库 recover database;Starting recover at 14-JUN-22using channel ORA_DISK_1starting media recoveryarchived log for thread 1 with sequence 8 is already on disk as file /u01/app/oracle/fast_recovery_area/CTEST/archivelog/2022_06_14/o1_mf_1_8_kbjz71dj_.arcarchived log for thread 1 with sequence 9 is already on disk as file /u01/app/oracle/oradata/CTEST/redo03.logarchived log file name=/u01/app/oracle/fast_recovery_area/CTEST/archivelog/2022_06_14/o1_mf_1_8_kbjz71dj_.arc thread=1 sequence=8archived log file name=/u01/app/oracle/oradata/CTEST/redo03.log thread=1 sequence=9media recovery complete, elapsed time: 00:00:00Finished recover at 14-JUN-22 打开数据库，注意设置resetlog alter database open resetlogs; 检查！ select * from scott.baktest; image-20220614210608902 结束 Logminer 启用日志挖掘器 select SUPPLEMENTAL_LOG_DATA_MIN from v$database;&gt;&gt;&gt; NOalter database add supplemental log data;&gt;&gt;&gt; Database altered.select SUPPLEMENTAL_LOG_DATA_MIN from v$database;&gt;&gt;&gt; YES Note: 删除方法 alter database drop supplemental log data;&gt;&gt;&gt; Database altered.select SUPPLEMENTAL_LOG_DATA_MIN from v$database;&gt;&gt;&gt; NO 产生数据字典文件 desc dbms_logmnr_d&gt;&gt;&gt; PROCEDURE BUILD Argument Name Type In/Out Default? ------------------------------ ----------------------- ------ -------- DICTIONARY_FILENAME VARCHAR2 IN DEFAULT DICTIONARY_LOCATION VARCHAR2 IN DEFAULT OPTIONS NUMBER IN DEFAULTPROCEDURE SET_TABLESPACE Argument Name Type In/Out Default? ------------------------------ ----------------------- ------ -------- NEW_TABLESPACE VARCHAR2 IN 产生方法： 创建目录 操作系统： mkdir -p /u01/&lt;dict&gt; oracle： create directory dict1 as &#x27;/u01/dict&#x27;; 创建文件 注意大小写 execute dbms_logmnr_d.build(&#x27;v816dict.ora&#x27;, &#x27;DICT1&#x27;); 开始事务 conn scott/tiger&gt;&gt;&gt; Connected.select * from emp;&gt;&gt;&gt;update emp set sal=1800 where empno=7369;&gt;&gt;&gt; 1 row updated.commit&gt;&gt;&gt; Commit complete. 添加需要分析的日志文件 查看当前日志文件 select group#, status from v$log;&gt;&gt;&gt; GROUP# STATUS---------- -------------------------------- 1 INACTIVE 2 INACTIVE 3 CURRENT 查看对应的恢复日志文件： select member from v$logfile where group#=3;&gt;&gt;&gt;/u01/app/oracle/oradata/CTEST/redo03.log 添加要分析的日志 一定要注意不能写错路径查了别的数据库的log！ execute dbms_logmnr.add_logfile(LogFileName=&gt;&#x27;/u01/app/oracle/oradata/CTEST/redo03.log&#x27;, Options=&gt;dbms_logmnr.new);&gt;&gt;&gt; PL/SQL procedure successfully completed. 启动分析 execute dbms_logmnr.start_logmnr(DictFileName=&gt;&#x27;/u01/_logmin_test1/v816dict.ora&#x27;);&gt;&gt;&gt;PL/SQL procedure successfully completed. 查询结果v$logmnr_contents 修改时间戳格式 alter session set nls_date_format=&#x27;yyyy-mm-dd hh24:mi:ss&#x27;;&gt;&gt;&gt;Session altered. 查询最终结果 select username, timestamp, sql_redo from v$logmnr_contents where username=&#x27;SCOTT&#x27;;&gt;&gt;&gt;select timestamp, username, sql_redo from v$logmnr_contents where USERNAME=&#x27;SCOTT&#x27;;TIMESTAMP-------------------USERNAME------------------------------------------------------------------------------------------------------------------------SQL_REDO------------------------------------------------------------------------------------------------------------------------2022-06-16 10:47:17SCOTTset transaction read write;2022-06-16 10:47:17SCOTTupdate &quot;SCOTT&quot;.&quot;EMP&quot; set &quot;SAL&quot; = &#x27;1800&#x27; where &quot;SAL&quot; = &#x27;2900&#x27; and ROWID = &#x27;AAAR34AAHAAAAFvAAA&#x27;;2022-06-16 10:47:17SCOTTcommit; Oracle 数据库系统结构概述 官方参考资料 Oracle 数据库由数据库存储结构和数据库实例两部分构成。 数据库 数据库是位于磁盘上的一组文件，用于存储数据。这些文件可以独立于数据库实例而存在。 数据库实例 实例是一组管理数据库文件的内存结构。该实例由一个共享内存区域（称为系统全局区域SGA）和一组后台进程组成。实例可以独立于数据库文件而存在。 下图显示了数据库及其实例。对于与实例的每个用户连接，客户端进程将运行该应用程序。每个客户端进程都与自己的服务器进程相关联。服务器进程具有自己的专用会话内存，称为程序全局区域PGA。 其中存储结构包括物理存储结构和逻辑存储结构，是数据存储及空间分配的基础；实例是构成 Oracle 数据库的软件结构，包括内存结构和后台进程，是数据库运行与管理的基础。 Oracle 数据库由存放在磁盘上的数据库DB和对磁盘上的数据库进行管理的数据库管理系统DBMS两部分构成，分别对应着数据库的存储结构和软件结构。 Oracle 数据库的存储结构（Storage Structure）分为物理存储结构和逻辑存储结构两种，分别描述了在操作系统中和数据库系统内部数据的组织与管理方式。其中，物理存储结构表现为操作系统中一系列文件，逻辑存储结构是对物理存储结构的逻辑组织与管理。 Oracle 数据库的软件结构，即 Oracle 实例（Instance），包括内存结构与后台进程结构两部分。 图描述了 Oracle 数据库内存结构、后台进程结构、存储结构之间的关系。从图中可以看出，用户的所有操作都是通过实例完成的，首先在内存结构中进行，在一定条件下由数据库的后台进程结构写入数据库的物理存储结构做永久保存 存储结构 Oracle 数据库的存储结构分为物理存储结构和逻辑存储结构两种。 物理存储结构主要用于描述在 Oracle 数据库外部数据的存储，即在操作系统层面中如何组织和管理数据，与具体的操作系统有关。 逻辑存储结构主要描述 Oracle 数据库内部数据的组织和管理方式，即在数据库管理系统的层面中如何组织和管理数据，与操作系统没有关系。 物理存储结构具体表现为一系列的操作系统文件，是可见的；而逻辑存储结构是物理存储结构的抽象体现，是不可见的，可以通过查询数据库数据字典了解逻辑存储结构信息。 Oracle 数据库的物理存储结构与逻辑存储结构既相互独立又相互联系，如图所示。 从图中可以看出数据库物理存储结构与逻辑存储结构的基本关系。 一个数据库在物理上包含多个数据文件，在逻辑上包含多个表空间。 一个表空间包含一个或多个数据文件，一个数据文件只能从属于某个表空间。 数据库的逻辑块由一个或多个操作系统块构成。 一个逻辑区只能从属于某一个数据文件，而一个数据文件可包含一个或多个逻辑区。 1. 物理存储结构概述 Oracle 数据库的物理存储结构是由一系列操作系统文件组成的，存放于物理磁盘上，是数据库的实际存储单元。这些文件主要包括数据文件、控制文件、重做日志文件、归档文件、初始化参数文件、跟踪文件、告警文件等。每种文件都存储特定内容的信息，其数量也因文件类型不同而不同。 数据文件：是数据库中所有数据的实际存储空间，所有数据文件的大小和构成了数据库的大小。 控制文件：记录数据库结构信息的重要的二进制文件，由 Oracle 系统进行读 / 写操作，DBA 不能直接操作控制文件。 重做日志文件：是以重做记录的形式记录、保存用户对数据库所进行的变更操作，是数据库中最重要的物理文件。 归档日志文件：是历史联机重做日志文件的集合，是联机重做日志文件被覆盖之前备份的副本。 初始化参数文件：是数据库启动过程所必需的文件，记录了数据库显式参数的设置。数据库启动的第一步就是根据初始化参数文件中的设置，创建并启动实例，即分配内存空间、启动后台进程。 跟踪文件：是数据库中重要的诊断文件，是获取数据库信息的重要工具，对管理数据库的实例起着至关重要的作用。跟踪文件中包含数据库系统运行过程中所发生的重大事件的有关信息，可以为数据库运行故障的解决提供重要信息。 告警文件：是数据库中重要的诊断文件，记录数据库在启动、关闭和运行期间后台进程的活动情况。 2. 逻辑存储结构概述 Oracle 数据库的逻辑存储结构是从逻辑的角度来分析数据库的构成的，也就是数据库创建后利用逻辑概念来描述 Oracle 数据库内部数据的组织和管理形式。在操作系统中，没有数据库逻辑存储结构信息，而只有物理存储结构信息。数据库的逻辑存储结构概念存储在数据库的数据字典中，可以通过数据字典查询逻辑存储结构信息。 Oracle 数据库的逻辑存储结构分为 Oracle 数据块（Oracle DATE Block）、区（Extent）、段（Segment）和表空间（Table space）4 种，它们之间的关系如图所示。一个或多个连续的 Oracle 数据块构成区，一个或多个区构成段，一个或多个段构成表空间，所有表空间构成数据库。 Oracle 数据块 Oracle 数据块是数据库中最小的逻辑存储单元，是数据库执行输入、输出操作的最小单位，由一个或者多个操作系统块构成。在 Oracle 11g 数据库中，数据块分为标准块和非标准块两种，其中标准块由数据库初始化参数 DB_BLOCK_SIZE 设置，其大小不可更改。Oracle 数据库的默认数据缓冲区就是由标准数据块构成的。 区 区是由一系列连续的数据块构成的逻辑存储单元，是存储空间分配的最小单位。当创建一个数据库对象时，Oracle 为对象分配若干个区，以构成一个段来为对象提供初始的存储空间。当段中已分配的区都写满后，Oracle 会为段分配一个新区，以容纳更多的数据。构成一个段的所有区只能在一个文件中。在 Oracle 数据库中，引入区的目的是为了提高系统存储空间分配的效率，以区为单位的存储空间分配大大减少了磁盘分配的次数。 段 段是由一个或多个连续或不连续的区组成的逻辑存储单元，用于存储特定的、具有独立存储结构的数据库对象。根据存储对象类型不同，分为表段、索引段、临时段和回退段 4 类。 表段，又称数据段，用来存储表或簇的数据，可以细分为普通表段（TABLE）、分区表段（TABLE Partition）、簇段（Cluster）、索引化表段（INDEX-organized TABLE）。 索引段用来存放索引数据，包括 ROWID 和索引键值。 临时段是进行查询、排序等操作时，如果内存空间不足，用于保存 SQL 语句在解释和执行过程中产生的临时数据。会话结束时，为该操作分配的临时段将被释放。 回退段用于保存数据库的回退信息，包含当前未提交事务所修改的数据的原始版本。利用回退段中保存的回退信息，可以实现事务回滚、数据库恢复、数据的读一致性和闪回查询。 表空间 表空间是 Oracle 数据库最大的逻辑存储单元，数据库的大小从逻辑上看就是由表空间决定的，所有表空间大小的和就是数据库的大小。在 Oracle 数据库中，存储结构管理主要就是通过对表空间的管理来实现的。 表空间与数据库文件直接关联，一个表空间包含一个或多个数据文件，一个数据文件只能从属于某一个表空间，数据库对象就是存储在表空间对应的一个或多个数据文件中。 表空间根据存储数据的类型不同，分为系统表空间和非系统表空间两类。系统表空间主要存放数据库的系统信息，如数据字典信息、数据库对象定义信息、数据库组件信息等。非系统表空间又分为撤销表空间、临时表空间和用户表空间等。其中，撤销表空间用于自动管理数据库的回退信息，临时表空间用于管理数据库的临时信息，用户表空间用于存储用户的业务数据。Oracle 11g 数据库在创建时会自动创建 6 个表空间，见表 3-1。 Oracle 11g 数据库自动创建的表空间 名称 类型 描述 SYSTEM 系统表空间 存放数据字典、数据库对象定义、PL/SQL 程序源代码等系统信息 SYSAUX 系统表空间 辅助系统表空间，存储数据库组件等信息 TEMP 临时表空间 存放临时数据，用于排序等操作 UNDOTBS1 撤销表空间 存储、管理回退信息 USERS 用户表空间 存放用户业务数据信息 EXAMPLE 示例表空间 示例表空间，存放示例的数据库方案对象信息 内存结构 Oracle 数据库实例由一系列内存结构和后台进程组成。用户操作数据库的过程实质上是与数据库实例建立连接，然后通过实例来操作数据库的过程。用户的所有操作都在内存中进行，最后由数据库后台进程将操作结果写入各种物理文件中永久性保存。 内存结构是 Oracle 数据库体系结构的重要组成部分，是 Oracle 数据库重要的信息缓存和共享区域。根据内存区域信息使用范围的不同，分为系统全局区（System Global Area，SGA）和程序全局区（Program Global Area，PGA）。 1. SGA SGA 是由 Oracle 分配的共享内存结构，包含一个数据库实例的数据和控制信息。SGA 数据供所有的服务器进程和后台进程共享，所以 SGA 又称为共享全局区（Shared Global Area）。用户对数据库的各种操作主要在 SGA 中进行。该内存区随数据库实例的创建而分配，随实例的终止而释放。 SGA 主要由数据高速缓冲区（Database Buffer Cache）、共享池（Shared Pool）、重做日志缓冲区（Redo Log Cache）、大型池（Large Pool）、Java 池（Java Pool）、流池（Streams Pool）和其他结构（如固定 SGA、锁管理等）组成。 数据高速缓冲区 数据高速缓冲区存储的是最近从数据文件中检索出来的数据，供所有用户共享。当用户要操作数据库中的数据时，先由服务器进程将数据从磁盘的数据文件中读取到数据高速缓冲区中，然后在缓冲区中进行处理。用户处理后的结果被存储在数据高速缓冲区中，最后由数据库写入进程 DBWR 写到硬盘的数据文件中永久保存，如图所示。 根据数据缓冲区中存放的信息的不同，数据高速缓冲区分为下列 4 种类型。 脏缓存块（Dirty Buffers）：脏缓存块中保存的是已经被修改过的数据。 空闲缓存块（Free Buffers）：空闲缓存块中不包含任何数据，它们等待后台进程或服务器进程向其中写入数据。 命中缓存块（Pinned Buffers）：命中缓存块是那些正被使用的数据块，同时还有很多会话等待修改或访问的数据块。 干净缓存块（Clean Buffers）：干净缓存块是指那些当前没有被使用，即将被换出内存的缓存块，这些块中的数据要么没有被修改，要么在内存中有该数据块的快照。 在 Oracle 11g 中，数据高速缓冲区由标准缓冲区和非标准缓冲区构成，两者的和决定了数据高速缓冲区大小。标准缓冲区大小由参数 DB_CACHE_SIZE 设定，非标准缓冲区由参数 DB_nK_CACHE_SIZE 设定。 重做日志缓冲区 重做日志缓冲区用于缓存用户对数据库进行修改操作时生成的重做记录。为了提高工作效率，重做记录并不是直接写入到重做日志文件中，而是首先被服务器进程写入重做日志缓冲区中，在一定条件下，再由日志写入进程 LGWR 把重做日志缓冲区的内容写入到重做日志文件中做永久性保存。在归档模式下，当重做日志切换时，由归档进程 ARCH 将重做日志文件的内容写入到归档文件中，如图所示。 重做日志缓存区大小由初始化参数 LOG_BUFFER 设定。 共享池 共享池用于缓存最近执行过的 SQL 语句、PL/SQL 程序和数据字典信息，是对 SQL 语句、PL/SQL 程序进行语法分析、编译、执行的区域。 共享池由库缓存（Library Cache）和数据字典缓存（Dictionary Cache）组成。 库缓存 Oracle 执行用户提交 SQL 语句或 PL/SQL 程序之前，先要对其进行语法分析、对象确认、权限检查、执行优化等一系列操作，并生成执行计划。这一系列操作会占用一定的系统资源，如果多次执行相同的 SQL 语句、PL/SQL 程序，都要进行如此操作的话，将浪费很多系统资源。库缓存的作用就是缓存最近被解释并执行过的 SQL 语句、PL/SQL 程序代码正文、编译后代码以及执行计划，以提高 SQL、PL/SQL 程序的执行效率。当执行 SQL 语句或 PL/SQL 程序时，Oracle 首先在共享池的库缓存中搜索，查看正文完全相同的 SQL 语句或 PL/SQL 程序是否已经被分析、解析、执行并缓存过。如果有，Oracle 将利用缓存中的分析结果和执行计划来执行该语句，而不必重新对它进行解析，从而大大提高了系统的执行速度。 数据字典缓存区 数据字典缓存区中保存最常使用的数据字典信息，如数据库对象信息、账户信息、数据库结构信息等。当用户访问数据库时，可以从数据字典缓存中获得对象是否存在、用户是否有操作权限等信息，大大提高了执行效率。 共享池的大小由初始化参数 SHARED_POOL_SIZE 设定。 大型池 大型池是一个可选的内存配置项，主要为 Oracle 共享服务器、服务器 I/O 进程、数据库备份与恢复操作、执行具有大量排序操作的 SQL 语句、执行并行化的数据库操作等需要大量缓存的操作提供内存空间。如果没有在 SGA 中创建大型池，上述操作所需要的缓存空间将在共享池或 PGA 中分配，因而会影响共享池或 PGA 的使用效率。 大型池的大小由初始化参数 LARGE_POOL_SIZE 设定。 Java 池 Java 池是一个可选的内存配置项，提供对 Java 程序设计的支持，用于存储 Java 代码、Java 语句的语法分析表、Java 语句的执行方案和进行 Java 程序开发等。 Java 池大小由初始化参数 JAVA_POOL_SIZE 设定。 流池 流池是一个可选的内存配置项，用于对流的支持。 流池大小由初始化参数 STREAMS_POOL_SIZE 设定。 2. PGA Oracle 创建一个服务器进程的同时要为该服务器进程分配一个内存区，该内存区称为程序全局区（Program Global Area，PGA）。PGA 是一个私有的内存区，不能共享，每个服务器进程只能访问自己的 PGA，因此 PGA 又称为私有全局区（Private Global Area）。系统同时为每个后台进程分配私有的 PGA 区。所有服务器进程 PGA 与所有后台进程 PGA 大小的和，即为实例的 PGA 的大小。PGA 随着服务器进程与后台进程的启动而分配，随着服务器进程和后台进程终止而被释放。 PGA 由下列 4 部分组成。 排序区（SORT Area）：存放排序操作所产生的临时数据。 游标信息区（Cursor Information）：存放执行游标操作时所产生的数据。 会话信息区（Session Information）：保存用户会话所具有的权限、角色、性能统计信息。 堆栈区（Stack Space）：用于保存会话过程中的绑定变量、会话变量等信息。 后台进程 1. Oracle 进程概述 进程概念 进程是操作系统中一个独立的可以调度的活动，用于完成指定的任务。进程与程序的区别在于： 进程是动态的概念，即动态创建，完成任务后立即消亡；而程序是一个静态实体。 进程强调执行过程，而程序仅仅是指令的有序集合。 进程类型 在 Oracle 数据库服务器中，进程分为用户进程（USER Process）、服务器进程（Server Process）和后台进程（Background Process）3 种。 用户进程 当用户连接数据库执行一个应用程序时，会创建一个用户进程，来完成用户所指定的任务。 服务器进程 Oracle 服务器进程由 Oracle 自身创建，用于处理连接到数据库实例的用户进程所提出的请求。 服务器进程主要完成以下任务： 解析并执行用户提交的 SQL 语句和 PL/SQL 程序。 在 SGA 的数据高速缓冲区中搜索用户进程所要访问的数据，如果数据不在缓冲区中，则需要从硬盘数据文件中读取所需的数据，再将它们复制到缓冲区中。 将用户改变数据库的操作信息写入日志缓冲区中。 将查询或执行后的结果数据返回给用户进程。 后台进程 为了保证 Oracle 数据库在任意一个时刻都可以处理多用户的并发请求，进行复杂的数据操作，而且优化系统性能，Oracle 数据库启用了一些相互独立的附加进程，称为后台进程。服务器进程在执行用户进程请求时，会调用后台进程来实现对数据库的操作。 2. Oracle 后台进程 Oracle 实例的主要后台进程包括数据库写入进程（DBWR）、日志写入进程（LGWR）、检查点进程（CKPT）、系统监控进程（SMON）、进程监控进程（PMON）、归档进程（ARCH）、恢复进程（RECO）、锁进程（LCKn）、调度进程（Dnnn）等，其中前 5 个后台进程是必需的。 数据库的后台进程随数据库实例的启动而自动启动，它们协调服务器进程的工作，优化系统的性能。可以通过初始化参数文件中参数的设置来确定启动后台进程的数量。 DBWR 数据库写入进程负责把数据高速缓冲区中已经被修改过的数据（脏缓存块）成批写入数据文件中永久保存，同时使数据高速缓冲区有更多的空闲缓存块，保证服务器进程将所需要的数据从数据文件中读取到数据高速缓冲区中，提高缓存命中率。 当下列某个条件满足时，DBWR 进程将启动，将数据高速缓冲区中的脏数据写入数据文件： 服务器进程在数据高速缓存区中搜索一定数量的缓存块后，仍然没有找到可用的空闲缓存块，此时 DBWR 进程将被启动； 检查点发生时，将启动 DBWR 进程； 当数据高速缓冲区中 LRU 列表长度达到初始化参数 DB_BLOCK_WRITE_BATCH 指定值的一半时，DBWR 进程将被启动； DBWR 进程发生超时（约 3s），DBWR 进程将被启动。 注意：DBWR 进程启动的时间与用户提交事务的时间完全无关。 LGWR 日志写入进程负责把重做日志缓冲区的重做记录写入重做日志文件中永久保存。 DBWR 进程在工作之前，需要了解 LGWR 进程是否已经把相关的日志缓冲区中的重做记录写入重做日志文件中。如果还没有写入重做日志文件，DBWR 进程将通知 LGWR 进程完成相应的工作，然后 DBWR 进程才开始写入。这样可以保证先将与脏缓存块相关的重做记录信息写入重做日志文件，然后将脏缓存块写入数据文件，即先写重做日志文件，后写数据文件。 当下列事件发生时，LGWR 进程会将重做日志缓冲区中的重做记录写入重做日志文件： 用户通过 COMMIT 语句提交当前事务； 重做日志缓冲区被写满三分之一； DBWR 进程开始将脏缓存块写入数据文件； LGWR 进程超时（约 3s），LGWR 进程将启动。 CKPT 检查点是一个事件，当该事件发生时（每隔一段时间发生），DBWR 进程把数据高速缓冲区中的脏缓存块写入数据文件中，同时 Oracle 将对数据库控制文件和数据文件的头部的同步序号进行更新，以记录下当前的数据库结构和状态，保证数据的同步。 在执行了一个检查点事件后，Oracle 知道所有已提交的事务对数据库所做的更改已经全部被写入到数据文件中，此时数据库处于一个完整状态。在发生数据库崩溃后，只需要将数据库恢复到上一个检查点执行时刻即可。因此，缩短检查点执行的间隔，可以缩短数据库恢复所需的时间。 CKPT 进程的作用就是执行检查点，完成下列操作： 更新控制文件与数据文件的头部，使其同步； 触发 DBWR 进程，将脏缓存块写入数据文件。 SMON 如果由于某种原因系统崩溃了，那么 SGA 中任何没有来得及写入磁盘文件中的信息都将丢失。如果有些已经提交的数据还没有真正写入数据文件中就会丢失了，当数据库重新启动时，SMON 进程将自动执行 Oracle 实例的恢复工作。 除了进行数据库实例恢复外，SMON 进程还具有以下功能： 回收不再使用的临时空间； 将各个表空间的空闲碎片合并（表空间的存储参数 PCTINCREASE 不为 0 时）。 SMON 进程除了在实例启动时执行一次外，在实例运行期间，它会被定期唤醒，检查是否有工作需要它来完成。如果有其他任何进程需要使用 SMON 进程的功能，它们将随时唤醒 SMON 进程。 PMON PMON 进程的主要功能包括： 负责恢复失败的用户进程或服务器进程，并且释放进程所占用的资源； 清除非正常中断的用户进程留下的孤儿会话，回退未提交的事务，释放会话所占用的锁、SGA、PGA 等资源； 监控调度进程和服务器进程的状态，如果它们失败，则尝试重新启动它们，并释放它们所占用的各种资源。 与 SMON 进程类似，PMON 进程在实例运行期间会被定期唤醒，检查是否有工作需要它来完成。如果有其他任何进程需要使用 PMON 进程的功能，它们将随时唤醒 PMON 进程。 ARCH ARCH 进程负责在日志切换后将已经写满的重做日志文件复制到归档目标，以防止写满的重做日志文件被覆盖。 只有当数据库运行在归档模式，并且初始化参数 LOG_ARCHIVE_START 设置为 TRUE，即启动自动归档功能时，才能启动 ARCH 进程；否则当重做日志文件全部被写满后，数据库将被挂起，等待 DBA 进行手工归档。 数据字典 1.概述 数据字典的内容与作用 数据字典是数据库重要组成部分，是在数据库创建过程中创建的，保存了数据库系统信息以及数据库中所有的对象信息，是数据库系统运行的基础。 Oracle 数据库的数据字典由一系列表和视图构成，这些表和视图对于所有的用户，包括 DBA，都是只读的。只有 Oracle 系统才可以对数据字典进行管理与维护。在 Oracle 数据库中，所有数据字典表和视图都属于 SYS 模式，存储于 SYSTEM 表空间中。 Oracle 数据字典保存数据库本身的系统信息及所有数据库对象信息，包括： 各种数据库对象的定义信息，包括表、视图、索引、同义词、序列、存储过程、函数、包、触发器及其他各种对象； 数据库存储空间分配信息，如为某个数据库对象分配了多少空间，已经使用了多少空间等； 数据库的安全信息，包括用户、权限、角色、完整性等； 数据库运行时的性能和统计信息； 其他数据库本身的基本信息。 数据字典除了用于 Oracle 进行系统管理外，对于 DBA 以及普通数据库用户都有着非常重要的作用。数据字典的主要用途包括： Oracle 通过访问数据字典获取用户、模式对象、数据库对象定义与存储等信息，以判断用户权限合法性、模式对象存在性及存储空间的可用性等； 使用 DDL 语句修改数据库对象后，Oracle 将在数据字典中记录所做的修改； 任何数据库用户都可以从数据字典只读视图中获取各种数据库对象信息； DBA 可以从数据字典动态性能视图中获取数据库的运行状态，作为进行性能调整的依据。 数据字典的管理与维护 数据字典主要是由 Oracle 数据库服务器使用的，服务器通过访问数据字典基表获取用户、数据库对象、存储结构等信息，并利用这些信息进行数据库的管理与维护。只有 Oracle 系统可以对数据字典进行管理与维护。在 Oracle 数据库运行过程中，如果数据库结构发生变化，Oracle 数据库服务器会及时地修改相应的数据字典以记录这些变化。 当数据库中执行下列各种 SQL 语句操作时，Oracle 数据库服务器会修改数据字典信息。 DDL 语句。如增加或减少表空间、增加或减少用户。 DCL 语句。如授予用户权限、回收用户权限。 DML 语句。某些 DML 语句，如引起表的存储空间扩展的插入、修改语句，Oracle 会将磁盘上存储空间的变化信息记录到数据字典中。 包括数据库管理员（DBA）在内的任何用户都不能直接使用 DML 语句修改数据字典中的内容。所有用户和管理员（DBA）只能通过访问数据字典视图来得到数据库的相关信息。一些数据字典视图可以被所有用户访问，而另一些只能被数据库管理员访问。 2. 数据字典的结构 数据字典主要包括数据字典表和数据字典视图两种。根据数据字典对象的虚实性不同，分为静态的数据字典和动态数据字典两种，其中，静态数据字典在用户访问数据字典时不会发生改变，但动态数据字典是依赖数据库运行的性能的，反映数据库运行的一些内在信息，所以在访问这类数据字典时往往不是一成不变的。 静态数据字典表 静态数据字典表是在数据库创建过程中自动运行 sql.bsq（%Oracle_HOME%\\RDBMS\\ADMIN\\sql.bsq）脚本创建的，由 SYS 用户所拥有，表中信息都是经过加密处理的。数据字典中的所有信息实际上都是存储在静态数据字典表中的。静态数据字典表的命名中通常包含 $ 符号。只有 Oracle 才能读 / 写这些静态数据字典表。例如，静态数据字典表 tab$。 静态数据字典视图 由于静态数据字典表对于用户而言是不可访问的，因此，通过对静态数据字典表进行解密和处理，创建了一系列用户可读的静态数据字典视图。在数据库创建过程中，通过自动运行 catalog.sql（%Oracle_HOME%\\RDBMS\\ADMIN\\catalog.sql）脚本创建静态数据字典视图及其公共同义词，并进行授权。例如，静态数据字典视图 USER_TABLES。 动态数据字典表 动态数据字典表是在数据库实例运行过程中由 Oracle 动态创建和维护的一系列“虚表”，在实例关闭时被释放。动态数据字典表中记录与数据库运行的性能相关的统计信息，因此又称为动态性能表。通常，动态性能表的命名以 X$开头。动态性能表由 SYS 用户所拥有。例如，动态性能表 X$KSPPI。 动态数据字典视图 在动态性能表上创建的视图称为动态数据字典视图，又称动态性能视图。所有动态性能视图命名都以 V开头，Oracle自动为这些视图创建了以‘V开头，*Oracl**e自动为这些视图创建了以‘V*开头命名的公共同义词，因此动态性能视图又称为V$ 视图。例如，动态性能视图V$DATAFILE`。 通过查询表 dictionary，可以获得全部可以访问的数据字典表或视图的名称和解释；通过查询表 dict_columns，可以获得全部可以访问的数据字典表或视图中字段名称和解释。例如： SQL&gt; SELECT * FROM dictionary;SQL&gt; SELECT * FROM dict_columns WHERE TABLE_NAME=&#x27;USER_TABLES&#x27;; SQL Copy 3. 数据字典的使用 静态数据字典表的使用 静态数据字典表只能由 Oracle 进行维护，用户不能对这些表进行直接操作。当用户执行 DDL 操作时，Oracle 系统自动对相应的静态数据字典表进行操作。例如，当执行 CREATE TABLE、ALTER TABLE 和 DROP TABLE 操作时，系统会自动对 TAB$ 表进行 INSERT、UPDATE 和 DELETE 操作。 静态数据字典视图的使用 通常，用户通过对静态数据字典视图的查询可以获取所需要的所有数据库信息。 Oracle 静态数据字典视图可以分为 3 类，各类视图具有独特的前缀，其表示形式和含义如表所描述。 静态数据字典视图分类及其含义 名称前缀 含义 USER_ 包含当前数据库用户所拥有的所有的模式对象的信息 ALL_ 包含当前数据库用户可以访问的所有的模式对象的信息 DBA_ 包含所有数据库对象信息，只有具有 DBA 角色的用户才能够访问这些视图 例如，查询当前用户所拥有的表的信息、可以访问的表的信息及当前数据库所有表的信息，可以分别执行下列语句： SQL&gt; SELECT * FROM USER_TABLES;SQL&gt; SELECT * FROM ALL_TABLES;SQL&gt; SELECT * FROM SYS.DBA_TABLES; SQL Copy 注意：以 USER_、ALL_开头的数据字典视图都具有与其同名公共同义词，用户可以直接访问，而以 DBA_开头的数据字典视图归 SYS 用户所有，没有与其对应的同名公共同义词，因此非 SYS 用户访问时，需在 DBA_视图名前加 SYS 前缀。 动态性能表的使用 动态性能表是数据库实例启动后动态创建的表，用于存放数据库运行过程中的性能相关的信息。动态性能表都属于 SYS 用户，Oracle 使用这些表生成动态性能视图。 可以通过下列语句查询当前数据库中所有的动态性能表和动态性能视图： SQL&gt; SELECT NAME FROM V_$FIXED_TABLE; SQL Copy 动态性能视图的使用 动态性能视图是 SYS 用户所拥有的，在默认状况下，只有 SYS 用户和拥有 DBA 角色的用户可以访问。与静态数据字典表和视图不同，在数据库启动的不同阶段只能访问不同的动态性能视图。 当数据库启动到 NOMOUNT 状态时，Oracle 数据库打开初始化参数文件，分配 SGA 并启动后台进程，因此只能访问从 SGA 中获得信息的动态性能视图，如 V$PARAMETER、V$SGA、V$SESSION、V$PROCESSE、V$INSTANCE、V$VERSION、V$OPTION等。 当数据库启动到 MOUNT 状态时，Oracle 打开控制文件，因此不仅能访问从 SGA 中获得信息的动态性能视图，还可以访问从控制文件中获得信息的动态性能视图，如 V$LOG、V$LOGFILE、V$DATAFILE、V$CONTROLFILE、V$DATABASE、V$THREAD、V$DATAFILE_HEADER等。 当数据库完全启动后，可以访问 V_$fixed_table 表中所有的动态性能视图。 例如，利用动态性能视图查询当前数据库参数设置信息、数据文件信息。 SQL&gt; SELECT * FROM V$PARAMETER;SQL&gt; SELECT * FROM DATAFILE; 数据类型 要使用数据库来存储数据，首先就要知道这个数据库都能存储什么类型的数据。 数据类型是在向数据表中存储数据前必须设定好的，就像如果要使用记事本查看文件内容，那么文件就要是文本的，不能有图片，否则图片是查看不了的，因为记事本中只能查看文本文件。 官网文档 在 Oracle 11g 中提供的数据类型有 23 种，下面介绍常用的数据类型。 1. 字符型 字符型在 Oracle 11g 中有 varchar2、char、nchar、nvarchar2 和 long 五种，它们在数据库中是以 ASCII 码的格式存储的。 数据类型 说明 CHAR(n) 存储固定长度的字符串，长度以字节为单位，默认和最小字符数为 1，最大字符数为 2000 VARCHAR2(n) 存储可变长度的字符串，长度以字节为单位，最小字符数是 1，最大字符数是 4000 2. 数字型 数字型在 Oracle 11g 中常用的有 number 和 float 类型两种，可以用它们来表示整数和小数。 数据类型 说明 NUMBER(p, s) 可以存储 0、正数和负数。p 表示数值的总位数（精度），取值范围为 1～38；s 表示刻度，取值为−84～127 3. 日期类型 日期类型在 Oracle 11g 中常用的有 date 和 timestamp 两种类型，可以用它们来存放日期和时间。 数据类型 说明 DATE 用于存储日期和时间。可以存储的日期范围为公元前 4712 年 1 月 1 日到公元后 9999 年 12 月 31 日，占据 7 字节的空间，由世纪、年、月、日、时、分、秒组成 TIMESTAMP(n) 表示时间戳，是 DATE 数据类型的扩展，允许存储小数形式的秒值。p 表示秒的小数位数，取值范围为 0～9，默认值为 6 4. 其他数据类型 除了上面讲过的字符型、数字型、日期类型之外，在 Oracle 11g 中还有存放大数据的数据类型以及存放二进制文件的数据类型。 数据类型 取值范围（字节） 说明 CLOB 用于存储单字节或多字节的大型字符串对象，支持使用数据库字符集的定长或变长字符。在 Oracle 11g 中 CLOB 类型最大存储容量为 128TB BLOB 用于存储大型的、未被结构化的变长的二进制数据（如二进制文件、图片文件、音频和视频等非文本文件）。在 Oracle 11g 中 BLOB 类型最大存储容量为 128TB BFILE 用于存储指向二进制格式文件的定位器，该二进制文件保存在数据库外部的操作系统中。在 Oracle 11g 中 BFILE 文件最大容量为 128TB，不能通过数据库操作修改 BFILE 定位器所指向的文件 RAW(n) 用于存储变长的二进制数据，n 表示数据长度，取值范围为 1～2000 字节 LONG RAW 用于存储变长的二进制数据，最大存储数据量为 2GB。Oracle 建议使用 BLOB 类型代替 LONG RAW 类型 ROWID 行标识符，表示表中行的物理地址的伪列类型","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"神奇的 C++ 代码片段（模版元编程）","slug":"study/ComputerScience/fragments/Snippets","date":"2022-05-26T16:00:00.000Z","updated":"2022-05-27T07:29:55.952Z","comments":true,"path":"2022/05/27/study/ComputerScience/fragments/Snippets/","link":"","permalink":"http://adversarr.github.io/2022/05/27/study/ComputerScience/fragments/Snippets/","excerpt":"哈希函数","text":"哈希函数 The code 理论上说，把任何类型丢进去都能够直接hash了： vector、map、set等stl容器 tuple、pair 等固定长模版容器 定义了 size_t hash() 成员函数的任何类/结构体 可变参数模版 ……（todo...） struct Hash &#123; template &lt;typename T&gt; typename enable_if&lt;!is_class&lt;T&gt;::value, size_t&gt;::type operator()(const T &amp;v) const &#123; return hash&lt;T&gt;&#123;&#125;(v); &#125;private: size_t __hash_reduce(size_t h) const &#123; return h; &#125; size_t __hash_combine(size_t l, size_t r) const &#123; return (l &lt;&lt; 1) ^ r; &#125; size_t __hash_reduce(size_t h, size_t t...) const &#123; return __hash_combine(h, __hash_reduce(t)); &#125; template &lt;typename T&gt; size_t comb(const T &amp;t) const &#123; return Hash&#123;&#125;(t); &#125; template &lt;typename T, typename... Args&gt; size_t comb(const T &amp;t, const Args &amp;...args) const &#123; return __hash_reduce(Hash&#123;&#125;(t), comb(args...)); &#125;public: template &lt;typename T1, typename T2, typename... Args&gt; size_t operator()(const T1 &amp;t1, const T2 &amp;t2, const Args &amp;...args) &#123; return comb(t1, t2, args...); &#125; template &lt;typename L, typename R&gt; size_t operator()(const pair&lt;L, R&gt; p) const &#123; return Hash&#123;&#125;(p.first, p.second); &#125; template &lt;typename I, typename C = typename I::const_iterator&gt; size_t operator()(const I &amp;it) const &#123; size_t hv = 0; for (const auto &amp;v : it) &#123; hv = __hash_combine(hv, Hash&#123;&#125;(v)); &#125; return hv; &#125; size_t operator()(const vector&lt;bool&gt; &amp;bs) const &#123; size_t hv = 0; for (int i = 0; i &lt; bs.size(); ++i) &#123; hv = __hash_combine(hv, Hash&#123;&#125;((int)bs[i])); &#125; return hv; &#125; template &lt;typename... Args&gt; size_t operator()(const tuple&lt;Args...&gt; &amp;tup) &#123; return apply([](Args... v) -&gt; size_t &#123; return Hash&#123;&#125;.comb&lt;Args...&gt;(v...); &#125;, tup); &#125; template &lt;typename Hashable, typename = is_same&lt;decltype(std::declval&lt;Hashable&gt;().hash()), size_t&gt;&gt; size_t operator()(const Hashable &amp;v) &#123; return v.hash(); &#125;&#125;;","categories":[],"tags":[]},{"title":"面向夏令营的微分几何整理","slug":"study/Math/SummerCamp/DiffGeometry","date":"2022-05-21T08:50:03.176Z","updated":"2022-05-21T08:50:03.176Z","comments":true,"path":"2022/05/21/study/Math/SummerCamp/DiffGeometry/","link":"","permalink":"http://adversarr.github.io/2022/05/21/study/Math/SummerCamp/DiffGeometry/","excerpt":"待完善","text":"待完善 TODO 欧氏空间 向量空间 向量空间的基本概念 首先是相关概念。 定义了内积的有限维向量空间是欧氏向量空间 经过 Schmidt 正交化可以得到标准正交基 可以定义外积运算 外积的性质 设\\(\\mathbf v_{1} ..\\mathbf v_{4}\\)是向量，则： 1. \\(\\mathbf v_1 \\wedge (\\mathbf v_2 \\wedge \\mathbf v_3) = \\langle\\mathbf v_1 , \\mathbf v_3\\rangle - \\langle \\mathbf v_1,\\mathbf v_2\\rangle \\mathbf v_3\\) 2. 拉格朗日恒等式 3. 混合积循环不变 向量分析 考虑向量值/数量值-向量/数量函数的微分： \\(\\frac{d}{dt}(\\lambda \\mathbf a ) = \\frac{d\\lambda}{dt} a + \\lambda \\frac{d\\mathbf a}{dt}\\) 外积也满足上述公式 混合积也满足上述公式 多变量时，可以进行偏导和微分，也满足上述公式 引入 梯度 场 和 Nabla算子： \\[ \\mathbf {grad} f = \\nabla f \\] 引入散度和旋度场： \\[ \\mathrm{div} \\mathbf F\\quad \\mathbf{rot} \\mathbf F \\] 欧氏空间 向量运算 注意外积的运算： 1. 反交换律 2. 分配律 坐标变换 注意欧氏空间的定向： 定向 两个标架之间的正交变换\\(T\\)的行列式为\\(1\\)时，称之为定向相同。 合同变换 Theo 设\\(\\mathcal T\\)是合同变换，则存在\\(\\mathbf T\\in O(3)\\)以及\\(P \\in E^3\\)，使得： \\[ \\mathcal T(X) = X\\mathbf T + P,\\quad \\forall X = (x^1,x^2, x^3)\\in E^3 \\] 即合同变换是正交变换和平移的复合 不难验证：合同变换的全体是一个群，称为三维合同变换群，当\\(\\det = 1\\)是，对应的合同变换是刚体运动（也是一个群），反之称为反向刚体运动。 正交标架和合同变换群 \\(E^3\\)的标架全体\\(\\mathcal F\\)与\\(E^3\\)的欧式变换群之间有一一对应。 即\\(E^3\\)的所有元素的稳定化子只有\\(\\mathbf{id}\\)，并且\\(E^3\\)中只有一个轨道。 曲线 曲线的概念 在这里我们只考虑如下定义的正则曲线 正则曲线 如果曲线满足，每一个分量都是\\(C^\\infty\\)且 \\(|dr/dt| &gt; 0\\)，对于所有\\(t\\)，则称该曲线是正则曲线。 平面上连续可微的参数曲线不一定是正规的 \\[ \\mathbf r(t) = (t^3 , t ^ 2) \\] 曲线的弧长 假设有参数方程\\(\\mathbf r = \\mathbf r(t)\\)，那么： \\[ s= \\int _ a ^ b \\| \\mathbf r&#39;(t)\\| \\mathrm dt \\] 是其弧长，是曲线的一个不变量 曲率、Frenet 标架 Theo 测地曲率和测地线 根据 Gauss 绝妙定理，\\(K\\) 只决定于曲面的第一基本形式，在保长对应下不变， 是曲面的内蕴性质。在这里继续研究曲面内蕴几何的主要研究对象。 测地曲率和测地线 我们考虑正则曲面\\(S:\\mathbf r = \\mathbf r(u^1, u^2)\\)，设有曲线\\(u^\\alpha = u^\\alpha (s)\\) 是一条弧长参数曲线。其作为空间中的曲线参数方程为： \\[ \\mathbf r = \\mathbf r(s) = \\mathbf r (u^1, u^2) \\] 建立新的正交标架： \\[ \\begin{aligned} \\mathbf e_1 &amp;= \\frac {d\\mathbf r(s)}{ds} = \\alpha(s)\\\\ \\mathbf e_2 &amp;= \\mathbf n(s)\\times \\alpha(s) \\\\ \\mathbf e_3 &amp;= \\mathbf n(s) \\end{aligned} \\] 对于该曲线来考察原曲面的性质： \\[ \\begin{cases} \\frac{d\\mathbf r}{ds} &amp;= \\mathbf e_1&amp;\\\\ \\frac{d\\mathbf e_1}{ds} &amp;= &amp; +\\kappa _g\\mathbf e_2 &amp; + \\kappa_n\\mathbf e_3\\\\ \\frac{d\\mathbf e_2}{ds} &amp;= -\\kappa_g\\mathbf e_1 &amp;&amp;+\\tau_g \\mathbf e_3 \\\\ \\frac{d\\mathbf e_3}{ds} &amp;= -\\kappa_n \\mathbf e_1 &amp; +\\tau_g \\mathbf e_2\\\\ \\end{cases} \\] 显然，式中的： \\(\\kappa_n\\) 就是曲面\\(S\\)沿着曲线\\(C\\)的切方向的法曲率； 而也可以求解出其他的参数： \\[ \\kappa_g = \\left( \\mathbf n, \\mathbf r&#39;, \\mathbf r&#39;&#39; \\right) \\] 是曲面上曲线 \\(C\\) 的测地曲率； \\[ \\tau_g = \\left( \\mathbf n, \\mathbf n&#39;,\\mathbf r&#39;\\right) \\] 是曲面上曲线 \\(C\\) 的测地挠率。 下面的定理描述了测地曲率和测地挠率的几何意义： Theo 设 \\(C\\) 是曲面 \\(S\\) 上的一条正则曲线，其在 \\(p\\) 处的测地曲率等于将其投影到切平面上的曲线的相对曲率，其平面的正向由曲面 \\(S\\) 在点 \\(p\\) 的法向量给出。 Theo 曲面\\(S\\)上任一条曲线\\(C\\)的测地曲率是保长对应的不变量，即：测地曲率是内蕴量。 在取正交参数系的情况下，计算测地曲率有如下的Liouville 公式： Theo 设\\((u,v)\\)是\\(S\\)上的正交参数系，从而\\(S\\)的第一基本形式为 \\[ I = E(du)^2 + G(dv)^2 \\] 假设\\(C\\)与\\(u\\)曲线的夹角为\\(\\theta\\)，那么其测地曲率是 \\[ \\kappa_g = \\frac{d\\theta}{ds} - \\frac{1}{2\\sqrt G} \\frac{\\partial \\log E}{\\partial v} \\cos \\theta + \\frac{1}{2\\sqrt E} \\frac{\\partial \\log G}{\\partial u}\\sin \\theta \\] 最后我们讨论测地挠率，从自然标架的运动公式可以得出： \\[ \\tau _ g = \\frac{1} {\\sqrt g} \\begin{vmatrix} &amp;\\left(\\frac{du^2}{ds} \\right)^2 &amp; - \\frac{du^1du^2}{dsds} &amp; \\left(\\frac{du^1}{ds} \\right)^2 \\\\ &amp;g_{11} &amp;g_{12} &amp; g_{22}\\\\ &amp;b_{11} &amp;b_{22} &amp; b_{22} \\end{vmatrix} \\] 故测地挠率和测地曲率一样，是\\(S\\)上切方向的函数，反映的是曲面\\(S\\)本身的性质，但其不是内蕴量。 对比主方向的方程，主方向恰好是测地挠率为 0 的切方向。同时也有如下定理成立： Theo 在曲面上非直线的渐进曲线\\(C\\) 的挠率是\\(S\\)沿着曲面\\(C\\)的切方向的测地挠率。 测地线 观察到测地曲率是内蕴量，从而要观察曲面上测地曲率为 0 的曲线（测地线） Theo 曲面上曲线\\(C\\)是测地线，当且仅当，它或是一条直线，或者其主法向量处处是曲面的法向量 例如： 旋转面上的经线是测地线 若曲面上运动的质点 \\(p\\) 只受到将它约束在曲面上的力的作用，而不受到任何其他外力作用，则\\(p\\)的轨迹是测地线 Theo 对于曲面上任意一点\\(p\\)和曲面在\\(p\\)的任意单位切向量\\(v\\)，在曲面上存在唯一的一条弧长参数测地线通过\\(p\\)且以\\(v\\)为切向量 平面 – 直线 曲面 – 测地线 Theo 设 \\(C\\) 是曲面 \\(S\\) 上的一条曲线，则\\(C\\)的弧长在任意一个有固定端点的变分\\(C_t\\)中达到临界值的充分必要条件是\\(C\\)是\\(S\\)的测地线。 从而我们有：若曲线\\(C\\)是连接\\(p,q\\)的最短线，则\\(C\\)是测地线。 测地坐标系和法坐标系 测地线族 在研究了测地线的性质后，我们研究测地线族的性质。 Theo 设\\(\\Sigma\\)是曲面\\(S\\)上覆盖了区域\\(D\\)的测地线族，\\(\\Sigma_1\\)是由在区域\\(D\\)内与\\(\\Sigma\\)中的曲线正交的轨线构成的曲线组，则其中任意两条曲线在\\(\\Sigma\\)中各条测地线上截出的曲线段长度相等。 也就是说，测地线族的任意两条正交轨线之间的距离是处处相等的。 即：测地线族的任意两条正交轨线是测地平行的 Theo 设\\(C\\)是曲面\\(S\\)上连接了\\(p,q\\)两点的一条测地线，若曲线\\(C\\)能够潜入到覆盖了区域\\(D\\)的测地线族\\(\\Sigma\\)中，且\\(p,q\\in D\\)，则其是区域内连接两点的最短线 测地平行坐标系 Theo 在曲面\\(S\\)的每一点\\(p\\)的一个充分小的邻域内必定存在参数系\\((u,v)\\)使得\\(p\\rightarrow (0, 0)\\)，而第一基本形式可以写作 \\[ I = (du)^2 + G(u,v) (dv)^2 \\] 函数 \\(G\\) 满足：$G(0, v)=1 \\(，\\)(0, v) =0\\(，参数系\\)(u,v)$是测地平行坐标系 测地极坐标系 定义指数映射： \\[ \\exp_p : T_pS \\rightarrow S\\quad \\mathbf v\\rightarrowtail \\gamma(|\\mathbf v|, \\mathbf v_0) \\] \\(\\gamma\\)对于点\\(p\\)处的单位切向量\\(\\mathbf v_0\\)，映射为弧长参数测地线上的参数为\\(s\\)的位置。 显然指数映射 \\(\\exp_p\\) 是连续可微的。于是有 法坐标系： \\[ u^\\alpha = u ^ \\alpha(\\exp_p(\\mathbf v)) = u ^ \\alpha(v^1, v^2) \\] 从而有测地圆（以\\(p\\)为中心，\\(s_0\\)为半径） Theo 高斯引理 从\\(p\\)出发的测地线与以点\\(p\\)为中心的测地圆是彼此正交的。（即曲线族\\(\\Sigma_1\\)中的每一条曲线都是测地线族\\(\\Sigma\\)的正交轨线。 由此可以推导出测地极坐标系 \\(（s,\\theta)\\) Theo 在曲面\\(S\\)的每一点的\\(p\\)邻域内，出去从点\\(p\\)出发的一条测地线外，也存在测地极坐标系，使得曲面第一形式为 \\[ I = (ds)^2 + G(d\\theta)^2\\quad \\begin{cases} \\lim _{s\\rightarrow 0} \\sqrt G = 0\\\\ \\lim_{s\\rightarrow 0} \\frac{\\partial }{\\partial S} \\sqrt{G(s,\\theta)} = 1 \\end{cases} \\] 对应了平面上的极坐标系 常曲率曲面 高斯曲率为常数的曲面为常曲率曲面。 由于高斯曲率为内蕴量，我们不难考虑如下的定理： Theo 有相同高斯曲率的任意两块常曲率曲面在局部上有保长对应。 从现在的观点来看： 常曲率曲面的第一基本形式是由其高斯曲率完全决定的 非欧几何学：将平面几何学推广到常曲率曲面 平行移动 考虑切向量场的协变微分和平行移动 Gauss-Bonnet公式 假定曲线是邮箱曲面上的一条分段光滑简单闭曲线，其包围的区域是曲面 \\(S\\) 的一个单连通区域，则 \\[ \\oint _C. \\kappa _ g \\mathrm d s + \\iint _D K \\mathrm d \\sigma = 2 \\pi - \\sum _ {i = 1} ^ n \\alpha _ i \\] \\(\\kappa_g\\) 是曲线的测地曲率， \\(K\\) 是曲面的高斯曲率 $_ i $ 表示曲线在角点\\(i\\)的外角","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"夏令营","slug":"夏令营","permalink":"http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"},{"name":"微分几何","slug":"微分几何","permalink":"http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"}]},{"title":"离散微分几何 01 - Introduction","slug":"CG/DiscreteGeometry/c1","date":"2022-04-30T15:18:43.139Z","updated":"2022-04-30T15:18:43.139Z","comments":true,"path":"2022/04/30/CG/DiscreteGeometry/c1/","link":"","permalink":"http://adversarr.github.io/2022/04/30/CG/DiscreteGeometry/c1/","excerpt":"","text":"Introduction Application: Geometry Processing: Up-sample / Down-sample — 3d-surface Shape Analysis Machine Learning. Numerical Simu What will we learn / Won't Diff Geometry Geo Processing Central — Link These two perspectives Won't view points on diff geometry huge number of algorithms What is Diff Geo Diff Geo Talk about local properties of shape and thier connection to global properties of shape Lang of geometry physics Discrete Diff Geo infinity no longer allowed expressed in terms of lenghs, angles Loss is littow: captures many fundamental ideas Translate continuous to discrete How to DDG — obtain discrete definitions write down several equivalent definitions in the smooth setting apply each smooth definition to an object in discrete Determine which properties are captured by each resulting inequivalent discrete definition Example: Discrete Curvature Curves in the Plane in 2D, a parameterized curve is a map taking each point in an interval \\([0, L]\\). Discrete Curves in the Plane: piecewise linear parameterized curve, vertices connected by straight line segments view as a interval \\(\\rightarrow\\) Segments Tangent/Normal/Curvature unit tangent: \\[ T(s) := \\frac{d}{ds} \\gamma(s) / |\\frac{d}{ds}\\gamma(s)| \\] unit Normal: \\[ N(s) = \\mathcal JT(s) \\] \\(\\mathcal J\\)表示顺时针旋转 curvature can be expressed as the rate of change in the tangent. \\[ \\kappa(s):=\\langle N, \\frac{d}{ds} T\\rangle \\] Key idea 1 — curvature is a second devirative. Key idea 2 — curvature can have sign. To Discrete in continuous: Turning angle length variation steiner formula osculating curve Integrated Curvature \\[ \\int _ b ^ a \\kappa(s) \\mathrm ds = \\varphi(b) - \\varphi(a) \\] consider \\(\\gamma_{i - 1}\\), \\(\\gamma_{i}\\),\\(\\gamma_{i + 1}\\) \\[ \\theta _ i =: \\kappa_i ^A\\quad (\\text{turning angle}) \\] integrated rather than pointwise values total change in angle, not derivative. Length Variation The fastest way to descrease the length of a curve is to move it in the normal direction, with speed proportioonal to curvature Intuition — in flat rigions, normal motions doesn't change curve length. 变分： \\[ \\eta(0) = \\eta(L) = 0 \\] Gradient of Length for a line segment","categories":[],"tags":[]},{"title":"201-04-欧拉视角","slug":"CG/GAMES/g201-04","date":"2022-04-24T16:00:00.000Z","updated":"2022-08-05T01:18:30.933Z","comments":true,"path":"2022/04/25/CG/GAMES/g201-04/","link":"","permalink":"http://adversarr.github.io/2022/04/25/CG/GAMES/g201-04/","excerpt":"GAMES 201–欧拉视角","text":"GAMES 201–欧拉视角 《Fluid Simulation for computer graphics》 Overview Material Derivatives — L. vs E. \\[ \\frac{D}{Dt} =\\frac{\\partial }{\\partial t} + \\mathbf u \\cdot \\nabla \\] 后一项：物理量随着材料一起移动造成的 例如，温度\\(T\\)： \\[ \\frac{DT}{Dt} = \\frac{\\partial T}{\\partial t} + \\mathbf u \\cdot \\nabla T \\] 温度随着时间的导数 粒子移动导致变化 例如，物质的速度\\(\\mathbf u_x\\) \\[ \\frac{D \\mathbf u_x}{D\\mathbf u_x} = \\frac{\\partial \\mathbf u_x}{\\partial t} + \\mathbf u \\cdot \\nabla \\mathbf u_x \\] （不可压缩的）NS方程 流体中速度关于时间的导数有三个成分： 压强导致 “黏”性：一般情况下忽略 重力 \\[ \\frac{D\\mathbf u}{Dt} = -\\frac 1 \\rho \\nabla p +\\nu \\nabla^2 \\mathbf u+\\mathbf g \\] 不可压缩： \\[ \\nabla \\cdot \\mathbf u = 0 \\] \\(\\mu\\) — dynamic viscosity 分成几份：（Operator Splitting） \\[ \\frac{D\\mathbf u}{Dt} = -\\frac 1 \\rho \\nabla p +\\mathbf g \\] \\[ \\nabla \\cdot \\mathbf u = 0 \\] 变为： \\[ \\begin{aligned} \\frac{D\\mathbf u}{Dt} = 0\\\\ \\frac{D\\alpha}{Dt} =0\\\\ \\frac{\\partial \\mathbf u}{\\partial t} = \\mathbf g\\\\ \\frac{\\partial \\mathbf u}{\\partial t} = - \\frac{1}{\\rho} \\nabla p\\quad s.t. \\nabla \\cdot \\mathbf u = \\mathbf 0 \\end{aligned} \\] 时间离散后： Advection：“移动”流体场 求解\\(u^*\\)：\\(Du/Dt = D\\alpha / Dt = 0\\) External Forces \\(u^{**}\\) Projection：添加压强作用：\\(\\partial u / \\partial t = -1/\\rho \\nabla p, s.t. \\nabla \\cdot u^{t+1} = 0\\) 使用网格（Grid）进行模拟 Staggerd-Grid: 边 - 存放 \\(u\\) 和 \\(v\\) 中心 - 存放 \\(p\\) 使用双线性插值来计算任何一点的压强、速度等属性 双线性插值 - 利用面积相对总面积作为权重。 Advection Semi-Langrangian MacCormack/BFECC BiMocq Partical advection Semi-Lagrangian 如何计算速度场的变化：取上一步在 \\(x-u(x) \\Delta t\\) 处的值 假设有顺时针旋转的速度场，那么这个速度场会越来越“小”。 实际上这一步是一个ODE的求解问题，可以使用RK方法来解决这个问题。 但会越来越糊 -- 加权平均的问题。 BFECC: Back and Force Error Compensation and corrrection. \\(x^* = SL(x, dt)\\) \\(x^{**} = SL(x^*, - dt)\\) Estimate error: \\(e = \\frac 1 2 (x ^ {**} - x)\\) Apply error: \\(x^{final} = x^* + e\\) Projection 目标：求出标量场 \\(u\\) 使得 \\[ \\frac{\\partial \\mathbf u}{\\partial t} = - \\frac{1}{\\rho} \\nabla p \\] 转化为： \\[ \\nabla \\cdot \\nabla p = \\frac{\\rho}{\\Delta t} \\nabla \\cdot u \\] 这是一个泊松方程。 Top Algorithms: Krylov Subspace Iteration method. Decompositional Approach For Matrix Computation. FFT FMM (Fast Multipole Method) 求解大规模线性系统 PARDISO Iterative Gauss-Seidel Jacobi (Preconditioned) Krylov-subspace solvers. Matrix Storage Dense Sparse Matrix-Free. Krylov Subspace Iteration method. CG CR GMERS BiCGStab An introduction to Conjugate Gradient Method Without the Agonizing Pain. Tricks Warm Starting 对于大多数情况下有显著效果。 Preconditioning 消除较大的条件数 Multigrid (MGPCG) A Multigrid Tutorial A parallel multigrid Poisson solver for fluid simulation ... References. 2018 TOG: An Advection-Reflection Solver for Detail-Preserving Fluid Simulation.","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"Programming","slug":"study/ComputerScience/fragments/WhyProgramming","date":"2022-04-21T14:54:19.222Z","updated":"2022-04-21T14:54:19.222Z","comments":true,"path":"2022/04/21/study/ComputerScience/fragments/WhyProgramming/","link":"","permalink":"http://adversarr.github.io/2022/04/21/study/ComputerScience/fragments/WhyProgramming/","excerpt":"占坑","text":"占坑 为什么要研究语言 很多时候，我们会在网络上看到一些没有意义的问题： Q: 什么是世界上最好的语言？ anwser 肯定不是php。 这类问题是怎么产生的呢？我们日常开发中经常见到的一个场景是： Why????写 C++：为什么这个文件无法通过编译！为什么别人的代码无法在我的机器上运行！为什么别人的代码和我学过的完全不是一个东西！xxxx……写 Python：为什么这个变量传递进去就是错的！为什么没有自动补全为什么这么慢！这是个什么神奇的语法？为什么这个变量不变/变了！！！写函数式：为什么我要写/学这个东西？！写 Java / C#：为什么能够有人不用ide就开发！写 Swift：为什么这个语法如此的丑陋！ 诸如此类，这些乱七八糟问题都会促使工程师们（码农们）去想要用别的语言来处理当前/原有的业务。 回到最开始的那个问题，为什么人们会孜孜不倦的讨论世界上最好的语言这个问题？实际上问题在于，对于一个极其复杂的业务，一种编程语言，或者说一种编程范式，其始终无法满足需求。而当一个新的语言，在当前的业务逻辑上，相交于之前的语言的实现上更加简单且高效的时候，程序员一定会破口大骂，为什么自己没有早点发现/学习这个语言。 最经典的场景莫过于绝大多数的同学，在大二开始接触Python/Java的时候，疯狂抱怨自己为什么要学习 C/C++，为什么学校还要墨守陈规得继续教授C++。 从上面的问题中，我们不难看到几个关键词： 编程范式：什么是面向对象/数据/过程/函数式 效率：简单、高效的实现/程序加速 这些东西我们分开来一个个谈吧。 到底程序是个啥 程序 = 方法 + 数据 （一般在设计 Class 的时候，人们更倾向于把成员函数称为一个方法，而对于一些其他的函数，我们就叫做函数。 Anyway，如果你和我一样只是把函数和方法都看作数据上的操作的话，实际上也没有必要特别区分方法和函数，因此在我考虑问题、设计程序算法的时候，我通常不区分方法和函数） 这几乎就是我们进行所谓的程序设计的一个起点！很大程度上，我在程序设计的起点，我需要搞明白的很少的一些东西： 这个程序的输入是什么 这个程序的输出是什么 这个程序会对外部（例如操作系统状态）产生什么影响 举一些🌰： 一个矩阵乘法程序，就是拿到两个矩阵的数据，对它们进行矩阵乘法这个方法，然后吐出来一个矩阵 一个计算器，就是监听用户的输入，并记录下来，使用内置的一些固定的方法，在记录的数据上做操作，然后给用户一个输出 ……（你也可以再想想自己写过的啥程序） 对于其中的数据我们再熟悉不过了，在你见到的几乎所有的语言中，他们就是你直接操作的常/变量。对于这些量而言，在设计算法的初期，我们几乎不考虑它具体的值，我们更加关心的是它的类型！（有关类型，会在后面进行介绍）但是对于程序而言，一个运行时的程序，通常更加关注它的值。 正如SICP中对于程序设计的描述上，其关键点有： 定义出这个程序的输入和输出 定义出这个程序所需要的数据，例如 Point&#123; int x; int y; &#125; 根据我们拿到的数据、输入，来设计我们程序的大体框架（画流程图、伪代码等等） 设计函数：把上面的框架做拆解，通常我习惯于类似于做一个广度遍历，逐步把上面流程图中涉及的一些方法做一个实现。 开始你的实现。 语言逻辑、表达能力 好吧，我们这里根本不考虑所谓程序，因为我们绝大多数人从来都不是直接写二进制程序的！因此我们这里考虑的是语言的表达能力。（虽然我们在后文中不太考虑程序和代码的区别） 实际上我们已经知道答案了 —— 图灵完备： In computability theory, a system of data-manipulation rules (such as a computer's instruction set, a programming language, or a cellular automaton) is said to be Turing-complete or computationally universal if it can be used to simulate any Turing machine (devised by English mathematician and computer scientist Alan Turing). This means that this system is able to recognize or decide other data-manipulation rule sets. Turing completeness is used as a way to express the power of such a data-manipulation rule set. Virtually all programming languages today are Turing-complete. TLDR：从理论上说，我们使用的所有语言都有相同的表达能力！ 那么问题是，为什么我们还需要考虑一个编程语言的表达能力呢？从我的理解来看，回答这个问题就和 Hello World 一样简单： 对于 Python： print &quot;Hello World&quot; # py2print(&quot;Hello World&quot;) # py3 对于 C： #include&lt;stdio.h&gt;int main() &#123; printf(&quot;Hello World\\n&quot;); return 0;&#125; 或者 C++： #include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl; return 0;&#125; 对于 Racket（一种函数式编程语言）： (print &quot;Hello World&quot;) 从这里我们就能看出问题了，为了实现相同的功能，三种语言体现出完全不同的复杂、直观程度。 Python：直观的、简单 -- 很简单 C：直观的、不简单 -- 至少函数叫做 print C++：不直观的、不简单 -- 什么是 cout？什么是 &lt;&lt;？为什么是 &lt;&lt;？ Racket：不直观、简单 -- 问题在于为什么需要这个括号？ 程序=数据+函数 范式 函数是第一公民 ASYNC 词法、语法、解析与执行 NFL 简单 + 舒适 复杂 + 舒适 简单 + 难受 复杂 + 难受","categories":[],"tags":[]},{"title":"201-03-拉格朗日视角2","slug":"CG/GAMES/g201-03","date":"2022-04-20T16:00:00.000Z","updated":"2022-08-05T12:32:54.038Z","comments":true,"path":"2022/04/21/CG/GAMES/g201-03/","link":"","permalink":"http://adversarr.github.io/2022/04/21/CG/GAMES/g201-03/","excerpt":"GAMES 201 -高级物理引擎实战 - 4 - 拉格朗日视角","text":"GAMES 201 -高级物理引擎实战 - 4 - 拉格朗日视角 变形 – Deformation Reading： The classical FEM method and discretization methodology The MPM for simulating continuous … 形变就是一个单对单的映射：(从静止的位置映射到形变的位置） \\[ \\phi : \\mathbb R^3 \\rightarrow \\mathbb R^3 \\] 从而形变梯度为： \\[ \\mathbf F = \\frac{\\partial \\mathbf x_{deformed}}{\\partial \\mathbf x_{rest}} \\] 不难发现到\\(\\mathbf F\\)是平移不变的。 体积变化即为：\\(J = \\det \\mathbf F\\) 弹性 弹性 材料有恢复原始状态的性质 考虑超弹性模型 我们只观察超形变物体（有strain能量函数\\(\\Psi\\)）的 Potential Function: 惩罚函数，惩罚形变。\\(\\varPsi(\\mathbf F)\\) 注意区别： stress - 应力：材料内部的弹性力 - 就是Deformation Gradient strain - 应变：（形变的Measure）直接替换为 \\(\\mathbf F\\) Stress Tensor 表明了材料微元和其他材料微元的相互作用： 有不同的stress tensor（三种常用的） PK1：\\(\\mathbf P(\\mathbf F) = \\partial \\Psi (\\mathbf F) /\\partial \\mathbf F\\) 容易计算，但在rest space Kirchhoff stress：\\(\\tau\\) Cauchy Stress：\\(\\sigma\\) 相互关系为： \\[ \\tau = J \\sigma = \\mathbf P\\mathbf F^T \\] Traction = \\(\\mathbf t = \\sigma^T \\mathbf n\\) 常用属性（描述弹性材料） 杨氏模量 – \\(E = \\sigma / \\varepsilon\\) - 对应弹簧的 \\(k\\) Bulk modulus - 常见于可压缩液体的仿真 泊松比 \\(\\nu \\in [0, 0.5)\\) - 泊松比是材料的一个力学参数，定义为横向应变与纵向应变的比值，也叫横向应变系数。 考虑 Lame Parameters： \\(\\mu\\) \\(\\lambda\\) 可以相互转换，只要指定\\(\\mu\\)和杨氏模量 常用超弹性模型 Linear elsaticity – 小形变下可以，但对于旋转没有惩罚 - 导出的是线性方程组 Neo-Hookean Fixed Corotated FEM basics 目标：建立离散方程（PDE） Linear Tetrahedral FEM(Triangular) 假设对每一个元素 Deformation map 是仿射变换，即\\(F\\)为常数。 对于每一个元素（三角形） \\(e\\)，弹性势能为： \\[ U(e)=\\int_e \\psi(\\mathbf F(\\mathbf x))\\mathbf x = V_e \\psi (\\mathbf F_e) \\] 简单求解一个线性方程组即可解得 \\(\\psi = Fx + B\\) 力是势能\\(U\\)对位置\\(x\\)的导数 求出力： \\[ f_{t, i} = - \\frac{\\partial U}{\\partial \\mathbf x_i}= - \\sum_e V_e \\mathbf P(\\mathbf F_e)\\frac{\\partial \\mathbf F_e}{\\partial \\mathbf x_i} \\] FEM Table","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"102-05-B样条曲线","slug":"CG/GAMES/g102-05","date":"2022-04-19T16:00:00.000Z","updated":"2022-04-26T13:29:00.253Z","comments":true,"path":"2022/04/20/CG/GAMES/g102-05/","link":"","permalink":"http://adversarr.github.io/2022/04/20/CG/GAMES/g102-05/","excerpt":"GAMES 102 -- 5 B样条曲线","text":"GAMES 102 -- 5 B样条曲线 B 样条曲线 建模的两种形式 重建 – 形状已经有了，猜出来– 基函数组合 设计 – 产生 – 自行组合权系数 如果用 Bernstein 基函数？ 顶点和曲线的关联性强，具有较高的几何意义 \\(n\\) 次Bernstein基函数 \\[ B_i ^{(n)} (t) = C_n ^ i t ^ i ( 1- t ) ^{n - i} \\] 从而： \\[ \\mathbf f ( t ) = \\sum_{i = 1} ^ n b_i ( t )\\mathbf p_i, \\quad t \\in [0, 1] \\] 我们使用Bernstein基函数替代权函数： \\[ x(t) = \\sum_{i=0}^n B_i^n(t) b_i \\] B曲线的性质 观察基函数： 具有对称性（关于 \\(i\\)） 当 \\(t = i/n\\) 最大 非负性 + 权性（加和为1）— 具有凸包性 曲线始终在凸包内 基性 – 是\\(n\\)次多项式空间的基 递推公式（从组合系数证明） 端点差值 – 经过始末顶点 端点性质 – 插值 切线方向和边相同 升阶 — 通过递推公式来推导 de Casteljau 算法 输入：点 输出：在 \\(t\\) 位置的值 思想：反复用 \\(t \\mathbf x + (1-t)\\mathbf y\\) 作用在相邻点上 复杂度 – \\(O(n^2)\\) 算法只有线性运算，计算稳定 应用：离散、求根 两Bezier曲线的拼接条件 要求\\(C^1\\)：要求有连接点同向 要求\\(C^2\\)：要求连接点是中点 广义样条曲线 分段的多项式曲线（Bezier曲线） B 样条 Bezier 曲线的不足： 全局性！牵一发而动全身-不利于设计 思考：怎样统一表达？ 类比：每个控制顶点用一个基函数 \\[ x(t) = \\sum N_{i, k}(t) \\cdot d_i \\] 性质： 局部性 正、权性 …… 启发：根据递推公式– 局部类似，由一个基函数平移得到 高阶的由两个低阶的基函数升阶得到 B-样条 对于均匀节点\\(\\cdots,i,i+1,\\cdots\\) 定义如下： \\[ N_i^1(t) = \\begin{cases} 1, &amp; i \\le t &lt; i + 1\\\\ 0 \\end{cases} \\] 那么： \\[ N_i^k= \\frac{t-i}{k-1}N_i^{k-1} + \\frac{i+k-t}{k-1}N_{i+1}^{k-1} \\] 对于非均匀节点：\\(t_0&lt; t_1 &lt; \\cdots&lt;t_n\\) \\[ N_i^1(t) = \\begin{cases} 1, &amp; t_i \\le t &lt; t_{i + 1}\\\\ 0 \\end{cases} \\] \\[ N_i^k= \\frac{t-t_i}{t_{i+k-1}-t_i}N_i^{k-1} + \\frac{t_{i+k}-t}{t_{i + k} - t_{i + 1}}N_{i+1}^{k-1} \\] 样条曲线 从而根据上述基函数，可以定义样条曲线。 设置重数： 设置重数来避免始末点不重合 其他理论知识 性质很多： 局部凸包性 变分缩减性 包络性 导数、积分 几何作图","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"102-04-B样条曲线","slug":"CG/GAMES/g102-06","date":"2022-04-19T16:00:00.000Z","updated":"2022-04-28T12:56:59.341Z","comments":true,"path":"2022/04/20/CG/GAMES/g102-06/","link":"","permalink":"http://adversarr.github.io/2022/04/20/CG/GAMES/g102-06/","excerpt":"","text":"B-样条 Bezier 曲线问题：无法表示圆弧 投影几何： 齐次坐标： \\[ x\\rightarrow \\left(wx, w\\right) \\] 提出有理Bezier曲线 有理Bezier曲线 在每个控制顶点上设置权函数 \\[ f^{eucl}(t) =\\sum_{i=0}^n\\mathbf p_i\\frac{B_i^d(t) \\omega_i}{\\sum_{j = 1} ^ n B_j^{d} (t) \\omega _i}=\\sum_{i=0}^n\\mathbf q_i(t)p_i \\] NURBS — 非均匀有理B样条 定义： \\[ f(t) = \\frac{\\sum_{i = 1} ^ n N_i^{(d)} (t) \\omega_i \\mathbf p_i}{\\sum _ {i = 1} ^ n N_i^{(d)} \\omega_i} \\] 影响 NURBS 曲线因素： 控制顶点 — 用户交互 节点向量 — 决定了 B-样条基函数 权系数 — 形状 细分曲线 回顾 Bezier 曲线作图法 逐步割角、磨光 思想 拓扑规则：加入新的点 — splitting 几何规则：移动顶点 — averaging Chaikin细分 割角法 每条边取中点，生成新的点 取相邻点的平均作为新的点 如果用矩阵表示， \\[ x&#39; = M x \\] 那么可以用极限来计算 好的细分规则，则其最大特征根 \\(= 1\\) 插值型细分方法 细分方法： 保留原有顶点 对每个边增加新顶点 迭代生成新曲线 思路 可以看成“补角”法 四点插值细分 \\[ p&#39;_{2i + 1} = \\frac{p_i+p_i+1}{2}+ \\alpha (\\frac{p_i + p_ i + 1}{2}- \\frac{p_{i - 1} + p _ {i + 2}}{2}) \\] 隐式曲线 隐函数定理：存在且唯一 — 难以找到 隐式曲线 升高一维： \\[ z = f(x, y) \\] 可以看作是二元函数的零等值线 同时可以定义曲线的内部和外部。 隐式曲线的绘制 例如： 直线 — 三元一次方程 等值线抽取 输入：一个二院隐式函数 输出：等值线 目的 — 参数化 Marching Cubes算法：最常用算法 思想： 在离散格子上求值 利用局部连续性来插值 按一定的顺序形成离散曲线 还有很多其他歧义的情况。 Adaptive Grids： 隐式曲线拟合 输入：平面上的一些点（设为自封闭曲线） 输出：拟合这些点的一个隐式曲面 转化为拟合问题。 构造方法很多 NURBS曲面 参数曲面 — \\(\\mathbb R ^ 2 \\rightarrow \\mathbb R ^ 3\\) 基本方法：张量积函数转化为张量积曲面 可以看作是曲线的曲线 两个参数的顺序无关。 Bezier 曲面 曲面性质 — 类似于曲线 作图法：de Casteljau Bezier曲面拼接连续 表达带“洞”/非矩形边界的曲面 使用参数域上的洞来表达 三角面片也可以对应定义Bazier曲面片 总结 张量积曲面： 两个独立方向的“曲线的曲线” 性质类同于曲线的性质 表达、公式形式比曲线情况更加复杂 特殊性 — 角点是否光滑？ 张量积体： Bezier 体","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"102-03-参数曲线拟合","slug":"CG/GAMES/g102-03","date":"2022-04-18T16:00:00.000Z","updated":"2022-04-19T03:40:08.873Z","comments":true,"path":"2022/04/19/CG/GAMES/g102-03/","link":"","permalink":"http://adversarr.github.io/2022/04/19/CG/GAMES/g102-03/","excerpt":"几何建模与处理","text":"几何建模与处理 多元函数 \\[ f:\\R ^n \\rightarrow \\R \\] 二元函数基函数构造 方法：张量积（两两相乘） 张量基函数 优点：定义简单，多个一元基函数的乘积形式 不足： 维数增加 – 基函数个数 \\(n^2\\) – 变量（参数数量）增加 神经网络表达 用单变量函数 \\(\\sigma(x)\\) 和不同的仿射变换来构造基函数。 向量值函数 \\[ f:\\R^m \\rightarrow \\R^n \\] 看成多个单变量函数，各个函数独立无关。 共享基函数 几何上： 对于\\(m=1\\) – 轨迹为曲线 — 本质维度=1 对于 \\(\\R^2 \\rightarrow \\R^3\\) — 参数曲面 — 本质维度=2 — \\(3\\rightarrow3\\) — 变形 – 应用：有限元、图像变形 \\(3\\rightarrow 2\\) — 降维映射 — 例如 AutoEncoder 总结 曲线拟合 曲线拟合问题 输入：给定平面上的点 输出：一条参数曲线，拟合这些点 \\[ f:\\R \\rightarrow \\R^2 \\] 参数化 — \\[ \\begin{cases} x = x(t)\\\\ y = y(t) \\end{cases} \\] 问题转化为：对数据点 \\((x_i,y_i)\\)，对应哪个参数\\(t_i\\)？ \\(E = \\sum\\|\\mathbf p (t_i) - \\mathbf p_i\\|\\) 如何确定 \\(t\\) 均匀参数化（Equidistant Parameterization） 弦长参数化 \\(t_{i+1} - t_i =\\|\\mathbf b_{i+1} -\\mathbf b\\|\\) 中心参数化 需要好的参数化 目的：保持原有结构！ 曲面参数化 三维点找二维的参数 — 降维问题 例如： 纹理映射 世界地图","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"102-04-三次样条函数","slug":"CG/GAMES/g102-04","date":"2022-04-18T16:00:00.000Z","updated":"2022-04-19T07:52:10.194Z","comments":true,"path":"2022/04/19/CG/GAMES/g102-04/","link":"","permalink":"http://adversarr.github.io/2022/04/19/CG/GAMES/g102-04/","excerpt":"GAMES 102 – 几何建模与处理","text":"GAMES 102 – 几何建模与处理 三次样条函数 力学解释 曲线：弹性梁 — 弹性模量为 \\(E\\) 利用贝努利-欧拉方程，得到近似为分段三次函数 2次 — 无法表达拐点、三次 — \\(C^2\\)，四次 — 误差大 如何求？满足什么条件？ 思路 分段三次多项式，四个变量待定 \\[ y_{i}(x) = a_i + b_i x. + c_i x ^ 2 + d_i x ^ 3 \\] 从而有 \\(4n-2\\) 个约束条件，加上两个边界条件。 列出三弯矩方程组（对称、三对角、对角占优），可以使用追赶法来计算。 边界条件 自由端 — 指定二阶导数 夹持端 — 指定一阶导数 三次基样条 使用三次基函数，计算在基函数下的“坐标” 三次样条曲线 取 \\(x,y,z\\) 参数化 曲线的连续性 参数连续性：\\(C^2\\)连续 — 和参数有关 几何连续性：设 \\(\\phi(t)\\) 是给定曲线的参数方程，存在参数变换，可以达到的连续性是几何连续性。记为\\(G^n\\) 具体： \\(G^0\\)，连续 \\(G^1\\) 切线相同 \\(G^2\\) 曲率相同","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"实时布料仿真","slug":"CG/SortByCato/ContactDetection/ClothSimu","date":"2022-04-14T14:07:32.651Z","updated":"2022-04-14T14:07:32.651Z","comments":true,"path":"2022/04/14/CG/SortByCato/ContactDetection/ClothSimu/","link":"","permalink":"http://adversarr.github.io/2022/04/14/CG/SortByCato/ContactDetection/ClothSimu/","excerpt":"Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021","text":"Real-Time Cloth Simulation on GPU -- by Huaming Wang 2021 Introduction Dynamic Solver： High resolution High nonlinearity High stiffness — 多次迭代、计算量 Collision: Collision detection Collision Response. Problem Definitions Terms Position Vector: \\[ \\mathbf x = [\\mathbf x_0 \\mathbf x_1 \\cdots \\mathbf x_N]&#39; \\] Velocity: \\[ \\mathbf v = \\dot {\\mathbf x}\\quad \\mathbf M = diag(m_0, \\dots, m_N) \\] Energy – Holonomic(Position only): \\[ E(\\mathbf x) \\] 例如： 重力势能 弹簧能量 Fixing Energy — \\(\\frac{\\sigma}2 (\\mathbf x_i -\\mathbf y_i)^2\\) Time Integration 常用：隐式欧拉法 求解方法： 消去 \\(\\mathbf v^{t + \\Delta t}\\) 转化为非线性优化问题 从而，整个问题都变为： \\[ \\mathbf x^{t + \\Delta t} = \\arg\\min_{\\mathbf x} F(\\mathbf x) \\] 其中 \\(F\\) 由动能和势能组成。 碰撞 作为约束项出现： \\[ \\mathbf x^{t + \\Delta t} = \\arg\\min_{\\mathbf x} F(\\mathbf x) \\\\ s.t.\\quad \\mathbf x^{t + \\Delta t} \\in \\Omega \\] 上式存在隧穿问题(Tunnel)。故采用CCD。 \\[ \\mathbf x^{t + \\Delta t} = \\arg\\min_{\\mathbf x} F(\\mathbf x) \\\\ s.t.\\quad s \\mathbf x^t + (1-s) \\mathbf x^{t + \\Delta t} \\in \\Omega \\forall s\\in [0,1] \\] Dynamics 非线性优化通常有如下的形式： \\[ \\mathbf x ^{k+1} = \\mathbf x^k - \\alpha^{k + 1} \\left(A^{k+1}\\right)^{-1} \\mathrm{grad} \\] Newton 法 优点 2 阶方法 Hessian Matrix 问题 如何求解 \\(A^{-1}f\\) — 计算量大 不一定收敛 减小 \\(\\alpha\\) 要求 Hessian 正定 梯度下降 \\[ A = \\mathrm{id} \\] 优点 GPU++ 简单 缺点 1阶收敛 – 慢 没有任何实时模拟器使用 Projective Dynamics 用常矩阵代替 \\(A\\) 优点： CPU++，（C 可以被预分解） 收敛快 — smoother 缺点 GPU不友好 1阶收敛速度（总体上很慢） Diagonal Hessian \\[ \\mathbf A^{k+1} = \\mathrm{diag\\ grad} \\] 优点 收敛快于GD GPU++ 缺点 速度仍然差于牛顿 Lower Hessian 使用hessian的下三角 优缺点同 Diag Hess 总结对比 Acceleration Chebyshev — GPU Firendly Multiscale Acceleration Conclusion CPU：Projective Dynamics + Newton-Raphson GPU：Chebyshev + Diagonal Hessian / Newton + PCG More PBD — Position-Based Dynamics NVCLOTH Regular Grid Mesh Avoid Topology info mem access more suitable for high resolution 碰撞 两部分：碰撞检测 + 碰撞响应 具体看综述 检测 mesh -&gt; pair -&gt; collision Response Iterative Position-Based Repulsion Impact Zone Method Untangling Other Topics Friction Nonelastic Locking Physical model and measurement","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"仿真模拟","slug":"仿真模拟","permalink":"http://adversarr.github.io/tags/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/"},{"name":"布料","slug":"布料","permalink":"http://adversarr.github.io/tags/%E5%B8%83%E6%96%99/"}]},{"title":"Collision Detection 整理 6 - 综述","slug":"CG/SortByCato/ContactDetection/Survey","date":"2022-04-11T16:00:00.000Z","updated":"2022-04-15T04:13:25.291Z","comments":true,"path":"2022/04/12/CG/SortByCato/ContactDetection/Survey/","link":"","permalink":"http://adversarr.github.io/2022/04/12/CG/SortByCato/ContactDetection/Survey/","excerpt":"碰撞检测 学习笔记","text":"碰撞检测 学习笔记 [toc] 碰撞处理简述 碰撞处理的难度是不大的，主要问题是如何进行快速、准确的碰撞检测。碰撞检测主要算法执行流程如下图： GAMES-103-Wang 碰撞检测 -- Introduction 首先再次引一下 PhyX 里面的内容，这也是这篇文章整体的一个思路。 Overview of Collision in PhysX Broad Phase AABB vs AABB, 3 axis sweep and prune Mid Phase AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABB tree 对于 Narrow Phase： 流体-SPH Fluids (CCD) Particles vs static triangle mesh • Particles vs dynamic primitives 布料-Cloth (CCD) Vertices vs static triangle mesh • Vertices vs dynamic primitives 刚体-Rigid body (Discrete) – GJK or SAT Convex mesh and primitives vs static triangle mesh Convex, primitives vs Convex, primitives 解释一些事情： 对于大多数情况下的碰撞，我们只考虑物体之间的情况，而不是物体内部。 Broad-Phase做的实际上是生成式的，而非筛选式的，Mid-Phase对于Broad-Phase进行筛选，Narrow-Phase是筛选结果来精确计算是否真正发生了碰撞。 很多研究认为 Narrow-Phase 的效率并不需要太多考虑，而前两个筛选的效率大大影响了结果 对于Narrow-Phase中的三类物体，它们有不同的属性： 流体 -- SPH模拟假设为一个个小的水块，自相交检测策略不同 布料 -- Mass-Spring or PBD，约束为任何物体不能穿透布料表面，也适用于自身，所以需要进行自碰撞处理 刚体 -- 不可能发生自碰撞，只考虑物体之间的碰撞。 Broad-Phase 实际上这个没啥好讲的，主要思路就是建立空间数据结构，然后加速计算。 BVHs Spatial Hashing 加速结构 就如之前提到的，Broad-Phase主要是使用空间数据结构来加速碰撞检查，这类数据结构按照欧氏空间的坐标来对于整个空间进行索引加速，从而实现快速查找近邻的目的。 OCT-tree/kdTree 八叉树：将一个Box按照点\\(P\\)和经过\\(P\\)平行于\\(xOy,yOz,zOx\\)的平面划分。 kd树：每一次选择一个超平面划分所有点，超平面的选择依照\\(xOy, yOz, zOx,xOy,yOz,\\cdots\\)的顺序选择。 可能碰撞转化为查询轨迹和物体是否相交，等价于查询是否和当前节点的覆盖范围相交，若检查到轨迹和结点覆盖范围 相交： 叶子节点，认定为可能碰撞的目标 非叶结点，继续递归查询 不相交： 停止递归查询 这样构造层次结构的问题是： 过于规则：容易出现不均匀分割，从而导致内存浪费和查询效率下降。 不利于并行计算—这也是层次结构的通病 BVH BVH可以看作是OCT-Tree和kdTree的一个推广：Bounding Volumn Hierarchy（BVH） 将全空间进行划分，对于维度为 1 的情况，BVH与线段树几乎没有区别。不过，BVH和OCT-Tree等的最大的区别在于 OCT-Tree 和 kdTree进行划分时使用的是边界去切分整个平面，而BVH用的是有限体积的“框”去做空间细分。典型的BVH包括： AABB：轴对齐包围盒 OBB：旋转包围盒 kDOP：k边形包围盒 Bounding Sphere：包围球 可以看出，各个算法不同的部分是选用的“框”的形状。另外，在构造上BVH有启发算法，可以是的其构造的层次结构尽量均匀，进一步提高BVH的加速能力。 Spatial Hashing / Spatial Partitioning Spatial Hashing 的思想是为每一个空间一个编号。最简单的方法是均匀的使用格点来对于全空间进行划分。最基础的 Spatial Hashing 在为每一个格子建立列表，列表中存放所有和该格子有重合区域的物体（即一个物体可能出现在多个格子内），在查询碰撞时即对于同一列表中的不同物体进行查询即可。 Spatial Partitioning 如图所示，其将全空间划分为16个格子。考虑到减少空间浪费的问题，将这些物体的按id进行排序，即可在不为每一个id建立表格的情况下完成筛选。 该算法的主要问题在于，现代的渲染常常物体、面元分布极不均匀，在可能在几个小的cell中包含大量物体，而产生大量的可能碰撞物体对，极大的降低了其查询效率。 但是得益于其可以轻松在并行计算环境，特别是GPU上进行实现，其在物理引擎中也得到了广泛的应用。 Mid-Phase 之所以把Mid-Phase放在BroadPhase中是因为它用的算法和数据结构实际上和BroadPhase几乎是一致的。 Mid-Phase会对Broad-Phase筛选出的pair进行进一步筛选，针对每一个物体，其通过细分为更小的物体块（如凸包，面元组等），然后继续应用加速结构进行筛选。 在这个的基础上还有一些 local 的加速方法，但这也不能算是 Broad-Phase 的方法，因为这个方法针对于 Deformed 的物体进行计算的效率较高。这些方法在曲面上进行划分，相当于在曲面上定义了一个空间划分。比如通过形变能量来指导在其上的空间划分，最后精细化求解使用三次方程法求解。例如：该论文提出，可以依照形变能量，在曲面的表面上建立BVH，来指导Culling进行。 Energy-based Self-Collision Culling for Arbitrary Mesh Deformations Narrow-phase 1 刚体 DCD Signed Distance Function 如果我们能为刚体定义一个连续函数，使得对于\\(\\mathbf x \\in \\Omega -\\partial \\Omega\\)有\\(\\phi(\\mathbf x) &lt; 0\\)对于所有\\(x\\not \\in \\overline \\Omega\\)，有\\(\\phi(x) &gt; 0\\)，则可以很简单的通过函数零点的存在性来判断是否碰撞。 但对于一般的网格，难以定义这样一个带符号的距离函数。 凸包/刚体的DCD计算 对于一般的刚体之间的碰撞检测，一般采用分解为凸包的算法来进行精准的碰撞检测。因此，最基础的针对凸物体的碰撞检测算法（即凸物体之间的碰撞检测） GJK算法 Idea 设\\(\\mathcal A = \\{\\mathbf x\\}\\)，\\(\\mathcal B = \\{\\mathbf x\\}\\)是两个凸集，定义其 Minkowski 差为： \\[ \\mathcal A - \\mathcal B :=\\{\\mathbf x_1 - \\mathbf x_2| \\mathbf x_1 \\in \\mathcal A, \\mathbf x_2 \\in \\mathcal B \\} \\] 不难证明，\\(\\mathcal A\\)和\\(\\mathcal B\\)碰撞，当且仅当\\(0 \\in \\mathcal A - \\mathcal B\\)。 问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于凸物体，我们可以有快速算法实现。 Support 函数和 Simplex 单纯形 其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski 差的一个子集包含了\\(0\\)，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。 为了生成这样的单纯形，我们计算 support 函数来快速获取给定方向上的支撑点，如图所示[^1]。 迭代求解 有了如上的论述，我们可以通过如此构造单纯形： 随机生成一个单纯形 假定当前的单纯形为\\(\\{v\\}\\)则选择距离原点最远的抛弃，对于 n - 1 维单纯形求法向量，求support（两个） 直到 检查到 0 =&gt; 碰撞 如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞 可以证明，这样的算法一定在有限步内结束。 SAT算法 一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个\\(n - 1\\)维的超平面能够完全分开这两个凸集合。 遍历所有的边（三维则是面），投影到其正交补空间上。若存在一个边，能使得投影完全分离，则其是不相交的，反之相交。具体实现为遍历所有的边来进行判断。 凸包分解和碰撞检测 对于一般的刚体，我们可以选择使用凸包分解（V-HACD），将刚体“拆分”成小的凸包。并使用适用于凸包的 Collision Detect 来进行碰撞的判断。 CCD 刚体的CCD算法大致有如下几类： 求解代数方程 滑动体积法（Swept Volume） 二分搜索 Conservative Advancement 上述大部分都难以处理一般的多面体情况。但也有一些特殊情况。 代数方程求解 这种方法仅适用于简单而特殊的情况，例如Ref： 光线 平面 球体、圆柱、圆锥、视锥 AABB、OBB、kDOP 凸包 “近似CCD” 通过减小模拟的时间步长，可以将 DCD 近似为 CCD。 二分搜索 这个方法仅仅用于确定 TOI 物理模拟中有时会使用二分法（二分搜索）来查找撞击时间：使用这种方案，可以非常快速地到达撞击时间，但我们不涉及Tunnel问题，因为如果在第 i 帧和第 i + 1 帧没有碰撞，二分就不会开始。 Swept Volumn 考察\\(t\\)和\\(t+1\\)时刻物体对应点连线（按物体形状、沿直线执行扫描）构成的体积区域，不难发现，如果有相交，则可能会出现碰撞。计算TOI（碰撞时间）后将物体移动到改时间，执行碰撞处理（如计算速度等）然后重新扫描。 在物体角速度很大的情况下会产生不精确的结果 Ref： Unity 3D Speculative CCD Speculative CCD 的工作原理是根据物体的速度和角速度，计算物体的AABB，从而推测出下一个物理步骤中所有潜在的接触。然后将所有可能接触送入求解器，以确保满足所有接触约束，以便对象不会通过任何穿模（Tunnel）的情况。求解器使用速度、体积来精确计算CCD。 但该方法并不能完全解决所有碰撞问题。考虑如下的情况，小球因为被杆击打而获得更大的速度，先前计算的AABB并不能检测到这样的速度变化： Ray-cast 小而高速和大而低速物体之间的碰撞检测中可以视作光投射到低速物体上的过程，该方法在 Unreal Engine 中被作为试验性功能提供（支持GPU加速）。算法将光线从对象中心点投射到低速物体上，在高速物体中放置更多的采样点并投射出多条光线，可以获得更好的结果。缺点在于，由于假设了其速度差距极大，该方法不适合计算两个运动的物体的碰撞检测。 Conservasive Advancement Ref: C2A: Controlled Conservative Advancement for Continuous Collision Detection of Polygonal Models 在每次迭代中，计算两个对象的最近点（例如使用 GJK）。使用此信息，计算对象可以在避免碰撞的同时移动的安全距离。仅经过几次迭代，就可以找到影响时间。 Narrow-Phase 2 变形体 DCD DCD检查的是如下的方程的解的问题（考察 V-E)： \\[ \\begin{cases} \\left( ((1-t)\\mathbf{x}_a + t \\mathbf x _ b - \\mathbf x_0 ) \\quad \\mathbf x _{10} \\quad x_{20}\\right) = 0\\\\ t = (\\mathbf x_{0a} \\mathbf x_{10}\\mathbf x_{20}) / (\\mathbf x_{ba} \\mathbf x_{10} \\mathbf x_{20})\\\\ t \\in [0, 1]\\\\ \\mathbf x(t) \\text{ inside } \\triangle \\end{cases} \\] 分为三步求解： 求解前两行的方程 判断\\(t\\)是否在\\([0, 1]\\) 判断\\(\\mathbf x(t)\\)是否在三角形内 这一部分基本很少有人做，原因在于现代的模拟算法越来越追求计算效率，使用较大的时间步长来进行模拟计算。若仅仅使用DCD，容易产生“穿模”的问题。 CCD 对于变形体（主要是三角网格）的连续碰撞检测处理算法研究主体还是对于三次方程（即VT/EE条件求解），同时也借鉴了一些在刚体碰撞检测中常用的技巧： 二分法 IRF：interval-root-finder UIRF：Unifromed-Interval-Root-Finder （针对三角网格）求解三次方程： FPRF：floating-point time-of-impact root finder TightCCD(TCCD) BSC 光线投射 Root Parity(RP) Rational implementation of RP （RRP） 分割空间微元 Preliminaries 沿用IPC中的记号。对于碰撞检测而言，最基本的模型是假设其在两个迭代步骤之间是线性的，即 \\[ \\mathbf x(t) = t \\cdot \\mathbf x ^{i + 1} + (1 - t) \\cdot \\mathbf x ^{i} \\] 其中： -\\(t\\)为归一化后的时间，即\\(t = (t - t_{i}) / (t_{i + 1} - t _i )\\)其中右侧的\\(t\\)是模拟运行时间 -\\(\\mathbf x\\)是坐标，是关于时间的函数。上标表示迭代代数 为了简单期间，用\\(\\mathcal A = \\mathbf x_1\\cdots \\mathbf x_i\\)来表示一个\\(n\\)维单纯形，用\\(\\mathbf x_{ij}\\)来表示\\(\\mathbf x_{i} - \\mathbf x_{j}\\)。 在这样的记号下，碰撞可以用\\(t\\)来描述，即： 单纯形\\(\\mathcal A = \\{\\mathbf x_1 \\cdots\\mathbf x_n\\}\\)和\\(\\mathcal B = \\{\\mathbf x_1 \\cdots \\mathbf x_m\\}\\)碰撞，当且仅当： \\[ \\exists t\\in[0, 1]\\quad s.t. \\ \\mathcal A(t) \\cap \\mathcal B(t) \\ne \\emptyset \\] 这个公式仅仅是一个定义，并没有很大的计算价值，因此我们需要对于这样的问题进行适当的简化。主要有几种思路： 二分搜索，找可能的碰撞时间\\(t\\) 约束为三角网格再： 求解重心坐标\\((u,v)\\)和\\(t\\) 简化为三次方程求根 光线投射方法 二分法 IRF Ref: Interval Analysis For Computer Graphics Interval Methods for Multi-Point Collisions between Time-Dependent Curved Surfaces 逐个检查原点在哪一个时间片中，并迭代缩小时间片。 优点： 不会有遗漏的碰撞情况，并且每一步都保证包含 \\(0\\)，所以能够确保检查到碰撞 通过改变时间片的允许最小大小，来改变算法的精度和速度 缺点： 基于二分查找 — 太慢 难以实施编译优化 UIRF 差不多的思路，但是是用二分法求的是单变量的方程根。 由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。 与此同时，它不能满足控制求解器的运行精度 针对三角网格的三次方程求解方法 Ref: Collision and self-collision handling in cloth model dedicated to design garments 针对于三角网格，上文提出： Theorem 碰撞发生，当且仅当至少发生以下一种碰撞： Vertex-Triangle Edge-Edge 在这篇论文中，还提出了这两类条件的符号语言描述： \\[ VT\\iff \\exists t\\in [0, 1]\\quad \\begin{cases} \\left(\\mathbf x_{12} \\mathbf x_{13}\\mathbf x_{14}\\right) = 0\\\\ \\mathbf x_4 \\in \\left\\{ x_1 x_2 x_3 \\right\\} \\end{cases} \\] 其中：\\(1,2,3\\)为三角形顶点，\\(4\\)为顶点 \\[ EE\\iff \\exists t\\in [0, 1] \\quad \\begin{cases} \\left(\\mathbf x_{12} \\mathbf x_{13}\\mathbf x_{14}\\right) = 0\\\\ \\left\\{\\mathbf x_1 \\mathbf x_2\\right\\} \\cap \\left\\{\\mathbf x_3 \\mathbf x_4\\right\\} \\ne \\emptyset \\end{cases} \\] 对于上述两种做法，我们观察到条件中都有一个关于\\(t\\)的三次方程（因为每一个\\(\\mathbf x_i\\)都是关于\\(t\\)仿射），因此我们的解决思路就是： 求三次方程在\\([0, 1]\\)内的根 检查这个根是否满足第二个条件 其中的数值精度问题体现在： 三次方程求解： 不能使用求根公式（误差放大几个数量级） -- 只能用牛顿法求 何时停止迭代 判断是否碰撞时的误差上界？ FPRF 最老、最经典的一篇论文 Ref: Collision and self-collision handling in cloth model dedicated to design garments 思想：解三次方程，解出来的解对应函数值是小于一常数，则判断为碰撞。 主要问题： FN太多，即有很多碰撞点不被检测到。 当平行时无法处理 EE 的情况。 优点： 速度 TightCCD Ref: TightCCD: Efﬁcient and Robust Continuous Collision Detection using Tight Error Bounds 老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算，观察的是 \\[ Y(0),Y&#39;(0),Y&#39;(1),Y&#39;&#39;(0),Y&#39;&#39;(1) \\] 优点： 速度快，准确率也高，几乎是最好的算法 完全没有检测不出的碰撞 问题： 为了 FN == 0，牺牲了 FP 如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。 BSC Ref: Fast and exact continuous collision detection with bernstein sign classification 通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解） 缺点： False Positive + False Negative 实际上这两个思路和我一开始想的是一致的： 既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。 我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！ 原理上：给定一个三次函数 \\(Y(t)\\) 用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为 从而通过观察： \\[ Y(0), Y(1/3), Y(2/3), Y(1) \\] （其中 \\(Y\\) 即为三次方程对应的函数）的值来减少计算开销并提升精度。 光线投射 RP / RRP 转化为光线投射问题：设 \\(\\partial \\Omega\\) 是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。 问题： 实际上只能做DCD – 小TS 容易出现漏报的问题：在 \\([t,t+\\Delta t]\\) 内有 2 解 原理： 根据 Brouwer topological degree theory： 假设 \\(\\Omega\\) 是一个 \\(n\\) 多面体，设 \\(F:\\Omega \\rightarrow \\mathbb R^{n}\\)满足 \\(C^2\\)，且有有限多个根，且没有在边界\\(\\Gamma=\\partial \\Omega\\) 上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 \\(0\\) 出发，记交点数为 \\(q\\) ，\\(F\\) 在交点处光滑且不相切于光线，那么 \\(p,q\\) 有相同的奇偶性。 从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次） 碰撞处理 在这里假设在上一步已经获取了碰撞的时刻（TOI） Ref: Robust Treatment of Collisions, Contact and Friction for Cloth Animation 根据王老师在GAMES103和2021图形学大会讲的内容（Real-Time Cloth Simulation on GPUs），其程序流程如下： A Practical System 前两种方法都是基于如下公式： \\[ \\mathbf x^{k+1} = \\arg\\min \\|\\mathbf x - \\mathbf x ^ *\\| \\] 而Untangle Cloth不基于上式直接进行解除相交问题。 Interior Point Method 内点法 思想：添加\\(\\log\\)边界函数，保持在可行域内，逐步迭代： 优点 Always succeed 缺点： 可能达到局部最优解 需要计算所有的顶点来迭代 小步长 — 速度慢 Interior Point Method Impact Zone Optimization 思想：直接从 \\(\\mathbf x^*\\) 开始迭代，逐步逼进可行域，如下图 Impact Zone Optimization 优点： 很容易得到一个可能的解。 只需要对不满足约束的点处理 可以使用大步长 缺点： 可能不收敛到可行域内 相交解除 — Untangle Cloth Ref Untangle Cloth Resolving Surface Collisions through Intersection Contour Minimization 当拿到碰撞点后，使用“注水”法，可以直接求出交叉的区域。对于这两个交叉的边界，假设为“紧密贴合”。 优点： 保证在绝大部分情况下能够处理 缺点： 原文中之处理了相交的闭区域，对于边界交叉处理不方便。 物理上不真实 难以在GPU上实现 Rigid Impact Zone 如果上述方法都失败了，那么就考虑使用该方法，其对于不满足要求的点，直接回退到上一模拟步的状态（无相交的状态）。 非接触方法 这一类方法都将原有的碰撞条件增强为保持一些点/面之间的距离大于一定值，从而避免 CCD 过程。正如zhihu上所说： 之前大家试过很多方法，比如定义物体表面距离很近的“点-三角”对和“边-边”对（接触元对）组成的四面体的有符号体积要恒大于0；或者在每个时间歩开始时，找到距离近的每个接触元对上距离最近的点对，限定这些点对的距离大于0等。这些定义的问题在于，如果物体在某个时间歩移动比较多，他们可能无法正确描述无穿透这件事。另外这类方法大多基于sequential quadratic programming优化方法，没法像无约束条件时的牛顿迭代那样方便地通过line search保证稳定收敛。 By Minchen Li. IPC Ref: Incremental potential contact: intersection-and inversion-free, large-deformation dynamics Medial IPC: accelerated incremental potential contact with medial elastics Codimensional incremental potential contact BFEMP: Interpenetration-Free MPM-FEM Coupling with Barrier Contact 主要思路：迭代的每一步，都把所有 primitive pair 分成两类： \\(0&lt;\\min \\mathrm{distance} \\le \\hat d\\)：设置 \\(\\log\\)-barrier 函数，防止直接碰撞 \\(\\min \\mathrm{distance} &gt; \\hat d\\)：设置迭代最大步长，避免距离在迭代路径上碰撞（穿透） 依据这两个基本假设来避免 CCD。 首先，其主要处理的是如何避免连续碰撞检测，在论文中，其提出： 我们称一个状态是可接受的，当且仅当存在一条可行路径，到达该状态，或以该状态为极限。 一个迭代路径是可接受的，当且仅当其可以作为上述的极限过程中的状态序列 \\[ \\mathbf x \\in \\Omega \\iff \\exists \\mathbf x_i \\in \\Omega.\\ \\lim_{i\\rightarrow \\infty} = \\mathbf x \\] 那么，基于以上假设，我们完全可以不去度量是否产生了碰撞，而把约束换成 \\[ \\|\\mathbf x - \\mathbf x&#39;\\| &gt; 0,\\quad \\forall \\mathbf x&#39; \\in \\partial \\Omega \\] 这样，我们可以将问题转化为： \\[ \\|\\mathbf x - \\mathbf y\\| \\ge \\epsilon, \\forall \\mathbf x ,\\mathbf y\\text{ from different primitives} \\] 那么，可以将动力学方程和约束放在一起求解即： \\[ \\begin{aligned} \\min_{\\mathbf x}\\quad &amp;F(\\mathbf x) + G(\\min \\mathrm{distance}(\\mathbf x))\\\\ \\text{s.t.}\\quad &amp;\\mathbf x \\text{ is feasible} \\end{aligned} \\] 其中： \\(F\\) 为动力学方程中的能量 \\(G\\) 为障碍函数 这是一个几乎没有约束的优化问题：因为原来的碰撞处理的全套流程转化为在迭代求解过程中，保证迭代路径是可接受的！ 具体而言，Log函数为了避免在不充分接近时也出现“抵抗力”，其在保证\\(C^2\\)的情况下，构造了如下的“log-barrier”： 该方法可以看作是一个“内点法” 如何计算 “距离” IPC方法中并不限于三角网格等具体的空间结构，因此距离的计算并不需要依赖于物体表示的维数。基本思路是通过重心坐标构造两个 primitive 上的点\\(\\mathbf x\\)和\\(\\mathbf y\\)，从而计算 \\[ d(\\mathbf x, \\mathbf y) = \\min \\|\\mathbf x - \\mathbf y\\| \\] 来得到距离。 Constraint Set 通过 Spatial Hashing 算法来加速 Constraint Set 计算，定义为： \\[ \\{\\langle i , j \\rangle | d(\\mathbf x_i, \\mathbf x_j) \\le \\hat d \\} \\] 迭代过程中如何保证约束 算法使用 Intersection-Aware Line-Search（回溯线搜索）来进行迭代。并且在每次执行搜索之前，重新计算 Constraint Set。而观察到对于： Constraint Set 中的元素对：一定出现在优化的能量函数中，通过barrier函数避免碰撞 不在其中的元素对：初始距离\\(&gt;\\hat d\\) 从而可以通过 \\(\\hat d\\) 指导迭代的最大步长。 从而将原本难以解决的CCD问题避免。 总结 优点： 不需要繁琐的 CCD -- 速度、精度都有保证 嵌入到 Dynamic Solver 迭代过程中 容易在GPU上实现 缺点： 非接触方法，摩擦难以解决 SIGGRAPH 2021 -- Repulsion Method Ref: A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions 思路：找到使不产生VT/EE碰撞的充分条件，且该充分条件仅需要考虑顶点之间的距离，而和三角网格无关。 \\[ \\min d(\\mathbf v_i, \\mathbf v_j) \\ge \\hat d = L / 2 \\] 其中\\(L\\)为三角网格的最大边长。 求解过程分为两部分： Soft-Phase Hard-Phase 并且为了避免约束过强，使用了自适应的重采样方法。 Soft-Phase \\[ \\mathbf x^{k+1} = \\arg \\min\\left\\{ \\|\\mathbf x − \\mathbf x^{\\mathrm {init}} \\| − \\rho \\min \\left\\{c_{ij} (\\mathbf x) − \\varepsilon_{slack} , 0 \\right\\}\\right\\} \\] Hard-Phase \\[ \\mathbf x^{k+1} = \\arg \\min\\left\\{ \\|\\mathbf x − \\mathbf x^{\\mathrm {init}} \\| − \\mu \\sum { \\log (f(c_{ij}(x), \\varepsilon_{slack})) }\\right\\} \\] 其中的 \\(f\\) 是满足 \\(C^1\\) 的分段函数： \\[ f = \\begin{cases} x &amp; x\\le 0\\\\ ax^3 + bx^2 + cx + d &amp; 0 &lt;x \\le \\varepsilon\\\\ \\varepsilon&amp; \\text{otherwise} \\end{cases} \\] Adaptive Resampling 由于要求所有距离大于 \\(L / 2\\)，为了使得这个条件不是过于充分的，要求最小边长和最大边长\\(l\\)与\\(L\\)的比例大于一定值。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"201-02-拉格朗日视角1","slug":"CG/GAMES/g201-02","date":"2022-04-10T16:00:00.000Z","updated":"2022-04-13T05:59:19.797Z","comments":true,"path":"2022/04/11/CG/GAMES/g201-02/","link":"","permalink":"http://adversarr.github.io/2022/04/11/CG/GAMES/g201-02/","excerpt":"games201 拉格朗日视角","text":"games201 拉格朗日视角 拉格朗日视角简介 两种视角： 拉格朗日视角 – 粒子，携带位置、速度等 MPM、弹簧质点模型…… 欧拉视角 – 通过固定的“传感器”来表示 烟雾模拟 弹簧质点模型 Mass-Spring System Extremely example But very useful. – cloth/hair 基本原理 利用 胡克定律 和 牛顿第二定律 来计算 加速度-速度-位置 \\(k\\) — stiffness — 刚度 时间积分 Forward Euler 前向欧啦 \\[ v_{t+1} = v_t + \\frac{f_t}{m}\\Delta t \\] 半隐式欧拉法 用 \\(t+1\\) 时刻的 \\(v\\) 计算 \\(x\\) 的更新。 Implementation 使用 substep — 保证小步长 积分器对比 数值分析 显式积分器 未来仅仅基于过去 简单 容易出现数值爆炸问题 — 前向欧拉 对于 \\(stiff \\gg 1\\) 效果很差。 隐式积分器 未来需要基于自己和过去 复杂！难以实现、难以优化、GPU…… Timestep 更大，但是计算更加昂贵 Numerical damping 弹簧质点的隐式积分器 假设： \\[ \\begin{cases} \\mathbf x_{t+1} = \\mathbf x_t + \\Delta t \\mathbf v_{t+1}\\\\ \\mathbf v_{t+1} = \\mathbf v_t + \\Delta t \\mathbf M ^{-1}\\mathbf f_{t+1} \\end{cases} \\] 在上式中消除 \\(\\mathbf x_{t+1}\\)，使用泰勒公式： \\[ \\left[I - \\Delta t^2 \\mathbf M^{-1} \\frac{\\partial \\mathbf f}{\\partial \\mathbf x} (\\mathbf x_t)\\right] \\mathbf v_{t+1} = \\mathbf v_t + \\Delta t \\mathbf M^{-1} \\mathbf f(\\mathbf x_t) \\] 在这一节课中，仅仅使用 Jacobbi 迭代解上述方程。 在显式和隐式之间转换 \\[ \\left[I - \\beta \\Delta t^2 \\mathbf M^{-1} \\frac{\\partial \\mathbf f}{\\partial \\mathbf x} (\\mathbf x_t)\\right] \\mathbf v_{t+1} = \\mathbf v_t + \\Delta t \\mathbf M^{-1} \\mathbf f(\\mathbf x_t) \\] 其中 \\(\\beta\\) 控制了在显式、隐式之间的“比例” \\(\\beta = 1\\) — Explicit \\(\\beta = .5\\) — Semi-Implicit \\(\\beta = 0\\) — Implicit 大规模情况 稀疏矩阵 共轭梯度法 Preconditioning PBD 拉格朗日法流体模拟 — SPH 用一些粒子（并附带物理量）以及一个核函数去模拟一个物理场。 优点： 不需要 Mesh、适合自由表面物体 容易理解 WCSPH 可压缩物体模拟 Momentum Equation: \\[ \\frac{D\\mathbf v}{D t} = - 1/\\rho \\nabla p + \\mathbf g,\\quad p = B\\left(\\left( \\frac{\\rho}{\\rho_0}\\right)^\\gamma - 1\\right) \\] 表面张力、粘滞力 SPH simulation Cycle 通过半隐式欧拉法计算 SPH 变种 CFL条件 对于显式积分，\\(dt\\) 具有上界： \\[ C = \\frac{u\\Delta t}{\\Delta x} \\le C_\\max \\sim ~ \\] \\(C\\): CFL number Application SPH: \\(C_\\max\\sim 0.4\\) MPM:\\(C_\\max -0.3\\sim1\\) 加速 SPH 通过 Neighbour search with hashing（空间数据结构）","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"Collision Detection 整理 5 - 2021 A large scale benchmark and an Inclusion-based Algorithm","slug":"CG/SortByCato/ContactDetection/Benchmark","date":"2022-04-10T16:00:00.000Z","updated":"2022-08-07T07:24:36.530Z","comments":true,"path":"2022/04/11/CG/SortByCato/ContactDetection/Benchmark/","link":"","permalink":"http://adversarr.github.io/2022/04/11/CG/SortByCato/ContactDetection/Benchmark/","excerpt":"Collision Detection 整理5 – CCD 算法对比","text":"Collision Detection 整理5 – CCD 算法对比 准确说，这篇blog是一篇论文的整理emmm，但由于老板的任务就是做 collsion 的汇总，这篇论文的涉及面也算是相对 Broad 的了。 论文主要用了： IRF：interval-root-finder UIRF：Unifromed-Interval-Root-Finder FPRF：floating-point time-of-impact root finder TightCCD(TCCD) Root Parity(RP) Rational implementation of RP MSRF：minimum seperation floating-point time-of-impact root finder 预备知识 首先论文对于 CCD 的数学背景进行了简要的介绍：考虑三角网格，每一个时间步长内都以线性轨迹运动。那么CCD可以简化为VT和EE检查。 Multivariate CCD Formulation 最简单的方法是直接对于CCD条件参数化，转化为关于 \\(u,v,t\\) 的方程求解即可。 Univariate CCD 单变量CCD 实际上上面一种求解方法一步到位解出了 \\(u,v,t\\) 但没有注意到在接触时，四点共面的事实，所以，在[Provot 97] 中，改为先求解三次方程，然后检查是否满足条件的问题 方法介绍 IRF 类似于计算 Minkowski 差，逐个检查原点在哪一个时间片中，并迭代缩小时间片。 优点： 保守估计，每一步都保证包含 \\(0\\)，所以能够确保检查到碰撞 通过改变时间片的允许最小大小，来改变算法的精度和速度 缺点： 基于二分查找 — 慢 难以实施编译优化 UIRF 差不多的思路，但是是用二分法求的是单变量的方程根。 由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。 与此同时，它不能满足控制求解器的运行精度 FPRF Robust treatment of simultaneous collisions. 主要问题： FN太多，即有很多碰撞点不被检测到。 当平行时无法处理 EE 的情况。 优点： 速度 TightCCD 老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算。 优点： 速度快 完全没有检测不出的点 问题： 为了 FN == 0，牺牲了 FP 如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。 RP / RRP 转化为光线投射问题：设 \\(\\partial \\Omega\\) 是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。 问题： 实际上只能做DCD – 小TS 容易出现漏报的问题：在 \\([t,t+\\Delta t]\\) 内有 2 解 原理： 根据 Brouwer topological degree theory： 假设 \\(\\Omega\\) 是一个 \\(n\\) 多面体，设 \\(F:\\Omega \\rarr \\mathbb R^{n}\\)满足 \\(C^2\\)，且有有限多个根，且没有在边界\\(\\Gamma=\\partial \\Omega\\) 上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 \\(0\\) 出发，记交点数为 \\(q\\) ，\\(F\\) 在交点处光滑且不相切于光线，那么 \\(p,q\\) 有相同的奇偶性。 从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次） BSC Fast and exact continuous collision detection with bernstein sign classification 通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解） 缺点： False Positive + False Negative 实际上这个思路和我一开始想的是几乎一致的： 既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。 我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！ 原理上：给定一个三次函数 \\(Y(t)\\) 用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为 其他思路 Bridson 2009 添加一个时间维度，通过在四维空间中的相交检测来实现碰撞检测。 问题： 不直观、不常用 导致了 FP 的出现 — 平行的两个三角形认定为碰撞。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"libigl 简述","slug":"CG/Libigl","date":"2022-04-09T16:00:00.000Z","updated":"2022-04-12T12:42:19.081Z","comments":true,"path":"2022/04/10/CG/Libigl/","link":"","permalink":"http://adversarr.github.io/2022/04/10/CG/Libigl/","excerpt":"TODO: Libigl 教程（翻译和解释） 现挖个坑，后面补上。","text":"TODO: Libigl 教程（翻译和解释） 现挖个坑，后面补上。 libigl Tutorial","categories":[],"tags":[]},{"title":"102-08-离散微分几何","slug":"CG/GAMES/g102-08","date":"2022-04-08T16:00:00.000Z","updated":"2022-04-13T05:59:16.345Z","comments":true,"path":"2022/04/09/CG/GAMES/g102-08/","link":"","permalink":"http://adversarr.github.io/2022/04/09/CG/GAMES/g102-08/","excerpt":"Games 102 - 离散微分几何","text":"Games 102 - 离散微分几何 三角网格存储 常用的是半边数据结构（Half-Edge）数据结构 将网络连接关系存储在边上，表达为两条半边 目的：提高点线面和查找效率 曲线、曲面微分几何 曲线的微分几何学 Frenet标架 Curvature \\(\\kappa\\) 和 密切圆 与参数选择无关 — 本征量 曲面的微分几何学 关于 \\(u\\) 和 \\(v\\) 的偏导 — 切平面 切平面的法向 — \\(r_u\\times r_v\\) 法平面和曲面求交线，可以定义出一个空间曲线，可以定义其曲率 – 方向曲率（法曲率）— 描述曲面沿着方向的弯曲程度 曲面的曲率 观察法曲率： 有两个正交的方向，使得其能够取最大 \\(\\kappa_1\\) 和最小\\(\\kappa_2\\) 有 Euler's Equation 成立： \\[ \\kappa = \\kappa_1 \\cos^2\\theta + \\kappa_2 \\sin^2\\theta \\] 高斯曲率： \\(\\kappa = \\kappa_1\\kappa_2\\) 等距变换的不变量 处处为 0 的曲面 — 可展曲面 可展曲面可以分类为： 柱面 锥面 切线面 平均曲率： \\(\\kappa = \\frac {\\kappa_1 + \\kappa_2}{2}\\) 处处平均曲率为 0 的曲面 — 极小曲面 — 所有点都是鞍点 离散微分几何 考虑到三角网格只有 \\(C^0\\) ，使用采样的点来估计原有曲面属性。 方法 连续逼近 考虑使用一个简单的曲面来拟合曲面的局部。从而就能计算出 离散估计 用面积/角度等特征来进行计算 例子 平均曲率计算 由 Laplace-Beltrami 定理： \\[ \\mathbf K (\\mathbf x_i) = \\frac{1}{2\\mathcal A_M} \\sum_{j\\in N_1(i)} (\\cot \\alpha_{ij}+ \\cot \\beta_{ij})(\\mathbf x_i - \\mathbf x_j) \\] 高斯曲率计算 由 Gauss-Bonnet 定理： \\[ \\kappa(\\mathbf x_i) = (2\\pi - \\sum_{j = 1}^{\\#f} \\theta_j) / \\mathcal A_M \\] Discrete differential-geometry operators for trangulated 2-manifolds. – 2003 极小曲面","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"102-09-微分坐标","slug":"CG/GAMES/g102-09","date":"2022-04-08T16:00:00.000Z","updated":"2022-05-17T08:06:08.068Z","comments":true,"path":"2022/04/09/CG/GAMES/g102-09/","link":"","permalink":"http://adversarr.github.io/2022/04/09/CG/GAMES/g102-09/","excerpt":"Games 102 - 微分坐标","text":"Games 102 - 微分坐标","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"}]},{"title":"数值分析-常微分方程的数值解","slug":"study/Math/NumericRecipies/Chapter 6 常微分方程数值解","date":"2022-04-06T03:34:36.321Z","updated":"2022-04-06T03:34:36.321Z","comments":true,"path":"2022/04/06/study/Math/NumericRecipies/Chapter 6 常微分方程数值解/","link":"","permalink":"http://adversarr.github.io/2022/04/06/study/Math/NumericRecipies/Chapter%206%20%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/","excerpt":"数值分析 Chapter 6 常微分方程的数值解","text":"数值分析 Chapter 6 常微分方程的数值解 主要内容： Euler公式、后向Euler公式、梯形公式、改进的Euler公式、局部截断误差和阶数 R-K方法 单步的收敛性和稳定性 线性多步法（Adams显式、隐式公式，基于Taylor展开的线性多步法的构造） 主要讨论一阶常微分方程初值问题的数值解： \\[ \\begin{cases} y&#39; = f(x,y),&amp; a\\le x \\le b\\\\ y(a) = \\eta. \\end{cases} \\] 假设其存在唯一解，且充分光滑，在解的邻域内 \\(f(x, y)\\) 和 \\(\\displaystyle \\frac{\\partial f(x,y)}{\\partial y}\\) 连续。 将\\([a,b]\\)作\\(n\\)等分，作\\(h=(b-a)/n\\)和\\(x_i=a+ih\\) 在计算\\(y_i\\)时， 如果只用到前一步的值\\(y_{i-1}\\)：单步法 如果用到前\\(r\\)步的值：\\(r\\)步方法。 Euler方法 Euler公式的构造 将两边积分： \\[ \\int_{x_i}^{x_{i+1}} y&#39;(x) \\mathrm dx = \\int _{x_i} ^{x_{i+1}} f(x, y(x))\\mathrm dx\\\\ \\Rightarrow y(x_{i+1}) = y(x_i)+\\int _{x_i} ^{x_{i+1}} f(x, y(x)) \\mathrm dx \\] 从而应用左矩形公式做近似： \\[ y(x_{i+1}) = y(x_i) +h\\cdot f(x_i, y (x _ i)) +R_{i+1}^{(1)} \\] 其中： \\[ R_{i+1}^{(1)}=\\frac 1 2 y&#39;&#39;(\\xi_i) h ^ 2,\\quad \\xi _i \\in (x_i, x_{i+1}) \\] 如果忽略\\(R_{i+1}^{(1)}\\)可以得到Euler公式。 Euler 公式 称下公式为求解初值问题的Euler方法 \\[ \\begin{cases} y_0 = \\eta \\\\ y_{i+1} = y_{i} + h f(x_i, y_i) \\end{cases} \\] Euler公式在计算式只用到了前一步的值来计算，另外，Euler公式给出了\\(y_{i+1}\\)和\\(y_i\\)的显式依赖关系，直接代入即可得到\\(y_{i+1}\\)。因而称为单步显式公式 单步显式公式 一般形式为，其中\\(\\varphi(x,y,h)\\)称为增量函数 \\[ \\begin{cases} y_{i+1} = y_i + h\\varphi(x_i, y_i, h)\\\\ y_0 = \\eta \\end{cases} \\] 单步显式公式的局部截断误差 一个单步显示公式在\\(x_{i+1}\\)处的局部截断误差为 \\[ R_{i+1} = y(x_{i+1}) - [y(x_i) + h\\varphi(x_i,y(x_i), h)] \\] 后退Euler公式 单步隐式公式 一般形式如下，其中\\(\\psi\\)为增量函数，后退Euler公式的增量函数为\\(\\psi(x_i, y_i, y_{i+1}, h)=f(x_i+h, y_{i+1})\\) \\[ \\begin{cases} y_{i+1} = y_i + h \\psi(x_i, y_i, y_{i+1}, h)\\\\ y_0 = \\eta \\end{cases} \\] 单步隐式公式的局部截断误差 后退Euler公式的局部截断误差为 \\[ R_{i+1} = -\\frac12 y&#39;&#39;(\\xi_i)h^2 \\] 梯形公式 应用梯形公式近似： \\[ y(x_{i+1})=y(x_i) +\\frac h2\\left[ f(x_i, y_i) + f(x_{i+1},y_{i+1})\\right]+R_{i+1}^{(3)} \\] 其中： \\[ R_{i+1}^{(3)} = - \\frac{1}{12} y&#39;&#39;&#39;(\\xi_i) h^3 \\] 预测校正系统和改进的Euler公式 预测校正公式 称侠士为改进的Euler公式，为单步显式公式 \\[ \\begin{cases} y_{i+1}^{(p)}=y_i+hf(x_i, y_i) &amp;预测公式\\\\ y_{i+1} = y_i + \\frac{h}{2}[f(x_i, y_i) + f(x_{i+1}, y_{i+1}^{(p)})] &amp; 校正公式 \\end{cases} \\] 也可以改写为： \\[ \\begin{cases} y_{i+1}^{(p)} = y_i + h f(x_i , y_i)\\\\ y_{i+1}^{(c)} = y_i + hf(x_{i+1}, y_{i+1}^{(p)})\\\\ y_{i+1} = (y_{i+1}^{(p)}+ y_{i+1}^{(c)})/2 \\end{cases} \\] 局部截断误差为： \\[ R_{i+1} = y(x_{i+1}) - \\left\\{ y(x_i) + \\frac h2 [f(x_i, y(x_i)) + f(x_{i+1}, y(x_i) + hf(x_i, y(x_i)))] \\right\\} \\] 求解公式的阶数 如果一个求解公式的局部截断误差为\\(R_{i+1}=O(h^{p+1})\\)则称该求解公式是\\(p\\)阶的。 R-K方法 R-K方法的基本思想 利用积分中值定理： \\[ y(x_{i+1}) = y(x_i) + hf(x_i+\\theta h, y(x_i + \\theta h)) \\] 称\\(f(x_i+\\theta h, y(x_i + \\theta h))\\)为平均斜率 记： \\[ \\begin{aligned} &amp;k_1 = f(x_i, y_i)\\\\ &amp;k_2 = f(x_{i+1}, y_i + hk_1) \\end{aligned} \\] 若用\\(k_1\\)近似\\(k^*\\)，则得到一阶Euler公式，若用\\(\\frac{k_1+k_2}{2}\\)来近似\\(k^*\\)，则得到二阶改进的Euler公式。 R-K方法 一般的显式r-级Runge-Kutta方法为 \\[ \\begin{cases} y_{i+1} = y_i + h\\sum_{j=1}^r \\alpha_j k_j\\\\ k_1=f(x_i , y_i)\\\\ k_j = f(x_i + \\lambda_j h, h_i + h\\sum_{l=1}^{j-1} \\mu_{jl}k_l), &amp;j=2,3,...,r \\end{cases} \\] 例如：\\(r=\\alpha_1=1\\) 可得Euler方法。 2阶R-K公式 \\[ \\begin{cases} y_{i+1} = y_i + h(\\alpha_1k_1+\\alpha_2k_2)\\\\ k_1 = f(x_i, y_i)\\\\ k_2 = f(x_i + \\lambda_2h, y_i + h\\mu_{21}k_1) \\end{cases} \\] 要使得其具有二阶精度，iff参数 \\(\\alpha_1,\\alpha_2,\\lambda_2\\) 和 \\(\\mu_{21}\\)满足： \\[ \\begin{cases} 1-\\alpha_1 - \\alpha_2 =0\\\\ \\frac 12 - \\alpha_2\\lambda_2 = 0\\\\ \\frac{1}{2}-\\alpha_2\\mu_{21} = 0 \\end{cases} \\] 若取 \\(\\alpha_2=1/2\\) 则得到二阶改进的Euler公式。 若取 \\(\\alpha_2=1\\) 则得到变形的Euler公式 单步法的收敛性和稳定性 收敛性 整体截断误差 设 \\(\\{y(x_i)\\}\\) 是微分方程的解，\\(\\{y_i^{[h]}\\}\\) 是通过某个数值方法近似解。则称 \\(E(h) = \\max|y(x_i) -y_i^{[h]}|\\) 为该方法的整体截断误差，若 \\[ \\lim_{h\\rightarrow 0} E(h) = 0 \\] 则称该方法收敛。 Theorem 若\\(y(x)\\)是微分方程的解，\\(\\{y_i\\}\\)是单步显式公式的解，如果存在： \\(c_0&gt;0\\) 使得 \\(|R_{i+1}|\\le c_0h^{p+1}\\) \\(h_0&gt;0,L&gt;0\\) 使得 \\(\\max|\\frac{\\partial\\varphi}{\\partial y}|\\le L\\) 则当 \\(h&lt;\\min\\{h_0, (\\delta/c)^{1/p}\\}\\) 有： \\[ E(h) \\le ch^p \\] 稳定性 对于初值问题\\(\\{y_i\\}_{i=0}^n\\)是由单步法到的的近似解, \\(\\{z_i\\}_{i=0}^n\\)是扰动后的解, 即满足 \\[ \\left\\{\\begin{array}{l} z_{i+1}=z_i+h[\\varphi(x_i,z_i,h)+\\delta_{i+1}],\\quad i=0,1,\\cdots n-1,\\\\ z_0=\\eta+\\delta_0,\\end{array}\\right. \\] 如果存在正常数 \\(C, \\varepsilon_0, h_0\\), 使得对所有 \\(\\varepsilon\\in(0,\\varepsilon_0]\\), \\(h\\in(0,h_0]\\), 当 \\(\\max\\limits_{0\\le i\\le n}|\\delta_i|\\le\\varepsilon\\) 时, 有 \\[ \\max_{0\\le i\\le n}|y_i-z_i|\\le C\\varepsilon, \\] 则称单步法稳定. Theorem 在定理1的条件下，单步公式是稳定的","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数值分析","slug":"数值分析","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"},{"name":"常微分方程","slug":"常微分方程","permalink":"http://adversarr.github.io/tags/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"}]},{"title":"C++ 编程规范","slug":"study/ComputerScience/fragments/Google_C_programming_specification","date":"2022-04-06T03:31:16.162Z","updated":"2022-04-06T03:31:16.162Z","comments":true,"path":"2022/04/06/study/ComputerScience/fragments/Google_C_programming_specification/","link":"","permalink":"http://adversarr.github.io/2022/04/06/study/ComputerScience/fragments/Google_C_programming_specification/","excerpt":"Google C/C++ 规范文档。","text":"Google C/C++ 规范文档。 c++编程规范 0. 扉页 版本: 4.45 原作者: Benjy WeinbergerCraig SilversteinGregory EitzmannMark MentovaiTashana Landray 翻译: YuleFoxYang.Yacgtyrantlilinsanity 项目主页: Google Style GuideGoogle 开源项目风格指南 - 中文版 0.1 译者前言 Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码. 但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰. Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格. 翻译初衷: 规则的作用就是避免混乱. 但规则本身一定要权威, 有说服力, 并且是理性的. 我们所见过的大部分编程规范, 其内容或不够严谨, 或阐述过于简单, 或带有一定的武断性. Google 保持其一贯的严谨精神, 5 万汉字的指南涉及广泛, 论证严密. 我们翻译该系列指南的主因也正是其严谨性. 严谨意味着指南的价值不仅仅局限于它罗列出的规范, 更具参考意义的是它为了列出规范而做的谨慎权衡过程. 指南不仅列出你要怎么做, 还告诉你为什么要这么做, 哪些情况下可以不这么做, 以及如何权衡其利弊. 其他团队未必要完全遵照指南亦步亦趋, 如前面所说, 这份指南是 Google 根据自身实际情况打造的, 适用于其主导的开源项目. 其他团队可以参照该指南, 或从中汲取灵感, 建立适合自身实际情况的规范. 我们在翻译的过程中, 收获颇多. 希望本系列指南中文版对你同样能有所帮助. 我们翻译时也是尽力保持严谨, 但水平所限, bug 在所难免. 有任何意见或建议, 可与我们取得联系. 中文版和英文版一样, 使用 Artistic License/GPL 开源许可. 中文版修订历史: 2015-08 : 热心的清华大学同学 @lilinsanity 完善了「类」章节以及其它一些小章节。至此，对 Google CPP Style Guide 4.45 的翻译正式竣工。 2015-07 4.45 : acgtyrant 为了学习 C++ 的规范，顺便重新翻译了本 C++ 风格指南，特别是 C++11 的全新内容。排版大幅度优化，翻译措辞更地道，添加了新译者笔记。Google 总部 C++ 工程师 innocentim, 清华大学不愿意透露姓名的唐马儒先生，大阪大学大学院情报科学研究科计算机科学专攻博士 farseerfc 和其它 Arch Linux 中文社区众帮了译者不少忙，谢谢他们。因为 C++ Primer 尚未完全入门，暂时没有翻译「类」章节和其它一些小章节。 2009-06 3.133 : YuleFox 的 1.0 版已经相当完善, 但原版在近一年的时间里, 其规范也发生了一些变化. Yang.Y 与 YuleFox 一拍即合, 以项目的形式来延续中文版 : Google 开源项目风格指南 - 中文版项目. 主要变化是同步到 3.133 最新英文版本, 做部分勘误和改善可读性方面的修改, 并改进排版效果. Yang.Y 重新翻修, YuleFox 做后续评审. 2008-07 1.0 : 出自 YuleFox 的 Blog, 很多地方摘录的也是该版本. 0.2 背景 C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护. 本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性. 风格, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 \"风格\" 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单. 使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 \"模式匹配\" 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做. 本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用. Google 主导的开源项目均符合本指南的规定. 注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉. 1. 头文件 通常每一个 .cc 文件都有一个对应的 .h 文件. 也有一些常见例外, 如单元测试代码和只包含 main() 函数的 .cc 文件. 正确使用头文件可令代码在可读性、文件大小和性能上大为改观. 下面的规则将引导你规避使用头文件时的各种陷阱. 1.1. Self-contained 头文件 Tip 头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 .h 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 .inc 结尾。不允许分离出 -inl.h 头文件的做法. 所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 1.2. ##define 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols. 不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 .inc 文件扩展名。 如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 .cc 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 -inl.h 文件里（译者注：过去该规范曾提倡把定义放到 -inl.h 里过）。 有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。 1.2. ##define 保护 [!TIP] 1 所有头文件都应该使用 ##define 来防止头文件被多重包含, 命名格式当是: ___H_ . 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: #ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 1.3. 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 定义： 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义. 优点： 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义： // b.h:struct B &#123;&#125;;struct D : B &#123;&#125;;// good_user.cc:#include &quot;b.h&quot;void f(B*);void f(void*);void test(D* x) &#123; f(x); &#125; // calls f(B*) 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) . 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂. 结论： 尽量避免前置声明那些定义在其他项目中的实体. 函数：总是使用 #include. 类模板：优先使用 #include. 至于什么时候包含头文件，参见 1.5. #include 的路径及顺序 。 1.4. 内联函数 Tip 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用. 优点: 只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 缺点: 滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。 结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用! 另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行). 有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数. 1.5. #include 的路径及顺序 Tip 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录). 例如, google-awesome-project/src/base/logging.h 应该按如下方式包含: #include &quot;base/logging.h&quot; 又如, dir/foo.cc 或 dir/foo_test.cc 的主要作用是实现或测试 dir2/foo2.h 的功能, foo.cc 中包含头文件的次序如下: dir2/foo2.h (优先位置, 详情如下) C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cc 或 dir/foo_test.cc 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。 dir/foo.cc 和 dir2/foo2.h 通常位于同一目录下 (如 base/basictypes_unittest.cc 和 base/basictypes.h), 但也可以放在不同目录下. 按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。 您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明 (forward declarations) 情况除外。比如您要用到 bar.h 中的某个符号, 哪怕您所包含的 foo.h 已经包含了 bar.h, 也照样得包含 bar.h, 除非 foo.h 有明确说明它会自动向您提供 bar.h 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 foo.cc 只包含 foo.h 就够了，不用再管后者所包含的其它内容。 举例来说, google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下: #include &quot;foo/public/fooserver.h&quot; // 优先位置#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;hash_map&gt;#include &lt;vector&gt;#include &quot;base/basictypes.h&quot;#include &quot;base/commandlineflags.h&quot;#include &quot;foo/public/bar.h&quot; 例外： 有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如： #include &quot;foo/public/fooserver.h&quot;#include &quot;base/port.h&quot; // For LANG_CXX11.#ifdef LANG_CXX11#include &lt;initializer_list&gt;#endif // LANG_CXX11 译者 (YuleFox) 笔记 避免多重包含是学编程时最基本的要求; 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应; 内联函数的合理使用可提高代码执行效率; -inl.h 可提高代码可读性 (一般用不到吧:D); 标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起); 包含文件的名称使用 . 和 .. 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了. 译者（acgtyrant）笔记 原来还真有项目用 ##includes 来插入文本，且其文件扩展名 .inc 看上去也很科学。 Google 已经不再提倡 -inl.h 用法。 注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 .cc 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。 2. 作用域 2.1. 命名空间 Tip 鼓励在 .cc 文件内使用匿名命名空间或 static 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。 定义: 命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突. 优点: 虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层. 举例来说, 两个不同项目的全局作用域都有一个类 Foo, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, project1::Foo 和 project2::Foo 作为不同符号自然不会冲突. 内联命名空间会自动把内部的标识符放到外层作用域，比如： namespace X &#123;inline namespace Y &#123;void foo();&#125; // namespace Y&#125; // namespace X X::Y::foo() 与 X::foo() 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。 缺点: 命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难。 内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。 有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。 在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)). 结论: 根据下文将要提到的策略合理使用命名空间. 遵守 命名空间命名 中的规则。 像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。 用命名空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间: // .h 文件namespace mynamespace &#123;// 所有声明都置于命名空间中// 注意不要使用缩进class MyClass &#123; public: ... void Foo();&#125;;&#125; // namespace mynamespace // .cc 文件namespace mynamespace &#123;// 函数定义都置于命名空间中void MyClass::Foo() &#123; ...&#125;&#125; // namespace mynamespace 更复杂的 .cc 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。 #include &quot;a.h&quot;DEFINE_FLAG(bool, someflag, false, &quot;dummy flag&quot;);namespace a &#123;...code for a... // 左对齐&#125; // namespace a 不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件. 不应该使用 using 指示 引入整个命名空间的标识符号。 // 禁止 —— 污染命名空间using namespace foo; 不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。 // 在 .cc 中使用别名缩短常用的命名空间namespace baz = ::foo::bar::baz; // 在 .h 中使用别名缩短常用的命名空间namespace librarian &#123;namespace impl &#123; // 仅限内部使用namespace sidetable = ::pipeline_diagnostics::sidetable;&#125; // namespace implinline void my_inline_function() &#123; // 限制在一个函数中的命名空间别名 namespace baz = ::foo::bar::baz; ...&#125;&#125; // namespace librarian 禁止用内联命名空间 2.2. 匿名命名空间和静态变量 Tip 在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。但是不要在 .h 文件中这么做。 定义: 所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 static 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。 结论: 推荐、鼓励在 .cc 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 .h 中使用。 匿名命名空间的声明和具名的格式相同，在最后注释上 namespace : namespace &#123;...&#125; // namespace 2.3. 非成员函数、静态成员函数和全局函数 Tip 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关. 优点: 某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域. 缺点: 将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此. 结论: 有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 2.1. 命名空间 。举例而言，对于头文件 myproject/foo_bar.h , 应当使用 namespace myproject &#123;namespace foo_bar &#123;void Function1();void Function2();&#125; // namespace foo_bar&#125; // namespace myproject 而非 namespace myproject &#123;class FooBar &#123; public: static void Function1(); static void Function2();&#125;;&#125; // namespace myproject 定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内. 如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 2.1. 命名空间 或 static 链接关键字 (如 static int Foo() &#123;...&#125;) 限定其作用域. 2.4. 局部变量 Tip 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化. C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如: int i;i = f(); // 坏——初始化和声明分离int j = g(); // 好——初始化时声明vector&lt;int&gt; v;v.push_back(1); // 用花括号初始化更好v.push_back(2);vector&lt;int&gt; v = &#123;1, 2&#125;; // 好——v 一开始就初始化 属于 if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言: while (const char* p = strchr(str, &#x27;/&#x27;)) str = p + 1; Warning 有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低. // 低效的实现for (int i = 0; i &lt; 1000000; ++i) &#123; Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i);&#125; 在循环作用域外面声明这类变量要高效的多: Foo f; // 构造函数和析构函数只调用 1 次for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething(i);&#125; 2.5. 静态和全局变量 Tip 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。 禁止使用类的 静态储存周期 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构。 静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。 静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。 Note Xris 译注: 同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。 同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 main() 返回还是对 exit() 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。 改善以上析构问题的办法之一是用 quick_exit() 来代替 exit() 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 atexit() 所绑定的任何 handlers. 如果您想在执行 quick_exit() 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 _at_quick_exit(). 如果您想在 exit() 和 quick_exit() 都用上该 handler, 都绑定上去。 综上所述，我们只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])。 如果您确实需要一个 class 类型的静态或全局变量，可以考虑在 main() 函数或 pthread_once() 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。 Note Yang.Y 译注: 上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量. 译者 (YuleFox) 笔记 cc 中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用 using 关键字污染命名空间; 嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 public; 尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元; 多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug. 作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率. 译者（acgtyrant）笔记 注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。 匿名命名空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。 注意别在循环犯大量构造和析构的低级错误。 3. 类 类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项. 3.1. 构造函数的职责 总述 不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化. 定义 在构造函数中可以进行各种初始化操作. 优点 无需考虑类是否被初始化. 经过构造函数完全初始化后的对象可以为 const 类型, 也能更方便地被标准容器或算法使用. 缺点 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患. 在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 禁用 了) 等方法的条件下, 构造函数很难上报错误 如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 bool IsValid() 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法. 构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的. 结论 构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 Init() 方法或工厂函数. 构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式. Avoid Init() methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作). 3.2. 隐式类型转换 总述 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字. 定义 隐式类型转换允许一个某种类型 (称作 源类型) 的对象被用于需要另一种类型 (称作 目的类型) 的位置, 例如, 将一个 int 类型的参数传递给需要 double 类型的函数. 除了语言所定义的隐式类型转换, 用户还可以通过在类定义中添加合适的成员定义自己需要的转换. 在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如 operator bool()). 在目的类型中定义隐式类型转换, 则通过以源类型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现. explicit 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换, 例如使用 cast. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法: class Foo &#123; explicit Foo(int x, double y); ...&#125;;void Func(Foo f); 此时下面的代码是不允许的: Func(&#123;42, 3.14&#125;); // Error 这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是 explicit 应当限制的行为. 优点 有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强. 隐式类型转换可以简单地取代函数重载. 在初始化对象时, 列表初始化语法是一种简洁明了的写法. 缺点 隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换. 隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用. 单参数构造函数有可能会被无意地用作隐式类型转换. 如果单参数构造函数没有加上 explicit 关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上 explicit 标记. 并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清. 如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候. 结论 在类型定义中, 类型转换运算符和单参数构造函数都应当用 explicit 进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换. 对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的. 这时应当联系项目组长并说明特殊情况. 不能以一个参数进行调用的构造函数不应当加上 explicit. 接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化 (例如 MyType m = &#123;1, 2&#125;;) . 3.3. 可拷贝类型和可移动类型 总述 如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用. 定义 可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. string 类型就是一个可拷贝类型的例子. 可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). std::unique_ptr 就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的. 拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象. 优点 可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器. 拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如 Clone(), CopyFrom() or Swap(), 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过 = default. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 省略不必要的拷贝 这样的优化它们也更加合适. 移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰. 缺点 许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型 (Registerer), 与特定的作用域相关的类型 (Cleanup), 与其他对象实体紧耦合的类型 (Mutex) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 对象切割 . 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误. 拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题. 结论 如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作. 如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的. class Foo &#123; public: Foo(Foo&amp;&amp; other) : field_(other.field) &#123;&#125; // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符. private: Field field_;&#125;; 由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现. 如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之. // MyClass is neither copyable nor movable.MyClass(const MyClass&amp;) = delete;MyClass&amp; operator=(const MyClass&amp;) = delee; 3.4. 结构体 VS. 类 总述 仅当只有数据成员时使用 struct, 其它一概使用 class. 说明 在 C++ 中 struct 和 class 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字. struct 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数. 如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class. 为了和 STL 保持一致, 对于仿函数等特性可以不用 class 而是使用 struct. 注意: 类和结构体的成员变量使用不同的 命名规则. 3.5. 继承 总述 使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承. 定义 当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称. 优点 实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误. 缺点 对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局. 结论 所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式. 不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo. 必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数. 对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 注意, 数据成员都必须是 私有的. 对于重载的虚函数或虚析构函数, 使用 override, 或 (较不常用的) final 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 virtual 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 override, final 或 virtual 的其中之一进行标记. 标记为 override 或 final 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数. 3.6. 多重继承 总述 真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类. 定义 多重继承允许子类拥有多个基类. 要将作为 纯接口 的基类和具有 实现 的基类区别开来. 优点 相比单继承 (见 继承), 多重实现继承可以复用更多的代码. 缺点 真正需要用到多重 实现 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案. 结论 只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀. 注意 关于该规则, Windows 下有个 特例. 3.7. 接口 总述 接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制). 定义 当一个类满足以下要求时, 称之为纯接口: 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数). 没有非静态数据成员. 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected. 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承. 接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 The C++ Programming Language, 3rd edition 第 12.4 节. 优点 以 Interface 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 多重继承 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心. 缺点 Interface 后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户. 结论 只有在满足上述条件时, 类才以 Interface 结尾, 但反过来, 满足上述需要的类未必一定以 Interface 结尾. 3.8. 运算符重载 总述 除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量. 定义 C++ 允许用户通过使用 operator 关键字 对内建运算符进行重载定义 , 只要其中一个参数是用户定义的类型. operator 关键字还允许用户使用 operator\"\" 定义新的字面运算符, 并且定义类型转换函数, 例如 operator bool(). 优点 重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如 ==, &lt;, =, &lt;&lt;), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作. 对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记. 缺点 要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug. 过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时. 函数重载有多少弊端, 运算符重载就至少有多少. 运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧. 对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具. 如果重载运算符的参数写错, 此时得到的可能是一个完全不同的重载而非编译错误. 例如: foo &lt; bar 执行的是一个行为, 而 &amp;foo &lt; &amp;bar 执行的就是完全不同的另一个行为了. 重载某些运算符本身就是有害的. 例如, 重载一元运算符 &amp; 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. 重载诸如 &amp;&amp;, || 和 , 会导致运算顺序和内建运算的顺序不一致. 运算符从通常定义在类的外部, 所以对于同一运算, 可能出现不同的文件引入了不同的定义的风险. 如果两种定义都链接到同一二进制文件, 就会导致未定义的行为, 有可能表现为难以发现的运行时错误. 用户定义字面量所创建的语义形式对于某些有经验的 C++ 程序员来说都是很陌生的. 结论 只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道. 只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, .cc 中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 &lt;, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, &lt; 和 &gt; 不会同时返回 true. 建议不要将不进行修改的二元运算符定义为成员函数. 如果一个二元运算符被定义为类成员, 这时隐式转换会作用域右侧的参数却不会作用于左侧. 这时会出现 a &lt; b 能够通过编译而 b &lt; a 不能的情况, 这是很让人迷惑的. 不要为了避免重载操作符而走极端. 比如说, 应当定义 ==, =, 和 &lt;&lt; 而不是 Equals(), CopyFrom() 和 PrintTo(). 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入 std::set 中, 最好还是定义一个自定义的比较运算符而不是重载 &lt;. 不要重载 &amp;&amp;, ||, , 或一元运算符 &amp;. 不要重载 operator\"\", 也就是说, 不要引入用户定义字面量. 类型转换运算符在 隐式类型转换 一节有提及. = 运算符在 可拷贝类型和可移动类型 一节有提及. 运算符 &lt;&lt; 在 流 一节有提及. 同时请参见 函数重载 一节, 其中提到的的规则对运算符重载同样适用. 3.9. 存取控制 总述 将 所有 数据成员声明为 private, 除非是 static const 类型成员 (遵循 常量命名规则). 处于技术上的原因, 在使用 Google Test 时我们允许测试固件类中的数据成员为 protected. 3.10. 声明顺序 总述 将相似的声明放在一起, 将 public 部分放在最前. 说明 类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:. 省略空部分. 在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员. 不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 参见 内联函数 一节. 译者 (YuleFox) 笔记 不在构造函数中做太多逻辑相关的初始化; 编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数; 为避免隐式转换, 需将单参数构造函数声明为 explicit; 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现; 仅在作为数据集合时使用 struct; 组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这样做; 避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口; 接口类类名以 Interface 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 protected; 为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明; 存取函数一般内联在头文件中; 声明次序: public -&gt; protected -&gt; private; 函数体尽量短小, 紧凑, 功能单一; 4. 函数 4.1. 参数顺序 总述 函数的参数顺序为: 输入参数在先, 后跟输出参数. 说明 C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或 const 引用, 输出参数或输入/输出参数则一般为非 const 指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前. 这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通. 4.2. 编写简短函数 总述 我们倾向于编写简短, 凝练的函数. 说明 我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割. 即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码. 在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数. 4.3. 引用参数 总述 所有按引用传递的参数必须加上 const. 定义 在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 int foo(int *pval). 在 C++ 中, 函数还可以声明为引用参数: int foo(int &amp;val). 优点 定义引用参数可以防止出现 (*pval)++ 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针. 缺点 容易引起误解, 因为引用在语法上是值变量却拥有指针的语义. 结论 函数参数列表中, 所有引用参数都必须是 const: void Foo(const string &amp;in, string *out); 事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap(). 有时候, 在输入形参中用 const T* 指针比 const T&amp; 更明智. 比如: 可能会传递空指针. 函数要把指针或对地址的引用赋值给输入形参. 总而言之, 大多时候输入形参往往是 const T&amp;. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑. 4.4. 函数重载 总述 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数. 定义 你可以编写一个参数类型为 const string&amp; 的函数, 然后用另一个参数类型为 const char* 的函数对其进行重载: class MyClass &#123; public: void Analyze(const string &amp;text); void Analyze(const char *text, size_t textlen);&#125;; 优点 通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利. 缺点 如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑. 结论 如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append(). 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数. 4.5. 缺省参数 总述 只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下. 优点 有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”. 缺点 缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 不应当使用函数重载的理由 也都适用于缺省参数. 虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数. 缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值. 缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题. 结论 对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 void f(int n = counter++); 这样的代码.) 在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载. 4.6. 函数返回类型后置语法 总述 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法. 定义 C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如: int foo(int x); C++11 引入了这一新的形式. 现在可以在函数名前使用 auto 关键字, 在参数列表之后后置返回类型. 例如: auto foo(int x) -&gt; int; 后置返回类型为函数作用域. 对于像 int 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别. 优点 后置返回类型是显式地指定 Lambda 表达式 的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 但并不是在所有的情况下都能实现. 即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了. 有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单, 也更易读, 尤其是在返回类型依赖于模板参数时. 例如: template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u); 对比下面的例子: template &lt;class T, class U&gt; decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u); 缺点 后置返回类型相对来说是非常新的语法, 而且在 C 和 Java 中都没有相似的写法, 因此可能对读者来说比较陌生. 在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍. 因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下, 只使用一种版本是相对来说更规整的形式. 结论 在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 复杂的模板代码. 5. 来自 Google 的奇技 Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同. 5.1. 所有权与智能指针 ==总述== 动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权. ==定义== 所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象. 智能指针是一个通过重载 * 和 -&gt; 运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位. std::unique_ptr 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 std::unique_ptr 离开作用域时, 对象就会被销毁. std::unique_ptr 不能被复制, 但可以把它移动（move）给新所有主. std::shared_ptr 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁. ==优点== 如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存. 传递对象的所有权, 开销比复制来得小, 如果可以复制的话. 传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作. 如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升. 可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼. 对于 const 对象来说, 智能指针简单易用, 也比深度复制高效. ==缺点== 不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题. 其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失. 如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型. 如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显. std::unique_ptr 的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员. 如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统. 所有权共享机制的登记工作在运行时进行, 开销可能相当大. 某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁. 智能指针并不能够完全代替原生指针. ==结论== 如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 std::unique_ptr 来明确所有权传递, 例如： std::unique_ptr&lt;Foo&gt; FooFactory();void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr); 如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 std::shared_ptr ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 std::shared_ptr . 不要使用 std::auto_ptr, 使用 std::unique_ptr 代替它. 5.2. Cpplint &gt; 总述 使用 cpplint.py 检查风格错误. &gt; 说明 cpplint.py 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错. 某些项目会指导你如何使用他们的项目工具运行 cpplint.py. 如果你参与的项目没有提供, 你可以单独下载 cpplint.py. 译者（acgtyrant）笔记 把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了. 原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊. scoped_ptr 和 auto_ptr 已过时. 现在是 shared_ptr 和 uniqued_ptr 的天下了. 按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意. Arch Linux 用户注意了, AUR 有对 cpplint 打包. 6. 其他 C++ 特性 6.1. 引用参数 ==Tip== 所有按引用传递的参数必须加上 const. ==定义:== 在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 int foo(int *pval). 在 C++ 中, 函数还可以声明引用参数: int foo(int &amp;val). ==优点:== 定义引用参数防止出现 (*pval)++ 这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 NULL 指针. ==缺点:== 容易引起误解, 因为引用在语法上是值变量却拥有指针的语义. ==结论:== 函数参数列表中, 所有引用参数都必须是 const: void Foo(const string &amp;in, string *out); 事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数，除非用于交换，比如 swap(). 有时候，在输入形参中用 const T* 指针比 const T&amp; 更明智。比如： 您会传 null 指针。 函数要把指针或对地址的引用赋值给输入形参。 总之大多时候输入形参往往是 const T&amp;. 若用 const T* 说明输入另有处理。所以若您要用 const T*, 则应有理有据，否则会害得读者误解。 6.2. 右值引用 ==Tip== 只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 std::forward. ==定义:== 右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, void f(string&amp;&amp; s); 声明了一个其参数是一个字符串的右值引用的函数. ==优点:== 用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果 v1 是一个 vector, 则 auto v2(std::move(v1)) 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升. 右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作. 右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用. 要高效率地使用某些标准库类型, 例如 std::unique_ptr, std::move 是必需的. ==缺点:== 右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的. ==结论:== 只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 std::forward 功能函数. 你可能会使用 std::move 来表示将值从一个对象移动而不是复制到另一个对象. 6.3. 函数重载 ==Tip== 若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。 ==定义:== 你可以编写一个参数类型为 const string&amp; 的函数, 然后用另一个参数类型为 const char* 的函数重载它: class MyClass &#123; public: void Analyze(const string &amp;text); void Analyze(const char *text, size_t textlen);&#125;; ==优点:== 通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利. ==缺点:== 如果函数单单靠不同的参数类型而重载（acgtyrant 注：这意味着参数数量不变），读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。 ==结论:== 如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 AppendString() 和 AppendInt() 等， 而不是一口气重载多个 Append(). 6.4. 缺省参数 ==Tip== 我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。 ==优点:== 当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。 ==缺点:== 缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复（acgtyrant 注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。 ==结论:== 由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant 注：即不能再通过缺省参数来省略参数了）。 其一，位于 .cc 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。 其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。 其三，可以用来模拟变长数组。 // 通过空 AlphaNum 以支持四个形参string StrCat(const AlphaNum &amp;a, const AlphaNum &amp;b = gEmptyAlphaNum, const AlphaNum &amp;c = gEmptyAlphaNum, const AlphaNum &amp;d = gEmptyAlphaNum); 6.5. 变长数组和 alloca() ==Tip== 我们不允许使用变长数组和 alloca(). ==优点:== 变长数组具有浑然天成的语法. 变长数组和 alloca() 也都很高效. ==缺点:== 变长数组和 alloca() 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”. ==结论:== 改用更安全的分配器（allocator），就像 std::vector 或 std::unique_ptr. 6.6. 友元 ==Tip== 我们允许合理的使用友元类及友元函数. 通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 FooBuilder 声明为 Foo 的友元, 以便 FooBuilder 正确构造 Foo 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便. 友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 public, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作. 6.7. 异常 ==Tip== 我们不使用 C++ 异常. ==优点:== 异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant 注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。 很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。 有些第三方 C++ 库依赖异常，禁用异常就不好用了。 异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 Init() 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。 在测试框架里很好用。 ==缺点:== 在现有函数中添加 throw 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，f() 调用 g(), g() 又调用 h(), 且 h 抛出的异常被 f 捕获。当心 g, 否则会没妥善清理好。 还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。 异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得. 启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。 滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。 ==结论:== 从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难. 鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担. 我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实. 对于 Windows 代码来说, 有个 特例. (YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定) 6.8. 运行时类型识别 ==Tip== 我们禁止使用 RTTI. ==定义:== RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 typeid 或者 dynamic_cast 完成. ==优点:== RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中. RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用. 在考虑多个抽象对象时 RTTI 也很好用. 例如: bool Base::Equal(Base* other) = 0;bool Derived::Equal(Base* other) &#123; Derived* that = dynamic_cast&lt;Derived*&gt;(other); if (that == NULL) return false; ...&#125; ==缺点:== 在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类. 随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们. ==结论:== RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型: 虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理. 如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断. 如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast 也是一种替代方案. 基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样: if (typeid(*data) == typeid(D1)) &#123; ...&#125; else if (typeid(*data) == typeid(D2)) &#123; ...&#125; else if (typeid(*data) == typeid(D3)) &#123;... 一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块. 不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图. 6.9. 类型转换 ==Tip== 使用 C++ 的类型转换, 如 static_cast&lt;&gt;(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式; ==定义:== C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类. ==优点:== C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 (int)3.5), 有时是在做类型转换 (如 (int)\"hello\"). 另外, C++ 的类型转换在查找时更醒目. ==缺点:== 恶心的语法. ==结论:== 不要使用 C 风格类型转换. 而应该使用 C++ 风格. 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时. 用 const_cast 去掉 const 限定符. 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用. 至于 dynamic_cast 参见 6.8. 运行时类型识别. 6.10. 流 ==Tip== 只在记录日志时使用流. ==定义:== 流用来替代 printf() 和 scanf(). ==优点:== 有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 printf 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件. ==缺点:== 流使得 pread() 等功能函数很难执行. 如果不使用 printf 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 %.*s) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用. ==结论:== 不要使用流, 除非是日志接口需要. 使用 printf 之类的代替. 使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流. ==拓展讨论:== 对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 printf + read/write. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因. 流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势. 流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误: cout &lt;&lt; this; // 输出地址cout &lt;&lt; *this; // 输出值 由于 &lt;&lt; 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载. 有人说 printf 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰? cerr &lt;&lt; &quot;Error connecting to &#x27;&quot; &lt;&lt; foo-&gt;bar()-&gt;hostname.first &lt;&lt; &quot;:&quot; &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno);fprintf(stderr, &quot;Error connecting to &#x27;%s:%u: %s&quot;, foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second, strerror(errno)); 你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备. 每一种方式都是各有利弊, “没有最好, 只有更适合”. 简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 printf + read/write. 6.11. 前置自增和自减 ==Tip== 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符. ==定义:== 对于变量在自增 (++i 或 i++) 或自减 (--i 或 i--) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减). ==优点:== 不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢? ==缺点:== 在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 for 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (i) 在谓语动词 (++) 前. ==结论:== 对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减). 6.12. const 用法 ==Tip== 我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好。 ==定义:== 在声明的变量或参数前加上关键字 const 用于指明变量值不可被篡改 (如 const int foo ). 为类中的函数加上 const 限定符表明该函数不会修改类成员变量的状态 (如 class Foo &#123; int Bar(char c) const; &#125;;). ==优点:== 大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的. ==缺点:== const 是入侵性的: 如果你向一个函数传入 const 变量, 函数原型声明中也必须对应 const 参数 (否则变量需要 const_cast 类型转换), 在调用库函数时显得尤其麻烦. ==结论:== const 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 const: 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const. 尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const 函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const. 如果数据成员在对象构造之后不再发生变化, 可将其定义为 const. 然而, 也不要发了疯似的使用 const. 像 const int * const * const x; 就有些过了, 虽然它非常精确的描述了常量 x. 关注真正有帮助意义的信息: 前面的例子写成 const int** x 就够了. 关键字 mutable 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全. const 的位置: 有人喜欢 int const *foo 形式, 不喜欢 const int* foo, 他们认为前者更一致因此可读性也更好: 遵循了 const 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消大部分你原本想保持的一致性. 将 const 放在前面才更易读, 因为在自然语言中形容词 (const) 是在名词 (int) 之前. 这是说, 我们提倡但不强制 const 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 const 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.) 6.13. constexpr 用法 ==Tip== 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。 ==定义:== 变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量。 ==优点:== 如今 constexpr 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。 ==缺点:== 若过早把变量优化成 constexpr 变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。 ==结论:== 靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。 6.14. 整型 ==Tip== C++ 内建整型中, 仅使用 int. 如果程序中需要不同大小的变量, 可以使用 `中长度精确的整型, 如int16_t.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如int64_t`. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。 ==定义:== C++ 没有指定整型的大小. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64 位. ==优点:== 保持声明统一. ==缺点:== C++ 中整型大小因编译器和体系结构的不同而不同. ==结论:== `定义了int16_t,uint32_t,int64_t等整型, 在需要确保整型大小时可以使用它们代替short,unsigned long long等. 在 C 整型中, 只使用int. 在合适的情况下, 推荐使用标准类型如size_t和ptrdiff_t`. 如果已知整数不会太大, 我们常常会使用 int, 如循环计数. 在类似的情况下使用原生类型 int. 你可以认为 int 至少为 32 位, 但不要认为它会多于 32 位. 如果需要 64 位整型, 用 int64_t 或 uint64_t. 对于大整数, 使用 int64_t. 不要使用 uint32_t 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据. 如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。 小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 int 与 unsigned int 运算时，前者被提升为 unsigned int 而有可能溢出），总有意想不到的后果。 关于无符号整数: 有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子: for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ... 上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料. 因此, 使用断言来指出变量为非负数, 而不是使用无符号型! 6.15. 64 位下的可移植性 ==Tip== 代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记: 对于某些类型, printf() 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 inttypes.h 仿标准风格): // printf macros for size_t, in the style of inttypes.h##ifdef _LP64##define __PRIS_PREFIX &quot;z&quot;##else##define __PRIS_PREFIX##endif// Use these macros after a % in a printf format string// to get correct 32/64 bit behavior, like this:// size_t size = records.size();// printf(&quot;%&quot;PRIuS&quot;\\n&quot;, size);##define PRIdS __PRIS_PREFIX &quot;d&quot;##define PRIxS __PRIS_PREFIX &quot;x&quot;##define PRIuS __PRIS_PREFIX &quot;u&quot;##define PRIXS __PRIS_PREFIX &quot;X&quot;##define PRIoS __PRIS_PREFIX &quot;o&quot; 类型 不要使用 使用 备注 void * (或其他指针类型) %lx %p int64_t %qd, %lld %\"PRId64\" uint64_t %qu, %llu, %llx %\"PRIu64\", %\"PRIx64\" size_t %u %\"PRIuS\", %\"PRIxS\" C99 规定 %zu ptrdiff_t %d %\"PRIdS\" C99 规定 %zd 注意 PRI* 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 PRI* 宏同样可以在 % 后包含长度指示符. 例如, printf(\"x = %30\"PRIuS\"\\n\", x) 在 32 位 Linux 上将被展开为 printf(\"x = %30\" \"u\" \"\\n\", x), 编译器当成 printf(\"x = %30u\\n\", x) 处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串). 记住 sizeof(void *) != sizeof(int). 如果需要一个指针大小的整数要用 intptr_t. 你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 int64_t/uint64_t 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 __attribute__((packed)). MSVC 则提供了 ##pragma pack() 和 __declspec(align()) (YuleFox 注, 解决方案的项目属性里也可以直接设置). 创建 64 位常量时使用 LL 或 ULL 作为后缀, 如: int64_t my_value = 0x123456789LL;uint64_t my_mask = 3ULL &lt;&lt; 48; 如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 ##ifdef _LP64 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化) 6.16. 预处理宏 ==Tip== 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之. 宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域. 值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 const 变量代替. 用宏 “缩写” 长变量名可被引用代替. 用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (##define 防止头文件重包含当然是个特例). 宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 ## 字符串化, 用 ### 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的. 下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守: 不要在 .h 文件中定义宏. 在马上要使用时才进行 ##define, 使用后要立即 ##undef. 不要只是对已经存在的宏使用##undef，选择一个不会冲突的名称； 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为. 不要用 ### 处理函数，类和变量的名字。 6.17. 0, nullptr 和 NULL ==Tip== 整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 '\\0'. 整数用 0, 实数用 0.0, 这一点是毫无争议的. 对于指针 (地址值), 到底是用 0, NULL 还是 nullptr. C++11 项目用 nullptr; C++03 项目则用 NULL, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 NULL 的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL) 就和 sizeof(0) 不一样。 字符 (串) 用 '\\0', 不仅类型正确而且可读性好. 6.18. sizeof ==Tip== 尽可能用 sizeof(varname) 代替 sizeof(type). 使用 sizeof(varname) 是因为当代码中变量类型改变时会自动更新. 您或许会用 sizeof(type) 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。 Struct data;Struct data; memset(&amp;data, 0, sizeof(data)); ==Warning== memset(&amp;data, 0, sizeof(Struct));if (raw_size &lt; sizeof(int)) &#123; LOG(ERROR) &lt;&lt; &quot;compressed record not big enough for count: &quot; &lt;&lt; raw_size; return false;&#125; 6.19. auto ==Tip== 用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。 ==定义：== C++11 中，若变量被声明成 auto, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 auto 来复制初始化或绑定引用。 vector&lt;string&gt; v;...auto s1 = v[0]; // 创建一份 v[0] 的拷贝。const auto&amp; s2 = v[0]; // s2 是 v[0] 的一个引用。 ==优点：== C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像： sparse_hash_map&lt;string, int&gt;::iterator iter = m.find(val); 返回类型好难读，代码目的也不够一目了然。重构其： auto iter = m.find(val); 好多了。 没有 auto 的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像： diagnostics::ErrorStatus* status = new diagnostics::ErrorStatus(&quot;xyz&quot;); 有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。 ==缺点：== 类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了： auto i = x.Lookup(key); 看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。 程序员必须会区分 auto 和 const auto&amp; 的不同之处，否则会复制错东西。 auto 和 C++11 列表初始化的合体令人摸不着头脑： auto x(3); // 圆括号。auto y&#123;3&#125;; // 大括号。 它们不是同一回事——x 是 int, y 则是 std::initializer_list. 其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：Why is vector not a STL container?）也有大同小异的陷阱。 如果在接口里用 auto, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。 结论： auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 auto 变量。 auto 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。 6.20. 列表初始化 ==Tip== 你可以用列表初始化。 早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体： struct Point &#123; int x; int y; &#125;;Point p = &#123;1, 2&#125;; C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下： // Vector 接收了一个初始化列表。vector&lt;string&gt; v&#123;&quot;foo&quot;, &quot;bar&quot;&#125;;// 不考虑细节上的微妙差别，大致上相同。// 您可以任选其一。vector&lt;string&gt; v = &#123;&quot;foo&quot;, &quot;bar&quot;&#125;;// 可以配合 new 一起用。auto p = new vector&lt;string&gt;&#123;&quot;foo&quot;, &quot;bar&quot;&#125;;// map 接收了一些 pair, 列表初始化大显神威。map&lt;int, string&gt; m = &#123;&#123;1, &quot;one&quot;&#125;, &#123;2, &quot;2&quot;&#125;&#125;;// 初始化列表也可以用在返回类型上的隐式转换。vector&lt;int&gt; test_function() &#123; return &#123;1, 2, 3&#125;; &#125;// 初始化列表可迭代。for (int i : &#123;-1, -2, -3&#125;) &#123;&#125;// 在函数调用里用列表初始化。void TestFunction2(vector&lt;int&gt; v) &#123;&#125;TestFunction2(&#123;1, 2, 3&#125;); 用户自定义类型也可以定义接收 std::initializer_list 的构造函数和赋值运算符，以自动列表初始化： class MyType &#123; public: // std::initializer_list 专门接收 init 列表。 // 得以值传递。 MyType(std::initializer_list&lt;int&gt; init_list) &#123; for (int i : init_list) append(i); &#125; MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) &#123; clear(); for (int i : init_list) append(i); &#125;&#125;;MyType m&#123;2, 3, 5, 7&#125;; 最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收 std::initializer_list 的构造函数。 double d&#123;1.23&#125;;// MyOtherType 没有 std::initializer_list 构造函数， // 直接上接收常规类型的构造函数。class MyOtherType &#123; public: explicit MyOtherType(string); MyOtherType(int, string);&#125;;MyOtherType m = &#123;1, &quot;b&quot;&#125;;// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。MyOtherType m&#123;&quot;b&quot;&#125;; 千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂： ==Warning== auto d = &#123;1.23&#125;; // d 即是 std::initializer_list&lt;double&gt;auto d = double&#123;1.23&#125;; // 善哉 -- d 即为 double, 并非 std::initializer_list. 至于格式化，参见 9.7. 列表初始化格式. 6.21. Lambda 表达式 ==Tip== 适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。 ==定义：== Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如： std::sort(v.begin(), v.end(), [](int x, int y) &#123; return Weight(x) &lt; Weight(y);&#125;); C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper） std::function. ==优点：== 传函数对象给 STL 算法，Lambdas 最简易，可读性也好。 Lambdas, std::functions 和 std::bind 可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。 ==缺点：== Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。 Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。 ==结论：== 按 format 小用 lambda 表达式怡情。 禁用默认捕获，捕获都要显式写出来。打比方，比起 [=](int x) &#123;return x + n;&#125;, 您该写成 [n](int x) &#123;return x + n;&#125; 才对，这样读者也好一眼看出 n 是被捕获的值。 匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。 如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto. 6.22. 模板编程 ==Tip== 不要使用复杂的模板编程 ==定义:== 模板编程指的是利用c++ 模板实例化机制是图灵完备性, 可以被用来实现编译时刻的类型判断的一系列编程技巧 ==优点:== 模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如Google Test, std::tuple, std::function 和 Boost.Spirit. 这些工具如果没有模板是实现不了的 ==缺点:== 模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩, 难懂的. 在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和 维护起来都很麻烦 模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候, 即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解. 大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor for C++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用, 其次有些重构工具只对已经做过模板类型替换的代码的AST 有用. 因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构. ==结论:== 模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉 在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非c++ 程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板, 或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载, 那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用 如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. 你最好只在实现里面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解, 并且用户很容易知道如何修改这些错误 6.23. Boost 库 ==Tip== 只使用 Boost 中被认可的库. ==定义:== Boost 库集 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集. ==优点:== Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。 ==缺点:== 某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 “函数化” 的编程风格. ==结论:== 为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库: Call Traits : boost/call_traits.hpp Compressed Pair : boost/compressed_pair.hpp [ : boost/graph, except serialization (adj_list_serialize.hpp) and parallel/distributed algorithms and data structures(boost/graph/parallel/* and boost/graph/distributed/*) Property Map : boost/property_map.hpp The part of Iterator that deals with defining iterators: boost/iterator/iterator_adaptor.hpp, boost/iterator/iterator_facade.hpp, and boost/function_output_iterator.hpp The part of Polygon that deals with Voronoi diagram construction and doesn’t depend on the rest of Polygon: boost/polygon/voronoi_builder.hpp, boost/polygon/voronoi_diagram.hpp, and boost/polygon/voronoi_geometry_type.hpp Bimap : boost/bimap Statistical Distributions and Functions : boost/math/distributions Multi-index : boost/multi_index Heap : boost/heap The flat containers from Container: boost/container/flat_map, and boost/container/flat_set 我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化. 以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励： Pointer Container : boost/ptr_container, 改用 std::unique_ptr Array : boost/array.hpp, 改用 std::array 6.24. C++11 ==Tip== 适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。 ==定义：== C++11 有众多语言和库上的变革 &lt;https://en.wikipedia.org/wiki/C%2B%2B11&gt;_ 。 ==优点：== 在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++ 编译器支持。它标准化很多我们早先就在用的 C++ 扩展，简化了不少操作，大大改善了性能和安全。 ==缺点：== C++11 相对于前身，复杂极了：1300 页 vs 800 页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。 和 6.23. Boost 库 一样，有些 C++11 扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。 ==缺点：== C++11 特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11 特性之外，以下特性最好不要用： 尾置返回类型，比如用 auto foo() -&gt; int 代替 int foo(). 为了兼容于现有代码的声明风格。 编译时合数 ``, 因为它涉及一个重模板的接口风格。 和 头文件，因为编译器尚不支持。 默认 lambda 捕获。 译者（acgtyrant）笔记 实际上，缺省参数会改变函数签名的前提是改变了它接收的参数数量，比如把 void a() 改成 void a(int b = 0), 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。 此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。 我还发现 滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。 friend 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 .cc 文件加以定义。 本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。 由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考 声明顺序 。 对使用 C++ 异常处理应具有怎样的态度？ 非常值得一读。 注意初始化 const 对象时，必须在初始化的同时值初始化。 用断言代替无符号整型类型，深有启发。 auto 在涉及迭代器的循环语句里挺常用。 Should the trailing return type syntax style become the default for new C++11 programs? 讨论了 auto 与尾置返回类型一起用的全新编码风格，值得一看。 7. 命名约定 最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则. 命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则. 7.1. 通用命名规则 总述 函数命名, 变量命名, 文件命名要有描述性; 少用缩写. 说明 尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词. int price_count_reader; // 无缩写int num_errors; // &quot;num&quot; 是一个常见的写法int num_dns_connections; // 人人都知道 &quot;DNS&quot; 是什么int n; // 毫无意义.int nerr; // 含糊不清的缩写.int n_comp_conns; // 含糊不清的缩写.int wgc_connections; // 只有贵团队知道是什么意思.int pc_reader; // &quot;pc&quot; 有太多可能的解释了.int cstmr_id; // 删减了若干字母. 注意, 一些特定的广为人知的缩写是允许的, 例如用 i 表示迭代变量和用 T 表示模板参数. 模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循 类型命名 的规则, 而非类型模板应当遵循 变量命名 的规则. 7.2. 文件命名 总述 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-), 依照项目的约定. 如果没有约定, 那么 “_” 更好. 说明 可接受的文件命名示例: my_useful_class.cc my-useful-class.cc myusefulclass.cc myusefulclass_test.cc // _unittest 和 _regtest 已弃用. C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾, 参见 头文件自足. 不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 db.h. 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar. 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. 7.3. 类型命名 总述 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum. 说明 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如: // 类和结构体class UrlTable &#123; ...class UrlTableTester &#123; ...struct UrlTableProperties &#123; ...// 类型定义typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// using 别名using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;// 枚举enum UrlTableErrors &#123; ... 7.4. 变量命名 总述 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_. 说明 普通变量命名 举例: string table_name; // 好 - 用下划线.string tablename; // 好 - 全小写.string tableName; // 差 - 混合大小写 类数据成员 不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线. class TableInfo &#123; ... private: string table_name_; // 好 - 后加下划线. string tablename_; // 好. static Pool&lt;TableInfo&gt;* pool_; // 好.&#125;; 结构体变量 不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线: struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 结构体与类的使用讨论, 参考 结构体 vs. 类. 7.5. 常量命名 总述 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如: const int kDaysInAWeek = 7; 说明 所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 存储类型) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则. 7.6. 函数命名 总述 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable(). 说明 一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()). AddTableEntry()DeleteUrl()OpenFileOrDie() (同样的命名规则同时适用于类作用域与命名空间作用域的常量, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.) 取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如 int count() 与 void set_count(int count). 7.7. 命名空间命名 总述 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突. 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中. 注意 不使用缩写作为名称 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写. 要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 std 命名空间. 建议使用更独特的项目标识符 (websearch::index, websearch::index_util) 而非常见的极易发生冲突的名称 (比如 websearch::util). 对于 internal 命名空间, 要当心加入到同一 internal 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 frobber.h, 使用 websearch::index::frobber_internal). 7.8. 枚举命名 总述 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME. 说明 单独的枚举值应该优先采用 常量 的命名方式. 但 宏 方式的命名也可以接受. 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式. enum UrlTableErrors &#123; kOK = 0, kErrorOutOfMemory, kErrorMalformedInput,&#125;;enum AlternateUrlTableErrors &#123; OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2,&#125;; 2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题. 7.9. 宏命名 总述 你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 说明 参考 预处理宏; 通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线: #define ROUND(x) ...#define PI_ROUNDED 3.0 7.10. 命名规则的特例 总述 如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略. bigopen(): 函数名, 参照 open() 的形式 uint`: `typedef bigpos: struct 或 class, 参照 pos 的形式 sparse_hash_map: STL 型实体; 参照 STL 命名约定 LONGLONG_MAX`: 常量, 如同 `INT_MAX 译者（acgtyrant）笔记 感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 query_result, 区分度很好; 再次, 类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如 TextQuery::TextQuery(std::string word) : word_(word) &#123;&#125; , 其中 word_ 自然是类内私有成员. 8. 注释 注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字. 你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你! 8.1. 注释风格 总述 使用 // 或 /* */, 统一就好. 说明 // 或 /* */ 都可以; 但 // 更 常用. 要在如何注释及注释风格上确保统一. 8.2. 文件注释 总述 在每一个文件开头加入版权公告. 文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释. 说明 法律公告和作者信息 每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL) 如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息. 文件内容 如果一个 .h 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系. 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中. 不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义. 8.3. 类注释 总述 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显. // Iterates over the contents of a GargantuanTable.// Example:// GargantuanTableIterator* iter = table-&gt;NewIterator();// for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) &#123;// process(iter-&gt;key(), iter-&gt;value());// &#125;// delete iter;class GargantuanTableIterator &#123; ...&#125;; 说明 类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用. 如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适. 如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起. 8.4. 函数注释 总述 函数声明处的注释描述函数功能; 定义处的注释描述函数实现. 说明 函数声明 基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情. 函数声明处注释的内容: 函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 函数是否分配了必须由调用者释放的空间. 参数是否可以为空指针. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 举例如下: // Returns an iterator for this table. It is the client&#x27;s// responsibility to delete the iterator when it is done with it,// and it must not use the iterator once the GargantuanTable object// on which the iterator was created has been deleted.//// The iterator is initially positioned at the beginning of the table.//// This method is equivalent to:// Iterator* iter = table-&gt;NewIterator();// iter-&gt;Seek(&quot;&quot;);// return iter;// If you are going to immediately seek to another place in the// returned iterator, it will be faster to use NewIterator()// and avoid the extra seek.Iterator* GetIterator() const; 但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了: // Returns true if the table cannot hold any more entries.bool IsTableFull(); 注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释. 注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的. 函数定义 如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要. 不要 从 .h 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上. 8.5. 变量注释 总述 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明. 说明 类数据成员 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释. 特别地, 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明. 比如: private: // Used to bounds-check table accesses. -1 means // that we don&#x27;t yet know how many entries the table has. int num_total_entries_; 全局变量 和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如: // The total number of tests cases that we run through in this regression test.const int kNumTestCases = 6; 8.6. 实现注释 总述 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释. 说明 代码前注释 巧妙或复杂的代码段前要加注释. 比如: // Divide result by two, taking into account that x// contains the carry from the add.for (int i = 0; i &lt; result-&gt;size(); i++) &#123; x = (x &lt;&lt; 8) + (*result)[i]; (*result)[i] = x &gt;&gt; 1; x &amp;= 1;&#125; 行注释 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如: // If we have enough memory, mmap the data portion too.mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock)) return; // Error already logged. 注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志. 如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性: DoSomething(); // Comment here so the comments line up.DoSomethingElseThatIsLonger(); // Two spaces between the code and the comment.&#123; // One space before comment when opening a new scope is allowed, // thus the comment lines up with the following comments and code. DoSomethingElse(); // Two spaces before line comments normally.&#125;std::vector&lt;string&gt; list&#123; // Comments in braced lists describe the next element... &quot;First item&quot;, // .. and should be aligned appropriately.&quot;Second item&quot;&#125;;DoSomething(); /* For trailing block comments, one space is fine. */ 函数参数注释 如果函数参数的意义不明显, 考虑用下面的方式进行弥补: 如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破. 考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义. 如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改. 用具名变量代替大段而复杂的嵌套表达式. 万不得已时, 才考虑在调用点用注释阐明参数的意义. 比如下面的示例的对比: // What are these arguments?const DecimalNumber product = CalculateProduct(values, 7, false, nullptr); 和 ProductOptions options;options.set_precision_decimals(7);options.set_use_cache(ProductOptions::kDontUseCache);const DecimalNumber product = CalculateProduct(values, options, /*completion_callback=*/nullptr); 哪个更清晰一目了然. 不允许的行为 不要描述显而易见的现象, 永远不要 用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意: 你所提供的注释应当解释代码 为什么 要这么做和代码的目的, 或者最好是让代码自文档化. 比较这样的注释: // Find the element in the vector. &lt;-- 差: 这太明显了!auto iter = std::find(v.begin(), v.end(), element);if (iter != v.end()) &#123; Process(element);&#125; 和这样的注释: // Process &quot;element&quot; unless it was already processed.auto iter = std::find(v.begin(), v.end(), element);if (iter != v.end()) &#123; Process(element);&#125; 自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的: if (!IsAlreadyProcessed(element)) &#123; Process(element);&#125; 8.7. 标点, 拼写和语法 总述 注意标点, 拼写和语法; 写的好的注释比差的要易读的多. 说明 注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性. 虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助. 8.8. TODO 注释 总述 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释. TODO 注释要使用全大写的字符串 TODO, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 TODO 相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 TODO 时, 一般都是写上自己的名字. // TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.// TODO(Zeke) change this to use relations.// TODO(bug 12345): remove the &quot;Last visitors&quot; feature 如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”). 8.9. 弃用注释 总述 通过弃用注释（DEPRECATED comments）以标记某接口点已弃用. 您可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行. 在 DEPRECATED 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识. 弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点. 在 C++ 中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口. 仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手. 修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量. 译者 (YuleFox) 笔记 关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释; 文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你; 注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的; 对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗； 注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space; TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了. 9. 格式 每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行. 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码. 为了帮助你正确的格式化代码, 我们写了一个 emacs 配置文件. 9.1. 行长度 总述 每一行代码字符数不超过 80. 我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要. 优点 提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢? 缺点 反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码. 结论 80 个字符是最大值. 如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符. 包含长路径的 #include 语句可以超出80列. 头文件保护 可以无视该原则. 9.2. 非 ASCII 字符 总述 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码. 说明 即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码. 十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 \"\\xEF\\xBB\\xBF\", 或者更简洁地写作 u8\"\\uFEFF\", 在 Unicode 中是 零宽度 无间断 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的. (Yang.Y 注: \"\\xEF\\xBB\\xBF\" 通常用作 UTF-8 with BOM 编码标记) 使用 u8 前缀把带 uXXXX 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8, 输出就会出错. 别用 C++11 的 char16_t 和 char32_t, 它们和 UTF-8 文本没有关系, wchar_t 同理, 除非你写的代码要调用 Windows API, 后者广泛使用了 wchar_t. 9.3. 空格还是制表位 总述 只使用空格, 每次缩进 2 个空格. 说明 我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格. 9.4. 函数声明与定义 总述 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致. 说明 函数看上去像这样: ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123; DoSomething(); ...&#125; 如果同一行文本太多, 放不下所有参数: ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) &#123; DoSomething(); ...&#125; 甚至连第一个参数都放不下: ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) &#123; DoSomething(); // 2 space indent ...&#125; 注意以下几点: 使用好的参数名. 只有在参数未被使用或者其用途非常明显时, 才能省略参数名. 如果返回类型和函数名在一行放不下, 分行. 如果返回类型与函数声明或定义分行了, 不要缩进. 左圆括号总是和函数名在同一行. 函数名和左圆括号间永远没有空格. 圆括号与参数间没有空格. 左大括号总在最后一个参数同一行的末尾处, 不另起新行. 右大括号总是单独位于函数最后一行, 或者与左大括号同一行. 右圆括号和左大括号间总是有一个空格. 所有形参应尽可能对齐. 缺省缩进为 2 个空格. 换行后的参数保持 4 个空格的缩进. 未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名: class Foo &#123; public: Foo(Foo&amp;&amp;); Foo(const Foo&amp;); Foo&amp; operator=(Foo&amp;&amp;); Foo&amp; operator=(const Foo&amp;);&#125;; 未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来: class Shape &#123; public: virtual void Rotate(double radians) = 0;&#125;;class Circle : public Shape &#123; public: void Rotate(double radians) override;&#125;;void Circle::Rotate(double /*radians*/) &#123;&#125;// 差 - 如果将来有人要实现, 很难猜出变量的作用.void Circle::Rotate(double) &#123;&#125; 属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前: MUST_USE_RESULT bool IsOK(); 9.5. Lambda 表达式 总述 Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开. 说明 若用引用捕获, 在变量名和 &amp; 之间不留空格. int x = 0;auto add_to_x = [&amp;x](int n) &#123; x += n; &#125;; 短 lambda 就写得和内联函数一样. std::set&lt;int&gt; blacklist = &#123;7, 8, 9&#125;;std::vector&lt;int&gt; digits = &#123;3, 9, 1, 8, 4, 7, 1&#125;;digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) &#123; return blacklist.find(i) != blacklist.end(); &#125;), digits.end()); 9.6. 函数调用 总述 要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里. 说明 函数调用遵循如下形式： bool retval = DoSomething(argument1, argument2, argument3); 如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格： bool retval = DoSomething(averyveryveryverylongargument1, argument2, argument3); 参数也可以放在次行, 缩进四格： if (...) &#123; ... ... if (...) &#123; DoSomething( argument1, argument2, // 4 空格缩进 argument3, argument4); &#125; 把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性. 有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过, 比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办： 如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数： int my_heuristic = scores[x] * y + bases[x];bool retval = DoSomething(my_heuristic, x, y, z); 或者放着不管, 补充上注释： bool retval = DoSomething(scores[x] * y + bases[x], // Score heuristic. x, y, z); 如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. 参数的格式处理应当以可读性而非其他作为最重要的原则. 此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式： // 通过 3x3 矩阵转换 widget.my_widget.Transform(x1, x2, x3, y1, y2, y3, z1, z2, z3); 9.7. 列表初始化格式 总述 您平时怎么格式化函数调用, 就怎么格式化 列表初始化. 说明 如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字, 就视作名字长度为零. // 一行列表初始化示范.return &#123;foo, bar&#125;;functioncall(&#123;foo, bar&#125;);pair&lt;int, int&gt; p&#123;foo, bar&#125;;// 当不得不断行时.SomeFunction( &#123;&quot;assume a zero-length name before &#123;&quot;&#125;, // 假设在 &#123; 前有长度为零的名字. some_other_function_parameter);SomeType variable&#123; some, other, values, &#123;&quot;assume a zero-length name before &#123;&quot;&#125;, // 假设在 &#123; 前有长度为零的名字. SomeOtherType&#123; &quot;Very long string requiring the surrounding breaks.&quot;, // 非常长的字符串, 前后都需要断行. some, other values&#125;, SomeOtherType&#123;&quot;Slightly shorter string&quot;, // 稍短的字符串. some, other, values&#125;&#125;;SomeType variable&#123; &quot;This is too long to fit all in one line&quot;&#125;; // 字符串过长, 因此无法放在同一行.MyType m = &#123; // 注意了, 您可以在 &#123; 前断行. superlongvariablename1, superlongvariablename2, &#123;short, interior, list&#125;, &#123;interiorwrappinglist, interiorwrappinglist2&#125;&#125;; 9.8. 条件语句 总述 倾向于不在圆括号内使用空格. 关键字 if 和 else 另起一行. 说明 对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有. 最常见的是没有空格的格式. 哪一种都可以, 最重要的是 保持一致. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了. if (condition) &#123; // 圆括号里没有空格. ... // 2 空格缩进.&#125; else if (...) &#123; // else 与 if 的右括号同一行. ...&#125; else &#123; ...&#125; 如果你更喜欢在圆括号内部加空格: if ( condition ) &#123; // 圆括号与空格紧邻 - 不常见 ... // 2 空格缩进.&#125; else &#123; // else 与 if 的右括号同一行. ...&#125; 注意所有情况下 if 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格: if(condition) // 差 - IF 后面没空格.if (condition)&#123; // 差 - &#123; 前面没空格.if(condition)&#123; // 变本加厉地差.if (condition) &#123; // 好 - IF 和 &#123; 都与空格紧邻. 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用: if (x == kFoo) return new Foo();if (x == kBar) return new Bar(); 如果语句有 else 分支则不允许: // 不允许 - 当有 ELSE 分支时 IF 块却写在同一行if (x) DoThis();else DoThat(); 通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号: if (condition) DoSomething(); // 2 空格缩进.if (condition) &#123; DoSomething(); // 2 空格缩进.&#125; 但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用: // 不可以这样子 - IF 有大括号 ELSE 却没有.if (condition) &#123; foo;&#125; else bar;// 不可以这样子 - ELSE 有大括号 IF 却没有.if (condition) foo;else &#123; bar;&#125;// 只要其中一个分支用了大括号, 两个分支都要用上大括号.if (condition) &#123; foo;&#125; else &#123; bar;&#125; 9.9. 循环和开关选择语句 总述 switch 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 &#123;&#125; 或 continue. 说明 switch 语句中的 case 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法. 如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果 default 应该永远执行不到, 简单的加条 assert: switch (var) &#123; case 0: &#123; // 2 空格缩进 ... // 4 空格缩进 break; &#125; case 1: &#123; ... break; &#125; default: &#123; assert(false); &#125;&#125; 在单语句循环里, 括号可用可不用： for (int i = 0; i &lt; kSomeNumber; ++i) printf(&quot;I love you\\n&quot;);for (int i = 0; i &lt; kSomeNumber; ++i) &#123; printf(&quot;I take it back\\n&quot;);&#125; 空循环体应使用 &#123;&#125; 或 continue, 而不是一个简单的分号. while (condition) &#123; // 反复循环直到条件失效.&#125;for (int i = 0; i &lt; kSomeNumber; ++i) &#123;&#125; // 可 - 空循环体.while (condition) continue; // 可 - contunue 表明没有逻辑.while (condition); // 差 - 看起来仅仅只是 while/loop 的部分之一. 9.10. 指针和引用表达式 总述 句点或箭头前后不要有空格. 指针/地址操作符 (*, &amp;) 之后不能有空格. 说明 下面是指针和引用表达式的正确使用范例: x = *p;p = &amp;x;x = r.y;x = r-&gt;y; 注意: 在访问成员时, 句点或箭头前后没有空格. 指针操作符 * 或 &amp; 后没有空格. 在声明指针变量或参数时, 星号与类型或变量名紧挨都可以: // 好, 空格前置.char *c;const string &amp;str;// 好, 空格后置.char* c;const string&amp; str;int x, *y; // 不允许 - 在多重声明中不能使用 &amp; 或 *char * c; // 差 - * 两边都有空格const string &amp; str; // 差 - &amp; 两边都有空格. 在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格. 9.11. 布尔表达式 总述 如果一个布尔表达式超过 标准行宽, 断行方式要统一一下. 说明 下例中, 逻辑与 (&amp;&amp;) 操作符总位于行尾: if (this_one_thing &gt; this_other_thing &amp;&amp; a_third_thing == a_fourth_thing &amp;&amp; yet_another &amp;&amp; last_one) &#123; ...&#125; 注意, 上例的逻辑与 (&amp;&amp;) 操作符均位于行尾. 这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外, 直接用符号形式的操作符, 比如 &amp;&amp; 和 ~, 不要用词语形式的 and 和 compl. 9.12. 函数返回值 总述 不要在 return 表达式里加上非必须的圆括号. 说明 只有在写 x = expr 要加上括号的时候才在 return expr; 里使用括号. return result; // 返回值很简单, 没有圆括号.// 可以用圆括号把复杂表达式圈起来, 改善可读性.return (some_long_condition &amp;&amp; another_condition);return (value); // 毕竟您从来不会写 var = (value);return(result); // return 可不是函数！ 9.13. 变量及数组初始化 总述 用 =, () 和 &#123;&#125; 均可. 说明 您可以用 =, () 和 &#123;&#125;, 以下的例子都是正确的： int x = 3;int x(3);int x&#123;3&#125;;string name(&quot;Some Name&quot;);string name = &quot;Some Name&quot;;string name&#123;&quot;Some Name&quot;&#125;; 请务必小心列表初始化 &#123;...&#125; 用 std::initializer_list 构造函数初始化出的类型. 非空列表初始化就会优先调用 std::initializer_list, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 std::initializer_list 构造函数, 请改用括号. vector&lt;int&gt; v(100, 1); // 内容为 100 个 1 的向量.vector&lt;int&gt; v&#123;100, 1&#125;; // 内容为 100 和 1 的向量. 此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误. int pi(3.14); // 好 - pi == 3.int pi&#123;3.14&#125;; // 编译错误: 缩窄转换. 9.14. 预处理指令 总述 预处理指令不要缩进, 从行首开始. 说明 即使预处理指令位于缩进代码块中, 指令也应从行首开始. // 好 - 指令从行首开始 if (lopsided_score) &#123;#if DISASTER_PENDING // 正确 - 从行首开始 DropEverything();## if NOTIFY // 非必要 - ## 后跟空格 NotifyClient();## endif##endif BackToNormal(); &#125;// 差 - 指令缩进 if (lopsided_score) &#123; #if DISASTER_PENDING // 差 - &quot;#if&quot; 应该放在行开头 DropEverything(); ##endif // 差 - &quot;##endif&quot; 不要缩进 BackToNormal(); &#125; 9.15. 类格式 总述 访问控制块的声明依次序是 public:, protected:, private:, 每个都缩进 1 个空格. 说明 类声明 (下面的代码中缺少注释, 参考 类注释) 的基本格式如下: class MyClass : public OtherClass &#123; public: // 注意有一个空格的缩进 MyClass(); // 标准的两空格缩进 explicit MyClass(int var); ~MyClass() &#123;&#125; void SomeFunction(); void SomeFunctionThatDoesNothing() &#123; &#125; void set_some_var(int var) &#123; some_var_ = var; &#125; int some_var() const &#123; return some_var_; &#125; private: bool SomeInternalFunction(); int some_var_; int some_other_var_;&#125;; 注意事项: 所有基类名应在 80 列限制下尽量与子类名放在同一行. 关键词 public:, protected:, private: 要缩进 1 个空格. 除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空. 这些关键词后不要保留空行. public 放在最前面, 然后是 protected, 最后是 private. 关于声明顺序的规则请参考 声明顺序 一节. 9.16. 构造函数初始值列表 总述 构造函数初始化列表放在同一行或按四格缩进并排多行. 说明 下面两种初始值列表方式都可以接受: // 如果所有变量能放在同一行:MyClass::MyClass(int var) : some_var_(var) &#123; DoSomething();&#125;// 如果不能放在同一行,// 必须置于冒号后, 并缩进 4 个空格MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) &#123; DoSomething();&#125;// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行// 并逐行对齐MyClass::MyClass(int var) : some_var_(var), // 4 space indent some_other_var_(var + 1) &#123; // lined up DoSomething();&#125;// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行// 如果这样做合适的话MyClass::MyClass(int var) : some_var_(var) &#123;&#125; 9.17. 命名空间格式化 总述 命名空间内容不缩进. 说明 命名空间 不要增加额外的缩进层次, 例如: namespace &#123;void foo() &#123; // 正确. 命名空间内没有额外的缩进. ...&#125;&#125; // namespace 不要在命名空间内缩进: namespace &#123; // 错, 缩进多余了. void foo() &#123; ... &#125;&#125; // namespace 声明嵌套命名空间时, 每个命名空间都独立成行. namespace foo &#123;namespace bar &#123; 9.19. 水平留白 总述 水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白. 说明 通用 void f(bool b) &#123; // 左大括号前总是有空格. ...int i = 0; // 分号前不加空格.// 列表初始化中大括号内的空格是可选的.// 如果加了空格, 那么两边都要加上.int x[] = &#123; 0 &#125;;int x[] = &#123;0&#125;;// 继承与初始化列表中的冒号前后恒有空格.class Foo : public Bar &#123; public: // 对于单行函数的实现, 在大括号内加上空格 // 然后是函数实现 Foo(int b) : Bar(), baz_(b) &#123;&#125; // 大括号里面是空的话, 不加空格. void Reset() &#123; baz_ = 0; &#125; // 用括号把大括号与实现分开. ... 添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE) 循环和条件语句 if (b) &#123; // if 条件语句和循环语句关键字后均有空格.&#125; else &#123; // else 前后有空格.&#125;while (test) &#123;&#125; // 圆括号内部不紧邻空格.switch (i) &#123;for (int i = 0; i &lt; 5; ++i) &#123;switch ( i ) &#123; // 循环和条件语句的圆括号里可以与空格紧邻.if ( test ) &#123; // 圆括号, 但这很少见. 总之要一致.for ( int i = 0; i &lt; 5; ++i ) &#123;for ( ; i &lt; 5 ; ++i) &#123; // 循环里内 ; 后恒有空格, ; 前可以加个空格.switch (i) &#123; case 1: // switch case 的冒号前无空格. ... case 2: break; // 如果冒号有代码, 加个空格. 操作符 // 赋值运算符前后总是有空格.x = 0;// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.// 圆括号内部没有紧邻空格.v = w * x + y / z;v = w*x + y/z;v = w * (x + z);// 在参数和一元操作符之间不加空格.x = -5;++x;if (x &amp;&amp; !y) ... 模板和转换 // 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.vector&lt;string&gt; x;y = static_cast&lt;char*&gt;(x);// 在类型与指针操作符之间留空格也可以, 但要保持一致.vector&lt;char *&gt; x; 9.19. 垂直留白 总述 垂直留白越少越好. 说明 这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行. 基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好. 下面的规则可以让加入的空行更有效: 函数体内开头或结尾的空行可读性微乎其微. 在多重 if-else 块里加空行或许有点可读性. 译者 (YuleFox) 笔记 对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的; 行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去; 尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了; UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非; 函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行; 除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行; ./-&gt; 操作符前后不留空格, */&amp; 不要前后都留, 一个就可, 靠左靠右依各人喜好; 预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进; 初始化用 = 还是 () 依个人喜好, 统一就好; return 不要加 (); 水平/垂直留白不要滥用, 怎么易读怎么来. 关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (.cc 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然. 译者（acgtyrant）笔记 80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等. Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码, 不像奇葩的 Windows. Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号. Apple 正好 有栽过跟头 . 其实我主张指针／地址操作符与变量名紧邻, int* a, b vs int *a, b, 新手会误以为前者的 b 是 int * 变量, 但后者就不一样了, 高下立判. 在这风格指南里我才刚知道 C++ 原来还有所谓的 Alternative operator representations, 大概没人用吧. 注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事, 我就差点混淆了它们的翻译. 事实上, 如果您熟悉英语本身的书写规则, 就会发现该风格指南在格式上的规定与英语语法相当一脉相承. 比如普通标点符号和单词后面还有文本的话, 总会留一个空格; 特殊符号与单词之间就不用留了, 比如 if (true) 中的圆括号与 true. 本风格指南没有明确规定 void 函数里要不要用 return 语句, 不过就 Google 开源项目 leveldb 并没有写; 此外从 Is a blank return statement at the end of a function whos return type is void necessary? 来看, return; 比 return ; 更约定俗成（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）, 且可用来提前跳出函数栈. 10. 规则特例 前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例. 10.1. 现有不合规范的代码 总述 对于现有不符合既定编程风格的代码可以网开一面. 说明 当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, 一致性 也包括原有的一致性. 10.2. Windows 代码 总述 Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南. 说明 如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南: 不要使用匈牙利命名法 (比如把整型变量命名成 iNum). 使用 Google 命名约定, 包括对源文件使用 .cc 扩展名. Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 DWORD, HANDLE 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 const TCHAR * 而不是 LPCTSTR. 使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理. 不要使用 ##pragma once; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 ##ifndef SRC_DIR_BAR_H_, 参考 ##define 保护 一节). 除非万不得已, 不要使用任何非标准的扩展, 如 ##pragma 和 __declspec. 使用 __declspec(dllimport) 和 __declspec(dllexport) 是允许的, 但必须通过宏来使用, 比如 DLLIMPORT 和 DLLEXPORT, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展. 然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则: 通常我们 禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承. 虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 _ATL_NO_EXCEPTIONS 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理). 通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 StdAfx.h 或 precompile.h 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 precompile.cc 中), 使用 /FI 编译器选项以自动包含该文件. 资源头文件通常命名为 resource.h 且只包含宏, 这一文件不需要遵守本风格指南. 11. 结束语 运用常识和判断力, 并且 保持一致. 编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 if 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做. 风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏, 所以要尽量避免. 好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://adversarr.github.io/tags/C/"}]},{"title":"Collision Detection 整理 2 - Broad Phase 阶段","slug":"CG/SortByCato/ContactDetection/BroadPhase","date":"2022-03-27T16:00:00.000Z","updated":"2022-04-12T16:05:28.166Z","comments":true,"path":"2022/03/28/CG/SortByCato/ContactDetection/BroadPhase/","link":"","permalink":"http://adversarr.github.io/2022/03/28/CG/SortByCato/ContactDetection/BroadPhase/","excerpt":"介绍几种在各类代码库中应用的 Broad Phase 算法","text":"介绍几种在各类代码库中应用的 Broad Phase 算法 来源包括但不限于： Unity UE Nvidia PhyX 各大博客 论文 Broad Phase Algorithms 根据 Nvidia-GPU Gems 31的描述，Broad Phase最主要的还是依靠一些最基础的观察来降低时间复杂度。主要的算法有： Sort and Sweep：按Axis排序，然后扫描分段，认为每一个在Axis上相邻的即可能会相交。 Spatial Subdivision：空间细分算法。可以有两种主要的形式，包括固定空间划分（每个格子尺寸一致） BVH（层次包围盒 – AABB/k-DOP/OBB，更基础的还有oct-tree这些数据结构）算法。实际上固定的空间划分算法和Sort And Sweep可以互相转化。 不考虑并行的情况下，固定的空间划分算法是明显慢的。但考虑到Spatial Subdivision可以在GPU上运行，实际上这类算法也很常用。 在实际的游戏引擎中，为了达到实时的要求，使用的算法也相对简单： Sweep-based：考察物体运动所划过的面积，是否相互接触。计算TOI（impact 产生时刻），然后重新计算。 — 会增加 CPU 的负载、角速度大时会产生误差。 Speculative CCD：计算运动过程中的AABB，然后对于覆盖到的物体进行针对性检查。 – maybe cheaper，但是会出现误检为collision 的问题。 其次，对于每一个物体，其也可能有针对性的优化措施，例如在Unreal Engine中，每一个物体的碰撞处理可以设置为不同的细度，从而获取不同的效果。同时其也对于输入的物体Mesh/Obj进行 凸包变换（V-HACD2），并使用适用于凸包的 Collision Detect 来进行碰撞的判断 设置 k-DOP 无一例外，这些算法都是BVH的变体。 其他的，例如 PhysX 中，碰撞检测还可以通过光线投射（Raycast）算法计算得出。 对于高速物体–低速物体的情形，可以考虑在每一次计算得到无碰撞位移后，通过Raycast算法得出运动路径上是否与其余物体有碰撞产生。 Overview of Collision in PhysX Broadphase AABB vs AABB, 3 axis sweep and prune Midphase AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABB tree 对于 Narrow Phase： 流体-SPH Fluids (CCD) Particles vs static triangle mesh • Particles vs dynamic primitives 布料-Cloth (CCD) Vertices vs static triangle mesh • Vertices vs dynamic primitives 刚体-Rigid body (Discrete) – GJK or SAT Convex mesh and primitives vs static triangle mesh Convex, primitives vs Convex, primitives Nvidia- Sort and sweep Sweep Method 的角速度过大，导致CCD失败 speculative ccd 考虑两种情形： 只有 Rigid Body：不可能产生自交问题，这样子的话 Rigid + Deformed：Rigid肯定不会自交，但是Deformed物体可能存在自交问题、Rigid-Deformed之间可能产生相交 BVH 和 Spatial Hashing 来实现 https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda↩︎ https://github.com/kmammou/v-hacd↩︎","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"Collision Detection 整理 4 - Deformed Object","slug":"CG/SortByCato/ContactDetection/Deformed","date":"2022-03-27T16:00:00.000Z","updated":"2022-04-10T06:39:13.320Z","comments":true,"path":"2022/03/28/CG/SortByCato/ContactDetection/Deformed/","link":"","permalink":"http://adversarr.github.io/2022/03/28/CG/SortByCato/ContactDetection/Deformed/","excerpt":"碰撞检测 4 - Deformed Object","text":"碰撞检测 4 - Deformed Object 90-00初 变形体和三角网格的处理的经典论文是： [Bridson02] Robust Treatment of Collisions, Contact and Friction for Cloth Animation [Provet97] Collision and self-collision handling in cloth model dedicated to design garments 其中这两篇论文几乎可以说是篇篇论文都在引了。其主要的思想在于 Provet 97 简介 这篇论文之所以重要，是因为其提出了三角网格产生碰撞一个充分必要条件：对于三角网格而言，其产生碰撞，当且仅当，存在 Vertical - Triangle （原文 Point Triangle collision）碰撞 Edge - Edge 碰撞 之一（或兼有） 显然的是，两个碰撞都导致了四点共面的情况。根据空间几何的知识，\\(\\mathbf x_{1}\\cdots\\mathbf x_4\\) 共面，当且仅当： \\[ (\\mathbf x_{12}\\quad \\mathbf x_{13} \\quad \\mathbf x_{14}) = 0 \\] 其中 \\((\\quad )\\)记号为混合积。因此为检测碰撞，转化为求解一个关于 \\(t\\) 的三次方程，即： \\[ \\exists t \\in [0, 1]\\quad (\\mathbf x_{12}\\quad \\mathbf x_{13} \\quad \\mathbf x_{14}) = 0 \\] 其中的三次方程采用牛顿法求解。 求解出 \\(t\\) 是不够的，因为方程可能出现 V 不处于 T 内部，或 E 和 E 不交的情况，但考虑到已经共面，下一步的判断是简单的，几乎不需要计算。因此该算法主要的计算量在于三次方程的求解上。 Broad Phase 剔除 BVH 计算曲率：根据显然的事实 — 给定一个曲面局部，如果它是凸的，且有充分低的曲率，则其不可能产生自相交。 Impact Zone 为了消除一个碰撞，可能会引入其他的碰撞，这是因为在处理碰撞的时候，我们只针对当前选出来的碰撞对进行更新，在该更新过程中是不考虑其他点的情况的。 因此，若一个 Impact Zone 在充分大的时候，考虑Frozen，并通过群速度、群角速度进行整体更新。 相关内容 Fast CCD Safe CCD Tight CCD Bridson 02 这篇嘛是一个完整的Workflow介绍了，从文章标题也能看出来主要是为了准确和高鲁棒性来实现的。主要还是处理了自碰撞的问题。 碰撞检测 Broad-Phase：AABB，自下而上构造。 Narrow-Phase：还是基于上面的共面，但是判断是否在内部改进为解线性方程组（分解到现有基底上） 处理 摩擦：库伦定律（摩擦角）用于静摩擦和动摩擦。 Rigid Impact Zone：用于失败的补偿机制","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"Collision Detection 整理 1 - Introduction","slug":"CG/SortByCato/ContactDetection/Introduction","date":"2022-03-27T16:00:00.000Z","updated":"2022-04-14T14:12:34.457Z","comments":true,"path":"2022/03/28/CG/SortByCato/ContactDetection/Introduction/","link":"","permalink":"http://adversarr.github.io/2022/03/28/CG/SortByCato/ContactDetection/Introduction/","excerpt":"碰撞检测相关介绍","text":"碰撞检测相关介绍 碰撞检测 众所又周知啊，碰撞检测是一个老大难的问题，在很多的仿真模拟、游戏引擎中间都会用哈 碰撞检测的主要流程是 1： GAMES 103- Collision Handling 其中： \\(\\{\\mathbf x, \\mathbf x^{new}\\}\\) 分别是更新前后的顶点位置向量 Pair Condidates 是指可能发生碰撞的 primitive pairq Colliding Pairs 是指真实发生碰撞的 primitive pair 注意： 一般而言，所谓的 primitive 是指组成这个 body (不管是 deformable 还是 rigid) 的单位元素，例如： 三角网格 (mass-spring 模型）中的三角面片 多边形模型（例如 FEM ）中的面片 图的顶点、边 可以看出，总体上的碰撞检测分为两个阶段：第一阶段（Broad-Phase）去除不可能出现的pairs（当然肯定使用反向计算出可能产生 collision 的 pair 去做的。第二阶段（Narrow-Phase）去针对每一个pair计算。 Broad-Phase 碰撞剔除两种常见的方法： Spatial Hashing：空间哈希 BVH：层次包围盒 空间划分 基本思想 将整个空间划分为各自，然后将Primitive存在单元格内。（有相交就存储，可能出现在多个格子里面） 对于每一个格子里面的所有 Primitive-Pair 输出。 动态过程 我们将 \\(x^{new}\\) 和 \\(x\\) 都认为是其位置，再进行划分。 存在的问题 三维空间的格子 – 100x100x100 – 计算量大 可能出现：分布不均匀 浪费存储空间 大量的三角形聚集在几个格子里 改进方案 排序 排序 目的：所有的Pair都按照格子的编号排列（类似于稀疏矩阵压缩），从而节约内存开销。 为了达到连续内存访问 使用 Morton Code 编码， BVH 层次包围盒 递归的建立一棵树，例如： BVH Idea：把包围盒组合成新的包围盒 如何检查： ProcessNode(A) &#123; for_each(B: A.child)&#123; ProcessNode(B); &#125; for_each([B, C]: A.childrenPair) &#123; if B-C intersect &#123; ProcessPair(B, C) &#125; &#125;&#125;ProcessPair(B, C) &#123; for_each(B&#x27;: B.child) &#123; for_each(C&#x27;: C.child) &#123; if B&#x27;-C&#x27; intersect &#123; ProcessPair(B&#x27;, C&#x27;) &#125; &#125; &#125;&#125; 常见的包围盒 AABB：intersect 当且仅当在轴上有相交 球 OBB：任意方向的包围盒 问题 难以处理紧邻的情况。 – 只有便利到底层才能解决 Energy-based Self-Collision Culling for Arbitary Mesh Deformations 形变越大，越容易相交 对比 SH =&gt; Edge-Triangle Easy to implement GPU-Friendly Need to recompute after updating obj. BVH =&gt; VT &amp; EE More Involved Not GPU Friendly To update BVH, just update BV Narrow Phase 进一步看是否真的有碰撞，两种：DCD和CCD DCD — 相交检测 只考虑是否相交（而非碰撞） 对于Triangle Mesh，只考虑 Edge-Triangle. \\[ \\begin{cases} ((1-t) x_a+tx_b -x_0)\\cdot x_{10} \\times x_{20} =0\\\\ t = \\frac{x_{0a}\\cdot x_{10} \\times x_{20}}{x_{ba}\\cdot x_{10} \\times x_{20}} \\end{cases} \\] 若解出来的 \\(t\\in [0, 1]\\) 则能够判断出在 \\(t\\) 处相交 DCD 问题 可能会产生穿透问题（运动很快的情况）。对于大体积问题的概率低，但是如果是cloth等薄物体，容易发生。 减少dt CCD 测试两个状态（之间）有无碰撞产生。 一般是做 VT 和 EE 的检测： V-T测试 EE测试 共同点： 解一元三次方程。观察解的情况 数值问题 公式法：开三次方的数值误差大 牛顿法：速度 GPU — 单精度 Expensive — 可以考虑加强 Broad-Phase Bridson2002-Robust … … 碰撞处理 IPM / IZO 内点法 截断 – IPC 内点法 反复进行碰撞检测 Robust…… Impact Zone Method. 备选 Rigid Impact Zone 一个常见的思路为 相交解除 碰撞不是灾难，可以在发生之后进行解除 处理当前已有的相交情况。 Untangling Cloth. 改进方法： 期望相交曲线变短，直到相交解除 Not always work. Resolving Service Collisons through 实际上，Narrow Phase 还可以继续细分： The narrow phase obtains the collision pair list and for every pair, using their actual geometry, it checks whether the two partners are colliding. This phase can get arbitrarily complex, so in the context of real-time physics simulation, the participating colliding shapes are usually restricted to being convex. For nonconvex shapes, only the convex hull will then be used for collision detection. In most cases this is good enough—for example if the concavities are small or constitute object parts where you don't want a game character to go anyway, such as the exhaust pipes of a spacecraft or other irrelevant places. To improve collision quality and performance, we can decompose big or concave objects into convex pieces. A game object therefore might hold a simplified collision geometry that is different from the one displayed. In this chapter we investigate a narrow-phase algorithm for determining the distance between two convex objects. For the two objects in Figure 33-1b, the contact point marked with the yellow star is detected, and its location is calculated and stored with the collision pair.（转化为凸包，进一步简化加速） 根据 [Provet97] 2 的描述，其可以通过 UE4 中的碰撞检测： 射线检测RayCasts 重叠检测Overlaps 渗透深度计算Penetration Depth Sweeps检测 InitialOverlaps检测 https://zhuanlan.zhihu.com/p/33529865 刚体碰撞 Penalty Method Impulse Method 空间划分 — Spatial Hashing Easy Implement GPU Friendly Recompute after updating. 包围盒 AABB More involved Not gpu friendly Update BVH -&gt; Update Bounding Volumes. 两种碰撞检测方式： DCD — Discrete Collision Detection 当前状态下有无自相交 CCD — Continuous Collision Detection 两个状态之间是否相交 对于三角网格： 点 - 三角 边 - 边 Co-planar Issues: 误差 - 三次方程 - GPU-float32 比 DCD 慢很多 难以实现 处理方法： Interior Point Method 每一步都是安全的 Slow - far from solution - all of vertices - cautiously by small steps Log-Barrier IPM. E(x) = -log |xij| + Gradient Descent IPC - not GD. Impact Zone Optimization 逐步满足 Constraint Fast - Close To solution - only vertices in collision - can take large steps sizes May not succeed. (Due to large dT) Rigid Impact Zones. 回到前一帧 -&gt; 没有碰撞（视为刚体） CCD -&gt; IZO -&gt; IPM or RIZ 相交解除 Not always intersection free. V-V intersection C-V intersection 推出即可 C-C 无法处理边界 难以在 GPU 上实现 Reference GAMES103 Collision Handling↩︎ Collision and self-collision handling in cloth model dedicated to design garments↩︎","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"Collision Detection 整理 3 - Narrow Phase 阶段","slug":"CG/SortByCato/ContactDetection/NarrowPhase","date":"2022-03-27T16:00:00.000Z","updated":"2022-04-12T12:43:58.767Z","comments":true,"path":"2022/03/28/CG/SortByCato/ContactDetection/NarrowPhase/","link":"","permalink":"http://adversarr.github.io/2022/03/28/CG/SortByCato/ContactDetection/NarrowPhase/","excerpt":"碰撞检测笔记 3 — Narrow Phase","text":"碰撞检测笔记 3 — Narrow Phase 一般而言的 Narrow Phase 是基于点线面的关系推导得到的。而且在很多情况下，我们不需要知道碰撞在两个插值点之间的具体位置，而只需要知道其是否碰撞。针对不同的物体，一可以有不同的优化策略。 一般物体间的碰撞检测 凸物体 刚体 变形体 &amp; 三角网格 凸物体的碰撞检测 一般而言，凸物体的碰撞可以通过 GJK 和 SAT 方法来判断。 Gilbert-Johnson-Keerthi (GJK) 算法 Idea 设 \\(\\mathcal A = \\{\\mathbf x\\}\\)， \\(\\mathcal B = \\{\\mathbf x\\}\\) 是两个点集，定义其 Minkowski 差为： \\[ \\mathcal A - \\mathcal B :=\\{\\mathbf x_1 - \\mathbf x_2| \\mathbf x_1 \\in \\mathcal A, \\mathbf x_2 \\in \\mathcal B \\} \\] 不难证明，\\(\\mathcal A\\) 和 \\(\\mathcal B\\) 碰撞，当且仅当 \\(0 \\in \\mathcal A - \\mathcal B\\)。 问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于凸物体，我们可以有快速算法实现。 Support 函数和 Simplex 单纯形 其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski 差的一个子集包含了 \\(0\\)，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。 为了生成这样的单纯形，我们计算 support 函数来快速获取给定方向上的支撑点，如图所示1。 Support 函数返回的点 迭代求解 有了如上的论述，我们可以通过如此构造单纯形： 随机生成一个单纯形 假定当前的单纯形为 \\(\\{v\\}\\) 则选择距离原点最远的抛弃，对于 n - 1 维单纯形求法向量，求support（两个） 直到 检查到 0 =&gt; 碰撞 如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞 可以证明，这样的算法一定在有限步内结束。 SAT 分离轴算法 一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个 \\(n - 1\\) 维的超平面能够完全分开这两个凸集合。 遍历所有的边（三维则是面），投影到其正交补空间上。若存在一个边，能使得投影完全分离，则其是不相交的，反之相交。 刚体碰撞检测 刚体碰撞的检测正如在 Broad Phase 里提到： 凸包变换（V-HACD），并使用适用于凸包的 Collision Detect 来进行碰撞的判断。 这类方法将原来的刚体预计算处理为凸包，用户可以控制其分割的粒度，从而权衡其加速/精度。 变形体 &amp; 三角网格 基本思路为： 求解三次方程； 设置两个非邻接顶点/面的距离下界为一个固定/可变的非零数（可以按照siggraph2022的论文结果强化到点-点距离） 在变形体网格上建立局部 BVH 来增加一部，返回1/2求解 https://zhuanlan.zhihu.com/p/127844705↩︎","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"面向夏令营的抽象代数整理","slug":"study/Math/SummerCamp/Algebra","date":"2022-03-27T16:00:00.000Z","updated":"2022-07-10T03:39:28.274Z","comments":true,"path":"2022/03/28/study/Math/SummerCamp/Algebra/","link":"","permalink":"http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/Algebra/","excerpt":"待完善","text":"待完善 群论初步 引论 群 在一个非空集合上，定义了一个代数运算，其满足 1. 结合 2. 存在幺元 3. 对每个元素都存在逆元 群的典型例子 在上述条件中，若只满足 1 ，则称为半群，满足12，称为幺半群 由群上的代数运算，可以定义\\(n\\)次幂运算 数集 x数加群 \\(\\mathbb R^*\\)乘法 （复数域）\\(n\\)次单位根对乘法 -- 循环群 1和3都有共同的特点：可以由一个元素生成整个群，即存在一个生成元（可以不唯一） \\[ k = k \\cdot 1\\quad z_k = \\left(e^{2 \\pi i/ n}\\right)^k \\] 从而可以定义： 循环群 如果群的每一个元素都是某一个元素的方幂， 几何 某欧式空间中的全体正交变换 二面体群 -- 正 n 边形的对称群 代数 模 \\(m\\) 剩余类对加法 模 \\(p\\) 剩余类除去 \\(\\bar 0\\)，对乘法 可逆矩阵 -- \\(GL_n(F)\\) 行列式为 1 的矩阵全体 \\(SL_n(F)\\) 置换 -- \\(\\Omega\\) 到自身的双射 一般\\(n\\)元置换可以写成： \\[ \\sigma = \\left( \\begin{matrix} 1 &amp; 2 &amp; \\cdots &amp; n\\\\ a_1 &amp; a_2 &amp; \\cdots &amp; a_n \\end{matrix} \\right) \\] 在其上，我们可以分解置换为不相交的轮换的积，在除顺序外，该分解唯一 \\[ \\left( \\begin{matrix} 1 &amp; 2 &amp; 3 &amp; 4\\\\ 4 &amp; 3 &amp; 2 &amp; 1 \\end{matrix} \\right) =(14)(23) \\] 即有 Theorem 每一个置换都可以分解为一些不相交的轮换的乘积，且在不计顺序的情况下该分解唯一。 除此之外，每一个置换都能分解为对换，考虑： \\[ (1 2 3 4) = (14)(13)(12) \\] 由此可以定义 1. 奇置换 2. 偶置换 子群、陪集、Lagrange定理、循环群的子群 子群 子群 群的一个非空子集，若满足群的要求，则称为子群 子群判定方法 若 \\(\\forall a, b\\in H, \\quad ab^{-1} \\in H\\)则 \\(H\\)是子群。 从另一个层面上，我们可以考虑生成子群 \\(\\langle S\\rangle\\) 即 \\(G\\) 中包含 \\(S\\) 的最小子群，反之，对任意一个群，我们可以找这样的生成元集。 我们考虑可以通过元素生成的子群，来观察元素的性质： 阶 一个元素生成的群 \\(\\langle a \\rangle\\) 是循环群，把这个群的阶定义为这个元素的阶（群元素个数） 对于元素的阶 \\(n\\) 有如下定理 \\(a^m = e \\iff n | m\\) 对任意正整数 \\(k\\)，其\\(|a^k| = n / (n, k)\\) 陪集 利用子群，可以得到群的一个划分： 左陪集 给定子群 \\(H\\)，对任意元素\\(a\\)都能定义左陪集：\\(aH\\) 其具有两个性质： \\(aH = bH \\iff b^{-1}a \\in H\\) 两个元素对应的左陪集，要么相等，要么不相交 左陪集构成的集合称为左商集 由此可以定义右陪集和右商集 我们观察到，通过映射： \\[ \\varphi :aH \\rightarrowtail Ha^{-1} \\] 能够在左商集和右商集之间建立一一对应，即我们知道，左商集和右商集有同样的基数。 于是我们猜测： 拉格朗日定理 \\(|G| = |H|\\cdot[G:H]\\) \\([G:H]\\)为商集的基数 利用该定理，我们不难得到： 素数阶群一定是循环群 有限群的每一个元素的阶都是\\(|G|\\)的因子 以及： 费马小定理 若\\(p\\)是素数，\\(a\\)不是\\(p\\)的倍数，则 \\[ a^p \\equiv a\\quad (\\mathrm{mod}~p)\\label{eq:6} \\] 证明：考察 \\(\\bar a\\) 在\\(Z_p^*\\)中的阶。 因此，我们能够完全描述循环群的结构： Theorem 一个有限阶循环群同构于\\(Z_m\\)，其中\\(m=|G|\\) Theorem 一个无穷阶循环群同构于\\(Z\\) Theorem 设 \\(G\\) 是有限Abel群，则\\(G\\)是循环群，当且仅当对于任一正整数\\(m\\)，方程\\(x^m = e\\) 在 \\(G\\)中的解个数不超过 \\(m\\)。 因此： 有限域\\(F\\)的乘法群\\(F^*\\)必为循环群 设 \\(p\\) 是素数，那么\\((p-1)!=-1\\quad(\\mathrm{mod} ~p)\\) 群同构 同构的定义 群的直和 在两个群上，定义运算：\\((g_1, g_1&#39;) \\cdot (g_2, g_2 &#39;) := (g_1 g_2, g_1&#39;g_2&#39;)\\) 例如Klein四元群是\\(Z_2 \\times Z_2\\) 群同态、正规子群、商群、可解群 同态、正规子群 群同态：指一个同态映射，能够让群的运算和映射交换 保持了幺元、逆元 可以按照映射，定义单同态（i.e. 嵌入）、满同态 利用同态，我们可以研究群的性质： \\(Ker(\\sigma)\\) 是一个子群 单同态 当且仅当 \\(Ker = \\{e\\}\\) 观察该群的性质，我们发现 \\(\\forall g\\in G, gHg^{-1} =H\\)，定义这样的子群为正规子群。 对于一般的子群，我们也可以定义\\(gHg^{-1}\\)，称为\\(H\\)的共轭子群。 对于正规子群，其另一个充要条件是： \\[ \\forall a\\in G\\quad aH= Ha \\] 显然，我们有： Theorem 若 \\(H\\) 是 \\(G\\) 的指数为 2 的子群，则\\(H\\)是正规的。 商群 利用正规子群\\(N\\)，可以定义商群（左右陪集相等！）即\\(G/N\\) 我们可以在\\(G, G/N\\)之间建立自然映射 \\[ \\pi : a \\rightarrowtail aN \\] 群同态基本定理 : \\(G/Ker\\sigma \\simeq Im \\sigma\\) 由该基本定理，我们可以得出2条定理 第一同构定理： \\(HN&lt;G\\) \\(H\\cap N \\vartriangleleft H, H/(H\\cap N) \\simeq HN/N\\) 第二同构定理 \\((G/N_2) / (N_1/N_2) \\simeq G/N_1\\) \\(N_1/N_2\\vartriangleleft G/N_2\\) 了解了正规子群，$$我们就可以对于这个群的一部分有所了解。我们定义： 单群 如果该群只有平凡的正规子群 直观理解：无法拆开的群，类似于素数在整数中的地位 显然的结论是： Theo Abel群是单的，当且仅当其是素数阶循环群。 称 \\(xyx^{-1}y^{-1}\\) 称为 \\(x\\) 和 \\(y\\) 的换位子，记作 \\([x,y]\\)。 所有换位子生成的子群称为换位子群/导群。 由此可见，Abel群的导群是 \\(\\{e\\}\\). 我们希望的结果是，拿到群可以使得其“分解”为几个小的群。 可解群 如果存在正整数 \\(k\\) 使得 \\(G^{(k)} = \\{e\\}\\)，称该群是可解的。 群在集合上的作用、自同构、轨道-稳定子定理 群在集合上的作用 设\\(G\\)是一个群，\\(\\Omega\\) 是一个非空集合，如果有从\\(G\\times\\Omega\\)到\\(\\Omega\\)的一个映射 \\[ (a, x) \\rightarrow a \\circ x \\] 满足 交换性、幺元对应恒等映射，则称\\(G\\)在\\(\\Omega\\)上有一个作用。 Theorem 假设\\(G\\)在\\(\\Omega\\)上有一个作用，任意给定\\(a\\in G\\)，令\\(\\psi (a) x := a \\circ x, \\forall x \\in \\Omega\\)，则\\(\\psi\\)是群\\(G\\)到\\(\\Omega\\)的全变换群的一个同态。 群\\(G\\)在集合\\(G\\)上的左平移 Cayley 任意一个群都同构于某一个集合上的变换群。 任意一个有限群都同构于一个变换群。 群\\(G\\)在左商集\\(G/H\\)上的作用 \\[ (a, xH) \\rightarrowtail axH \\] 群\\(G\\)在集合\\(G\\)上的共轭作用 \\[ (a,x)\\rightarrowtail axa^{-1} \\] 中心 \\(Z(G):= \\{a \\in G | ax = xa, \\forall x\\in G\\}\\) 自同构 \\(Aut(G)\\) 内自同构 由\\(\\sigma_a := x \\rightarrowtail a x a ^{-1}\\) 决定的 \\(Inn(G) &lt; Aut(G)\\) Theorem \\(Inn(G)\\) 同构于 \\(G\\) 于中心\\(Z(G)\\)的商群 \\(G/Z(G)\\) 轨道 轨道 设\\(G\\)在集合\\(\\Omega\\)上的作用，对于\\(x\\in \\Omega\\)， \\[ G(x) := \\{g \\circ x | g \\in G\\} \\] 称\\(G(x)\\)是 \\(x\\) 的\\(G\\)-轨道。 两个元素的轨道，要么不交，要么相等。因此可以定义等价关系。 考虑共轭作用 -- 共轭类。有如下的类方程： \\[ |G| = |Z(G)| + \\sum _ { j = 1 } ^ r | G(x_j)| \\] 同时，可以定义稳定子（稳定子群） \\[ G _ x := \\{ g \\in G | g \\circ x = x \\} \\] 轨道-稳定子定理 设\\(G\\)在集合上又一个作用，则对于任意的\\(x\\in \\Omega\\)，有 \\[ |G(x)| = [G: G_x] \\] proof: \\(\\varphi a \\circ x \\rightarrowtail a G_x\\) 是双射。 中心化子 -- 共轭作用下的稳定子群。 从上述定理，可以看出","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"抽象代数","slug":"抽象代数","permalink":"http://adversarr.github.io/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"},{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"夏令营","slug":"夏令营","permalink":"http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"}]},{"title":"面向夏令营的复变函数整理","slug":"study/Math/SummerCamp/ComplexAnalysis","date":"2022-03-27T16:00:00.000Z","updated":"2022-06-23T12:46:21.503Z","comments":true,"path":"2022/03/28/study/Math/SummerCamp/ComplexAnalysis/","link":"","permalink":"http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/ComplexAnalysis/","excerpt":"待完善","text":"待完善 TODO","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"夏令营","slug":"夏令营","permalink":"http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"}]},{"title":"面向夏令营的实变函数整理","slug":"study/Math/SummerCamp/RealAnalysis","date":"2022-03-27T16:00:00.000Z","updated":"2022-04-29T02:39:35.124Z","comments":true,"path":"2022/03/28/study/Math/SummerCamp/RealAnalysis/","link":"","permalink":"http://adversarr.github.io/2022/03/28/study/Math/SummerCamp/RealAnalysis/","excerpt":"待完善","text":"待完善 目录 集合论集合集合运算：上极限和下极限相关内容：映射Rn空间闭集、开集、Borel集开集结构、连续性基本定理勒贝格测度外测度、可测集外测度Lebesgue可测集测度空间可测函数基本性质测度空间上的可测函数Lesbegue可测函数列的收敛性几乎处处收敛/几乎一致收敛依测度收敛可测函数和连续函数的关系Lebesgue 积分Lebesgue 可测函数的积分非负可测函数的积分一般可测函数Riemann积分和Lebesgue积分的关系测度空间上的可测函数积分极限定理Riemann 可积的刻画重积分和累次积分Fubini 定理微分和不定积分单调函数的可微性有界变差函数不定积分的微分绝对连续函数和微积分基本定理分部积分公式和积分中值定理Lp空间定义和基本性质Lp 空间的结构完备空间可分空间L2内积空间内积和正交系广义 Fourier 级数Lp中的范数公式 集合论 集合 集合运算： 代数 -- 交并补差 分析 -- 上下极限 直积 上下极限可以有两种定义方式： \\[ \\lim\\sup _{n\\rightarrow \\infty} A_n =\\lim _{ n \\rightarrow \\infty}\\bigcup_{k = n} ^ \\infty A_n = \\bigcap _ { n = 1} ^ \\infty\\bigcup_{k = n} ^ \\infty A_n \\] 对于下极限同样定义。 上极限和下极限相关内容： 集合的上下确界 \\(\\sup, \\inf\\) Theo 确界存在定理 上下极限也可以通过上下界定义： \\[ \\lim \\sup = \\inf \\sup \\quad \\lim \\inf = \\sup \\inf \\] 类比点列、函数的上下极限定义 映射 映射 集合势 研究可列： 任何无穷集合中包含可列的子集 可列集的无穷子集可列 可列集的交并都可列 Rn空间 定义\\({\\mathbb R}^n\\) 线性空间、范数、柯西不等式、距离、球 考察点集： 点：内点、边界点、聚点 诱导集合：闭包、边界 相互关系：稠密 闭集、开集、Borel集 闭集、开集的定义 极限性质： 1. 开集的并始终是开的，两个开集的交是开的 2. 闭集的交始终是闭的，两个闭集的并是闭的 3. 从而定义\\(F_\\sigma\\)型集（可数闭集并）和\\(G_\\delta\\)型集（可数开集的交） 推广上述性质：\\(\\sigma\\)-代数 开集结构、连续性 Theo \\({\\mathbb R}\\) 上任意非空开集是至多可数个开集的并 Theo \\({\\mathbb R}^n\\) 上的任意非空开集是之多可数个互不相交的半开矩体的并。 通过这两个定理，我们来观察函数的连续性： Theo 设 \\(f:{\\mathbb R}^n \\rightarrow {\\mathbb R}\\) 则TFAE： 1. \\(f\\in C\\) 2. \\(\\forall \\lambda, \\{f &lt; \\lambda\\}, \\{f &gt; \\lambda \\}\\) 是开的 2. \\(\\forall \\lambda, \\{f &lt;= \\lambda\\}, \\{f &gt;= \\lambda \\}\\) 是闭的 基本定理 Cauchy-收敛原理 有限覆盖定理 闭区间套定理 魏尔斯特拉斯定理 关于紧集： 定义：任意开覆盖有有限子覆盖 性质：在 \\({\\mathbb R} ^ n\\) 中就是有界闭集 勒贝格测度 外测度、可测集 外测度 外测度 设 \\(E\\) 是 \\({\\mathbb R} ^ n\\) 中的点集，若\\(\\{I_k\\}\\)是一列开矩体，且为\\(E\\)的一个开覆盖，确定了一个实数：\\(u = \\sum _{k} I_k\\)，令： \\[ m^*(E) = \\inf \\{u\\} \\] 称为其的\\(Lebesgue\\)外测度。 关于外测度的性质： 1. 非负性 2. 单调性 3. 次可加性 4. 平移不变性 单点集、可数点集的外测度都为 0 \\(n-1\\) 维超平面测度为0 康托集外测度为0 题目 求证\\(m^* = \\sup / \\inf\\) 这一类一般一边好证明（直接用单调性）另一边用次可加性+\\(\\varepsilon\\)的任意性来描述求证有子集满足 xxx 条件设函数，利用连续性 Lebesgue可测集 外测度不符合可加性！因此在集合上加Carathedory条件： 可测 设 \\(E \\subseteq {\\mathbb R} ^ n\\) 如果\\(\\forall T \\subset {\\mathbb R} ^ n\\)，有 \\[ m^*(T) = m^*(T \\cap E) + m^*(T\\cap E^c) \\] 则称之为 Lebesgue 可测，全体记为 \\(\\mathcal M\\) 测度即其外侧度 上述条件中实际上只需要\\(\\ge\\)成立即可（另一侧自然成立） 考虑原来的简单集合： Theo 外测度的零测集是可测的，即为零测集。 对开矩体而言，其测度为其“长度” 对于可测集，其具有如下性质： 空集可测，测度为0 可测集的交并补差都是可测集 可数可加性：对于互不相交的可测集\\(E_i\\)，取并和取测度可换 平移不变性 进一步考察和极限的关系： Theo 可测集合的可数交是可测的 考虑极限和测度交换： Theo 对于递增的可测集列\\(E_i\\)，则其极限可测，且有极限和测度可换 Theo 对于递减的可测集列\\(E_i\\)，若存在\\(m(E_i) &lt; +\\infty\\)，则其极限可测，且有极限和测度可换 上式要求存在一个集合测度有限：考察\\(E_i = [i, \\infty)\\)的极限的测度和其测度的极限 下面的定理表述了可测集和 Borel 集的关系 Theo 若\\(E\\)可测，则存在 Borel 集\\(G, F\\)，使得\\(F\\subset E\\subset G\\) 且 \\(m(F) = m(E) = m(G)\\) 换句话说，对于任意可测集，存在 Borel 集来从两侧（在测度意义上）逼近。 题目 TODO 测度空间 TODO 可测函数 对于函数，正如我们一开始用开集闭集来表征连续性一样，考察用可测集来表述可测性。 可测函数 设 \\(E \\subseteq \\mathbb R^n\\) 可测，\\(f\\) 是 \\(E\\) 上的函数，若对于任何\\(t\\in {\\mathbb R}\\)有 \\[ E(f&gt;t) := \\{x\\in E| f(x) &gt; t\\} \\] 都可测，则称函数在\\(E\\)上可测，用\\(M(E)\\)表示。 对于上述定理中的\\(t\\in E\\)，只需要考察稠密的\\(t\\in E&#39;\\subset E\\)即可 对于 \\(&gt;\\)，可以等价替换为 \\(\\ge, \\le , &lt;\\) 对于以上的定义，我们还有一些基础的结论： 可测函数列的收敛点集和发散点集是可测的。 若\\(f,g\\)都可测，则\\(E[f&gt;g], E[f\\ne g]\\)可测（用有理数集插在\\(f,g\\)之间） 我们考察在这个定义下的简单函数，他们通过特征函数来定义： 简单函数 设有互不相交的\\(E_i\\)是\\(E\\)的一个分划，称 \\[ \\varphi (x) = \\sum_{i = 1} ^ m \\alpha _ i \\chi _{E_i} (x) \\] 是简单函数，当\\(E_i\\)是矩体时，\\(\\varphi\\)是阶梯函数 显然，简单函数是可测的。而下面的定理说明了简单函数能够构建出一个可测函数： 基本性质 Theo 对于可测函数集， 1. 是线性空间（对非零除法也是） 2. 连续函数都可测 下面考察其极限性质： Theo 对于可测函数列的 \\(f_k\\)的 上确界，下确界，上极限，下极限 都是可测函数 Theo 对于可测函数列，若\\(f_k \\rightarrow f\\)，则 \\(f\\) 可测。 下面考虑取绝对值前后的可测性： Theo 对于实值函数，可测的充要条件是正部和负部都是可测的，且若\\(f\\)可测，则\\(|f|\\)可测 考虑复合函数的可测性： Theo 对于 \\(f\\in C\\) 和 \\(g\\in M\\) 有 \\(h=f\\circ g\\)可测 下面引入几乎处处的概念： 几乎处处 称E在\\(A\\)几乎处处满足P(E)，是指存在一个固定的零测的\\(Z\\)使得对\\(A - Z\\)满足P(E) 从而，我们有： Theo 对于实函数，若\\(f = g\\quad a.e.\\)则\\(f\\)与\\(g\\)有相同的可测性。 从上面的描述中不难看出，相比于连续性，可测性在极限运算下具有良好的性质（保持、交换），这也是我们需要可测的原因。 测度空间上的可测函数 TODO Lesbegue可测函数列的收敛性 这一节，我们详细讨论收敛的概念。 几乎处处收敛/几乎一致收敛 几乎处处收敛 （直接从几乎处处收敛的定义得到） 相对于几乎处处收敛，我们有稍弱一些的几乎一致收敛，其描述的是定义域极限意义下的收敛性。（即我们不需要得到零测集，而得到测度充分小的集合） 几乎一致收敛 \\(\\forall \\delta &gt; 0, \\exists E_\\delta \\subset E\\) 使得（测度充分小）\\(m(E_\\delta) &lt; \\delta\\)，且在 \\(E - E_\\delta\\)上满足一直收敛到\\(f\\)。 下面的定理说明了这两个收敛行的关系： 叶戈罗夫定理 对于有限测度集上的几乎处处有限的可测函数列，若函数列几乎处处收敛，则函数列几乎一致收敛 有限和有界是不同的：\\(y = 1/x\\) 在\\((0, 1)\\)无界，但其是有限的。有界是对于区间而言，而有限是对于点（\\(&lt; +\\infty\\)而言） 依测度收敛 条件更弱，去掉的集合甚至不一定“稳定”，即该集合只需要测度的极限为0，而不需要考虑其极限是否存在。 依测度收敛 对于几乎处处有限的可测函数，对于给定的\\(\\epsilon&gt;0\\)，其能够满足 \\[ m(E(|f_k - f| &gt; \\epsilon)) \\rightarrow 0 \\] 则其是在\\(E\\)上依测度收敛到\\(f\\)（\\(f_k\\rightarrow_m f\\)） 显然，几乎处处收敛和几乎一致收敛蕴含了依测度收敛。但依测度收敛给出了收敛到什么函数的本质问题。 Theo 若函数列 \\(f_k\\) 依测度收敛于\\(f, g\\) ，则 \\(f= g \\quad a.e.\\) Theo — 勒贝格定理 对于有限测度集上的几乎处处有限的可测函数，则其依测度收敛到该极限函数 如果我们将几乎处处相等作为等价关系，实变函数考察的始终是这个等价关系下对于可测函数集的划分。 考虑从依测度收敛到几乎处处收敛的条件： Theo — Riesz 引理 若 \\(f_k \\rightarrow _m f\\)，则存在子列几乎处处收敛到\\(f\\) 依测度收敛意义下，我们可以类比柯西收敛准则： 依测度基本列 设有\\(f_k\\)为\\(E\\)上几乎处处有限的可测函数列，若 \\[ \\forall \\varepsilon &gt; 0, \\quad \\lim_{k , j \\rightarrow \\infty} m(E(|f_i - f_j| &gt; \\varepsilon)) = 0 \\] 则称其为\\(E\\)上的依测度基本列 类似柯西收敛准则： Theo 对于几乎处处有限的可测函数列，依测度收敛当且仅当它是依测度基本列 可测函数和连续函数的关系 连续函数在数学分析中具有重要的作用（特别是一致连续的函数）。因此我们考察连续和可测之间是否有一定的联系。 下面的定理描述了函数可测和连续之间的差别。 Theo — 鲁金定理 设\\(f\\)是有限测度集上几乎处处有限的可测函数，对于任一（充分小的）\\(\\delta &gt; 0\\)，存在\\(E\\)中的闭集\\(F\\)，满足\\(m(E \\backslash F) &lt; \\delta\\) 使\\(f\\)在\\(F\\)上连续。 下面的定理描述了如何从连续函数构造一个可测函数： Theo 对于任意可测函数\\(f\\)，存在连续函数列\\(g_k\\)，使得\\(g_k \\rightarrow f\\quad a.e.\\) 上面的定理可以推广为： Theo 对于几乎处处有限的函数\\(f\\)，\\(f\\)可测，当且仅当\\(\\exists g_k\\in C\\)使得\\(g_k \\rightarrow f\\quad a.e.\\) Lebesgue 积分 至此，我们得到了可测函数优秀的极限性质，我们开始考虑一类特殊的极限 -- 积分，这也是实变函数论目的：给积分 - 极限之间的互换关系一个完备的解释。 Lebesgue 可测函数的积分 非负可测函数的积分 非负简单函数的积分 设 \\(h(x)\\) 是可测集 \\(E\\) 上的非负可测函数，定义 \\[ h(x) = \\sum_{j = 1} ^ m a_j m(E_j) \\Longrightarrow \\int _ E h(x) \\mathrm dx = \\sum _{j = 1} ^ m a_j m ( E _ j ) \\] 为 \\(h(x)\\) 在可测集\\(E\\)傻姑娘的积分。 关于上面定义的积分，其满足： 线性性质 对定义域的连续性： \\[ \\lim E_k = E \\Rightarrow \\lim \\int _{E_k} h(x)\\mathrm dx = \\int _ E h(x) \\mathrm dx \\] 其中的 \\(\\mathrm d\\)仅仅是一个记号，并不代表自变量的微元。 从而我们可以定义： 非负可测函数的积分 对于 \\(f\\in \\mathcal M ( E)\\) 定义 \\[ \\int _ E f(x) \\mathrm dx = \\sup \\left\\{ \\int _ E h(x) \\mathrm dx | h(x) \\le f(x), h(x) 是简单函数 \\right\\} \\] 若上式有限，则称\\(f\\)在\\(E\\)上可积。 综合上面的定义可以看出： 对于一个零测集，任何函数的积分都为 0 （因为在实变函数中我们是中认为\\(0 \\cdot \\infty = 0\\)） 对于一个非负可测函数，我们通过和特征函数内积来确定在子集上的积分： \\[ \\int _A f = \\int _E f \\cdot \\chi _ A \\] 积分具有保序性 同时，由于上述的定义中 可积 这个条件实际上非常宽泛，所以我们很容易得到这样的结论： Theo 有限测度集上的几乎处处有界函数必可积。 这是区别于 Riemann 积分很大的一个地方，因为在 Riemann 积分中，我们甚至连 dirichlet 函数的积分都无法定义！ 下面介绍一个著名的定理，它揭示了可测函数积分在极限过程中体现出的性质： Levi Theo 设\\(\\{ f _ k \\}\\)是可测集\\(E\\)上的非负可测函数，满足 \\(f_1 \\le f_2 \\le \\cdots\\) 且有 \\[ \\lim _ {k \\rightarrow \\infty} f_k ( x) = f(x), \\quad \\forall x \\in E \\] 则有 \\[ \\lim _ {k \\rightarrow \\infty} \\int _ E f_k (x)\\mathrm dx = \\int _ E f(x) \\mathrm dx \\] 这个定理说明，对于单调、收敛的可测函数，其积分的极限就是极限的积分。 一般可测函数 通过非负可测函数的积分、将可测函数分为正负两部分，我们可以定义： 可测函数积分 设 \\(f\\) 是可测函数，\\(f^+\\)和\\(f^-\\)至少有一个是可积的，则称 \\[ \\int_E f(x) \\mathrm dx = \\int _ E f ^+ (x)\\mathrm dx - \\int _ E f ^ - (x) \\mathrm dx \\] 是\\(f\\)在\\(E\\)上的积分，如果右端两个积分都有限，则称该函数可积\\(f\\in \\mathcal L(E)\\)。 显然，其具有这样的简单性质： \\[ f\\in \\mathcal L ( E ) \\rightarrow | \\int_E f(x)\\mathrm dx| \\le \\int _ E | f(x) | \\mathrm dx \\] Theo Lebesgue可测函数积分性质 对于积分： 1. \\(|f| &lt; \\infty,\\quad a.e.\\) 2. 如果其中一个可积，\\(f = g\\quad a.e.\\implies \\int f = \\int g\\) 3. （控制性）若存在 \\(|f| &lt; |g|\\in \\mathcal L\\)，则 \\(f\\in \\mathcal L\\)，且\\(|\\int f| \\le \\int |g|\\) 4. 对于有限测度集，有界函数都可积 Theo Lebesgue积分具有线性性 下面给出 Lebesgue 积分的等价描述 Theo 可积/积分的等价描述 设 \\(f\\) 是有限测度集上的有界可测函数，\\(|f| \\le M\\)，作\\([-M, M]\\)的划分， \\[ -M = \\alpha_0 &lt; \\cdots &lt; \\alpha_k = M \\] 设\\(E_j= E(\\alpha_{j-1} &lt; f &lt; \\alpha_j)\\)，对于任意的 \\[ \\eta_j \\in [\\alpha_{j - 1}, \\alpha _ j] \\] 极限 \\[ \\lim_{\\max \\alpha_j - \\alpha_{j-1} \\rightarrow 0} \\sum_{j = 1} ^ k \\eta_j m(E_j) \\] 存在，则该极限就是Lebesgue积分。 对于Lebesgue积分，其具有绝对连续性（定义域测度充分小，则积分值充分小）： Theo 绝对连续性 设\\(f\\in \\mathcal L\\)，则对于任意的\\(\\varepsilon &gt; 0\\)，存在\\(\\delta &gt; 0\\)，使得对于任何的子集\\(A\\)，当\\(m(A) &lt; \\delta\\)时， \\[ |\\int_A f(x) \\mathrm dx | \\le \\int_A |f(x)|\\mathrm dx \\le \\varepsilon \\] 当然，对于Lebesgue积分，也有平移不变性。 我们之前考察了可测和连续的关系，在这里我们也有类似的结论： Theo 对于任意Lebesgue可积函数，对于任意 \\(\\varepsilon &gt; 0\\)，存在一个具有紧支集的连续函数\\(g\\)使得 \\[ \\int_ E| f(x) - g(x) | \\mathrm dx &lt; \\varepsilon \\] 。因此，可以构造具有紧支集的连续函数列\\(g_k\\)，使得 \\[ \\lim_{k\\rightarrow \\infty}\\int_ E| f(x) - g_k(x) | \\mathrm dx &lt; \\varepsilon, \\quad 即 g_k \\rightarrow f\\quad a.e. \\] Riemann积分和Lebesgue积分的关系 Theo Riemann积分和Lebesgue积分值的相等性 闭区间上有界函数\\(f(x)\\) Riemann 可积，则它时 Lebesgue 可积的且其积分值相等。 测度空间上的可测函数积分 极限定理 这一节我们考虑极限和Lebesgue积分的互换关系。 Lebesgue 基本定理 设\\(f_n\\)是可测集\\(E\\)上的非负可测函数列， \\[ f(x) = \\sum_{n = 1} ^ \\infty f_n(x) \\] 则 \\[ \\int _ E f(x) \\mathrm dx = \\sum _ {n = 1} ^ \\infty \\int _ E f_n (x) \\mathrm dx \\] 正函数项级数，和函数积分为积分的和。（积分与求和交换） 从上述定理，我们可以应用到定义域上： Col 设 \\(E = \\bigsqcup E_n\\)，若\\(f(x)\\)在\\(E\\)上有积分时，\\(f(x)\\)在每一个子集\\(E_n\\)时有积分的，且 \\[ \\int _ E f(x) \\mathrm dx = \\sum _ {n = 1} ^ \\infty \\int _{E_n} f(x) \\mathrm dx \\] 我们始终不希望只考虑单调的函数列 Fatou 引理 对于非负可测函数列\\(f_n\\)，有 \\[ \\int _ E \\lim \\inf f_n(x) \\mathrm dx \\le \\lim \\inf \\int _ E f_n(x)\\mathrm dx \\] 得到这样一个定理是不够的，我们希望得到更好的结论，而不局限于下确界和不等号： 控制收敛定理 给定可测集\\(E\\)，设\\(f_n\\subset \\mathcal M\\)，且有 \\[ f_n (x) \\rightarrow f(x)\\quad a.e.[E] \\] 如果存在函数 \\(F(x) \\in \\mathcal L(E)\\)，控制了\\(|f_n| \\le F\\quad, a.e.[E]\\)，那么，\\(f\\in \\mathcal L(E)\\)且 \\[ \\lim _ {n \\rightarrow \\infty} \\int_{E} f_n (x) \\mathrm dx = \\int_ E f(x) \\mathrm dx \\] 从而，我们有如下几个定理： Theo 设\\(E\\)是可测集，\\(f_n\\)是 \\(E\\)上的可测函数列，该函数列依测度收敛到 \\(f\\) ，若存在\\(F\\in \\mathcal L(E)\\)使得\\(|f_n| \\le F, a.e.[E]\\) 则\\(f_n, f\\)都在\\(E\\)上 Lebesgue可积，且积分和极限可换。 当然，对于有界函数，其在有限测度集上积分有很好的性质： Theo 有界收敛原理 设\\(m(E)&lt; \\infty\\)，\\(\\{f_n\\} \\subset L(E)\\)且一致有界，则当其依测度收敛时，其积分和极限可换。 对于函数项级数，有类似的定理： Theo 对于可积函数列，若 \\[ \\sum _ {n = 1} ^ \\infty \\int _ E | f_n ( x ) | \\mathrm dx &lt; \\infty \\] 则级数\\(\\sum f_n (x)\\) 在 \\(E\\)上几乎处处收敛，且和函数的积分是各函数积分的和。 Riemann 可积的刻画 首先，我们使用振幅函数来入手描述 Riemann 可积性 Theo 对于区间上的有界函数\\(f\\)，有 \\[ \\int _ I \\omega _f (x) \\mathrm dx = \\bar \\int _ a ^ b f - \\underline{\\int}_{a}^b f \\] 与此同时，我们揭示了Riemann可积的充要条件： Riemann可积 对闭区间上的有界函数 \\(f\\) ：Riemann可积，当且仅当不连续点集是零测的 重积分和累次积分 重积分的交换就是极限过程的交换。 Fubini 定理 截口 设\\(E\\subset {\\mathbb R}^{p+q}\\)，对于任意的\\(x\\in {\\mathbb R}^p\\)，令 \\[ E_x = \\{ y \\in {\\mathbb R}^ q| (x, y) \\in E\\} \\] 对于任意的\\(y\\)，对应定义\\(E_y\\)。其中，\\(E_x\\)称为\\(E\\)的\\(x\\)截口 显然： \\[ m(E) = \\int _ {\\mathbb R ^ p} m(E_x)\\mathrm dx = \\int _ {\\mathbb R ^ q} m(E_y)\\mathrm dy \\] Theo 设\\(n = p + q\\)，\\(E \\in \\mathcal M _ n\\)则 1. 对几乎处处的\\(x\\in \\mathbb R ^ p\\)，有\\(E_x \\in \\mathbb R^q\\) 2. \\(m(E_x)\\)在\\(\\mathbb R^q\\)上几乎处处有定义，且是非负可测函数 借助截口，我们一步步引入Fubini定理，来解决重积分和累次积分关系的问题： Theo 假设\\(E_1\\)和\\(E_2\\)是\\(\\mathbb R^p\\)和\\(\\mathbb R^q\\)中的可测集则\\(E_1\\times E_2 \\in M_n\\) 且有 \\[ m(E_1\\times E_2) = m(E_1)m(E_2) \\] 借助该定理，以及测度、积分在极限下的交换关系，我们有： Toneli 设\\(n = p + q\\)，\\(f(x,y)\\in \\mathcal M (\\mathbb R ^ {p + q})\\)且非负，则 1. 对于几乎处处的\\(x\\in \\mathbb R ^ p\\)，\\(f(x, \\cdot )\\)是非负可测函数； 2. 积分\\(F_f(x) = \\int _ {\\mathbb R^q}f(x, y) \\mathrm dy\\) 几乎处处有定义，是非负可测函数； 3. 重积分和累次积分相等。 对于上述定理，我们可以将条件加强为可积，得到： Fubini 定理 设\\(n = p + q\\)，\\(f(x,y)\\in \\mathcal L (\\mathbb R ^ {p + q})\\)，则 1. 对于几乎处处的\\(x\\in \\mathbb R ^ p\\)，\\(f(x, \\cdot )\\)可积； 2. 积分\\(F_f(x) = \\int _ {\\mathbb R^q}f(x, y) \\mathrm dy\\) 几乎处处有定义，且可积； 3. 重积分和累次积分相等。 至此，我们已经几乎研究完了定积分的极限性质，下面将研究微积分基本定理的成立条件 微分和不定积分 单调函数的可微性 我们先研究单调函数，它是一个性质好（有界变差）的函数！ Vitali 覆盖 设\\(E \\subset \\mathbb R\\)，设\\(\\tau = \\{ I _ \\alpha \\}\\)是一个区间族，若对于任意的\\(x\\in E\\)和\\(\\varepsilon &gt; 0\\)，存在一个\\(I_\\alpha \\in \\tau\\)，使得\\(x\\in I _ \\alpha\\) 且 \\(|I_\\alpha| &lt; \\varepsilon\\)，则称\\(E\\)是在Vitali意义下的覆盖。 研究Vitali覆盖，一方面是因为其对于任意点都可以找到充分小的区间覆盖，另一方面是其可以任意有限外测度集合，都能找到误差充分笑的有限覆盖： Vitali 覆盖定理 设\\(E \\subset \\mathbb{R}\\)，且\\(m^*(E)&lt;\\infty\\)，则对于任意的\\(\\varepsilon &gt; 0\\)存在有限个互不相交的\\(I_j\\in \\tau\\)使得 \\[ m^*(E -\\cup_{j=1}^n I_j) &lt; \\varepsilon \\] srds，这个东西用的也不多。我们下面先考虑微分的问题： Dini 导数 记如下的 \\[ D^+f(x_0):= \\limsup_{h\\rightarrow 0 ^ +} \\frac{f(x_0 + h) - f(x_0)}{h} \\] 同理定义\\(D^-,D_+,D_-\\)为 Dini 导数。 显然，函数可导（左右同理），当且仅当Dini导数全部存在且相等。 Lebesgue定理 设\\(f(x)\\)是\\([a,b]\\)上的递增函数，那么\\(f\\)的不可微点集为零测集，且有 \\[ \\int_ a ^ b f&#39;(x) \\mathrm dx \\le f(b) - f(a) \\] 例如， \\[ f(x) = I(x&gt;0) \\] 满足上述不等号（因为\\(0\\cdot \\infty = 0\\)） Fubini 逐项积分定理 设\\(f_n\\)是\\([a,b]\\)上的递增函数列，且\\(\\sum_{n = 1} ^ \\infty f_n\\)在\\([a,b]\\)上收敛，那么有： \\[ \\frac{d}{dx} \\left( \\sum_{n = 1}^\\infty f_n(x) \\right)= \\sum_{n = 1}^\\infty \\frac{d}{dx}f_n(x) \\quad a.e. \\] 至此，我们已经解决了一些问题，至少对于单调函数而言是这样的。 有界变差函数 这里我们引入有界变差函数，用于描述这个函数的在充分小的区间里变化的能力。 有界变差函数 设\\(f\\)是\\([a,b]\\)上的实函数，做定义域的分划，则： \\[ V_\\Delta = \\sum_{i = 1}^n | f(x_i) - f(x_{i-1}|) \\] 是\\(f\\)在\\([a,b]\\)上的一个变差。对上式取上极限： \\[ \\bigvee_{a}^b (f) := \\sup\\{V_\\Delta\\} \\] 是函数在该区间上的全变差，若上式有限，那么\\(f\\)是\\([a,b]\\)上的有界变差函数。 显然： 单调函数是有界变差函数 可微函数是有界变差函数 有界变差函数空间是线性空间。 有界变差函数对于函数做出了一定的限制，即全区间上的绝对变化是有界的。显然： Theo 设 \\(f(x)\\) 是一个实函数，\\(a&lt;c&lt;b\\)，有： \\[ \\bigvee_{a}^b (f) = \\bigvee_{a}^c (f) +\\bigvee_{c}^b (f) \\] 直觉告诉我们，一个有界变差函数可能可以拆成两个函数的差：值增加的时候，为正的函数增加，值减少的时候，权为负的函数增加。那么我们有如下的定理成立： Jordan 分解定理 \\(f \\in BV([a,b])\\) 当且仅当 \\(f = g - h\\)，其中 \\(g, h\\)是\\([a,b]\\)上的递增函数 不定积分的微分 这里我们开始研究不定积分。而所谓不定积分，我们可以认为是一个变上限积分+C： Lemma 设\\(f\\in \\mathcal L [a,b]\\)，令 \\[ F_h(x) = \\frac{1}{h} \\int _ x ^ {x + h} f(t) \\mathrm dt \\] 显然： \\[ \\lim_ {h\\rightarrow 0} \\int _ a ^ b |F_h( x) - f(x)| \\mathrm dx = 0 \\] 因此，我们有如下的性质 Theo 设 \\(f\\in \\mathcal L\\)，令 \\(F(x) = \\int _a^x f(t) \\mathrm dt\\)，则有 \\[ F&#39;(x) = f(x) \\quad a.e. x\\in [a,b] \\] 绝对连续函数和微积分基本定理 至此，我们已经非常接近我们要的答案了（即微积分基本定理成立的充要条件）。为此，我们需要观察出变上限积分一些额外的性质 Lemma 设\\(f\\)在\\([a,b]\\)几乎处处可微，且\\(f&#39;(x) = 0\\quad a.e.\\)，如果\\(f(x)\\)不是常函数，那么存在\\(\\varepsilon&gt;0\\)对于任意\\(\\delta &gt; 0\\)存在\\([a,b]\\)上有限个互不相交的区间，使得其测度之和小于\\(\\delta\\)，但： \\[ \\sum_{i = 1} ^ n| f(y_i) - f(x_i)| &gt; \\varepsilon \\] 很显然我们之前构造的阶跃函数满足这样的条件。从而我们希望将这一类函数暂时得从我们的考虑范围内去除。 绝对连续函数 设\\(f(x)\\)是实函数，若\\(\\forall \\varepsilon &gt; 0\\)，存在\\(\\delta &gt; 0\\)对于任意两个互不相交的开区间\\((x_i, y _ i )\\)满足其\\(\\sum |y_i - x_i| &lt; \\delta\\)且有 \\[ \\sum_{i = 1} ^ n |f(y _ i ) - f(x_i)| &lt; \\varepsilon \\] 则称其为绝对连续函数 这类函数有些简单的结论： 1. 绝对连续函数是连续函数 2. 绝对连续函数构成线性空间 Theo 设\\(f\\in L\\)，那么其变上限积分是绝对连续函数。 至此，我们找到了微积分基本定理成立的一个充分条件，借助上一节推出的结论，对一个函数先进行变上限积分，拿到的这个变上限积分函数是能够满足微积分基本定理的。这让我们不经怀疑，是否这个条件可以更进一步呢，我们直接引入微积分基本定理： 微积分基本定理 若 \\(f(x)\\) 是\\([a,b]\\)上的绝对连续函数，那么 \\[ f(x) - f(a) = \\int _ a ^ x f&#39;(t) \\mathrm dt \\] 即绝对连续函数导数的积分就是自身。 综合以上的讨论，我们得出结论： 微积分基本定理成立 \\(\\iff\\) 绝对连续 分部积分公式和积分中值定理 老朋友了： 分部积分公式 对于可积函数（作为被积函数）成立。 积分第一中值定理 若 \\(f(x)\\) 是连续函数，且\\(g\\)是非负可积函数，则存在一个\\(\\xi \\in [a,b]\\)使得 \\[ \\int f\\cdot g = f(\\xi)\\int_a^b g(x) \\mathrm dx \\] 第二中值定理 若\\(f\\int \\mathcal L\\)，\\(g\\)单调，啧\\(\\exists \\xi \\in [a,b]\\) 使得 \\[ \\int _ a ^ b f \\cdot g \\mathrm dx = g(a) \\int _ a ^ \\xi f + g(b) \\int _ \\xi ^ b f \\] 当然还有更多的积分换元公式，不在这里继续讨论，因为我们有更加重要的内容需要引入： Lp空间 定义和基本性质 引入\\(L^p\\)空间的很大的原因是积分变换（例如傅立叶等）。 Lp空间 设 \\(f(x)\\) 是 \\(E\\subseteq \\mathbb R ^ n\\)上的可测函数，记 \\[ \\|f\\|_p = \\left(\\int _E |f(x)|^p\\mathrm dx\\right)^{1/p}\\quad 0 &lt; p &lt;= \\infty \\] 用\\(L^p\\)来表示使得上式有限的函数全体，构成\\(L^p\\)空间。 显然Lp空间是线性空间。 $L^\\infty$显然我们有两种方式定义这个空间：直接定义：\\(L^\\infty\\)表示本性有界（\\(\\exists M, |f(x) | \\le M, \\quada.e.\\)）极限定义：\\(L^\\infty = \\lim_{p\\rightarrow\\infty} L^p\\)这两个定义是等价的 另一方面，我们要研究两个线性空间之间的关系，两个范数之间的关系： Holder 不等式 设 \\(p\\) 和 \\(q\\) 是共轭指标（\\(p^-1 + q ^ -1 = 2, p, q &gt; 1\\)，另有\\(f\\in L^p, g\\in L^q\\)，那么： \\[ \\|f\\cdot g\\|_1 = \\| f \\| _p \\cdot \\| g \\| _ q\\quad 1\\le p \\le \\infty \\] 上述定理的另一方面也成立，即反Holder不等式 Minkowski不等式 设\\(f,g \\in L ^ p\\)，那么： \\[ \\|f + g\\| _ p \\le \\| f \\| _ p + \\| g \\| _ p \\] \\(p=2\\)即三角不等式。 借助以上不等关系，我们来研究\\(L^p\\)空间的结构！ Lp 空间的结构 完备空间 定义\\(d(f, g) = \\| f - g\\| _ p\\)，那么\\(\\left(L^p(E), d\\right)\\)是一个距离空间。 依Lp收敛 设\\(\\{f_k\\}\\in L^p\\)若存在\\(f\\in L^p\\)使得 \\[ \\lim _ {k\\rightarrow\\infty} d(f_k, f) = \\lim_{k\\rightarrow \\infty} \\| f_ k - f \\|_ p = 0 \\] 则称\\(f_k\\)依\\(L^p(E)\\)意义收敛于\\(f\\)。 关于上述极限： 极限函数在几乎处处相等的意义下唯一 保范数性：极限函数的范数等于范数列的极限 完备距离空间 若\\(\\forall f_k\\)是依\\(L^p\\)收敛列，且\\(f_k \\rightarrow f\\)，那么\\(f\\in L^p\\)，则称\\(L^p\\)是完备距离空间。 Theo \\(L^p, p &gt; 1\\)都是完备的 可分空间 可分 设\\(\\tau\\)是\\(L^p\\)的子集，若\\(\\forall f\\in L^p\\)存在\\(\\{g_k\\}\\in \\tau\\)，使得\\(g_k\\rightarrow f\\quad L^p\\)，那么称\\(\\tau\\)在\\(L^p\\)中稠密。如果\\(\\tau\\)可数，那么\\(L^p\\)可分。 对于\\(p\\ge 1\\)的情况，我们也有： Theo \\(1\\le p &lt; +\\infty\\)时，\\(L^p\\)可分 我们考虑用一个Lp空间来描述另一个Lp空间： Theo 设\\(1\\le p &lt; \\infty, 1\\le r \\le \\infty\\) 那么 \\(L^p \\cap L^r\\)在\\(L^p\\)中稠密 L2内积空间 我们希望不仅仅得到距离，我们还希望得到内积，这要求对于两个函数位置都线性，那么两个函数的次数都必须为 1，从而 \\(p=2\\) 内积和正交系 L2内积 令 \\[ \\langle f, g \\rangle =\\int_E f(x) g(x) \\mathrm dx \\] 为 \\(L^2\\)空间上的内积（对称正定双线性函数）。 不难证明，该内积对于极限过程可交换。 有了内积的概念，我们试图在\\(L^2\\)这个线性空间中找标准正交基，来分解所有的函数。 Theo \\(L^2\\)中的所有正交系都是可数的。 广义 Fourier 级数 从线性代数的知识我们可以知道，广义上说，给定： 内积 标准正交基 向量 我们可以将向量分解到标准正交基上： \\[ c_i = \\langle e_i, f\\rangle\\quad f \\sim \\sum_{i = 1} ^ \\infty c_i e_i \\] 显然，我们还希望有更好的性质，例如我们不希望用 \\(\\sim\\) 符号（因为这里并不能直接相等） Theo 对于标准正交基\\(\\{\\varphi_i\\}\\)，\\(f\\in L^2\\)，取定\\(k\\)，作 \\[ f_k (x) = \\sum_{i = 1}^ k a_i \\varphi _ i \\] 则当\\(a_i = c_i\\)时，\\(\\|f-f_k\\|_2\\)取最小值 利用标准正交基来证明 一般情况下，帕斯瓦尔定理不成立，但我们仍有如下的不等式： Bessel 不等式 设\\(\\varphi_k\\)是\\(L^2\\)中的正交基，\\(c_i\\)是函数\\(f\\)的Fourier系数，那么： \\[ \\sum _ {k = 1} ^ \\infty c_k ^ 2 \\le \\|f_k\\|^2 \\] 如果我们对于一个函数进行Fourier分解，我们考虑是否能够复原这一个函数，下面的定理说明函数的 Fourier 系数一定能够对应 L2 空间中的一个函数。 Riesz-Fisher 设\\(\\varphi_k\\)是标准正交基，若\\(c_k\\)是 Fourier 系数且 \\(\\sum_{k =1} ^ \\infty c_k^2&lt; +\\infty\\)，存在 \\[ g\\in L^2\\quad \\langle g, \\varphi_k\\rangle = c_k, k = 1, 2, .... \\] 上面还只是考察了正交系（L2的子集），但我们并不知道这个正交基张成的空间的正交补空间的情况（即是否有一个函数不能用这个正交系表出）因此我们定义： 完全正交系 我们称一个正交系是完全的，当\\(L^2\\)中不存在任何的非零元和任一\\(\\varphi_k\\)正交。 Theo 三角函数系是完全正交系 正如之前提到的，完全正交系的补空间是零。不难理解： Theo 设\\(\\varphi_k\\)是标准完全正交系，那么 \\[ \\forall f\\in L ^ 2\\quad \\lim_{k \\rightarrow \\infty} \\| f - \\sum_{i = 1}^ k c_i \\varphi_i \\| _ 2 = 0 \\] Lp中的范数公式 我们在这里考虑一些Lp中的范数不等式，来帮助我们在一些问题中进行放缩。 Theo 若\\(f\\in L ^ p\\)，且\\(1\\le p &lt; \\infty\\)，那么存在\\(g\\in L ^{p&#39;}\\)，且\\(\\| g\\| _ {p&#39;} = 1\\) 使得， \\[ \\|f\\|_p = \\int _ E f(x) g(x) \\mathrm dx \\] 当然上式也可以推广到\\(L^\\infty\\)： \\[ \\| f \\| _ \\infty = \\sup _{\\| g \\| = 1}\\{ | \\int _ E f(x) g( x) \\mathrm dx\\} \\] 最后我们研究 Minkowski 不等式的推广 广义 Minkowski 设\\(f(x, y)\\)可测，若对于几乎处处的\\(y\\in \\mathbb R ^ n\\)有 \\[ f(x, y ) \\in L ^p\\quad \\int _{\\mathbb R^n}\\left[\\int _{\\mathbb R ^ n}|f(x, y) |^p \\mathrm dx \\right] ^{1/p} \\mathrm dy = M &lt; \\infty \\] 那么 \\[ \\int _{\\mathbb R^n}\\left[\\int _{\\mathbb R ^ n}|f(x, y) |^p \\mathrm dy \\right] ^{1/p} \\mathrm dx\\le \\int _{\\mathbb R^n}\\left[\\int _{\\mathbb R ^ n}|f(x, y) |^p \\mathrm dx \\right] ^{1/p} \\mathrm dy \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"夏令营","slug":"夏令营","permalink":"http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"},{"name":"实变函数","slug":"实变函数","permalink":"http://adversarr.github.io/tags/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"数值分析-非线性方程求解","slug":"study/Math/NumericRecipies/Chapter 2 非线性方程组的求解","date":"2022-03-03T04:30:41.764Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2022/03/03/study/Math/NumericRecipies/Chapter 2 非线性方程组的求解/","link":"","permalink":"http://adversarr.github.io/2022/03/03/study/Math/NumericRecipies/Chapter%202%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%B1%82%E8%A7%A3/","excerpt":"数值分析 ch 2 - 非线性方程求解","text":"数值分析 ch 2 - 非线性方程求解 Chapter 2 非线性方程的求解 一个自变量的非线性方程： \\(f(x)=0,\\quad x\\in R&#39;\\) [NO] 多个自变量的非线性方程组： \\(\\vec F (\\vec x) =\\vec 0,\\quad \\vec x\\in R^n,\\vec F(\\vec x)\\in R^m\\) Content： 二分法 简单迭代法 Newton迭代法 Idea： \\[ 线性：f(x)=0\\iff x=\\varphi(x)\\rightarrow x_{n+1}=\\varphi(x_n)\\\\ 非线性：x=\\psi (x)\\Rightarrow x_{n+1}:=\\psi(x_n),x_n\\rightarrow x^* \\] 重数：\\(f(x) = (x-x^*)^mg(x),g(x^*)\\ne0\\) 则m称为重数 一般分为如下2步： 搜索根，分析方程存在多少个实根，每个根存在的区间 图解法、近似方程法、解析法、定步长搜索法 精确化：求满足给定精度的根的近似值 从2项迭代导致的2阶方法。 二分法 简单迭代法 局部收敛（\\(x_0\\)与精确解靠近） 全局收敛（\\(x_0\\)未必与精确解靠近） 迭代格式的构造 通过方程 \\(f(x)=0\\) 得到的等价形式： \\(x=\\varphi(x)\\)，得到递推公式。 若根据 \\(x=\\varphi(x)\\) 得到的序列收敛， \\(\\lim_{k\\rightarrow\\infty}x_k=x^*\\)。（当 \\(x^*=\\varphi(x^*)\\)时，称为不动点，上述方法称为不动点迭代法） 序列是否收敛，由 \\(\\varphi\\)和 \\(x_0\\)确定。 迭代的收敛性 Thm若 \\(\\varphi(x)\\)在 \\((a,b)\\)内有一阶连续导数，且满足， \\(x\\in [a,b]\\)时， \\(\\varphi(x)\\in [a,b]\\) 存在正常数 \\(L&lt;1\\)使得当 \\(x\\in[a,b]\\)， \\(|\\varphi&#39;(x)|\\le L &lt;1\\) 则： \\(x=\\varphi(x)\\)在 \\([a,b]\\)上有实根 \\(x^*\\) 对于任意初值 \\(x_0\\in [a,b]\\)，迭代收敛→全局收敛 同时满足： \\(|x^*-x_k|\\le \\frac {L^k}{1-L} |x_1-x_0|\\) Thm 方程在区间 \\([a,b]\\)上有根，且当 \\(x\\in [a,b]\\)时， \\(|\\varphi&#39;(x)|\\ge 1\\)则对于任意 \\(x_0\\)迭代发散。 Def（局部收敛）方程 \\(x=\\varphi(x)\\)，若在 \\(x^*\\) 的某个邻域内，对于任意初值 \\(x_0\\in S\\)，迭代都收敛，则称迭代法在 \\(x^*\\)附近局部收敛。 Thm：若方程 \\(x=\\varphi(x)\\)有根 \\(x^*\\)，在某个邻域内一阶连续可导： \\(|\\varphi&#39;(x^*)|&lt;1\\)→ 局部收敛 \\(|\\varphi&#39;(x)|&gt;1\\)→发散 Newton 迭代法 迭代格式 基于 \\(f(x)=0\\) 的近似形式 \\[ x_{k+1}=x_k-\\frac{f(x_k)}{f&#39;(x_k)}=\\psi(x_k) \\] 如果需要计算二重根，Newton迭代法常常不能满足 Newton 迭代法的收敛性 Thm 设函数 \\(f\\)在区间 \\([a,b]\\)内二阶连续可导，且： \\(f(a)f(b)&lt;0\\) 当\\(x\\in[a,b]\\)时， \\(f&#39;(x)\\ne0\\) 当\\(x\\in (a,b)\\)时， \\(f&#39;&#39;(x)\\)保号 \\(a-\\frac{f(a)}{f&#39;(a)}\\le b,b-\\frac{f(b)}{f&#39;(b)}\\ge a\\) 则其Newton迭代格式收敛到 \\([a,b]\\)内的唯一实根。 重根的处理 若其是\\(m\\)重根，则修正为： \\[ x_{k+1}=x_k-m\\frac{f(x_k)}{f&#39;(x_k)} \\] Newton迭代的变形 Newton下山法： \\(x_{k+1}=x_k-\\lambda\\frac{f(x_k)}{f&#39;(x_k)}\\) 割线法： \\(x_{k+1} = x_k-\\frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1})\\) ......ch2: 5 6 11 12","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数值分析","slug":"数值分析","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"}]},{"title":"数值分析-数值积分和数值微分","slug":"study/Math/NumericRecipies/Chapter 5 数值积分和数值微分","date":"2022-03-03T04:30:41.764Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2022/03/03/study/Math/NumericRecipies/Chapter 5 数值积分和数值微分/","link":"","permalink":"http://adversarr.github.io/2022/03/03/study/Math/NumericRecipies/Chapter%205%20%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E5%92%8C%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/","excerpt":"数值分析 ch 5 - 数值积分和数值微分","text":"数值分析 ch 5 - 数值积分和数值微分 Chapter 5 数值积分和数值微分 插值型求积公式 复化求积公式 Romberg求积法 Gauss求积公式 数值微分 数值积分的基本概念 \\[ \\int_{a}^bf(x) \\mathrm dx\\approx \\sum_{k=0}^n A_k f(x_k \\] 其中： \\(x_k\\)称为插值节点 \\(A_k\\)为求积系数 插值型求积公式 记 \\(I(f) = \\int_a^bf(x)\\mathrm dx\\)，则\\(f\\)的一个插值多项式为 \\(L_n(x)\\)，其中 \\(l_k(x)\\) 是插值基函数。则用 \\(L_n(x)\\) 替代被积函数，一个求积公式为： \\[ I_n(f) = \\sum_k A_kf(x_k)\\\\ A_k = \\int _a^b l_k(x)\\mathrm dx \\] 插值型求积公式 插值型求积公式 设有计算\\(I(f)\\)的求积公式 \\[ I _ n(f)=\\sum _ {k=0}^nA _ k f(x _ k) \\] 若其求积系数\\(A _ k=\\int _ a ^ bl _ k (x)\\mathrm dx\\)，则称该求积公式为插值型求积公式。 截断误差为： \\[ R(f) = \\int_a^b \\frac{f^{(n+1)}(x_0)}{(n+1)!} \\prod_k(x-x_k)\\mathrm dx \\] Newton-Cotes公式 若求积节点是等间距的，即 \\(x_k = a+kh\\)，则该插值型求积公式称为 Newton-Cotes 公式。 记： \\[ C_{n,k} = \\frac{(-1)^{n-k} h}{k!(n-k)!} \\int _ {0} ^ n\\prod _ {j=0\\\\j\\ne k}^n(t-j)\\mathrm dt \\] N-C公式可转化为： \\[ I _ n(f) = \\sum _ {k=0} ^ n C _{n, k} f(x_k) \\] 常用的三种插值求积公式： 梯形公式：\\(T(f) = \\frac{b-a} 2 [f(a) + f(b)]\\) Simpson公式：\\(S(f) = \\frac{b-a}{6}[f(a)+4f(\\frac{a+b} 2)] + f(b)]\\) Cotes公式：\\(C(f) = \\frac{b-a}{90} [7f(a) +32f(\\frac{3a+b} 4) + 12 f(\\frac{a+b} 2) + 32f(\\frac{a+3b}4)+7f(b)]\\) 代数精度 当\\(f(x)\\)为多项式时，考虑截断误差： \\[ R(f) = \\int _ a ^ b \\frac{f^{(n+1)}(\\xi)}{(n+1)!} \\prod _ {k=0} ^ n (x-x _ k) \\mathrm dx = 0 \\] 则 \\(I _ n(f) = I(f)\\)，求积公式是精确的 代数精度 计算 \\(I_n(f)\\) 的求积公式，若对于所有\\(m\\)次多项式是精确的，但至少对一个\\((m+1)\\)次数的多项式是不精确的，则称该求积公式具有\\(m\\)次代数精度。 Theorem 求积公式 \\(I_n(f)\\) 至少有\\(n\\)次代数精度的充分必要条件是该公式是插值型的。 Theorem 求积公式 \\(I_n(f)\\) 至少有\\(m\\)次代数精度的充分必要条件是该公式对\\(f(x)=x^i,~i=0, 1, ...,m\\)都精确成立，但对\\(f(x)=x^{m+1}\\)不精确成立 常用三种插值求积公式的代数精度： 梯形公式：截断误差为\\(-\\frac{(b-a)^3}{12} f&#39;&#39;(\\eta)\\)，代数精度为 1 Simpson公式：截断误差为\\(-\\frac{(b-a)^5}{2880}f^{(4)}(\\eta)\\)，代数精度为3 Cotes公式：代数精度为5 梯形公式、Simpson公式和Cotes公式的截断误差 \\[ R_T(f) = -\\frac{(b-a)^3}{12}f&#39;&#39;(\\eta),\\quad \\eta\\in (a,b) \\] \\[ R_S(f) = -\\frac{(b-a)^4}{2880}f^{(4)}(\\eta),\\quad\\eta\\in (a,b) \\] \\[ R_C(f) = -\\frac{2(b-a)}{945}(\\frac{(b-a)}4)^6f^{(6)}(\\eta),\\quad\\eta\\in (a,b) \\] 复化求积公式 复化梯形求积公式 对每个小区间上的积分 \\(\\int _ {x _ k} ^{x _ {k+1} }f(x)\\mathrm dx\\) 都应用梯形公式： \\[ T _ n(f) = \\sum _ {k=0}^{n-1} \\frac h 2 [f(x _ k) + f(x _ { k + 1 })] \\] 截断误差为： \\[ I(f) - T_n (f) = - \\frac {h^3} {12} \\sum _ {k = 0} ^{ n - 1} f&#39;&#39;(\\eta _ k ) \\] 其先验误差估计为： \\[ I(f) - T _ n (f) = \\frac{b - a} {12} h^ 2|f&#39;&#39;(\\eta) | \\le \\frac{b - a} {12} M_2 h^2\\le \\varepsilon\\\\ M_2=\\max_{a\\le x \\le b} |f&#39;&#39;(x)|| \\] 其后验误差估计为： \\[ |I(f) - T _ {2n} (f) | \\approx \\frac 1 3 |T _ {2n} - T _ n (f)|&lt; \\varepsilon \\] 复化Simpson公式 对每个小区间上的积分 \\(\\int _ {x _ k} ^{x _ {k+1} }f(x)\\mathrm dx\\) 都应用Simpson公式： \\[ S _ n(f) = \\sum _ {h=0} ^ { n - 1} \\frac h 6 [f(x _ k) + 4 f(x _ {k + 1/2}) + f( x _ {k+1})]\\\\ x _ {k + 1/ 2} = \\frac 1 2(x_k + x _ { k + 1}) \\] 其截断误差为：\\(-\\frac{b-a}{180}(\\frac{h}2)^4\\sum_{k = 0} ^ {n-1} f^{(4)}(\\eta_k)\\) 先验误差估计为： \\[ I(f) - S_n(f) = - \\frac{b-a}{180}\\left( \\frac h 2 \\right)^4f^{(4)}(\\eta) \\\\ |I(f) - S_n (f)| \\le \\varepsilon \\] 后验误差估计为： \\[ I(f) - S_{2n}(f) \\approx \\frac 1 {15} (S_{2n}(f) - S_n (f))\\\\ |I(f) - S _ {2n} (f)|\\approx \\frac 1 {15} |S_{2n}(f) - S_j(f)| \\] 复化 Cotes 公式 记 \\[ x_{k+\\frac14} = x_k +\\frac14 h,\\quad x_{k+\\frac12}= x_k + \\frac 12 h,\\quad \\cdots \\] 对于积分\\(\\int_{x_k} ^{x_{k+1}}f(x)\\mathrm dx\\)应用Cotes公式，得到复化Cotes公式 \\[ C_n(f) = \\sum_{k=0}^{n-1} \\frac h{90}[7f(x_k) + 32 f(x_{k+\\frac 14}) + 12 f(x_{k+\\frac12}) + 32 f(x_{k+\\frac34}) + 7f(x_{k+1})] \\] 其截断误差为 \\[ I(f) - C_n(f) = -\\frac{2(b-a)}{945}\\left( \\frac h2 \\right)^6f^{(6)}(\\eta), \\quad \\eta\\in (a,b) \\] 后验误差估计为： \\[ I(f) - C_{2n}(f)\\approx \\frac1{63} [C_{2n}(f) - C_n(f)] \\] 求积公式的阶数 求积公式的阶数 如果计算积分\\(I(f)\\)的复化求积公式\\(I_n(f)\\)，存在正整数\\(p\\)和非零常数\\(C\\)使得： \\[ \\lim_{h\\rightarrow 0} \\frac{I(f)-I_n(f)}{h^p} = C \\] 则称公式\\(I_n(f)\\)是\\(p\\)阶的。 Theorem 复化公式的阶数 复化梯形公式 —— 2阶 复化Simpson公式 —— 4阶 复化Cotes公式 —— 6阶 Romberg 积分法 注意到： \\[ I(f) \\approx \\frac 43 T_{2n}(f) - \\frac13 T_n(f) \\] 实际上： \\[ S_n(f) = \\frac43 T_{2n}(f) - \\frac13 T_n(f) \\] \\[ C_n(f) = \\frac{16}{15} S_{2n}(f) - \\frac 1{15} S_n(f) \\] 则： Romberg公式 称 \\[ R_n(f) = \\frac{64}{63} C_{2n}(f) - \\frac{1}{63}C_n(f) \\] 为Romberg公式，且其具有7次代数精度。 Romberg求积法可以通过列表计算 n T S C R 1 \\(T_1\\) \\(S_1\\) \\(C_1\\) \\(R_1\\) 2 \\(T_2\\) \\(S_2\\) \\(C_2\\) \\(R_2\\) 4 \\(T_4\\) \\(S_4\\) \\(C_4\\) \\(R_4\\) 8 \\(T_8\\) \\(S_8\\) \\(C_8\\) \\(R_8\\) ... ... ... ... ... 每一次选择一个n，向右上方计算。 Gauss求积公式 Gauss-Legendre 公式 设 \\(I_n(f)\\) 是求积分\\(I(f)\\)的求积公式，其代数精度为\\((2n+1)\\)则称其为 Gauss-Legendre 公式，对应的节点为Gauss点。 Theorem 若有插值型求积公式 \\(I_n(f)\\)，\\(I_n(f)\\)是Gauss求积公式 当且仅当 \\(W_{n+1}(x)\\) 和让任何一个次数不超过 \\(n\\) 的多项式正交。 正交多项式 正交多项式序列 设 \\(g_n(x) = a_{n,0} x^n + a_{n,1}x^{n-1}+\\cdots + a_{n,n}\\) 对于任意 \\(i,j\\) 有 \\((g_i, g_j)=0\\) 则称 \\(\\{g_ k(x)\\} _{k=0}^\\infty\\) 是\\([a,b]\\)上的正交多项式序列。 Theorem 正交多项式序列是线性无关的 Theorem 正交多项式序列中\\(g_n(x)\\)在\\([a,b]\\)上有\\(n\\)个零点 n次Legendre多项式 称 \\[ P_n(t) = \\frac 1 {2^nn!} \\frac{\\mathrm d^n(t^2-1)^n}{\\mathrm dt^n},\\quad n = 0,1,2,\\cdots \\] 为Legendre多项式 Theorem Lerandre多项式 \\(\\{P_k(t)\\}\\) 在 \\([-1,1]\\) 上正交。 区间 [-1, 1] 上的Gauss公式 \\(n+1\\) 次 Legendre多项式的零点就是Gauss公式的节点，求积系数为： \\[ \\tilde A_k = \\int _{-1} ^1 \\prod_{j=0,j\\ne k} ^n \\frac{t-t_j}{t_k-t_j}\\mathrm dt \\] 区间 [a, b] 上的Gauss公式 转化为 \\([-1,1]\\) 的Gauss公式求解。 Gauss 公式的截断误差 截断误差为： \\[ R(f) = \\frac{f^{(2n+2)}(\\xi)}{(2n+2)!}\\int_a^b W_{n+1}^2(x)\\mathrm dx \\] Gauss 公式的稳定性和收敛性 Theorem Gauss公式的求积系数都是正的 求积公式的稳定性 若对于任意 \\(\\varepsilon&gt;0\\) 存在 \\(\\delta &gt; 0\\) 当 \\(\\max_{0\\le k \\le n}|f(x_k) - \\tilde f_k| &lt; \\delta\\) 时， 有\\(|I_n(f) - I_n(\\tilde{f})|&lt;\\varepsilon\\) 则该公式是稳定的。 Theorem Gauss公式是稳定的 求积公式的收敛性 若对于任意 \\(\\varepsilon&gt;0\\) 存在\\(N\\)，当\\(n&gt;N\\)时，有\\(|I(f) -I_n(f)|&lt;\\varepsilon\\) 则称该求积公式收敛。 Theorem Gauss公式的收敛性 若 \\(f\\in C[a,b]\\) 则 Gauss公式收敛。","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数值分析","slug":"数值分析","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"}]},{"title":"数值分析-多项式插值和函数最佳逼近","slug":"study/Math/NumericRecipies/Chapter 4 多项式插值和函数最佳逼近","date":"2022-03-03T04:30:41.764Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2022/03/03/study/Math/NumericRecipies/Chapter 4 多项式插值和函数最佳逼近/","link":"","permalink":"http://adversarr.github.io/2022/03/03/study/Math/NumericRecipies/Chapter%204%20%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%80%E4%BD%B3%E9%80%BC%E8%BF%91/","excerpt":"数值分析 ch 4 多项式插值和函数最佳逼近","text":"数值分析 ch 4 多项式插值和函数最佳逼近 Chapter 4 多项式插值和函数最佳逼近 给定一个函数： \\(f(x)\\in[a,b]\\) 在离散点处的值，能否给出一个近似？ 函数近似和函数逼近 函数近似表示：可能性 Def（插值函数）设函数 \\(y=f(x)\\)在区间\\([a,b]\\)上有定义，且已知在\\(a\\le x_0&lt;\\cdots&lt;x_n\\le b\\)上的值，若存在一个简单函数\\(P(x)\\)使 \\[ P(x_i)=f(x_i)\\quad (i=0,1,\\dots,n) \\] 成立，则称\\(P(x)\\)为\\(f(x)\\)的插值函数，上式称为插值条件，点\\(x_0,x_1,\\dots,x_n\\)称为插值节点，\\([a,b]\\)称为插值区间。求\\(P(x)\\)的方法称为差值法。 Thm（存在n次多项式插值）满足插值条件的n次多项式\\(p_n(x)\\)存在且唯一。 存在性：可以构造出Lagrange表示 唯一性：代数基本定理 存在性：- 构造范德蒙矩阵- 范德蒙矩阵的行列式 |X| ≠ 0 范德蒙行列式： \\[ |X| = \\prod_{0\\le i&lt;j\\le n} (x_i-x_j) \\] 基本插值多项式 求n次多项\\(l_k(x)\\)满足： \\[ l_k(x_j)= \\mathbb 1_{j=k} \\] 由条件4知道\\(x_0,x_1...,x_{k-1},x_{k+1},...,x_n\\)是\\(l_k(x)\\)的零点。所以\\(l_k(x)\\)有n个因子：\\(x-x_0,...x-x_{k-1},...,x_{k+1},...,x-x_n\\)，所以 \\[ l_k=A_k \\prod _{i\\ne k} (x-x_i) \\] 其中： \\[ A_k=\\cfrac{1}{\\prod_{i\\ne k}(x_i-x_k)} \\] 则\\(l_k(x)\\)称为n次（第\\(k\\)个）基本插值多项式（也就是Lagrange插值基函数） Lagrange插值多项式 Thm：设\\(x_0, x_1, \\cdots,x_n\\)是互异节点，则存在唯一的次数不超过\\(n\\)次的多项式\\(L_n(x)\\)，使得\\(L_n(x_i)=f(x_i)\\) 用Lagrange（选择\\(l_k(x)\\)为基函数），组合后的系数即为\\(f(x_i)\\)： \\[ L_n(x)=\\sum_{k=0}^nf(x_k)l_k(x)=\\sum _{k=0} ^ nf(x_k)\\prod_{i\\ne k,i=0}\\frac{x-x_i}{x_k-x_i} \\] 称为n次Lagrange插值多项式 插值余项和误差估计 Def（余项）\\(R_n(x)=f(x)-L_n(x)\\)为插值多项式的余项（一般的为\\(R_n(x)=f(x)-p_n(x)\\)） Thm：设\\(f(x)\\)在\\((a,b)\\)内有\\(f^{(n+1)}(x)\\)存在，\\(L_n(x)\\)为Lagrange插值多项式，则对于任意\\(x\\in [a,b]\\)，\\(\\exists \\xi\\in (a,b),s.t. R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}W_{n+1}(x)\\)，其中\\(W_{n+1} (x) = \\prod_{i=0}^n(x-x_i)\\) 注： \\(\\xi\\)依赖于\\(x\\) 一般不能求出，只能估计误差 差商和牛顿插值 Lagrange插值的缺点：节点增加或减少时，所有插值基函数的系数都可能变化（计算不变） 设\\(L_{k}(x)\\)时以\\(x_0,x_1,...,x_{k}\\)为插值节点的多项式，考察\\(L_k\\)和\\(L_{k-1}\\)的关系： \\[ let\\quad g(x)=L_k(x) - L_{k-1} (x) \\] 从而：\\(g\\)时一个次数不超过\\(k\\)的多项式，也就是说，\\(L\\)可以写成 \\[ L_k(x) = a_0+a_1(x-x_0) + \\cdots + a_k(x-x_0)(x-x_1)\\cdots(x-x_{k-1}) \\] 求出 \\(a_k\\)： \\[ a_k = \\sum_{m=0}^k\\frac{f(x_m)}{\\prod\\limits_{i\\ne m,i=0}^k(x-x_i)} \\] 差商和Newton插值公式 Def：设已知函数\\(f(x)\\)在\\(n+1\\)个互异节点上的值为\\(f(x_0),...,f(x_n)\\)称： \\[ f[x_i,x_j] =\\frac{f(x_j)-f(x_i)}{x_j-x_i} \\] 为节点\\(x_i,x_j\\)的一阶差商，其一阶差商的差商： \\[ f[x_i,x_j,x_k]=\\frac{f[x_j,x_k] - f[x_i,x_j]}{x_k-x_i} \\] 为二阶差商，以此类推。约定零阶差商为函数值。 Thm：k阶差商可以表示成\\(f(x_0),f(x_1),...,f(x_k)\\)的线性组合。 \\[ f[x_0,x_1,\\cdots,x_k] = \\sum_{m=0}^k \\frac{f(x_m)}{\\prod_{i=0,i\\ne m}^k(x_m-x_i)} =a_k \\] 则： \\[ L_n(x) = f(x_0) + f[x_0,x_1](x-x_0) + ...+f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1}) \\] Thm：k阶差商与节点的次序无关。 Thm：k阶差商和k阶导数有如下关系\\(f[x_0,...,x_k]=\\frac{f^{(k)}(\\eta)}{k!}\\quad \\eta \\in (\\min\\{x_0,...,x_k\\}, \\max\\{x_0,...,x_k\\} )\\) 差分和等距节点的Newton插值多项式 Def：若已知函数\\(f(x)\\)在等距节点\\(x_i\\)上的函数值为\\(f(x_i) = f_i(i = 0, 1, ...,n)\\)则称 \\(f_{i+1} - f_i\\)为\\(f(x)\\)在\\(x_i\\)处以\\(h\\)为步长的1阶向前差分\\(\\Delta f_i\\)。\\(\\Delta^k f_i = \\Delta^{k-1} f_{i+1} -\\Delta^{k-1} f_{i}\\)为k阶差分。 可以证明，差分和差商有如下关系 ： \\[ f[x_i,x_{i+1},\\cdots,x_{i+k}]=\\frac{\\Delta^k f_i}{k!h^k} \\] 从而可以得到Newton插值多项式： $$ \\[\\begin{aligned} N_n(x)&amp;=\\sum_{k=0}^n f[x_0, x_1,\\cdots, x_k]\\prod_{j=0}^{k-1}(x-x_j)\\\\ N_n(x_0+th)&amp;=\\sum_{k=0}^n \\frac{\\Delta^kf_0}{k!} \\prod_{j=0}^{k-1} (t-j) \\end{aligned}\\] $$ 第二个式子称为n次Newton前插公式。 高次插值的缺点、分段低次插值 埃尔米特插值(Hermite) Def：给定\\([a,b]\\)中的\\(n+1\\)个互异的节点及其函数值和直到\\(m_i\\)阶导数\\(f(x_i),f&#39;(x_i),...,f^{(m_i)}(x_i)\\)，令\\(m=\\sum_{i=0}^n(m_i+1)-1\\)若存在一个次数不超过\\(m\\)次的多项式\\(H_m(x)\\)，满足所有条件，则称\\(H_m(x)\\)为\\(f(x)\\)的\\(m\\)次Hermite插值多项式。 Thm：满足该插值条件的\\(m\\)次多项式\\(H_m(x)\\)是存在且唯一的。 Thm：设\\(H_m(x)\\)是满足条件的m次插值多项式，\\(f(x)\\)在包含\\(n+1\\)个互异节点\\(x_0,x_1,\\dots,x_n\\)的区间\\([a,b]\\)上有m阶连续导数，且在\\((a,b)\\)上有\\(m+1\\)阶导数 ，则对于其中每一个点，一定存在\\(\\xi\\)使得： \\[ R_m(x) = \\frac{f^{(m+1)}(\\xi)}{(m+1)!}\\prod _{i=0}^n (x-x_i)^{m_i+1} \\] Thm：（Hermite-Gennochi）若 \\(f\\in C^n[a,b],x_i\\in [a,b],i = 0, 1, ...,n\\)且互异，则： \\[ f[x_0,\\dots,x_n]=\\int\\mathop\\cdots\\limits_{\\tau_n}\\int f^{(n)}(t_0x_0+ t_1x_1+\\cdots + t_nx_n)\\mathrm dt_1\\cdots\\mathrm dt_n \\] 其中 \\(\\\\tau _ n = \\left\\{ { (t _ 1,\\dots,t _ n) |t_i\\ge 0, \\sum t _ i \\le 1 }\\right\\}\\)为n维单纯形，而\\(t _ 0 = 1- \\sum_{i=1} ^n t _ i\\) . 扩展差商的定义（重节点插值）： \\[ f[x_0,x_0] = \\lim _{x\\rightarrow x_0} f[x_0, x] =f&#39;(x_0)\\\\ f[x_0,...,x_0] = \\frac{f^{(k)}(x_0) }{k!} \\] 从而： \\[ \\begin{aligned} H_m(x) = &amp;f(x_0) + f[x_0,x_0](x-x0) + \\cdots + f[x_0, \\cdots,x_0](x-x_0)^{m_0}\\\\ &amp;+f[x_0,\\cdots,x_0,x_1] (x-x_0)^{m_0+1} + \\cdots +\\\\ &amp;f[x_0,\\cdots, x_0, x_1\\cdots x_1](x-x_0)^{m_0+1} (x-x_1)^{m_1}+\\cdots\\\\ &amp;+f[x_0,\\cdots,x_n](x-x_0)^{m_0+1}\\cdots(x-x_{n-1})^{m_{n-1}+1}(x-x_n)^{m_n} \\end{aligned} \\] 插值余项为： \\[ f(x)-H_m(x)=\\frac{f^{(m+1)}(\\xi)}{(m+1)!}\\prod_{i=0}^n(x-x_i)^{m_i+1} \\] 高次插值的缺点和分段线性插值 常见的问题：个数多→误差大 在数值分析领域中，龙格现象是在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。 它是由卡尔·龙格（Runge）在探索使用多项式插值逼近某些函数时的错误行为时发现的。[1]这一发现非常重要，因为它表明使用高次多项式插值并不总能提高准确性。 该现象与傅里叶级数近似中的吉布斯现象相似。——Wikipedia 分段线性插值 在数值分析这个数学分支中，样条插值是使用一种名为样条的特殊分段多项式进行插值的形式。 在数学学科数值分析中，样条（Spline）是一种特殊的函数，由多项式分段定义。 若给出\\(f(x)\\)在n+1个节点上的数据表，则线性插值： \\[ L_{1,i} (x) = f(x_i) + f[x_i, x_{i+1}](x-x_i)\\\\ \\tilde L_1(x) = \\begin{cases} L_{1,0}(x),&amp;x\\in[x_0,x_1)\\\\ L_{1,1}(x),&amp;x\\in[x_1,x_2)\\\\ \\vdots\\\\ L_{1,n-1}(x),&amp;x\\in [x_{n-1},x_n] \\end{cases} \\] 其插值误差为： \\[ \\max_{a\\le x\\le b}|f(x) - \\tilde L_1(x)| \\le \\frac 1 8 h^2 \\max_{a\\le x\\le b}|f&#39;&#39;(x)| \\] →产生了尖点（不光滑） 需要的： 小区间上是多项式 两个相邻区间内光滑连接 → 三次样条插值 三次样条插值 Def：设在区间\\([a,b]\\)上的n+1个插值节点 \\[ a=x_0&lt;x_1&lt;\\cdots&lt;x_n=b \\] 及其函数在节点上的值\\(y_i\\)，若存在函数\\(S(x)\\)满足： \\(S(x_j)=y_j\\) \\(S(x)\\)在每个小区间上都是三次多项式 \\(S\\in C^2[a,b]\\) 则称为三次样条插值函数 由于在边界上缺少边界条件，通常在端点上2个附加条件（边界条件）： （第一型）已知一阶导数 （第二型）已知二阶导数 （第三型）周期边界条件 三次样条插值函数的求法 从二阶导数入手： \\[ S&#39;&#39;(x_j)=M_j, S&#39;&#39;(x_{j+1})=M_{j+1} \\] 令\\(h_j = x_{j+1}-x_j\\)则： \\[ S(x) =y_j+c_j(x-x_j)+\\frac 1 2 M_j(x-x_j)^2+ \\frac 1 {6h_j}(M_{j+1} - M_j)(x-x_j)^3,x\\in [x_j,x_{j+1}] \\] 代入一次导数连续： \\[ S&#39;(x_j)=S&#39;(x_{j+1}) \\] 则 \\[ \\mu_j M_{j-1} +2M_j+\\lambda _jM_{j+1}=d_j\\\\ \\mu_j = \\frac{h_{j-1}}{h_{j-1}+h_j},\\quad\\lambda_j = 1 - \\mu_j,\\quad d_j=6f[x_{j-1}, x_j,x_{j+1}] \\] 即可构造出三对角矩阵，若给出第一型条件\\(d_0 = 6f[x_0,x_0,x_1]\\), \\(d_1 = 6f[x_{n-1}, x_n,x_n]\\)： \\[ \\left[\\begin{matrix} 2&amp;1\\\\ \\mu_1&amp;2&amp;\\lambda_1\\\\ &amp;\\mu_2&amp;2&amp;\\lambda_2\\\\ &amp;&amp;\\ddots&amp;\\ddots&amp;\\ddots\\\\ &amp;&amp;&amp;\\mu_{n-1}&amp; 2&amp; \\lambda_{n-1}\\\\ &amp;&amp;&amp;&amp;1 &amp;2 \\end{matrix}\\right] \\left[\\begin{matrix} M_0\\\\M_1\\\\M_2\\\\\\vdots\\\\M_{n-1}\\\\M_n \\end{matrix}\\right] = \\left[\\begin{matrix} d_0\\\\d_1\\\\d_2\\\\\\vdots\\\\d_{n-1}\\\\d_n \\end{matrix}\\right] \\] 三次样条插值函数的收敛性 Thm：设被插值函数四阶连续，则在插值区间上有 \\[ ||f^{(k)}-S^{(k)}||_\\infty \\le c_kh^{4-k}||f^{(4)}||_\\infty,\\quad k = 0, 1, 2\\\\h = \\max_{0\\le j\\le n-1}h_j,c_0 = 1/16, c_1=c_2=1/2 \\] 最佳一致逼近 线性赋范空间 Def（线性空间）若\\(\\forall x,y\\in X, \\lambda x\\in R,\\lambda x\\in X, x+y\\in X\\)则称\\(X\\)为线性空间。 Def（线性赋范空间）对应的空间称线性赋范空间 Def（距离）\\(X\\)是线性赋范空间，\\(x,y\\in X\\)则称\\(||x-y||\\)为\\(x\\)\\(y\\)之间的距离 Def（最佳逼近元）\\(X\\)是线性赋范空间，\\(M\\sube X\\)若存在\\(\\varphi \\in M\\)使得\\(\\forall \\psi\\in M\\)有 \\[ ||f-\\varphi||\\le ||f-\\psi|| \\] 则称\\(\\varphi\\)是\\(f\\)在\\(M\\)中的最佳逼近元 最佳一致逼近多项式 Def（最佳一致逼近多项式）若\\(\\exist p_n\\in M_n\\)使得\\(\\forall q_n\\in M_n\\) \\[ ||f-p_n||_\\infty \\le ||f-q_n||_\\infty \\] Thm：n次最佳一致逼近多项式是存在且唯一的 Def（偏差点）\\(|g(x_0)|=||g||_\\infty = \\max_{a\\le x\\le b}|g(x)|\\)（又分正偏差点、负偏差点） 引理1：对于最佳一致逼近多项式，\\(f-p_n\\)必存在正负误差点。 Thm：设\\(f\\in C[a,b]\\)，\\(p_n(x)\\)是n次多项式，则\\(p_n(x)\\)是\\(f(x)\\)的\\(n\\)次最佳一致逼近多项式\\(\\iff\\)\\(f(x)-p_n(x)\\)在\\([a,b]\\)上至少有n+2个交错偏差点。\\(a\\le x_0 &lt; x_1 &lt; \\cdots &lt; x_{n + 1} \\le b\\) \\[ f(x_i)-p_n(x_i)=(-1)^i\\sigma ||f-p_n || _\\infty \\] 推论1：若$f^{(n+1)} \\(在\\)(a,b)\\(上存在且保号，则\\)f(x)-p_n(x)\\(在\\)[a,b]\\(内恰好有\\)n+2$个交错偏差点，且两端点都是偏差点。 推论2：\\(p_n(x)\\)是\\(f(x)\\)的某一个n次插值多项式 最佳平方逼近 内积空间 Def（内积空间和内积）：若\\(X\\)是一个线性空间，若\\(\\forall x,y\\)有实数与之对应\\((x,y)\\)，且 \\(\\forall x,y \\in X,~(x,y)=(y,x)\\) \\(\\forall x,y \\in X,\\lambda\\in R,~(\\lambda x,y)=\\lambda(x,y)\\) \\(\\forall x,y,z\\in X,(x,y+z)=(x,y)+(y,z)\\) \\(\\forall x\\in X, (x,x)\\ge 0, (x,x)=0\\iff x=0\\) Def（正交）：\\((x,y)=0\\) Thm：柯西-施瓦茨不等式 最佳平方逼近 设\\(X\\)是内积空间，\\((\\cdot,\\cdot)\\)是内积，M是X的有限维子空间，\\(\\varphi_0,...,\\varphi_m\\)是M的一组基。求\\(\\varphi\\in M\\)使得：\\(\\varphi = \\arg\\min_{\\psi\\in M} ||f-\\psi||\\)，则称\\(\\varphi\\)为\\(f\\)在\\(M\\)中的最佳平方逼近元 记：\\(\\varphi = \\sum c_i \\varphi _i,\\quad\\psi = \\sum a_i\\varphi _i\\)，问题变为求解\\(c\\) \\[ \\left[ (\\varphi_i, \\varphi_j) \\right][c_0,c_1,...,c_m]^T = [(f, \\varphi_0), (f,\\varphi_1),...,(f,\\varphi_m)] \\] 上述方程组称为正规方程组。 引理：正规方程组是对称正定的。 Thm：正规方程组存在唯一解，且为\\(||f-\\sum a_i\\varphi_i||^2\\)的最小点。 超定线性方程组的最小二乘解 \\[ \\left[a_{i,j}\\right] [x_1,x_2,\\dots,x_n]^T = [b_1,b_2,\\dots,b_m]^T \\] 其中：\\(m&gt;n\\) \\[ A^TAx=A^Tb \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数值分析","slug":"数值分析","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"}]},{"title":"数值分析-引言","slug":"study/Math/NumericRecipies/Chapter-1-Introduction","date":"2022-03-03T04:30:41.764Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2022/03/03/study/Math/NumericRecipies/Chapter-1-Introduction/","link":"","permalink":"http://adversarr.github.io/2022/03/03/study/Math/NumericRecipies/Chapter-1-Introduction/","excerpt":"数值分析 ch 1 - 引言","text":"数值分析 ch 1 - 引言 Chapter-1-Introduction 绪论 非线性方程求根 线性方程组的数值解 插值和逼近 数值积分和数值微分 常微分方程的数值解 偏微分方程的数值解 绪论 主要内容： 科学计算的内容：科学模拟的过程、一般策略 误差的概念：绝对误差、相对误差、向前/向后误差、有效数字及它们之间的关系 数据误差对函数值的影响：讨论函数的误差与自变量误差之间的关系 算法的数值稳定性：讨论初始数据的误差对计算结果的影响 实际计算中应该注意的问题 科学计算 计算模拟解决问题的过程 建立数学模型 给出数值算法 计算机软件实现算法 运行、进行数值模拟 表示计算结果 解释计算结果 一般策略 有限维空间代替无限维空间 用有限过程代替无限过程 用线性方程代替微分方程 用低阶方程组代替高阶方程组 用简单函数代替复杂函数 用简单结构矩阵代替一般矩阵 机器数系 计算机中的实数（浮点数）\\(x = \\pm \\beta^p \\times (0.\\alpha _ 1\\alpha _ 2\\cdots)\\) 特点： 有限的离散集 有最大、（非零非负）最小数 溢出错误（\\(\\infty\\) 和 \\(0\\)） 计算机对于数的接收 误差的基本概念 误差的来源 模型误差：对实际情况的简化和近似 观测误差：测量误差等等 截断误差：计算中的无限过程，使用了有限的近似，例如级数求和 舍入误差：四舍五入 例1：\\(A=4\\pi r^2\\) 中，包含了各种误差 例2：Taylor 展开：\\(e^{-x} = 1-x+\\frac 1 2{x^2} -\\frac{1}{6}x^3+E_r(x)\\) ，其中略去 \\(E_r\\) 项，产生了截断误差 绝对误差 绝对误差：设\\(x^*\\)是准确值，\\(x\\)是近似值，则： \\[ e(x)=x^*-x \\] 为近似值\\(x\\)的绝对误差，简称误差。在实际计算中，绝对误差无法求出，但只需要知道误差的一个范围，从而有绝对误差限 \\(\\varepsilon\\)： \\[ |e(x)|\\le \\varepsilon \\] 相对误差 \\[ e_r(x)=\\frac{x^*-x}{x^*} \\] 若 \\(x^*\\) 无法确定，也用： \\[ e_r(x)=\\frac{x^*-x}{x} \\] 相应的，有相对误差限： \\[ |e_r(x)|\\le \\varepsilon \\] 有效数 若 \\(x\\) 为 \\(x^*\\) 的近似值，若 \\(|e(x)|\\) 是其某个数位的半个单位，从左起第一个非零数到这一位有 n 位，则称 n 个数字为其有效数字。 在实际情况中：n 位有效数字通常表示为： \\[ x = \\pm 0.\\alpha_1\\alpha_2\\alpha_3....\\times10^{m} \\] 则其误差（的绝对值）为：\\(|e(x)|\\le\\displaystyle \\frac 1 2 \\times 10^{m-n}\\)，误差限为： \\[ \\varepsilon = \\frac 1 2 \\times 10^{m-n} \\] 例如：\\(\\pi=3.14159.....\\)，3.14 有3位有效数字，3.1416有5位有效数字，3.1415只有4位有效数字。 对应作业部分：Week1 数据误差和计算误差 → \\(x\\)表示输入的真值，\\(f(x)\\)为所求的真实结果，假设所用的输入值不是精确值，即为\\(\\hat x\\)，得到的近似值为\\(\\hat f\\)则： \\[ 总误差=(\\hat f(\\hat x) -f(\\hat x)) + (f(\\hat x)-f(x))=计算误差+数据传播误差 \\] 例如： \\(\\sin x\\approx x-\\frac 1 {3!}x^3\\Rightarrow f\\approx \\hat x\\)l 向前误差和向后误差 \\(x,f\\)表示输入值和函数，\\(\\hat f\\)表示实际计算的函数，\\(x\\)表示能精确地得出计算值的输入，则：\\(\\hat f(x)=f(\\hat x)\\) 则： 绝对向前误差：\\(|\\hat f(x)-f(x)|\\) 绝对向后误差：\\(|\\hat x-x|\\) 条件数：\\(\\displaystyle\\frac {|(f(\\hat x) - f(x))/f(x)|} { |(\\hat x-x)/x|}\\)→ 相对误差的放大倍数 数据误差对函数值的影响 对于单变量函数而言： \\[ y=f(x)\\rightarrow e(y)=y^*-y=f(x^*)-f(x) \\] 若使用Taylor展开\\(e(y)\\approx f&#39;(x)(x^*-x)=f&#39;(x)e(x),\\quad e_r(y)=\\frac{xf&#39;(x)}{f(x)}e_r(x)\\) 对于多变量函数而言： \\[ \\begin{aligned} e(y)&amp;=f(x_1^*,x_2^*)-f(x_1,x_2)\\\\ &amp;\\approx \\frac{\\partial f(x_1,x_2)}{\\partial x_1}e(x_1)+\\frac{\\partial f(x_1,x_2)}{\\partial x_2}e(x_2)\\\\ e_r(y)&amp;=e(y)/y\\\\ &amp;\\approx\\frac{\\partial f(x_1,x_2)}{\\partial x_1}\\frac{x_1}{f(x_1,x_2)}e_r(x_1)+\\frac{\\partial f(x_1,x_2)}{\\partial x_2}\\frac{x_2}{f(x_1,x_2)}e(x_2) \\end{aligned} \\] 和差积商的误差计算方法： \\(e(x_1\\pm x_2)=e(x_1)\\pm e(x_2)\\) \\(e(x_1 x_2)=x_2e(x_1)+x_1e(x_2)\\) \\(e(x_1/x_2)\\approx \\displaystyle\\frac{1}{x_2}e(x_1)-\\frac{x_1}{x_2^2}e(x_2)\\) 算法的数值稳定性 数值稳定性 对于某一种算法，如果初始数据有很小的误差，仅仅使结果产生很小的误差，则称这个算法时（数值）稳定的，否则称为（数值）不稳定的。 例如：\\(I_n=\\int_0^1\\frac {x^n}{x+5}\\mathrm dx\\) \\(I_n=\\frac 1 n -5I_{n-1}\\)→ \\(|e_n|=5^n|e_0|\\)（误差传播）→ 不稳定 \\(I_{n-1}=\\frac 1 5(1/n -I_n)\\) 利用 \\(I_{10}\\)推算 病态问题（ill-posed） 多项式求根时一个病态问题！ 实际问题中应该注意的问题 避免除数远小于被除数 避免两个相近的数详见 防止大数“吃”小数 简化计算次数，减少计算次数：例如：快速幂算法，多项式计算的秦九韶算法","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数值分析","slug":"数值分析","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"}]},{"title":"数值分析-线性方程组的数值解","slug":"study/Math/NumericRecipies/Chapter 3 线性方程组的数值解","date":"2022-03-03T04:30:41.763Z","updated":"2022-03-03T04:30:41.763Z","comments":true,"path":"2022/03/03/study/Math/NumericRecipies/Chapter 3 线性方程组的数值解/","link":"","permalink":"http://adversarr.github.io/2022/03/03/study/Math/NumericRecipies/Chapter%203%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3/","excerpt":"数值分析 ch 3 - 线性方程组的数值解","text":"数值分析 ch 3 - 线性方程组的数值解 Chapter 3 线性方程组的数值解 Content： Gauss 消去法，Gauss列主元消去法 向量和矩阵的范数、方程组性态和误差估计 Jacobi迭代，Gauss-Seidel迭代格式，收敛性的判别 幂法和反幂法 迭代解法描述： \\[ \\begin{aligned}A\\vec x=\\vec b\\iff\\vec x&amp;=B\\vec x+\\vec c\\\\\\vec x_{n+1}&amp;=B\\vec x_n+\\vec c\\\\ if~x_n~converge,~\\vec x_n&amp;\\rightarrow \\vec x^* \\end{aligned} \\] Today's outline: 解线性方程组的可操作的解法 直接法：不考虑舍入误差，通过有限步运算一定能得到精确解 例如：Kramer's law - $A=(\\vec a_1, \\vec a_2,\\cdots)$$A_i = (\\vec a_1,\\cdots,\\vec a_&#123;i-1&#125;,\\vec b,\\vec a_&#123;i+1&#125;,\\cdots,\\vec a_n)$$x_i = |A_i|/|A|$ 消元法：Gauss 间接法：通过有限次运算得到近似解→如何刻画 矩阵/向量的范数 误差估计 迭代法求解（近似解） 恒等变形： \\[ Ax=b\\iff x = Bx+f \\] 构造迭代序列：（由 \\(B\\)和 \\(x_0\\)完全决定） \\[ x_{k+1}=Bx_k+f \\] 如果序列收敛，则： \\[ x^*=Bx^*+f \\] 对于充分大的\\(k\\)，有 \\(x_k\\approx x^*\\) 计算矩阵A的最大（小）特征值 Gauss 消元法 思想：利用线性代数中学过的初等行变换，将方程组化为等价的三角形方程组 三角形方程组的回代法 \\[ \\begin{aligned} u_{11}x_1+\\cdots +u_{1n}x_n=y_1&amp;\\\\ \\cdots&amp;\\\\ u_{nn}x_n=y_n&amp;\\end{aligned} \\] \\[ \\begin{cases} x_n=y_n/u _{nn}\\\\ x_i = (y_{n-1}-\\sum _{j=i+1}^n u_{ij}x_j)/u_{ii} \\end{cases} \\] Gauss 消去法 将 \\(Ax=b\\)化为增广矩阵：\\(\\overline A^{(1)}\\) 同解变换：非零数乘一个方程两边，互换位置，一个方程乘常数+另一个方程 下面用n-1步消元，将\\(\\overline A^{(1)}\\)转化为上三角矩阵 \\(\\bar A^{(1)}\\rightarrow \\bar A^{(2)}\\rightarrow\\cdots\\rightarrow \\bar A^{(n)}\\) 三角形方程组回代 →\\(O(n^3)\\) Thm：（充分条件）若 A 的各阶顺序主子式非零，则Gauss消去法中各主元\\(a_{kk}^{(k)}\\)均非零。 三对角方程组的追赶法 \\[ \\left[\\begin{matrix} b_1&amp;c_1\\\\ a_2&amp;b_2&amp;c_2\\\\ &amp;a_3&amp;b_3&amp;c_3\\\\&amp;&amp;&amp;\\cdots \\end{matrix}\\right]x = d \\] 且对角占优：\\(|b_i|&gt;|a_i|+|c_i|\\) 消元过程如下： \\(\\beta_1=b_1,y_1=d_1,l_i=\\frac {a_i} {\\beta _{i-1}},\\beta_i=b_i-l_ic_{i-1},y_i=d_i-l_iy_{i-1}\\) 列主元Gauss消元 → \\(|a_{tk}^{(k)}|=\\max_{k\\le i\\le n}|a_{ik}^{(k)}|\\) LU分解法 Gauss消元→行变换L→\\(L=(L_k^{-1}L_{k-1}^{-1}\\cdots L_1^{-1})\\)→\\(LUx=b\\)→\\(Ly=b,Ux=y\\) Thm A的各阶顺序主子式均不为0，则对A可做唯一的LU分解 Thm若A是对称矩阵，且各阶顺序主子式不为0，则A可以做LU分解，且 \\[ l_{ik}=\\frac {u_{ki}}{u_{kk}} \\] 方程组的性态和误差分析 #IMPORTANT 如何刻画一个矩阵A的性态→矩阵的条件数（与矩阵的模有关） 向量范数 Def（范数）一个函数，满足：非负性、齐次性、三角不等式 常用的： 1-范数 ∞-范数 2-范数←内积 Thm：有限维空间所有的模都是等价的（\\(\\exists c_1,c_2\\forall x\\in R^n,c_1||x||_p\\le ||x||_q\\le c_2||x||_p\\)) 定性描述为：两个范数等价是指在一个范数顶一下的向量，在另一个范数下也小 借助这样的理论：我们研究 两个向量之间的绝对误差和相对误差： 设\\(x^*\\)和\\(\\tilde x\\)是方程组\\(Ax=b\\)的精确解和近似解，则\\(||x^*-\\tilde x||, ||x^*-\\tilde x||/||\\tilde x||\\)可以表示其误差 矩阵范数 借助向量模定义矩阵模 Def（矩阵范数）一个函数，满足 非负性\\(||A||\\ge0 且||A||=0\\iff A=0\\) 齐次性\\(||\\alpha A||=|\\alpha|||A||\\) 三角不等式\\(||A+B||\\le ||A||+||B||\\) \\(||AB||\\le ||A||~||B||\\) 相容性\\(||Ax||\\le ||A||~||x||\\) 矩阵的行列式不可以作为范数 Def（向量范数导出的算子范数） 设 \\(||\\cdot||\\)是一个范数，称\\(\\max_{x\\in R^n} \\frac{||Ax||}{||x||}=\\max_{x\\in R^n,||x||=1}||Ax||\\)为A的向量范数导出的算子范数\\(|||A|||\\) Def（谱Spectrum半径）设\\(B\\in R^{n\\times n}\\)，\\(\\lambda_1,...,\\lambda_n\\)为特征值，谱半径为： \\[ \\rho(B)=\\max \\{\\lambda_i\\} \\] Thm：常用矩阵范数计算 \\(||A||_1=\\max_{1\\le j\\le n}\\sum_{i=1}^n\\)=最大列绝对值和 \\(||A||_\\infty\\)=最大行绝对值和 \\(||A||_2=\\sqrt{\\rho(A^TA)}\\) \\(||A|_F=\\sqrt{\\sum_{i,j=1}^na_{ij}^2}\\)→ 注意！不是算子范数！例如 \\(||I||\\ne 1\\) Thm：对于对称矩阵，\\(\\rho(A)=||A||_2\\) Thm：对于任意范数\\(\\rho(A)\\le ||A||\\) 可用于证明迭代法收敛！ Thm： \\(R^{n\\times n}\\) 中的任意两个矩阵范数是等价的 【推广】有限维空间中的两个范数是等价的。 Thm：对于两个矩阵范数，存在常数\\(d_1\\)和\\(d_2\\)满足： \\[ d_1||A||_p\\le ||A||_q\\le d_2||A||_p \\] Def（矩阵之间的距离）\\(||A-B||\\) Def（矩阵收敛）\\(\\lim_{k\\rightarrow \\infty} ||A^{(k)}-A||=0\\iff \\lim_{k\\rightarrow \\infty} A^{(k)}=A\\) Thm：\\(\\lim_{k\\rightarrow \\infty} B^k=0\\iff \\rho(B)&lt;1\\) 例如： \\[ \\begin{aligned} \\frac 1{1-q}&amp;=1+q+q^2+\\cdots\\\\ (I-A)^{-1}&amp;=I+A+A^2+\\cdots \\end{aligned} \\] 方程组的性态和条件数 矩阵的行列式可以一定程度上的表示误差大小，而用条件数进行精确刻画。 设\\(b\\)有一个小的扰动\\(\\delta b\\)，此时解变为\\(x^*+\\delta^*\\) 则有\\(A\\delta x^*=\\delta b\\)，也就是\\(\\delta x^*=A^{-1}\\delta b\\) 取范数： \\[ \\frac{||\\delta x^*||}{||x^*||}\\le ||A^{-1}||~||A||\\frac{||\\delta b||}{||b||} \\] 设\\(A\\)有微小变化\\(\\delta A\\) 则\\(\\delta x^*=-A^{-1} \\delta A(x^*+\\delta x^*)\\) 取范数： \\[ \\frac{||\\delta x^*||}{||x^*+\\delta x^*||}\\le ||A^{-1}||~||A||~\\frac {||\\delta A||}{||A||} \\] Def（条件数\\(\\mathrm {cond}A\\)）\\(A\\)为非奇异矩阵，则称 \\(||A^{-1}||~||A||\\)为条件数 Def（好的方程组）对于Ax=b而言，若 A的条件数很大，则为病态方程组（误差不一定大） A的条件数很小，则为良态方程组（误差一定小） 常用的判断方法： 列主元Gauss消去法出现绝对值很小的pivot 系数矩阵中，某些行（列）近似线性相关 系数矩阵元素间，数量级差距很大，且没有一定的规律 一般的解决方案： 提高计算精度 预处理：选择合理的非奇异矩阵\\(D,C\\)，将方程组化为等价的方程组，\\(DAC[C^{-1}]=Db\\)且使得\\(\\mathrm{cond} DAC\\)较小 例如：正则化方法：\\(Ax=b,|A|\\approx 0\\)→\\(x=(\\alpha I+A^TA)^{-1}A^Tb\\) 迭代法（Jacobi迭代，Gauss-Seidel迭代） 迭代格式的构造 将方程组改写为等价的方程： \\[ x=Bx+f \\] 通过该格式进行迭代，若迭代格式对于任意初始向量产生的迭代序列 \\(\\{x^{(k)}\\}\\)都收敛，则迭代收敛 对于线性方程组而言，迭代收敛只与\\(B\\)有关；对于非线性方程组而言，和 \\(B,x\\) 都有关。 三种常用的迭代格式 Jacobi迭代法 假设对角线元素都非零，则可以通过该公式得到： \\[ \\begin{aligned} x_1 = (b_1-a_{12}x_2-\\cdots - a_{1n}x_n)/a_{11}\\\\ \\cdots\\\\ x_n = (b_n - a _ {n1} x_1 - \\cdots - a_{n,n-1}x_{n-1})/a_{nn} \\end{aligned} \\] 若将原矩阵进行重写： $$ A=L+D+U $$ \\(J = -D^{-1}(L+U)\\) \\(f_J=D^{-1}b\\) Gauss-Seidel迭代 我们用已经求出的 \\(x^{(k)}_{i}\\)代入后续所有计算，即为Gauss-Seidel格式： \\[ x^{(k+1)}=D^{-1}(b-Lx^{(k+1)}-Ux^{(k)}) \\] 最终的迭代格式为： \\[ x^{(k+1)}=Gx^{(k)}+f_G \\] \\(G=-(D+L)^{-1}U\\) \\(f_G=(D+L)^{-1}b\\) SOR（逐次超松弛）迭代格式 \\[ x^{(k+1)}=(1-\\omega )x^{(k)}+\\omega D^{-1}(b-Lx^{(k+1)}-Ux^{(k)}) \\] \\(\\omega\\)称为松弛因子，当 \\(\\omega =1\\)时，即为Gauss-Seidel迭代。 最终格式为： \\[ x^{(k+1)}=S_\\omega x^{(k)}+f_\\omega \\] \\(S_\\omega =(D+\\omega L)^{-1}[(1-\\omega)D-\\omega U]\\) \\(f_\\omega =\\omega (D+\\omega L)^{-1}b\\) 迭代格式的收敛性 迭代法基本定理 Thm：迭代格式 \\(x^{(k+1)}=Bx^{(k)}+f\\)收敛的充分必要条件是 \\(\\rho(B)&lt;1\\) Thm：若迭代格式 \\(||B||&lt;1\\)，则\\(x^{(k+1)}=Bx^{(k)}+f\\)收敛。「Thm：对于任意范数(A)||A||」同时：（误差的先验估计和后验估计） \\(||x^*-x^{(k+1)}||\\le ||B||~||x^*-x^{(k)}||\\) \\(||x^*-x^{(k)}||\\le \\frac {||B||}{1-||B||} ||x^{(k)} - x^{(k-1)}||\\) \\(||x^*-x^{(k)}||\\le \\frac {||B||^k}{1-||B||} ||x^{(1)} - x^{(0)}||\\) Jacobi迭代和Gauss-Seidel迭代的收敛性 Jacobi迭代法收敛\\(\\iff\\rho(J)&lt;1\\) Gauss-Seidel迭代法收敛\\(\\iff \\rho(G)&lt;1\\) 严格行对角占优： \\(|a_{ii}|\\ge\\sum_{j,i\\ne j}|a_{ij}|\\) 严格列对角占优：\\(|a_{jj}|\\ge\\sum_{i,i\\ne j}|a_{ij}|\\) 引理 若A是严格对角占优的，则 \\(|A|\\ne0\\) Thm 如果对于矩阵 \\(Ax=b\\) 是严格对角占优的，则Jacobi迭代和Gauss-Seidel迭代收敛。 SOR迭代法的收敛性 Thm SOR迭代收敛的必要条件是 \\(0&lt;\\omega&lt;2\\) Thm 若A对称正定，且 \\(0&lt;\\omega&lt;2\\)则SOR迭代法收敛 Thm 若A对称正定，则Gauss-Seidel迭代法收敛 Homework ：P124:28 30 32(1,2) 34 幂法和反幂法 求主特征值的方法 Def（主特征值）若将\\(A\\)线性无关的特征向量对应的特征值\\(\\lambda_j\\)按模大小排列，有\\(\\max{|\\lambda_j|}=|\\lambda_1|\\)为主特征值。 Thm 幂法： \\[ \\begin{cases} u_0=v_0\\\\v_k=Au_{k-1}\\\\m_k=\\max(v_k)\\\\u_k=v_k/m_k \\end{cases} \\] Thm 若满足\\(|\\lambda_1|&gt;|\\lambda_2|\\ge\\cdots\\)，则通过幂法得到的序列有如下极限： \\[ \\begin{cases} m_k\\rightarrow \\lambda_1\\\\u_k\\rightarrow \\frac{x_1}{\\max x_1} \\end{cases} \\] 反幂法 求最小特征值：用\\(A^{-1}\\)代替\\(A\\)计算","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数值分析","slug":"数值分析","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"}]},{"title":"Hexo in 30 Minutes","slug":"talk-chat/hexo-in-30-minutes","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-08T14:25:55.702Z","comments":true,"path":"2022/01/08/talk-chat/hexo-in-30-minutes/","link":"","permalink":"http://adversarr.github.io/2022/01/08/talk-chat/hexo-in-30-minutes/","excerpt":"三十分钟实现你的Hexo博客。","text":"三十分钟实现你的Hexo博客。 Prerequisite一定的命令行操作基础（cd等基础命令的使用）（可能需要）科学上网，以登入 Github一定的耐心（来调bug）软件上：代码编辑器，例如vscodeNode.jsgit：下载地址tuna点右侧的获取下载链接按钮，找Git。安装时全默认即可。 创建你的 Github 账号和与你的账号关联的repo Reference: https://pages.github.com Github 账号 这个超级简单，就不展开了，但需要记住你的 username（例如我的是Jerryyang2001） 创建repo repo创建时，必须满足： Public访问权限（通过下面的选项来确定） 名字：必须是 username.github.io 例如： 测试效果 实际上，你已经完成了这里面（https://pages.github.com）最难的一个部分，下面要测试你的网站的代码仓库是否成功创建： 配置网站 下载 repo 到本地 首先，先打开一个terminal（Windows下的Powershell），并且用cd命令转到一个用来存放你的网站源码的文件夹，例如我的： cd D:/Documents/Repositories/ 通过： git clone https://github.com/username/username.github.io 来下载你这个网站对应的代码。 打开你的repo 首先，你需要一个vscode（或者sublime，或者任何一个轻量级的代码编辑器），用它打开这个repo的文件夹（想必大家都很熟悉） 这个时候，如果你不放心是否你的repo已经设置好了，可以看看这里 创建一个新的 index.html 文件内容简单的写一句：Hello world!就可以了～然后将它push到远端：git add --allgit commit -m &quot;Initial commit&quot;git push -u origin main然后稍微等等，然后访问：https://username.github.io网站，应该就能看到结果。 npm install -g hexo-cli 接着，执行： hexo init .npm install 然后，在当前文件夹应该就能看到hexo和npm自动生成了你的blog源码，配置好了相关环境。从这里起，你的Blog之旅将正式开始。 站点配置 一个Hexo站点主要由五部分组成： 软件框架环境（Hexo、Nodejs等） 主题文件（一个主题 一个文件夹，可以通过npm指令安装，也可以直接放在themes文件夹下） sourse文件夹下的blog内容，markdown格式 其中的_posts为内容 其他的文件夹下为一些特殊页面的内容，例如about me，categories，tags页面的布局和特殊设置 不同的branch！一般而言，repo中需要包含【源代码】和用源代码生成的、用于给用户看到的【网页源码】，但是【网页源码】和【源代码】不需要放在一起，就像开发人员开发了一个app，给你的只是一个软件，而不是源代码一样。我们希望实现这样的功能 在一个分支部署网站，用来存放【网站源码】，供github自动部署。 在另一个分支存放自己的源代码。例如： github远端 部署 https://hexo.io/docs/one-command-deployment 只有Git章节有用 先讲讲第四部分，就是不同的branch组织源码库。这一部分需要： npm install hexo-deployer-git --savegit branch gh-pages-sourcegit checkout gh-pages-source 然后在你的_config.yml文件中添加： deploy: type: git repository: git@github.com:username/username.github.io.git branch: master # 这里就是你存放【网站源码】的地方 message: Site updated:&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;) 然后试试看： hexo deploy 就能直接把生成的【网站源码】push到github仓库中，让github自动部署网站到username.github.io。 当然你也可以在 github repo 的设置中设置你想要的branch作为【网站源码】的路径 资料 我正在用的主题：Volantis 曾经用过，感觉还行的一个主题：Fluid文档 Fluid 官网 一些更多的折腾资料： 一定要多看 hexo 的官网介绍： 一键部署 站点基础组织结构 站点配置文件 当然也可以： 如果你懒的话，也可以直接clone我的源码嘛。毕竟都是配置好的东西，拿来就用就是了。（记得把我的内容全都删了） 在clone完我的源码之后需要注意的是： 我的【源代码】在gh-pages-volantis分支下。记得checkout到这个分支上，然后： 删除sourse/_posts文件夹下的所有文件 修改sourse/about sourse/categories sourse/chat 等源码中的一些不属于你的标题…… 修改所有的config文件中的东西（_config.volantis.yml 和 _config.yml 就这样？后面挺复杂的（细节太多了）各位慢慢摸索吧，百度上都有相应的解决方案的。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://adversarr.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"数据库原理","slug":"study/ComputerScience/fragments/DB2021","date":"2021-12-26T16:00:00.000Z","updated":"2022-04-06T03:32:23.577Z","comments":true,"path":"2021/12/27/study/ComputerScience/fragments/DB2021/","link":"","permalink":"http://adversarr.github.io/2021/12/27/study/ComputerScience/fragments/DB2021/","excerpt":"数据库原理复习提纲。","text":"数据库原理复习提纲。 引言 数据管理的发展 数据密集型应用 数据密集型应用 数据量大 数据不随程序的结束而消失 数据为多个 app 共享 数据库对比文件系统： 编写应用程序很不方便 文件设计难以满足多种应用程序的不同要求 → 产生数据冗余 文件结构的修改导致应用程序修改，应用程序的维护工作量大 文件系统一般不支持文件的并发访问 数据库系统 DBMS — 管理数据库的软件 → 数据库的核心 DBA — 数据库管理员 数据库系统 — app+DBMS+DBA 现代 DBMS 的功能： 提供高级的数据接口（抽象出物理存储的细节 → 物理形式和逻辑形式能够互相映射、GUI、非过程的 sql 语言） 查询处理和查询优化（性能） 数据目录管理（包含数据的逻辑属性、存储结构定义、访问、管理的信息） 并发控制 恢复功能 完整性约束检查（数据在语义上的约束—完整性约束） 访问控制 数据管理—如何有效的组织、存储、维护和使用大量的相关数据 数据库 — 利用计算机进行数据管理的一种技术 数据库中的数据的性质数据库是一个按数据结构来存储和管理数据的计算机软件系统。与数据文件相比，有如下的优点：数据库中的数据具有数据整体性数据库中的数据具有数据共享性用法不同 -为用户提供不同的数据是图，满足个别用户对于数据结构、数据命名、约束条件的特殊要求同时共享 - 不同的用户可以同时存取数据库中的同一个数据和文件系统相比的主要特点：以数据模型为基础数据冗余度小、数据共享度高数据和程序之间具有较高的独立性物理独立性：指应用程序对于数据存储结构（物理结构）的依赖程度。逻辑独立性：应用程序对于数据全局逻辑结构的依赖程序。通过 DBMS 实现数据安全性和数据完整性控制最小存取单位是数据项 数据库系统发展 手工管理数据阶段 不保存大量的数据没有软件系统对于数据进行管理没有文件的概念数据组成和数据存储过程必须由程序员自行设计一组数据对应一个程序相同数据重复多 文件系统管理阶段 特点：管理的数据以文件的形式存储在计算机的外村中文件系统由专门数据管理软件提供有关数据的存取、查询、维护功能文件系统的数据文件已经具有对氧化文件系统的数据存取是以记录为单位缺点：表现数据冗余度大（Redundancy）缺乏程序间的独立性反映数据文件为某一特定应用服务，可重复使用率低数据的逻辑结构改变时，必须改应用程序，修改文件结构的定义反之，应用程序的改变，影响文件数据结构的改变 数据、数据模型、数据模式 数据 对事物描述的符号记录是数据 从数据中获取有意义的内容 → 信息 数据是信息的一种存在形式，通过解释处理才成为有用的信息 数据模型 数据模型是用来描述数据的一组概念和定义，数据库的设计基础是数据模型。 例如：层次模型、网状模型、关系模型等 数据结构：数据的静态属性 → 数据的基本结构、数据间的联系(、数据的约束) 数据操作：数据的动态属性 → 定义在数据上的操作 数据约束条件 数据模型应该能自然的反应现实世界、接近现实世界的观察和理解；同时接近数据在计算机中的物理表示，便于实现、减少开销。 概念数据模型（需求导向）：面向用户的、面向现实世界的数据模型，和 DBMS 无关，是用来描述一个单位的概念化结构。 和 DBMS 无关 需要相关工作人员的参与 常常用 ER 图表示 逻辑数据模型 — 用户从数据库看到的数据模型 和 DBMS 有关 关系数据模型是目前最常用的逻辑数据模型 面向用户 且 面向实现 物理数据模型 — 数据的逻辑结构（文件、记录、字段等）不反映存储结构，例如物理块、指针、索引等 和 DBMS 有关、和 OS 和硬件有关 对某一类数据的结构、联系、约束的描述（型的描述），成为数据模式。 例如： 数据模式： (name, id, gender, birth)数据实例： (yang, 615, male, 2001) 有三级数据模式结构： 概念模式（逻辑模式）：用逻辑数据模型对一个单位的数据的描述 — 最基础任务 外模式 — 对用户用到的数据描述（从概念模式推导） — 逻辑数据模型 内模式 — 物理数据模型对数据的描述（和内模式相互映射） — 物理数据模型 关系为： 概念数据库是物理数据库的逻辑抽象形式。 物理数据库是概念数据库的具体实现 用户数据库是概念数据库的子集、是物理数据库子集的逻辑描述 三级数据模型 概念模式 包括：数据记录型、数据项的型、记录间联系的描述安全性定义、数据库完整性约束、寻址方式等目的：减小数据冗余实现数据共享对所有用户的数据进行综合抽象的全局统一视图 外模式 对于各个用户或程序设计的数据逻辑结构和数据特征的描述。设计对于子模式的数据结构、数据域、数据构造规则和数据安全性和完整性等属性的描述。优点如下：不必考虑与自己无关的数据，无需了解数据的存储结构，简化用户、程序设计工作有利于数据的安全和保密有利于数据的独立性和共享性 内模式和物理数据库 对于数据的内部表示、底层描述。设计目标：将全局逻辑模式组织称最优的无力模式，提高数据的存取效率，改善系统的性能指标。在数据库系统中，只有物理数据库是真实存在的，是存放在外存中的数据文件。 graph LR内模式 --&gt; a[概念模式] --&gt; 外模式1 --&gt; 用户1a--&gt;外模式2--&gt;用户2a--&gt;外模式3--&gt;用户3 物理独立性是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。即，数据在磁盘上怎样存储由 DBMS(DataBase Management System 数据库管理系统)管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变。 逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的，即： 当数据的逻辑结构改变时，用户程序也可以不变。 数据、数据模型、数据模式区分 数据(data)，数据模型(datamodel)，数据模式(data schema)区分数据数据是对事物描述的符号记录，是信息的存在的一种形式，只有经过解释和处理才能成为有用的信息。数据使用数据操作语言(DML)进行修改和访问数据模型模型是现实世界特征的模拟和抽象。数据模型是现实世界数据特征的抽象，用来描述某种数据的概念和定义。数据模型通常由数据结构、数据操作、完整性约束三部分组成。使用数据模型描述数据时不仅要描述数据本身，还要描述数据之间的联系。其中，三级数据模型分别为：概念数据模型、逻辑数据模型、物理数据模型。数据结构：数据结构是对系统静态特性的描述。常见结构有层次结构、网状结构、关系结构。数据操作：数据操作是对系统动态特性的描述。指对数据库中各种对象(型)的实例(值)运行执行的操作的集合，包括操作及有关操作的规则。数据库主要有检索和更新两大类操作，数据模型必须定义这些操作的确切含义、操作符号、操作规则(优先级)以及实现这些操作的语言。完整性约束：数据的约束条件是一组完整性规则的集合。完整性规则用以限定符合数据模型的数据库的状态以及状态的变化，以保证数据的正确、有效、相容。数据模式数据模式是以一定的数据模型对一个单位的类型、结构、及其相互间的关系所进行的描述。数据模型有型与值之分，型——框架，值——实例。ps:数据模型是描述现实世界数据的手段、工具。数据模式是利用这个手段和工具对具体对象相互间关系所进行的描述。是关于型的描述。数据模型可类比为c 语言，数据模式可类为 c 语言编写的程序。数据库的三级模式(levelsof abstraction)物理模式 physical schema(内模式):表示数据库的存储结构逻辑模式 conceptual/logical schema:定义了数据模型的逻辑结构外模式 external schema(视图view):对用户所用到的那部分数据的描述物理模式、逻辑描述、外模式都存储与数据目录中，是数据目录的最基本内容。DBMS通过数据目录管理和访问数据模式。模式使用数据定义语言(DDL)定义。数据模式、数据模型数据模型是描述数据的手段，而数据模式是用给定的数据模型对具体数据的描述。三级数据模式、两级数据映像两级映像：外模式/模式映像。模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。数据库中的同一模式可以有任意多个外模式，对于每个外模式，都存在一个外模式/模式映像，它确定了数据的局部逻辑结构与全局逻辑结构之间的对应关系。例如，在原有的记录型之间增加新的联系，或在某些记录型中增加新的数据项时，由数据库管理员对各个外模式/模式映像作相应改变，这一映像功能保证了数据的局部逻辑结构不变（即外模式保持不变）。由于应用程序是根据数据的局部逻辑结构编写的，所以应用程序不必修改，从而保证了数据与程序间的逻辑独立性。模式/内模式映像。数据库中的模式和内模式只有一个，所以模式/内模式映像是唯一的。它确定了数据的全局逻辑结构与储存逻辑结构之间的对应关系。存储结构变化时，如果采用了更先进的存储结构，由数据库管理员对模式/内模式映像作相应的变化，使其模式仍保持不变，即把存储结构变化的影响限制在模式之下，这使数据的存储结构和存储方法较高地独立于应用程序，通过映像功能保证数据存储结构的变化不影响数据的全局逻辑结构的改变，从而不必修改应用程序，即保证了数据的物理独立性。好处：保证数据独立性。将模式和内模式分开，保证了数据的物理独立性；将外模式和模式分开，保证了数据的逻辑独立性。简化了用户接口。按照外模式编写应用程序或输入命令，而不需要了解数据库内部的存储结构，方便用户使用系统。有利于数据共享。在不同的外模式下可以有多个用户共享系统中数据，减少了数据冗余。有利于数据的安全保密。在外模式下根据需要进行操作，只能对限定的数据操作，保证了其他数据的安全。 数据独立性(database independence) 两级数据独立性分别为逻辑数据性和物理独立性，数据独立性表示应用访问数据库时不受数据结构和存储的影响。即在我们修改数据之间的关系和数据的存储方式之后，我们无需对应用进行修改，而只需修改物理模式到逻辑模式及逻辑模式到外模式的映射。(因为应用访问的是外模式下的数据，我们只需保证用户看到的数据库视图不变) 数据独立性为什么越高越好要回答独立性具体是什么（物理独立性、逻辑独立性）与此同时阐明 独立性的意义即可总的来说：数据的物理独立性：数据的存取和程序分离，数据存储结构与存取方法改变不要求修改程序使得数据共享成为可能，只要知道数据测存取结构，不同程序可以共用同一个数据文件数据的逻辑独立性：数据的使用和数据的逻辑结构分离数据独立性是指建立在数据的逻辑结构和物理结构分离的基础上，用户以简单的逻辑结构操作数据而无需考虑数据的物理结构，转换工作由数据库管理系统实现。数据独立性分为数据的物理独立和数据的逻辑独立。 数据模型 层次数据模型 网状数据模型 关系数据模型 基本概念和定义 属性、域 属性（attribute） — 描述事物的特征 域（domain） — 属性可以取值的范围。 1NF 的限制 — 所有的域都是原子数据 有条件的有 NULL 存在 关系、元组 \\[ R=(A_1/D_1, \\cdots, A_n /D_n) \\] 上式事对于\\(R\\)的型的描述。→ R 的模式 \\[ r = \\{ t_1, t_2 \\cdots , t_m\\} \\] \\(r\\)是 \\(R\\) 的一个值。 一般来说，关系模式相对稳定、关系的值相对变化 键 候选键 candidate key— 唯一决定一个元组的“最小”集合 超键 superkey — 一个真子集是候选键 主键 primary key 全键 all key 主属性 prime attribute — 包含在任何一个候选键中的属性 非主属性 non-prime attribute 外键 foreign key 约束 完整性约束 — 语义限制。一般有四类 域完整性约束（最基本的、最简单的） 实体完整性约束 引用完整性约束 一般完整性约束 常用的两个完整性约束域完整性约束: 插入属性的值是否符合值域实体完整性约束: 主键不能为空引用完整性约束: 外键要么是空缺的要么是实际存在的主键值 操作 关系代数操作— 关系操作。（关系专用、集合操作） 选择操作： \\(\\sigma_C(R)\\) 投影操作： \\(\\Pi_A(R)\\) 集合操作：交并补 连接操作：连接、等连接、自然连接 除操作： \\(R\\div S = \\Pi _X(R) -\\Pi _X(\\Pi_X(R) \\times S) - R)\\) 外连接操作 外并操作 关系演算 元组关系演算 投影 选择 并 差 连接 和关系代数有相同的表达能力 — 关系完备 基本形式为： \\[ \\{t|P(t)\\} \\] 其中，\\(t\\)为元组变量。 其中 \\(P(t)\\) 可以由： \\(s\\in R,s[A]\\text{ op } C,s[A]\\text{ op } u[B]\\) \\(\\neg P\\) \\(P_1\\vee P_2,P_1\\wedge P_2\\) \\(\\exists t\\in R.P(t),\\quad \\forall t\\in R.P(t)\\) 对传统数据模型的评价 继承了文件的字段、记录的概念 物理级 — 借鉴了文件索引、散列的存取方法 — 在记录的基础上定义了各自数据的基本结构，约束和操作 向用户提供了统一的数据模型和相应的数据库语言。 以记录为基础，不能很好的面向用户和应用 不能以自然的方式表示实体之间的联系 语义信息贫乏 数据类型少、难以满足需要 ER 数据模型 基本概念 E-R 模型— 实体联系数据模型 → 面向现实世界的，不考虑如何实现 提出目的： 建立一个统一的数据模型来概括三种传统数据模型 作为三种传统数据模型转换的中间模型 作为超脱 DBMS 的一种概念数据模型，以比较自然的方式模拟现实世界 三类抽象概念： 实体 属性 联系 ER 图 SQL 集数据定义语言(DDL),数据操纵语言(DML)，数据控制语言(DCL)功能于一体 可以独立完成数据库生命周期中的全部活动 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行 数据操作符统一 高度非过程 面向集合的操作方式 以同一种语法结构提供多种使用方式 语言简洁，易学易用 数据库的用户接口 DBMS 需要给用户提供命令和语言 → 非过程性语言 → SQL SQL 语言概况 四个部分： DDL → 数据定义语言 QL → 查询语言 DML → 增删改 DCL → 权限控制 数据定义语言 术语、数据类型 在 SQL 中，表分为： 基表 base table 视图 view create table student (sno char(7) not null, sname varchar(8) not null, ... height dec(5,2) default 0.0, primary key(sno));注意要写分号 基表模式的修改 alter table[&lt;creator&gt;, ...] &lt;table_name&gt; add &lt;column_name&gt; &lt;type&gt;;drop table &lt;name&gt;;alter table &lt;table_name&gt; add primary key (&lt;column_name&gt;);alter table &lt;table_name&gt; drop primary key;alter table &lt;t1&gt; add foreign key [&lt;fk_name&gt;] (&lt;column_name&gt;) references &lt;t2&gt; [on delete&#123;restrict|cascade|set null&#125;]; SQL 查询语言 基本 SQL 查询 select ... from ... where ... 一些例子 Union 操作的实现 select ...UNIONselect ... 和： select ...from ...where c1 or c2 Intersect 操作的实现 select ... from ... where ...INTERSECTselect ... from ... where ... 和： select ...from ...where c1 and c2 嵌套查询 select ...from ...where exists (select ... from ... where ...) 需要考虑是否消除非闭包运算。 找出只被 1 个水手预定的船 select bidfrom reserves r1where bid not in( select bid from reserves r2 where r2.sid != r1.sid); 只被 1 个预定 iff 对于第一个人，不存在第二个人也预定了这条船 除法 用集合差实现：不存在一个船，不被这个人预定。 select s.namefrom sailors swhere not exists (select b.bid from boats b except select r.bid from reserves r where r.sid = s.sid) 不用集合差实现：不存在不被我预定的船 select s.namefrom sailors swhere not exists( select b.bid from boats b where not exists( select r.bid from reserves r where r.bid = b.bid and r.sid = s.sid)) 其他的集合比较操作 EXIST IN UNIQUE ANY/ALL 聚合函数 count, sum, avg, max, min 分组 GROUP-BY select [distinct] target-listfrom relation-listwhere qualificationgroup by grouping-listhaving group_qualification 需要满足： group_qualification 单值 target-list 必须包含一个 group-list 的子集 嵌套查询汇总 分为 3 类： 标量子查询 表表达式 公共表表达式 递归查询 with agents(name, salary) as ((select name, salary from FedEmp where manager = &quot;Hover&quot;) union all (select f.name, f.salary from agents as a, FedEmp as f)) 实质上是不动点算法 SQL 操纵语言 insert insert into T(attr-list) values (...) delete delete from sc where c; update update xxxset new-valswhere condition 视图 create view xxx as &lt;SQL-statement&gt; 和表的区别 从基表或其他视图导出的虚表， 对于查询：原则上可以操作 对于更新，有三个要求： 三个基表的主键都在视图中 → 可以唯一确定构成它的元组 …… 嵌入式 SQL 主要是嵌入式 C 语言 说明部分 sql 语句需要用 EXEC SQL 开头。例如 EXEC SQL BEGIN DECLARE SECTION; char SNO[7]; char GIVENSNO[7];EXEC SQL BEGIN DECLARE SECTION; 可执行语句 例如 EXEC SQL SELECT GRADE INTO: GRADE, : GRADEI FROM SC WHERE SNO=:GIVENSNO AND CNO=:GIVENSNO; 使用游标需要下面四条语句 说明游标 EXEC SQL DECLARE &lt;cursor-name&gt; CURSOR FOR SELECT ... FROM ... WHERE ... 打开游标 EXEC SQL OPEN &lt;cursor-name&gt;; 取数语句 EXEC SQL FETCH &lt;cursor-name&gt; INTO: hostvar1, hostvar2, ...; 关闭游标语句 EXEC SQL CLOSE &lt;cursor-name&gt;; 完整实例 简单版本： EXEC SQL DECLARE C1 CURSOR FOR SELECT SNO, GRADE FROM SC WHERE CNO = :GIVENCNO;EXEC SQL OPEN C1;while (TRUE)&#123; EXEC SQL FETCH C1 INTO :SNO, :GRADE, :GRADEI; if (SQLCA.SQLCODE == 100) // 表示当前游标中的数已经取完 break; if (SQLCA.SQLCODE &lt; 0) // 出错 break; 处理游标&#125;EXEC SQL CLOSE C1; 复杂一些的，打印绩点在 3.5 以上的学生名单： // 说明部分EXEC SQL BEGIN DECLARE SECTION; char sname[20];EXEC SQL END DECLARE SECTION;// 游标说明EXEC SQL DECLARE student_cursor CURSOR FOR SELECT sname FROM student WHERE gpa &gt; 3.5;// 打开游标EXEC SQL OPEN student_cursor;while (true)&#123; // 取数 EXEC SQL FETCH student_cursor INTO :sname; if (SQLCA.SQLCODE == 100) break; if (SQLCA.SQLCODE &lt; 0) break; printf(&quot;%s\\n&quot;, sname);&#125;// 关闭游标EXEC SQL CLOSE student_cursor; 几个环节都不能少 数据库管理系统 基本功能 → 安全可靠的执行数据库语言的语句 事务 事务是 DBMS 的执行单位，它由有限个数据库操作序列组。事务有 ACID 性质： 原子性（Atomic）：遵守 nothing or all 的原则 — 不允许部分完成 更新操作的保持一致性（Consistency）：事务对数据库的作用应该让数据库从一个一致状态 隔离性（Isolation）：如果多个并发的事务执行，应该和各个事务独立执行相同 持久性（Durability）：成功执行的事务，对数据库的影响是持久的，可恢复的 上述四个性质被称为 ACID 准则 DBMS 的进程结构 以进程为执行者的缺点 创建、撤销、切换、通信开销大 并发运行的进程数量过多 → 系统开销太大 → 性能下降 不利于事务共享内存空间 以线程为执行者的优点： 按照 DBMS 的需要进行线程调度 线程切换可以在操作系统的用户态进行，不必进入内核态 提高可移植性 存储结构 DMBS 的系统结构 集中式 分布环境下的客户、服务器结构 Web 下的三层客户、服务器结构 高可用、高缩放、高性能的数据库系统结构 数据目录 数据目录是关于数据的数据 → 元数据 DBMS 的任务是管理大量的、共享的，持久的数据。关于数据的定义、描述必须长期保存在系统中 → 数据目录。 数据目录中的数据按易变程度可以非为两类： 一类来自基表、视图和索引 — 相对稳定 一类来自数据库状态的统计 — 进程变化 数据库存储介质的特点 数据库是大量、持久数据的集合 内存/磁盘： 容量 易失存储器 成本 磁盘 — 物理存储以块为单位 延迟写入、预先读取 记录的存储结构 物理表示 记录分为若干的字段、每个字段有一个域、有定长和变长的区别，大致有是那种： 定位法 相对法 — 变长 计数法 — 变长 物理块上的分配 记录必须分配到物理块中： 不跨块组织 跨块组织 数据压缩 文件结构和存取路径 对数据库的操作最重要落实到对于文件的操作。文件的访问方式大致有： 查询全部 or 相当多的记录 ≥15% 查询特定记录 查询某些记录 — ≤ 15% 范围查询 数据更新 数据库对于文件的要求 需要附加信息 — 文件目录、文件描述块、物理块等部分； 传统的文件系统主要面向批处理。但数据库要求即时访问、动态修改； 传统文件都是为某一用户或某类用户服务的，用途单一；数据库文件需要被所有用户共享 采用文件管理系统 → 不利于移植 传统文件一旦建立，数据稳定；数据库的文件数据量变化大，文件结构应该能适应这样的变化。 文件的基本类型 堆文件 最简单、最原始的一种文件结构 不是所有记录都物理邻接 唯一的存取路径是：顺序搜索（扫描） 排序费时、需要解决空间回收问题 直接文件 记录的某一个属性用散列函数直接映射成记录的地址，散列的属性称为散列键 地址空间固定 只对于散列键到记录的访问有效 不便于处理变长记录 散列函数难找 索引文件 如果以主键为索引键，则称该索引为主索引 与此同时更新时也用主索引做主键唯一性检查 主要分为非稠密索引、稠密索引 索引分类主索引（索引是主键）按主键排序-非稠密索引不按主键排序 - 稠密索引次索引簇集索引 - 按索引键排序并簇集，稠密非簇集索引 - 不安索引键排序，稠密 优缺点提高查询的效率更新时，增加了维护的开销。 - 根据应用的要求选择。如果在文件的所有属性上都建立索引，则称为倒排文件。有利于多属性条件的查找数据更新时开销很大 非稠密索引不为每个键值都设立索引项的索引称为非稠密索引。同一时间，只能为一个索引键（一般是主键）建立非稠密索引。当某个单元的存储区溢出，则可以放在溢出区。可以节省索引的存储空间要求对于文件按索引键排序溢出过多时，指针链接次数增加，性能下降 稠密索引记录不按索引键排序，每个键值都有一个索引项。如果键值不唯一，那么对应的是一个地址集。 对于次索引，一个键值可能对应多个记录。如果它们分散在不同的物理块中，则索引带来的好处有时是有限的 -- 并不能减少 io。为了解决这个问题，开发了簇集索引。簇集索引的缺点如下： 建立开销大、整个文件都要重新组织，建立的索引也要重建。 对于和索引键相关的查询有力，对于与簇集索引键无关的访问没有影响。 动态索引 静态索引：多分树 动态索引：B-树、B+树 索引集的节点结构： 节点类型|索引键数|P0|K0|P1|K1|...|Kn-1|Pn （主索引）顺序集的节点结构 节点类型|索引键数|前向指针|后向指针|K0|tid0|K1|tid1|...|Kn|tidn （次索引）顺序集节点结构 类型|块中索引键数|前向指针|后向指针|K0|P0|...|Kn-1|Pn-1 P和tid的区别这里，由于次索引的一个键值可能对应了多个TID，数量可变，所以需要一个块来存放这些tid（可以组成链表存储） tid 由块号和块中的指针号组成。这样在块中移动的时候不需要修改 B+树索引的 tid，只需要修改指针号对应的块内指针。 B+树有如下的约束： 秩为 k 的 B+树每个节点最多有 2k 个键值 根节点至少有一个键值、其他节点至少有 k 个键值 除了叶节点（顺序集节点）没有子女外，其他的节点，若有 J 个键值，则有(J+1)个子女 所有叶节点都在树的同一级上（树保持平衡） B+树相关计算B+树实现的索引都是稠密索引。保证其提供顺序搜索功能。搜索 B+树所需 IO 次数取决于级数。级数取决于 N（不同的索引键值对数-区别于记录数）。若顺序集为 L级、秩为 k，则顺序集至少有\\(2(k+1)^{L-2}\\)个节点。\\[N \\ge 2 (k+1)^{L-2} \\times k\\]那么对于 L 做估计：\\[L\\le 2 + \\log_{k+1}(N/2k)\\approx 1 + \\log_{k+1} N / 2\\] 查询优化 查询语句 → 查询结果的处理过程 — 查询处理 DBMS 需要确定一个合理有效的执行策略 — 查询优化 不同方法： 对查询语句本身变换 — 代数优化 对根据系统所提供的存取路径的优化，选择合理的存取策略 — 物理优化 代数优化 基本原则为： 尽量所见查询过程中的中间结果 选择和投影先做 → 二元操作 连接时先做小关系的连接，再做大关系的连接 公共表表达式 具体而言： 以 select 子句对应投影操作、From 子句对应笛卡尔成绩、Where 子句对应选择操作，生成原始查询树 应用变换规则： \\(\\sigma\\)的交换律 $_C(RS) = _C(R)S $其中 \\(Attr(C)\\subseteq Attr(R)\\) \\(\\sigma_{C_1 \\wedge C_2}(R\\times S) = \\sigma_{C_1}(R)\\times \\sigma_{C_2}(S)\\)其中 \\(Attr(C_1)\\subseteq Attr(R)\\)\\(Attr(C_2)\\subseteq Attr(S)\\) 交、并、差运算对于 \\(\\sigma\\)的分配律 投影和集合并运算的分配律 应用连接和笛卡尔积的结合律，按照小关系先做的原则，重新安排连接的次序 如果笛卡尔乘积后还需要按照按连接条件进行选择操作，可以将两者组合成连接操作 对叶节点进行必要的投影操作，消除对于查询无用的属性。 物理优化 — 依赖于存取路径的规则优化 选择操作实现和优化 选择条件有等值、范围、集合之分。 最原始的实现方法：顺序扫描。 B+树索引、Hash 散列 连接操作的实现和优化 嵌套循环法：应当将物理块绍的关系作为外关系 利用索引或散列寻找匹配元组法 归并排序法：需要 RS 都按照连接属性排序 散列连接法 投影操作的实现 如果在投影的属性集合中没有主键，投影结果中可能出现重复元组 → 排序或散列去重 集合操作的实现 笛卡尔积一般用嵌套循环法实现 — 少用 组合操作 事务 恢复引论 主要可能有四类错误： 事务内部的故障：事务在运行至正常终点前被终止 有的是可以由事务程序发现的，有些是非预期的事务终止；事务可以通过 rollback 修复预期之中故障，更多的故障是非预期的，如运算溢出、死锁 系统故障（软故障）：CPU 错误、系统断电等造成的系统运转停止 系统故障不破坏数据库，只会造成事务的非正常终止，内存中数据库缓冲区丢失 系统故障的恢复需要： 撤销（undo）所有未完成的事务（事务非正常终止） 重做（redo）所有已提交的事务（有些已完成的事务可能有部分留在缓冲区尚未写入数据库） 介质故障（硬故障）：磁盘损坏、强磁场干扰造成的介质故障 计算机病毒 两个措施： 可靠性 故障恢复 对于恢复：数据冗余是必须的。 单纯以后背副本为基础的恢复技术 以后备副本和运行记录为基础的恢复技术 前像 BI — 更新前的映像 — undo 后像 AI — 更新后的映像 — redo 事务状态： 提交 commit — 成功执行标志 消除事务对数据库的影戏那个 — rollback / abort 用的最多、独立失效模式 基于多副本的恢复技术 — 独立的失效模式 运行记录的结构 记录和数据库一般不在一张磁盘上。 运行记录一般包括： 活动事务表 ATL：正在执行、未提交的事务标识符 TID 提交事务表 CTL：已经提交的事务 TID 前像文件：undo(undo(..undo(x)..)) = undo(x) 后像文件：redo(redo(..redo(x)..)) = redo(x) 更新事务的执行和恢复 更新事务应该满足如下的原则： 提交原则：后像必须在事务提交之前写入非易失存储器中 先记后写规则 因此有三种可能的解决方案，都可以通过判断所在 ATL 和 CTL 的位置来进行恢复。 AI 在 Commit 前写入 TID→ATL BI→log AI→DB,log TID→CTL ATL 删除 TID AI 在提交后写入 TID→ATL AI → LOG TID → CTL AI → DB 从 ATL 删除 TID AI 在提交前后写入 TID→ATL AI, BI → LOG AI → DB（部分） TID → CTL AI → DB（继续） ATL 删除 TID 消息的处理 失效类型和恢复对策 事务失效 事务无法执行、自行夭折（例如没有要访问的数据、输入数据类型不对、除数=0） 操作员操作失误，撤销事务 调度原因，终止事务执行（死锁等） 恢复策略： 丢弃事务的消息队列 如果需要 undo 从 ATL 删除事务的 TID，删除事务资源 系统失效 掉电 除了储存介质故障之外的软硬件故障 策略： 重启 DMBS 和操作系统 恢复到一致状态 存在的问题-CP的意义因为事务可以在提交前和提交后将数据的 AI 分别写入数据库，因此，对于CTL 中的事物只能全部redo，很费时间。虽然可能 CTL 中的很多事务都已经写入，但是鉴别的代价很大 可以设置检查点 CP，来强制写入已提交但没有更新数据库的后像。 取 CP 的过程一般如下： 暂停事务的执行和接受新的事务 上一个 CP 之后的所有事物 AI 写入数据库 在运行记录的 CTL 中记下检查点 恢复数据库、恢复事务的正常运行 好处：对于系统失效恢复，只需要对于最近的检查点之后提交的更新事务进行 redo。 缺点：影响数据库的正常运行。 介质失效 磁盘故障导致的数据库受损。 恢复如下： 修复系统、磁盘 重新启动系统 加载最近的后备副本 用档案存储器内运行记录中的 AI，redo 后备副本之后的所有更新事务 并发控制 数据库系统中的并发 目的 改善利用率和吞吐率 改善短事务的响应时间 问题 丢失更新 — 写-写冲突 读脏数据 — 读-写冲突 读值不可复现 — 读-写冲突 正确性原则 调度 对 n 个事务的安排 目标等价 对于同一个事务集，可能有多种调度。如果其中两个调度在任何初始状态下读出的数据相同，最终数据库状态相同，那么称两个调度是目标等价的。 冲突等价 冲突的操作 — 冲突的操作会影响执行的结果 不冲突的操作 — 次序可以相互调换，不会影响结果 可串行化的 调度和一个串行调度等价 冲突可串行化 → 目标可串行化（充分条件） 一般指冲突可串行化 加锁协议 X 锁 X-排他锁 请求 NL X X y n NL y y 连锁卷回问题过早的释放了锁，导致了读值不可复现。解决方法：锁保持到事务结束 两段加锁 若加锁动作都在所有释放锁之前 — 两段事务 合式事务 Well-Formed 若所有事务都是合式、两段事务 → 可串行化的 加锁机制发展- 提高并发控制能力 应该规定 FCFS SX 锁 S（Share Lock）用于读访问 X（eXclusive Lock）用于写访问 请求 NL S X S y y n X y n y NL y y y SUX 锁 请求 S U X NL S y y n y U y n n y X n n n y NL y y y y 注意 U-U 是不允许的，因为会导致死锁问题。 是否SUX锁能保证没有死锁不能，需要有正确的锁顺序。例如：A: X(a) -&gt; S(b)B: X(b) -&gt; S(a)发生循环等待。可以用相同的加锁顺序来防止死锁发生。 死锁的检测处理和防止 检测、处理 超时法 等待图法 防止 等待死亡法 击伤等待法 关系数据库规范化 规范化的必要性 基本要求： 满足 1NF：每一个分量必须是不可分的数据项 数据库中的数据冗余尽可能少 不能因为数据更新导致数据不一致的问题 不能在执行插入时发生插入一场 不能在执行删除时产生删除一场问题 考虑查询需求，数组组织合理 可能出现的问题： 数据冗余大 插入一场 删除异常 更新异常 关系表示法 关系的简化表示法： \\[ R\\langle U,D,Dom,F\\rangle \\] 分别表示： 关系属性集合\\(U\\) 属性集\\(U\\)中属性的数据域 \\(Dom\\)为从属性到域的映射 \\(F\\) 为函数依赖集 范式 1NF 所有属性都是简单属性（每个属性都不可再分） 2NF 1NF 的前提下，每一个非主属性都完全依赖于码。 3NF 2NF 前提下，不存在这样的码 X、属性组 Y、非主属性 Z，使得 X\\(\\rightarrow\\)Y，Y\\(\\not\\rightarrow\\)X，Y\\(\\rightarrow\\)Z。 BCNF 满足如下条件 非主属性对每一个码都是完全函数依赖 所有主属性对每一个不包含它的码是完全依赖 没有任何属性依赖于非码的任何一组属性 关系模式分解方法 函数依赖闭包 逻辑蕴含的函数依赖全体（从 \\(F\\) 到 \\(F^+\\)） 属性集闭包 对\\(X\\)，从\\(F\\)中能够推出的属性集\\(X_F^+\\) 函数依赖集的等价 闭包相等 函数依赖集的最小化 最小依赖集 满足如下条件 F 中的任一函数依赖的右部只有 1 个属性 不存在函数依赖\\(X\\rightarrow A\\)使得\\(F\\sim F-\\{X\\rightarrow A\\}\\) 不存在函数依赖\\(X\\rightarrow A\\)，\\(X\\)有真子集\\(Z\\)使得\\(F-\\{X\\rightarrow A\\}\\cup\\{Z\\rightarrow A\\}\\sim F\\) 最小依赖集的求法检查函数依赖，对于条件 1 拆分逐个检查函数依赖\\(X\\rightarrowA\\)，检查条件 2，若\\(A\\inX_{F-\\{X\\rightarrow A\\}}^+\\)则从 F 中消除这个依赖逐个检查函数依赖\\(X\\rightarrowA\\)，对于\\(X=B_1\\cdotB_m\\)，若\\(A\\in(X-B_i)^+_F\\)那么用\\(X-B_i\\)取代\\(X\\) 码 设 \\(R\\langle A_1, ..., A_n\\rangle\\) 是一个关系模式，\\(F\\) 是一组函数依赖，如果 X 满足：（1）\\(X\\rightarrow A_1,...,A_n \\in F^+\\)（2）真子集 Y 都不满足（1）条件；那么称 X 是 R 的码。 算法 转化为保持函数依赖的3nf先求出正则覆盖 Fc对于 Fc 里面的所有函数依赖 a-&gt;b,均转化为 Ri=ab对于所有的模式 Ri如果包含候选码，进行第 4如果都不包含候选码， 将任意一个候选码添加到模式 Ri 里面如果一个模式被另一个模式包含，则去掉此被包含的模式。 转化为无损链接、保持函数依赖的3nf求出保持函数依赖的3nf分解 \\(\\rho\\)，设 X 是 R 的码，\\(\\tau = \\rho \\cup \\{ R ^*\\langle X,F_X\\rangle\\}\\)观察新组成的分解模式中，是否存在包含关系，有则去掉被包含的。 例题 【例】关系模型R&lt; U, F&gt;，U={A，B，C，D，E}，F={A→BC，ABD→CE，E→D}算法一：将关系R转化3NF的保持函数依赖的分解第一步：首先计算出F的最小依赖集（算法详见最小函数依赖），得到F'={A→BC，AD→E，E→D}。第二步：观察U中是否有属性不在F'中的出现，如果有，则这个个属性组成一对关系R,并在原来的U中删除这些属性。而例子中U中的属性都出现在F中，则可以跳过这一步。第三步：对F'中的函数依赖，把左边的相同分为一组，一组中出现的所有属性为一个关系。如F={A→B，A→C，……}，左边都为A的分为一组，出项的所有属性组为一个关系R{A，B，C，……}。例题中左边都不相同，所以一个函数依赖组为一个关系得到转化为3NF的保持依赖分解R1{A,B,C}，R2{A,D,E}，R3{E,D}。算法二：将关系R转化3NF的既有无损连接性又保持函数依赖的分解第一步：先将R转化3NF的保持函数依赖的分解，由算法一得出R1{A,B,C}，R2{A,D,E}，R3{E,D}。第二步：求出F的候选码（算法相见候选码算法）得出候选码X为AD和AE。第三步：将候选码单独组成关系得R4{A,D}和R5{A,E}，然后与保持函数依赖后的分解取并集。得R1{A,B,C}，R2{A,D,E}，R3{E,D}，R4{A,D}，R5{A,E}。第四步：观察新组成的分解模式中，是否存在包含关系，有则去掉被包含的。如R3{E,D}，R4{A,D}，R5{A,E}都包含于R2{A,D,E}，则删去，最终得到转化3NF的既有无损连接性又保持函数依赖的分解R1{A,B,C}，R2{A,D,E}。 转换为BCNF无损分解let \\(\\rho = R\\langle U , F\\rangle\\)检查 \\(\\rho\\) 是否满足BCNF对于不满足BCNF的 Ri 分解，因为Ri中必然有 \\(X\\rightarrow A\\in F_i,A\\notinX\\)且X不是Ri的码，XA是Ui的真子集。Ri分解为 \\(\\{S_1, S _ 2\\}\\)，\\(U_{S_1} = XA, U_{S_2} =U_i-\\{A\\}\\)返回2 题目汇总 B+树计算假设物理块的有效大小 B=492 字节，块的指针为 6 字节，Sailors 表的 sid属性 2 字节，sname 占 4 字节，rating 占 1 字节，age 占 1 字节，master 占2 字节。每个记录除属性外，还需增加一个字节作为删除标记。若 Sailors 表的 rating 属性上建有 B+树簇集索引，求 B+树的秩k？（6 分）索引集 ： 2k * 1 (K) + (2k+1)* 6 (P) ≤ 492顺序集 ： 2k * 1 (K) + 2 * 6 (前后向指针) + 2k * 6 (P 因为是次索引) ≤492若 Sailors 表的 sid 属性上建有 B+树的主索引，求 B+树的秩 k？（6分）索引集 ： 2k * 2 + (2k + 1)* 6 ≤ 492顺序集 ： 2k * 2 (K) + 2 * 6 (前后向指针) + 2k * (6+2) (tid= P +块内偏移值 = 6+2，因为是主索引、块有效大小为 492，需要 2B作为块内偏移值) ≤ 492数据块的块因子是指一个块能够存放的记录数目：p = B/(2+4+1+1+2+1) =492/11 = 44 触发器create trigger &lt;trigger_name&gt;&#123;before | after&#125; &lt;trigger_event&gt;on &lt;table_name&gt;[referencing &lt;ref_name&gt;]for each &#123;row | statement&#125;when &lt;condition&gt;&lt;action&gt;&lt;trigger_event&gt;:= insert | update | delete [of &lt;attribute_list&gt;]&lt;ref_name&gt; := old [row] [as]&lt;name&gt; new [row] [as]&lt;name&gt; old table [as]&lt;name&gt; old table [as]&lt;name&gt;其中的action常为：insert into select * from ne where ne.grade &lt; 3.0rollback其中的 insert 语句的语法为：insert into &lt;table_name&gt; values (...)insert into &lt;table_name&gt; [SQL]其中的[SQL]部分为一个查询语句，它导致插入可能不止一个元组。 概念题 什么是基本表?什么是视图?两者的区别和联系是什么? 基本表是实际存储在数据库中的二维表，它是本身独立存在的表，在 SQL中一个关系就对应一个表。区别:视图是从一个或几个基本表(或视图)中导出的表，是一个虚表，数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。视图是关系数据库系统提供给用户以多种角度观察数据库中数据的重要机制。 什么叫数据与程序的物理独立性?什么叫数据与程序的逻辑独立性? 数据与程序的物理独立性是指当数据库的存储结构改变，将模式 /内模式映象作相应改变，使模式保持不变，从而应用程序不必改变。数据与程序的逻辑独立性是指当模式改变时，将外模式 /模式的映象作相应改变，使外模式保持不变，从而应用程序不用修改。 事务所具有的 ACID 特性。 事务的 ACID 特性是:原子性:事务是一个不可分割的单位。一致性:事务对数据库操作的结果是将数据库从一个一致性状态变为另一个一致性状态。隔离性:多个事务的并发执行不互相干扰。持续性:事务一旦提交，它对数据库中数据的改变就是永久性的。 登记日志文件时为什么必须先写日志文件，后写数据库? 答:把数据的修改写到数据库和把对数据的修改操作写到日志文件是两个不同的操作，在两个操作之间可能会发 生故障如果先写了数据库修改，而在日志文件中没有登记这个修改， 在恢复的时候就无法恢复这个修改了;如果先写日志，但没有修改数据库，按日志恢复时只是多执行一次撤消操作，并不影响数据库的正确性，为了安全，一定要先写日志文件。 DBMS的完整性控制机制应具有哪些功能? 应具有三方面的功能:定义功能，提供定义完整性条件的机制检查功能，检查用户发出的操作请求是否违背了完整性约束条件。如果发现用户的操作请求违背了完整性约束条件，则采取一定的动作来保证数据的完整性。 什么是数据字典?数据字典的作用是什么? 数据字典是系统中各类数据描述的集合作用:供 DBMS 在处理数据存取时快速查找有关对象的信息，供 DBA查询掌握系统的运行情况，支持数据库 设计和系统分析。 什么样的并发调度是正确的调度? 多个事务的并发执行的结果与按某一次序串行的执行它们时的结果相同，我们说这样的并发调度是可串行化的调度，如果一个调度是可串行化的，那么认为它是正确的调度。 试叙述事务的 4 个性质，并结实每一个性质由DBMS的哪个子系统实现?每一个性质对 DBS有什么益处? 事务的原子性是指一个事务对 DB的所有操作，是一个不可分割的工作单位。原子性是由 DBMS的事务管理子系统实现的。事务的原子性保证了 DB 的完整性。事务的一致性是指数据不会因事务的执行而遭受破坏。事务的一致性是由DBMS 的完整性子系统实现的。 事务的一致性保证数据库的完整性。事务的隔离性是指事务的并发执行与这些事务单独执行时结果一样。事务的隔离性是由DBMS的并发控制子系统实现的。隔离性使并发执行的事务不必关心其他事务，如同在单用户环境下执行一样。事务的持久性，是指事务对 DB 的更新应永久地反映在 DB 中。持久性是由DBMS 的恢复管理子系统实现的。 持久性能保证 DB 具有可恢复性。 事务的COMMIT语句和ROLLBACK语句的功能是什么? COMMIT 语句表示事务执行成功地接结束(提交)，此时告诉系统，DB要进入一个新的正确状态，该事务对 DB 的所有更新都已交付实施(写入磁盘)。ROLLBACK语句表示事务执行不成功地结束(应该“回退”)此时告诉系统，已发生错误，DB可能处在不正确的状态，该事务对 DB 的所有更新必须被撤消，DB应恢复该事务到初始状态。 日志文件中记载了哪些内容? 答:日志文件中记载了事务开始标记、事务结束标记以及事务对 DB的插入、删除和修改的每一次操作前后的值。 并发操作会产生几种不一致情况?用什么方法避免各种不一致的情况? 答:并发操作可能会产生丢失修改，不能重复读和读”脏”数据这三种不一致情况，采用封锁机制来进行并发控制，可避免各种不一致情况。一级封锁协议可以避免丢失修改，二级封锁协议可以避免丢失修改和读”脏”数据，三级封锁协议可以避免丢失修改、不能重复读和读”脏”数据。 X封锁与S封锁有什么区别? X 锁S 锁只允许一个事务独锁数据允许多个事务并发 S 锁某一数据获准 X 锁的事务可以修改数据获准 S 锁的事务只能读取数据，但不能修改数据事务的并发度低事务的并发度高，但增加了死锁的可能性X 锁必须保留到事务终点根据需要，可随时解除 S 锁解决“丢失更新”问题解决“读不一致性”问题 为什么要设立日志文件 答:设立日志文件的目的，是为了记录对数库中数据的每一次更新操作，从而DBMS可以根据日志文件进行事务故障的恢复和糸统故障的恢复，并可结合后授副本进去介质故障的恢复。 怎样进行系统故障的恢复? 系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤消故障发生时未完成的事务，重做已完成的事务。正向扫描日志文件(即从头扫描日志文件)，找出在故障发生前已经提交的事务(这些事务既有BEGIN TRANSACTION 记录，也有 COMMIT 记录)，将其事务标识记入重做(REDO)队列。同时找出故障发生时尚未完成的 事务(这些事务只有 BEGINTRANSACTION 记录，无相应的 COMMIT 记录)，将其事务标识记入撤消(UNDO)队列。对撤消队列中的各个事务进行撤消 (UNDO)处理。进行 UNDO处理的方法是，反向扫描日志文件，对每个 UNDO 事务的更新操作执行逆操作，即将日志记录中 “更新前的值”写入数据库。对重做队列中的各个事务进行重做 (REDO)处理。进行 REDO 处理的方法是:正向扫描日志文件， 对每个 REDO 事务重新执行日志文件登记的操作。即将日志记录中“更新后的值”写入数据库。 怎样进行介质故障的恢复? 发生介质故障后，磁盘上的物理数据和日志文件被破坏，恢复方法是重装数据库，然后重做已完成的事务。具体地说就是:装入最新的数据库后备副本 (离故障发生时刻最近的转储副本)，使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还须同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法(即REDO+UNDO)，才能将数据库恢复到一致性状态。装入相应的日志文件副本(转储结束时刻的日志文件副本)，重做已完成的事务。即:首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。 数据库在运行过程中可能产生的故障有哪几类? 事物故障事物在运行过程中由于种种原因，如输入数据的错误，运算溢出，违反了某些完整性限制，某些应用程序的错误，以及并行事物发生死锁等，使事物未能运行到正常中指点之前就被撤消了，这种情况称为“事物故障”。系统故障系统故障是指系统在运行过程中，由于某些原因，如 OS 和 DBMS代码错误，操作员操作事物。特定类型的硬件错误(CPU故障)，突然停电等造成系统停止运行，致使事物在执行过程中以非控方式中指。这时。内存中的信息丢失，而存储在外存储上的数据未受影响，这种情况称为“系统故障”。介质故障系统在运行过程中，由于某种硬件故障，如磁盘损坏，磁头碰撞，或由于 OS的某种潜在的错误。瞬间强磁场干扰，使存储在外存的数据部分损失或全部损失，称之为“介质故障”。计算机病毒计算机病毒是一种人为的故障和破坏，它是一种计算机程序，通过读写染有病毒的计算机系统中的程序和数据这些病毒可以迅速繁殖和传播，危害计算机系统和数据库。 怎样进行事务故障的恢复 事务故障是指事务在运行至正常终止点前被中止，这时恢复子系统应利用日志文件撤消(UNDO)此事务已对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。系统的恢复步骤是:反向扫描文件日志(即从最后向前扫描日志文件)，查找该事务的更新操作。对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。这样，如果记录中是插入操作，则相当于做删除操作(因此时“更新前的值”为空)。若记录中是删除操作，则做插入操作，若是修改操作，则相当于用修改前值代替修改后值。继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。 (4)如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。 试述文件系统与数据库系统的区别和联系 文件系统与数据库系统的区别是:文件系统面向某一应用程序，共享性差，冗余度大，数据独立性差，记录内有结构，整体无结构，由应用程序自己控制。数据库系统面向现实世界， 共享性高， 冗余度小，具有较高的物理独立性和一定的逻辑独立性，整体结构化，用数据模型描述，由数据库管理系统提供数据的安全性、完整性、并发控制和恢复能力。文件系统与数据库系统的联系:文件系统与数据库系统都是计算机系统中管理数据中管理数据的软件。 DBA的职责是什么? 决定数据库中的信息内容和结构决定数据库的存储结构和存取策略定义数据的安全性要求和完整性约束条件监控数据库的使用和运行数据库的改进和重组重构 试述查询优化的一般步骤。 把查询转换成某种内部表示把语法树转换成标准(优化)形式择低层的存取路径生成查询计划，选择代价最小的 数据库中为什么要有恢复子系统?它的功能是什么? 因为计算机系统中硬件的故障、软件的错误、操作员的失误以及恶意的破坏是不可避免的，这些故障轻则造成运行事务非正常中断，影响数据库中数据的正确性，重则破坏数据库，使数据库中全部或部分数据丢失。功能:是把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)，这就是数据库的恢复。 数据库转储的意义是什么?常用的有几种方法? 数据转储是数据库恢复中采用的基本技术，所谓转储即 DBA定期将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本或后援副本。当数据库遭到破坏后可以将后备副本重新载入，将数据库恢复到转储时的状态。转储可分为静态转储和动态转储。静态转储是在系统中无运行事务时进行的转储操作。动态转储是指转储期间允许对数据库进行存取或修改。即转储和用户事务可以并发执行。转储还可分为海量转储和增量转储两种方式。 试述使用检查点方法进行恢复的步骤。 从重新开始文件中找到追后一个检查点记录在日志文件中的地址，由该地址在体制文件中找到最后一个检查点记录。由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列:UNDO-LIST:需要执行 undo 操作的事务集合;REDO-LIST 需要执行 redo 操作的事务集合。把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列， REDO 队列暂时为空。检查点开始正向扫描日志文件:如果有新开始的事务 Ti ，把 Ti 暂时放入 UNDO-LIST 队列;如有提交的事务 T j ，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST队列，直到日志文件结束;对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST中的每个事务执行 REDO 操作。 什么是数据库镜像?它有什么用途? 根据 DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS 自动把更新后的数据恢复过去，即 DBMS自动保证镜像数据与主数据的一致性。 用途:一旦出现介质故障， 可由镜像磁盘继续提供使用， 同时 DBMS自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本。在没有出现故障时，数据库镜像还可以并发操作。提高数据库的可用性。 请给出预防死锁的若干方法。 在数据库中，产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。预防死锁通常有两种方法:一次封锁法。一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。顺序封锁法。顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。 请给出检测死锁发生的方法，当发生死锁后如何解决死锁? 答:一般使用超时法或事务等待图法。 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显。一是有可能误判死锁，事务因为其他原因使等待时间超过时限， 系统会误认为发生了死锁。二是时限若设置得太长， 死锁发生后不能及时发现。等待图法：事务等待图是一个有向图 G=(T,U) 。 T为结点的集合，每个结点表示正运行的事务; U 为边的集合，每条边表示事务等待的情况。若 T1 等待 T2 , 则 T1、T2 之间划一条有向边，从 T1指向 T2。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地(比如每隔 1分钟)检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务得以继续运行下去。当然，对撤消的事务所执行的数据修改操作必须加以恢复。 试述两段锁协议的概念。 所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁;在释放一个封锁之后，事务不再申请和获得对该数据的封锁。所谓“两段”锁的含义是，事务分为两个阶段，第一阶段是获得封锁，也称为扩展阶段。在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这个阶段，事务可以释放任何数据项上的任何类型锁，但是不能再申请任何锁。 什么是数据库的完整性约束条件? 答:完整性约束条件是指数据库中的数据应满足的语义约束条件。一般可以分为六类:静态列级约束静态元组约束静态关系约束动态列级约束动态元组约束动态关系约束 试说明数据、数据库、数据库管理系统和数据库系统的概念以及它们之间的关系。 数据(Data)：描述事物的符号记录称为数据。数据的种类有数字、文字、图形、图像、声音、正文等。数据与其语义是不可分的。数据库(Database, 简称DB)：数据库是长期储存在计算机内的、有组织的、可共享的数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。数据库系统(Database System，简称DBS)：数据库系统是指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统(及其开发工具) 、应用系统、数据库管理员构成。数据库管理系统（ Database Management System，简称 DBMS)：数据库管理系统是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据、高效地获取和维护数据。DBMS的主要功能包括数据库的建立和维护功能、数据定义功能、数据组织存储和管理功能、数据操作功能、事务的管理和运行功能。它们之间的联系：数据库系统包括数据库、数据库管理系统、应用系统、数据库管理员，所以数据库系统是个大的概念。数据库是长期存储在计算机内的有组织、可共享的大量的数据集合，数据库管理系统是由管理员操作管理数据库的查询、更新、删除等操作的，数据库应用系统是用来操作数据库的。 比较用文件管理和用数据库管理数据的主要区别。 数据库系统与文件系统相比实际上是在应用程序和存储数据的数据库之间增加了一个系统软件，即数据库管理系统，使得以前在应用程序中由开发人员实现的很多繁琐的操作和功能，都可以由这个系统软件完成，这样应用程序不再需要关心数据的存储方式，而且数据的存储方式的变化也不再影响应用程序。而在文件系统中，应用程序和数据的存储是紧密相关的，数据的存储方式的任何变化都会影响到应用程序，因此不利于应用程序的维护。 解释数据模型的概念，为什么要将数据模型分成两个层次？ 数据模型是对现实世界数据特征的抽象。数据模型一般要满足三个条件：第一是数据模型要能够比较真实地模拟现实世界；第二是数据模型要容易被人们理解；第三是数据模型要能够很方便地在计算机上实现。由于用一种模型同时很好地满足这三方面的要求在目前是比较困难的，因此在数据库系统中就可以针对不同的使用对象和应用目的，采用不同的数据模型。根据模型应用的不同目的，将这些模型分为概念层数据模型和组织层数据模型两大类，以方便对信息的描述。 数据库系统包含哪三级模式？试分别说明每一级模式的作用？ 数据库系统包含的三级模式为：内模式、模式和外模式。外模式是对现实系统中用户感兴趣的整体数据结构的局部描述，用于满足不同数据库用户需求的数据视图，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是对数据库整体数据结构的子集或局部重构。模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。内模式是对整个数据库的底层表示，它描述了数据的存储结构。 数据库系统的两级映像的功能是什么？它带来了哪些功能？ 数据库系统的两级映像是外模式／模式映像和模式／内模式映像。模式／内模式映像定义了概念视图和存储的数据库的对应关系，它说明了概念层的记录和字段在内部层次怎样表示。如果数据库的存储结构改变了，那么，必须对模式／内模式映像进行必要的调整，使模式能够保持不变。外模式／模式映像定义了特定的外部视图和概念视图之间的对应关系，当概念模式的结构可发生改变时，也可以通过调整外模式／模式映像间的映像关系，使外模式可以保持不变。 什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？ 数据与程序的物理独立性是指当数据库的存储结构改变，将模式/内模式映象作相应改变，使模式保持不变，从而应用程序不必改变。数据与程序的逻辑独立性是指当模式改变时，将外模式/模式的映象作相应改变，使外模式保持不变，从而应用程序不用修改。 数据库三级模式划分的优点是什么？它能带来哪些数据独立性？ 数据库的三级模式的划分实际上将用户、逻辑数据库与物理数据库进行了划分，使彼此之间的相互干扰减到最少。这三个模式的划分实际上带来了两个数据独立性，即物理独立性和逻辑独立性。这使得底层的修改和变化尽量不影响到上层。 试说明使用视图的好处。 简化数据查询语句使用户能从多角度看待同一数据提高了数据的安全性提供了一定程度的逻辑独立性 使用视图可以加快数据的查询速度，这句话对吗？为什么？ 不对。因为数据库管理系统在对视图进行查询时，首先检查要查询的视图是否存在，如果存在，则从数据字典中提取视图的定义，把视图的定义语句对视图语句结合起来，转换成等价的对基本表的查询，然后再执行转换后的查询，所以使用视图不可以加快数据的查询速度。 登记日志文件时为什么必须先写日志文件，后写数据库？ 把数据的修改写到数据库和把对数据的修改操作写到日志文件是两个不同的操作，在两个操作之间可能会发生故障如果先写了数据库修改，而在日志文件中没有登记这个修改，在恢复的时候就无法恢复这个修改了；如果先写日志，但没有修改数据库，按日志恢复时只是多执行一次撤消操作，并不影响数据库的正确性，为了安全，一定要先写日志文件。 试叙述事务的4个性质，并结合每一个性质由DBMS的哪个子系统实现？每一个性质对DBS有什么益处？ 事务的原子性是指一个事务对 DB的所以操作，是一个不可分割的工作单位。原子性是由 DBMS的事务管理子系统实现的。事务的原子性保证了 DBS 的完整性。事务的一致性是指数据不会因事务的执行而遭受破坏。事务的一致性是由DBMS 的完整性子系统实现的。事务的一致性保证数据库的完整性。事务的隔离性是指事务的并发执行与这些事务单独执行时结果一样。事务的隔离性是由DBMS的并发控制子系统实现的。隔离性使并发执行的事务不必关心其他事务，如同在单用户环境下执行一样。事务的持久性，是指事务对 DB 的更新应永久地反映在 DB 中。持久性是由DBMS 的恢复管理子系统实现的。持久性能保证 DB 具有可恢复性。 在数据库中为什么要有并发控制机制？ 数据库系统一个明显的特点是多个用户共享数据库资源，尤其是多个用户可以同时存取相同数据。在这样的系统中，在同一时刻同时运行的事务可达数百个。若对多用户的并发操作不加控制，就会造成数据库存、取的错误，破坏数据的一致性和完整性。所以数据库中要有并发控制机制。 怎样进行系统故障的恢复? 系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤消故障发生时未完成的事务，重做已完成的事务。正向扫描日志文件（即从头扫描日志文件），找出在故障发生前已经提交的事务（这些事务既有 BEGIN TRANSACTION记录，也有 COMMIT记录），将其事务标识记入重做（REDO）队列。同时找出故障发生时尚未完成的事务（这些事务只有BEGIN TRANSACTION 记录，无相应的 COMMIT记录），将其事务标识记入撤消(UNDO)队列。对撤消队列中的各个事务进行撤消(UNDO)处理。进行 UNDO 处理的方法是，反向扫描日志文件， 对每个 UNDO 事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。对重做队列中的各个事务进行重做(REDO)处理。进行 REDO 处理的方法是：正向扫描日志文件， 对每个 REDO事务重新执行日志文件登记的操作。即将日志记录中“更新后的值”写入数据库 怎样进行介质故障的恢复? 发生介质故障后，磁盘上的物理数据和日志文件被破坏，恢复方法是重装数据库，然后重做已完成的事务。具体地说就是：装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还须同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务。即：首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。 怎样进行事务故障的恢复 事务故障是指事务在运行至正常终止点前被中止，这时恢复子系统应利用日志文件撤消（UNDO）此事务已对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。系统的恢复步骤是：反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。这样，如果记录中是插入操作，则相当于做删除操作（因此时“更新前的值”为空）。若记录中是删除操作，则做插入操作，若是修改操作，则相当于用修改前值代替修改后值继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。 试述使用检查点方法进行恢复的步骤。 从重新开始文件中找到追后一个检查点记录在日志文件中的地址，由该地址在体制文件中找到最后一个检查点记录。由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST 。 这里建立两个事务队列：UNDO-LIST：需要执行 undo 操作的事务集合；REDO-LIST 需要执行 redo 操作的事务集合。把 ACTIVE-LIST 暂时放入UNDO-LIST 队列，REDO 队列暂时为空。检查点开始正向扫描日志文件：如果有新开始的事务 Ti ，把 Ti 暂时放入 UNDO-LIST 队列；如有提交的事务 Tj ，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST队列，直到日志文件结束；对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST中的每个事务执行 REDO 操作。 什么是数据库镜像？它有什么用途？ 根据 DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS 自动把更新后的数据恢复过去，即 DBMS自动保证镜像数据与主数据的一致性。用途：一旦出现介质故障， 可由镜像磁盘继续提供使用， 同时 DBMS自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本。没有出现故障时，数据库镜像还可以并发操作。提高数据库的可用性。 试述两段锁协议的概念。 所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；在释放一个封锁之后，事务不再申请和获得对该数据的封锁。所谓“两段”锁的含义是，事务分为两个阶段，第一阶段是获得封锁，也称为扩展阶段。在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这个阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。 数据模型的优化包含哪些方法？ 确定各属性间的函数依赖关系。根据需要分析阶段得出的语义，分别写出每个关系模式的各属性之间的函数依赖以及不同关系模式中各属性之间的数据依赖关系。对各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。判断每个关系模式的范式，根据实际需要确定最合适的范式。根据需要分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行分解或合并。 B-树为代表的树形索引成为当前数据库系统主流索引具有必然性? 索引文件是一种适应面比较广的文件结构，因此在数据库系统中得到了广泛的应用。对于经常变动的文件，静态索引的性能会随时间变化而变坏，所以目前在数据库系统中应用更多的是动态索引。而B-数就是为了磁盘或其它存储设备而设计的一种平衡多分树，能很好地进行动态索引。B-树提供了三种存取路径:通过索引集进行树形搜索;通过顺序集进行顺序搜索;先通过索引找到入口，再沿顺序集顺序搜索。B-树不仅提供了灵活的存取路径，而且能够自动保持平衡，不须定期重组，因此B-树为代表的树索引系列在数据库系统中应用甚广，成为数据库主流具有必然性。 SUX锁是否能保证死锁不发生 不能解决并发事务中的死锁问题。当一个事物 A 占用数据对象 a 的 X锁，事务 B 占用数据 对象 b 的 X 锁，事务 A 和事务 B 又分别申请数据对象 b和数据对象 a 的锁，在(S,X)和(S,U,X)锁中，均无法获准，需要等待对方事务释放锁，而进入等待状态则无法释放自己所占用的锁，从而陷入循环等待，即死锁。解决方法：资源按相同的顺序上锁来避免死锁。","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"人工智能导论复习","slug":"study/ComputerScience/fragments/AI2021","date":"2021-12-21T16:00:00.000Z","updated":"2022-03-28T03:37:15.043Z","comments":true,"path":"2021/12/22/study/ComputerScience/fragments/AI2021/","link":"","permalink":"http://adversarr.github.io/2021/12/22/study/ComputerScience/fragments/AI2021/","excerpt":"🐔寄！人工智能导论复习","text":"🐔寄！人工智能导论复习 人工智能导论 第 1 章 绪论 分数：5 分。 题目范围： 您认为什么是人工智能？ 答题重点从两个角度：像人一样 还是 理性思考 还是 行动不同人会对 AI有不同的思考。要问的两个重要问题是:你关心的是思考还是行为?你是想模拟人还是按照理想标准工作?例如：我认为 AI 是像人一样行动的系统：“创造能执行一些功能的机器的技艺,当由人来执行这些功能时需要智能”(Kurzweil,1990)“研究如何使计算机能做那些目前人比计算机更擅长的事情”(Rich 和Knight,1991) 什么是人工智能 人工智能 用人工的方法在机器(计算机)上实现的智能;或者说是人们使机器具有类似于人的智能。 定义一:像人一样思考的系统(评价:计算机从定义开始) 像人一样思考:认知建模的途径 定义二:理性地思考的系统 合理地思考:“思维法则”的途径 定义三:像人一样行动的系统 合理地行动:合理 Agent 的途径 定义四:理性地行动的系统 图灵测试(Turing test) 1950 年图灵发表的《计算机与智能》中设 计了一个测试，用以说明人工智能的概念。 目的是为智能提供一个满足可操作要求的定义。 与其提出一个长长的、可能有争议的清单来列举智能所需要的能力,不如采用一项基于人类这种无可置疑的智能实体的辨别能力的测试。如果人类询问者在提出一些书面问题后,无法判断答案是否由人写出,那么计算机就通过了测试。 需要的能力： 自然语言处理 知识表示 自动推理 机器学习 第 2 章 智能化 Agent 分数：5 分。 题目范围： Agent 的架构，尤其是基于模型和效用的 Agent 架构。 准确理解基于模型和效用 Agent 的任务、环境、评价标准等。 !基于学习 Agent 的一般模型。 考试内容画出架构图 PEAS：Agent 的任务、环境、评价标准 根据首字母缩写,我们称之为 PEAS 描述( Performance(性能), Environment(环境), Actuators(执行器), Sensors (传感器))。设计 Agent 时,第一步就是尽可能完整地详细说明任务环境 Agent 架构 智能体(Agent) 某种能够行动的东西。不同于简单程序, 它可以实现:自主控制的操作、感知环境、持续能力、适应变化、以及有能力承担其它 Agent 的目标。 理性智能体(Rational Agent) 可以通过自己的行动获得最佳结果。或者在不确定的情况下,获得最佳期望的结果。 在任何给定时间，什么是理性取决于四件事： 定义成功标准的绩效衡量标准。 代理对环境的先验知识。 代理可以执行的操作。 代理迄今为止的感知序列。 For each possible percept sequence, a rational agent should select an action that is expected to maximize its performance measure, given the evidence provided by the percept sequence and whatever built-in knowledge the agent has. 对于每个可能的感知序列，考虑到感知序列提供的证据以及智能体拥有的任何内置知识，理性智能体应该选择一个预期能够最大化其性能度量的动作。 agent = architecture + program 简单反射 Agent 基于模型的 Agent 基于目标的 Agent 基于效用的 Agent 基于学习的 Agent 学习 Agent 可以被划分为 4 个概念上的组件,如图 2.15 所示。最重要的区别体现在学习元件和性能元件之间,学习元件负责改进提高,而性能元件负责选择外部行动。性能元件是我们前面考虑的整个 Agent:它接受感知信息并决策。学习元件利用来自评判元件的反馈评价 Agent.做得如何,并确定应该如何修改性能元件以便将来做得更好。 第 7 章 逻辑 Agent 分数：5 分。 题目范围： 命题逻辑的语法、命题逻辑的推理模式或推理方法 理解书中怪兽世界任务的推理，包括 𝑹𝟏~𝑹𝟏𝟎 的证明，以及 𝑹𝟏𝟏~𝑹𝟏𝟓 的将句子转换成合取范式 基于归结或反证法的证明。 理解推理规则及公理，以便用于命题逻辑的推理。 !命题逻辑的连接符及其语义 往年题目推导 R1-R10，R11-R15 命题逻辑 Knowledge base (KB) A set of sentences Sentence Represents some assertion about the world Axiom Not derived from other sentences 经典问题为： 魔兽世界问题 语法 对于命题： \\[\\alpha |= \\beta\\quad \\iff\\quad M(\\alpha) \\subseteq M(\\beta)\\] 对于命题逻辑： \\(\\neg,\\wedge,\\vee,\\implies,\\iff\\) True, False 语义 注意 \\(\\implies\\) 的语义 命题推理 命题推理的目标： \\(KB|=\\alpha\\) 简单推理过程 逻辑推理：用蕴含关系来证明 模型检验：枚举所有的可能 定理证明 Applying inference rules without models. 利用逻辑等价的命题逻辑。 单调性：随着信息添加到知识库中，所包含的句子集只会增加。 产生了 R6-R10 使用搜索算法证明 INITIAL STATE：The initial knowledge base ACTIONS：Match the top half of the inference rule RESULT：Add the sentence in the bottom half of the inference GOAL：The sentence to prove 使用如下的方法： \\[ \\begin{aligned} \\alpha \\implies \\beta,\\quad \\alpha\\\\ -----------\\\\ \\beta \\end{aligned} \\] \\[ \\begin{aligned} \\alpha \\wedge \\beta\\\\ -----------\\\\ \\beta \\end{aligned} \\] 逻辑等价 \\[ \\begin{aligned} \\alpha \\iff \\beta\\\\ -----------\\\\(\\alpha\\implies \\beta)\\wedge (\\beta\\implies\\alpha)\\\\ \\\\ (\\alpha\\implies \\beta)\\wedge (\\beta\\implies\\alpha)\\\\-----------\\\\ \\alpha \\iff \\beta \\end{aligned} \\] 消解法（归结法） 消解规则： \\[ \\begin{aligned} l_1 \\vee l_2\\quad \\neg l_2\\vee l_3 \\\\----------\\\\ l_1\\vee l_3 \\end{aligned} \\] 思路 要证明：\\(KB|=\\alpha\\)即证明：\\(KB\\wedge\\neg\\alpha\\)不可满足的 方法： 转换\\(KB\\wedge \\neg \\alpha\\)为合取范式 消解 如果新子句尚不存在，则将其添加到集合中 该过程一直持续到： 不能添加新的条款 产生了空条款 -- 不可满足 产生了 R11-R15 第 10 章 知识表示 分数：6 分。 题目范围： 情景演算、情景、流、前提条件公理、效应公理等概念。 !本体论、类别、对象，并举例说明 本体论相关 本体 本体 Organize everything in the world into a hierarchy of categories 主要着重于一些在许多不同领域都会出现的通用概念例如事件、时间、物理对象以及信念。表示这些抽象概念有时被称为本体论工程（ontological engineering）。 念的通用框架被称为上位本体论( upper ontology),因为按照画图惯例，更一般概念在上面而更具体的概念在它们的下面。如图 Upper ontology: the general framework of concepts Concentrate on general concepts in different domains：专注于不同领域的一般概念 Events, Time, Physical Objects, and Beliefs 本体（ontology）的几个代表性定义： (1) 本体是对于“概念化”的某一部分的明确的总结或表达[2]。 (2) 本体在不同的场合分别指“概念化”或“本体理论”[3]。 (3) 本体是对于“概念化”的明确表达[4]。 (4) 本体是用于描述或表达某一领域知识的一组概念或术语。它可以用来组织知识库较高层次的知识抽象，也可以用来描述特定领域的知识[5]。 (5) 本体属于人工智能领域中的内容理论（content theories），它研究特定领域知识的对象分类、对象属性和对象间的关系，它为领域知识的描述提供术语[6]。 从以上定义我们可以知道，本体通过对于概念、术语及其相互关系的规范化描述，勾画出某一领域的基本知识体系和描述语言。其中定义 1、2 和 3 以“概念化”的定义为基础，概念化（以及定义 2 中的“本体理论”）的定义见下文。 与本体相关的概念和术语： 本体论（Ontology，o 大写）：特指哲学的分支学科[3]。 类别和对象 类别、对象 用一阶逻辑表示类别有两种选择: 谓词和对象。就是说,我们可以使用谓词 Basketball(b),或者可以将类别物化(reify)为一个对象, Basketball。然后,我们可以用 Member(b, Basketballs)(我们将它缩写为 b∈Basketballs)来说明 b 是篮球类别的一个成员。 我们用 Subset( Basketball,Bals)(缩写为 Basketballs c Balls)来说明 Basketball.s 是 Ball.s 的一个子类(subcategory)。我们将交替使用术语子类(subcategory)和子集(subclass, subset)。 将对象组织成类别是知识表示的重要组成部分。很多推理发生在类别层面。 一种是从感知输入推断某些对象的存在，从对象的感知属性推断类别成员资格，然后使用类别信息对对象进行预测。 一种是通过继承来组织和简化知识库，子类关系构成一个层次结构 （部分关系、a 组成了 b）Partof 一个对象可以是另一个对象的一部分 PartOf is transitive（传递） and reflexive（自反） 反之有：BunchOf: define composite objects with definite parts（定义一个物体由有限个 Part 组成） 事物 现实中有相当一部分对象没有明显的个性化(individuation)。 即划分成独特对象—事物 现实世界可以视为由原始对象(粒子)和由其构成的复合对象组成的、 事物和物体(thing)的最大区别：（如果将一只土豚切成两半， 不会得到两只土豚。） 对象=事物 stuff-物质、thing-物体 测度 Objects have height, mass, cost, and so on. The values that we assign for these properties are called measures. 情景演算 Event calculus Based on points of time rather than on situations Predicate T 断言 流体 在某个时间点是正确的 谓词 过程 过程（process / liquid event) 具有这种属性的事件类别被称为过程( process)类别或者流事件( liquid event)类别。发生在一个时间区间的任何过程 e 也在任何子区间里发生。 如果 fluent 是由过去某个时间的事件启动并且没有被中间事件变为 false（剪切），则 fluent 在某个时间点成立。 流(fluent)指的是使情景从一个变换到下一个的函数和谓词。 一个特殊的事件-Start 通过说明在开始时间启动或终止哪些流来描述初始状态。 一个物理对象是一块时空 Physical objects can be viewed as generalized events 第 14 章 概率推理 分数：8 分。 题目范围： 贝叶斯网络的定义、贝叶斯网络的语义。 给定贝叶斯网络，要求能够写出相应的联合概率分布。 针对书中的盗贼警报任务，理解贝叶斯网络的精确推理，并且能够在给定证据的情况下进行推理。 定义/语义 Represent the dependencies among variables 贝叶斯网络 贝叶斯网络是一个有向图,其中每个结点都标注了定量的概率信息。其完整的说明如下: 每个结点对应一个随机变量,这个变量可以是离散的或者连续的。 一组有向边或箭头连接结点对。如果有从结点 X 指向结点 Y 的箭头,则称 X 是 Y 的一个父结点。图中没有有向回路(因此被称为有向无环图,或简写为 DAG)。 每个结点 X 有一个条件概率分布 P( K| Parents(X)),量化其父结点对该结点的影响。 有两种方式可以理解贝叶斯网络的语义。 第一种是将贝叶斯网络视为对联合概率分布的表示。 第二种则将其视为是对一组条件依赖性语句的编码。 这两种观点是等价的,但是前者可以帮助我们理解如何构造网络,而后者则可以帮助我们设计推理过程 如何计算联合概率？ 遍历DAG 如何构造贝叶斯网络：链式法则 如何进行精确推理 原理：精确推理就是计算后验概率：随机变量：\\(X\\)，条件\\(e\\)，隐藏的节点\\(y\\)： \\[P(X|e)=\\frac{P(X,e)}{P(e)}\\mathop{=}^{\\alpha:=P(e)^{-1}}\\alpha \\sum_yP(x,y,e)\\] 计算方法： 重点：\\(\\alpha\\)不计算，通过求出 X 不同取值下的联合概率，然后归一化得到 求随机变量各个取值的联合概率 归一化得到结果 例题 注意其中的B是大写的变量，而jmea都是取值！ 最暴力的方法： Scene Probability Result b,e,a 0.001 0.002 0.95 0.9 0.7 1.197*10^-6 b,e,-a 0.001 0.002 0.05 0.05 0.01 5.*10^-11 b,-e,a 0.001 0.998 0.94 0.90 0.70 0.000591016 b,-e,-a 0.001 0.998 0.06 0.05 0.01 2.994*10^-8 -b,e,a 0.999 0.002 0.29 0.9 0.7 0.000365035 -b,e,-a 0.999 0.002 0.71 0.05 0.01 7.0929*10^-7 -b,-e,a 0.999 0.998 0.001 0.9 0.7 0.000628111 -b,-e,-a 0.999 0.998 0.999 0.05 0.01 0.000498002 所以 \\(P(b|j, m)=0.000592243 \\alpha\\) \\(P(\\neg b|j,m)=0.00149186\\alpha\\) 归一化后：（实际上\\(\\alpha =1/(0.000592243+0.00149186)\\)） \\(P(b|j, m)=0.000592243 \\alpha=0.284172\\) \\(P(\\neg b|j,m)=0.00149186\\alpha=0.715828\\) 从而： \\[P(B|j,m)=\\langle0.283172,0.715828\\rangle\\] 第 16 章 制定简单决策 分数：8 分。 题目范围： 理解什么是最大期望效用原则。 理解决策网络，尤其是决策网络中的节点类型。 给定一个决策网络，能够计算不同动作的期望效用，并选择具有最大期望效用的动作。 !偏好、效用 最大期望效用原则 最大期望效用(MEU)原则：理性 Agent 应该选择能最大化该 Agent 的期望效用的那个动作。 效用函数：效用是从状态映射到实数的函数。 决策网络 机会结点(Chance node)(椭圆)代表随机变量,就像它们在贝叶斯网中所表示的一样。关于建设费用、空中交通级别和诉讼可能性以及 Deaths、 Noise 和总体 Cosr 变量一其中每一个又依赖于选址一 Agent 可能是不确定的。每个机会结点关联着一个以父结点的状态为索引的条件分布。在决策网络中,父结点既可以包括决策结点也可以包括机会结点。注意到为了评估建设费用、空中交通级别或者诉讼可能性,每个当前状态机会结点都可能是一个大的贝叶斯网络的部分。 决策结点(decision node)(矩形)代表在该结点上决策制定者有一个对行动的选择。在这个案例中, Airport site 行动可以对考虑中的每个位置呈现不同的值。选择影响到费用、安全以及会产生的噪音。在本章中,我们假设我们处理的是单一决策结点。第 17 章将处理必须制定多于一个决策的情况效用结点(utility node)(菱形)代表 Agent 的效用函数'。 效用结点把所有那些描述直接影响效用的结果状态的变量作为父结点。与效用结点关联的是一个描述,它将 Agent 效用描述为对父结点属性的一个函数。这个描述可能只是函数的表格形式, 或者它可能是参数化的属性值的加法或线性函数。 给定决策网络，计算不同动作的期望效用 行动的选择是通过对决策结点的每种可能设定的决策网络进行评价而完成的。一旦决策结点被设定,它的行为表现完全像一个被设定为证据变量的机会结点。评价决策网络的算法如下: 为当前状态设定证据变量。 对于决策结点的每个可能值; 把决策结点设为该值。 对该效用结点的父结点,使用一个标准的概率推理算法计算其后验概率。 为该行动计算结果效用。 返回有最高效用的行动这是贝叶斯网络算法的一个直接扩展,可以直接结合到图 13.1 给出的 Agent T 设计中去。 依次执行几个行动的可能性使问题变得有趣得多 偏好和效用 下面六条约束被称为效用理论公理。它们指定附加在偏好和彩票上的明显的语义约束。 有序性(Orderability)。给定任意两个状态,一个理性 Agent 必须偏好一个状态甚于另一个。或者认为偏好两者的程度一样。也就是说,该 Agent 不能逃避决策。拒绝打赌就如同拒绝时间逝去一样。 传递性(Transitivity)。给定任意三个状态,如果一个理性 Agent 偏好 A 甚于 B,偏好 B 甚于 C,则该 Agent 一定偏好 A 甚于 C。 连续性(Continuity)。如果某个状态 B 在偏好上处于 A 和 C 之间,那么一定存在概率 p,使得该理性 Agent 在【肯定得到 B】、【以概率得到 A,并以概率 1 − p 得到 C】的彩票之间无偏向。 可替换性(Substituitability)。如果一个 Agent 在两个彩票 A 和 B 之间无偏向,则该 Agent 在更复杂的两个彩票之间也是无偏向的。这样的两个彩票,除了一个彩票中的 A 被 B 替换以外是一样的。这是成立的,而不用考虑彩票中的概率和其它结果。 单调性( Monotonicity)。假设存在两个彩票有两个结果 A 和 B,如果一个 Agent 偏好 A 甚于 B,那么该 Agent 一定偏好 A 的概率高的彩票。反之亦然。 可分解性(Decomposability)。复合彩票可以通过概率法则被简化为简单一些的彩票。由于两个相继的彩票能够被压缩成个等价的单个彩票,这曾被称为“赌博无乐趣”规则。 注意:效用理论的公理没有提到任何关于效用的内容：它们只谈论了偏好。偏好被假定为理性 Agent 的一个基本属性。一个效用函数的存在遵循下列效用公理: 效用原则(Existence of Utility Function)。如果一个 Agent 的偏好遵循效用公理，则存在一个在状态上进行运算的实值函数 U,使得 U(A)&gt;U(B),当且仅当 Agent 偏好 A 甚于 B 时。并且 U(A)=U(B),当且仅当该 Agent 在 A 和 B 之间无偏向时。 最大期望效用原则(Expected Utility of a Lottery)。一个彩票的效用是把每个结果的概率乘以每个结果的效用的乘积，然后求和。 换句话说,一旦可能结果状态的概率和效用被指定,涉及到那些状态的复合彩票的效用就被完全确定了。一个非确定性动作的结果是一个彩票,这将提供根据公式(16.1)得到的 MEU 决策规则。 效用函数刻画的是偏好关系，假如你相比梨来说更偏好苹果，那么苹果给你带来的效用就应当大于梨所带来的效用。但注意效用函数虽然是一个数学函数，但在本例中它仅表示不同消费组合之间效用的排序关系，而非真正的，可以用数字来刻画的“效用量”。换言之，你可以说你相对梨来说更偏好苹果，但绝对没办法说“苹果大于梨 n 个效用单位”。当然，在某些特定的领域也有用基数效用方程的，比如在期望效用理论中。 作者：徐惟能 链接：https://www.zhihu.com/question/22310615/answer/20962418 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"http://adversarr.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"编译原理","slug":"study/ComputerScience/fragments/CP2021","date":"2021-12-12T16:00:00.000Z","updated":"2022-03-03T04:30:41.727Z","comments":true,"path":"2021/12/13/study/ComputerScience/fragments/CP2021/","link":"","permalink":"http://adversarr.github.io/2021/12/13/study/ComputerScience/fragments/CP2021/","excerpt":"编译原理期末复习","text":"编译原理期末复习 编译原理习题集 Chapter 2：语言和文法 构造无e产生式的上下文无关文法 取模相关：奇偶性、整除性 {w| w \\(\\in\\) (a,b,c)* and the numbers of a’s and b’s and c’s occurred in w are even} {w| w \\(\\in\\) (a,b,c)* and the numbers of a’s and b’s occurred in w are odd} {w| w \\(\\in\\) (a,b,c)* , w is lead by a and the numbers of a’s and b’s occurred in w are even} 方法：构造有穷自动机，然后转换为CFG。 个数相关 { \\(a^i b^j\\) |i≥(2j+1) and j≥0} { \\(a^ib^jc^k\\)|j≥(i+k+1) and i≥0, k≥1} 方法：进行合理的拆分，例如： \\[ a^i b^j (i\\ge 2j + 1, j\\ge 0) = a^k(aab)^j(k \\ge 1, j \\ge 0) \\] 消除相关的不等式即可。 Chapter 3：词法分析 从RegEx构造（最小化）DFA： aa*(bab*a)*(a|b)b* a(bab*a)*(a|b)b* ((ba*)*a)*(a|b) 直接用书上的算法做就行。 这一章的定义、算法有： 定义：DFA、NFA、正则表达式（Regular Expression）、线性文法、正规定义（Regular Definition） 算法： NFA到DFA 子集法 DFA到NFA是没有意义的 DFA最小化 划分法 RegEx-NFA 正向：反复使用Thompson法则 反向：一样用Thompson法则，但是需要注意其中的一些路径组合 右线性文法-NFA -&gt;：增加新的终态、根据产生式设置move函数 &lt;-：分别考虑出边和终态来构造 左线性文法-NFA -&gt;：识别符号S设置为终态、设置Q0为新的初态、根据产生式考虑三种情况即可。 &lt;-： Chapter 4：语法分析 主要内容： 消除\\(\\varepsilon\\)产生式 消除（直接和间接）左递归 注意使用范围 提取左公因子 First 和 Follow 集 LL文法 构造LL1分析表 LL1文法的判断方法 LR文法 LR0 SLR LR1 LALR 真的烦人！ 消除左递归、提取左公因子并构造LL1 \\[ S \\rightarrow iCtS|iCtSeS|a\\\\ C \\rightarrow C \\text{ or } D | D\\\\ D \\rightarrow D \\text{ or } E | E\\\\ E \\rightarrow (C) | b \\] 构造LR1 \\[ S \\rightarrow \\text{ if } S \\text{ else } S\\\\ S \\rightarrow \\text{ if } S\\\\ S \\rightarrow S~;S\\\\ S \\rightarrow a \\] （带有二义性的文法）构造LR1 优先级：\\(; &gt; \\text{do} &gt; \\text{or}\\) \\[ S\\rightarrow \\text{ do } S \\text{ or } \\\\ S\\rightarrow \\text{ do } S\\\\ S\\rightarrow S~;S\\\\ S\\rightarrow a \\]","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"数值分析-总结","slug":"study/Math/NumericRecipies/NumericRecipiesTable","date":"2021-06-24T16:00:00.000Z","updated":"2022-04-06T03:34:09.363Z","comments":true,"path":"2021/06/25/study/Math/NumericRecipies/NumericRecipiesTable/","link":"","permalink":"http://adversarr.github.io/2021/06/25/study/Math/NumericRecipies/NumericRecipiesTable/","excerpt":"2020-2021-3 数值分析（现代数值方法）","text":"2020-2021-3 数值分析（现代数值方法） 考点概要 Chapter 1 绪论 误差（误差、误差限、相对误差限的概念） 有效数（位数） 非线性方程求根 简单迭代法（构造、收敛性判定） 牛顿迭代法（构造、收敛性判定） 收敛阶、误差估计公式 线性方程组的求解 矩阵范数 \\(\\|\\cdot\\|\\) 谱半径 \\(\\rho(A)\\) 条件数 \\(\\mathrm{cond}(A)\\) 三种迭代格式（Jacobi / Gauss-Seidel / SOR）的 构造（矩阵格式） 收敛性判定 （误差估计公式） 非迭代方法 Gauss消元法及其变体（Gauss消元法，列主元消元法） 三角分解，也就是LU分解（Doolite分解） 追赶法 插值拟合 多项式插值的构造（Lagrange插值、Newton插值）及其误差 分段插值（没见过） 最小二乘法 积分和微分 插值型求积公式和代数精度 复化求积公式：梯形、Simpson公式的构造 龙贝格积分的构造 ODE 改进欧拉法 二阶RK方法","categories":[],"tags":[]},{"title":"信号与系统-引论","slug":"study/ComputerScience/Signals and Systems/Chapter 1 Introduction/Chapter 1 Introduction","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.577Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 1 Introduction/Chapter 1 Introduction/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%201%20Introduction/Chapter%201%20Introduction/","excerpt":"信号与系统-引论","text":"信号与系统-引论 Chapter 1 Introduction 概述： 教材：《信号与线性系统》——管致中 参考书： （清华）《信号与系统》 （奥本海姆）《信号与系统》 （中科大）《信号与系统-理论、方法与应用》 考核：平时 10 + 中 30 + 末 60 绪论 1.1信号传输系统 信号：随时间变化的物理量 &gt; 在本课程中指电信号 系统：由若干个单元组成的具有某种功能以用来达到某些目的有机整体 信号传输系统：统称“通信系统”，分为五个部分 &gt; 信号源→输入转换→发送→信道→接收→输出转换→信宿 重点：信号的处理和传输 1.2信号的基本概念 确知信号的分类 与其相对应的有 随机信号 连续/离散： 连续（时间）信号：\\(f(t)\\) 离散（时间）信号：只在离散时刻有定义，\\(f(t_k)\\)。一般通过抽样得到：\\(f(kT)\\)，\\(T\\)为抽样间隔。简单计为\\(f(k)\\)。 能量/功率： 能量：\\(E=\\int_{-\\infty}^{+\\infty}|f(t)|^2\\mathrm dt\\) 平均功率：\\(P=\\lim_{T\\rightarrow \\infty} \\frac 1 {2T} \\int _{-T}^{T}|f(t)|^2\\mathrm dt\\) 能量信号：\\(E&lt;\\infty,P\\rightarrow 0\\) 例如：脉冲信号 功率信号：\\(P&lt;\\infty, E\\rightarrow \\infty\\) 例如：\\(\\varepsilon(t)\\) 其他的信号：\\(t\\varepsilon(t),\\delta(t)\\) 周期/非周期信号： 周期信号是功率信号 周期信号的和不一定是周期信号 奇/偶信号： 奇信号 偶信号 信号的特性 时间上：\\(f(t)\\) 空间：波形 频域：频谱 1.3信号的简单处理 基本运算 加、减、乘、除、积分、差分等等 信号自变量变换 尺度变换： \\[ f(t)\\rightarrow f(at),a\\ne 0\\\\\\begin{cases}|a|&gt;1&amp; 压缩\\\\|a|&lt;1&amp;扩展\\\\a=-1&amp;反褶\\end{cases} \\] 当\\(a&lt;0\\)时，也包含反褶 时移（延时）： \\[ f(t)\\rightarrow f(t-t_0)\\\\ \\] \\(t_0&gt;0\\)：右移 \\(t_0&lt;0\\)：左移 尺度+时移：（类似于仿射变换） 1.4系统的基本概念 系统的状态 激励e(t) → 系统 L → 相应 r(t) 线性系统中，设初始状态为：\\(\\{x_j(t_0)\\},j=1,2,...,n\\)（\\(n\\)个独立储能元件），则响应为： \\[ r(t)=L[\\{x_j(t_0),e(t)\\}]=r_{zi}(t)+r_{zs}(t),\\quad t\\ge t_0 \\] \\(r_{zi}(t)\\)为零输入响应 \\(r_{zs}(t)\\)为零状态响应 系统的分类 线性系统： 已知 \\(\\{x_j(0)\\},e(t)=\\sum_{i=1}^ma_ie_i(t)\\) 且：\\(x_j(0)=1\\rightarrow r_{x_j}(t),j=1,...,n\\)，\\(e_i(t)\\rightarrow r_{e_i}(t),i=1,...,m\\)，有： 分解性 \\(r_{zi}(t)\\)线性 \\(r_{zs}(t)\\)线性 &gt; 线性：Chapter 3向量空间的线性映射 时变、非时变（时不变系统）： 时不变：若 \\(e(t)\\rightarrow r(t)\\)则\\(e(t-t_0)\\rightarrow r(t-t_0)\\) → 恒参系统 连续时间系统、离散时间系统： 因果系统 稳定系统：\\(\\lim_{t\\rightarrow \\pm \\infty}h(t)=0.\\) 非稳定系统：\\(\\lim_{t\\rightarrow \\pm \\infty}h(t)=\\infty\\) 临界系统：\\(\\lim_{t\\rightarrow \\pm \\infty}h(t)\\le \\mathrm{constant}\\) 动态（记忆）系统、非动态（非记忆）系统 集总参数系统、分布参数系统 LTI系统分析（求响应）方法 系统建模：线性常系数微分/差分方程（组） 求解： 直接法：齐次通解+非齐次特解 间接法：时域、变换域→零状态响应 状态变量分析法 物理解释 间接法求零状态响应\\(r_{zs}(t)\\) 将激励\\(e(t)\\)分解为单元信号的叠加 求单元信号作用下的响应（子响应） 将子响应叠加","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"连续时间系统的时域分析","slug":"study/ComputerScience/Signals and Systems/Chapter 2 连续时间系统的时域分/Chapter 2 连续时间系统的时域分","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.638Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 2 连续时间系统的时域分/Chapter 2 连续时间系统的时域分/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%202%C2%A0%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86/Chapter%202%C2%A0%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86/","excerpt":"信号与系统-连续时间系统的时域分析","text":"信号与系统-连续时间系统的时域分析 Chapter 2 连续时间系 引言 时域：变量为\\(t\\)→ 连续时间 模型：线性常系数微分方程组 求解： 零输入（直接求解齐次方程；初态→等效源） 零状态相应（间接法、叠加积分） 算子方程 算子定义 微分算子\\(p=\\frac{d}{dt}\\) 积分算子\\(\\frac 1 p = \\int _{-\\infty}^t (\\cdot)d\\tau\\) 电感和电容可以看作是算子阻抗：\\(pL,\\displaystyle\\frac 1{pC}\\) 算子运算法则 可以进行代数运算：如\\((p+1)(p+2)=p^2+3p+2\\) →Chapter 3向量空间的线性映射 可以消去：在等式两端同时乘以\\(p\\) \\(pf=pg\\Rightarrow f(t) =g(t) +\\mathrm C\\) 求零输入时，一般不能随便消去 求零状态时，可以消去 → 线性完全满足的情况 例：一般的系统，有：\\((p^n+a_{n-1}p^{n-1} + \\cdots+a_0)r(t)=(b_mp^m+\\cdots + b_0)e(t)\\) 简记为：\\(D(p)r(t)=N(p)e(t)\\) 或 \\(r(t)=\\frac{N(p)}{D(p)}e(t)=H(p)e(t)\\) \\(H(p)\\) → 算子形式系统函数（转移算子） \\(D(p)\\)→ 特征多项式（其根为特征根「自由频率、固有频率」→体现了系统响应的特征） 零输入相应的求法 转化为 \\(D(p)r(t)=0\\) 的求解。 直接求解齐次方程 一阶系统 → 设 \\(\\lambda\\)→ \\((p-\\lambda)r(t)=0\\)→ \\(r_{zi}(t)=ce^{\\lambda t},c=r(0^-),t\\ge 0\\) n 阶系统 → 令特征方程=0，求出特征根 → 通解为 \\(r_{zi}(t)=\\sum_{i=1}^nC_ie^{\\lambda_it}\\) → 定解条件 \\(r(0^-),r&#39;(0^-),r^{(n-1)}(0^-)\\) 共轭根处理 → \\(e^t \\cos t\\) k重根的处理： \\(r_{zi}=(c_1+c_2t+\\cdots+c_kt^{k-1})e^{\\lambda_1t}+\\cdots\\) 初态转化为等效源 pass 奇异函数 定义：一个本身或其微、积分在某处不连续的函数 单位阶跃函数：\\(\\varepsilon(t)\\) 单位冲激函数：\\(\\delta(t)\\) 单位冲激函数 工程定义： \\[ \\delta(t)=\\begin{cases}\\infty, &amp;t=0 \\\\0,&amp;t\\ne 0\\end{cases},\\int _{-\\infty}^\\infty\\delta(t)dt=1 \\] 狄拉克定义：抽样性，筛选性 \\[ \\forall \\varphi(t)在t=0连续,\\int_{-\\infty}^\\infty\\varphi(t)\\delta(t)\\mathrm dt =\\varphi(0) \\] 数学定义： \\[ \\delta (t)=\\frac{\\mathrm d}{\\mathrm dt}\\varepsilon(t) \\] 极限定义： \\[ \\lim_{c\\rightarrow 0}\\int_{-\\infty}^\\infty f_c(t)\\mathrm dt = \\varphi(0)\\rightarrow f_c(t)\\rightarrow \\delta(t)(c\\rightarrow0) \\] 广义定义广义傅立叶变换（广义谱） 常用性质： 抽样性→狄拉克定义：抽样性，筛选性 偶函数\\(\\delta(t)=\\delta(-t)\\) 尺度变换性质：\\(\\delta(at)=\\frac 1{|a|}\\delta(t),a\\ne0\\) 冲激偶：\\(\\delta&#39;(t)\\) 信号的时域分解 例子 门函数 \\[ G\\tau(t)=\\varepsilon(t+\\frac \\tau 2)-\\varepsilon(t-\\frac \\tau 2) \\] 信号分解为\\(\\delta(t)\\)的组合 若\\(f(t)\\)有始： \\[ \\begin{aligned}f(t)&amp;=\\lim_{\\Delta t\\rightarrow 0}\\sum_{k=0}^nf(k\\Delta t)G_{\\Delta t}(t-k\\Delta t)\\\\&amp;=\\lim_{\\Delta t\\rightarrow 0}\\sum_{k=0}^nf(k\\Delta t)\\frac{G_{\\Delta t}(t-k\\Delta t)}{\\Delta t}\\Delta t\\\\&amp;=\\int_0^tf(\\tau)\\delta(t-\\tau)\\mathrm d\\tau\\\\&amp;=f(t)*\\delta(t)\\end{aligned} \\] 信号分解为单位阶跃 \\[ f(t) = \\int_{-\\infty}^tf&#39;(\\tau)\\varepsilon(t-\\tau)\\mathrm d\\tau=f&#39;(t)*\\varepsilon(t) \\] 冲激响应和阶跃响应 H(t) 的求法 拉氏反变换：\\(h(t)=L^{-1}H(s)\\) \\(H(p)\\)分解法 系数平衡法 将\\(\\delta (t)\\)的作用转化为\\(t=0^+\\)的初态，于是求\\(h(t)\\)就是求相应初态作用下的零输入相应\\(r_{zi}(t)\\) 状态方程法（Ch9 TODO） 叠加积分 \\(\\varepsilon(t),\\delta(t)\\)→LTI→\\(r_{\\varepsilon}(t),h(t)\\) \\[ r_{zs}(t)=e(t)*h(t) \\] \\(\\tau\\)：冲激分量出现的时刻 \\(t\\)：观察的时刻 \\(t-\\tau\\)：记忆时间 \\(r_{zs}(t)=\\int_{-\\infty}^\\infty e(\\tau)h(t-\\tau)d\\tau,-\\infty&lt;t&lt;\\infty\\) 卷积及其性质 定义 两个函数 \\(f_1(t)\\) \\(f_2(t)\\)，则其卷积为： \\[ f_1(t)*f_2(t)=\\int_{-\\infty}^{\\infty}f_1(\\tau) f_2(t-\\tau)\\mathrm d\\tau \\] 卷积图解 图解法求卷积 卷积的性质 代数运算性质 交换律\\(f_1(t)*f_2(t)=f_2(t)*f_1(t)\\)→ 系统串联和子系统次序无关（理想情况下） 分配律\\(f_1(t)*(f_2(t)+f_3(t))=f_1(t)*f_2(t)+f_1(t)*f_3(t)\\)→ 系统并联等效 结合律\\((f_1*f_2)*f_3=f_1*(f_2*f_3)\\)→ 系统串联等效 微积分性质 微分 \\(\\frac d {dt}(f_1*f_2)=(\\frac {d}{dt}f_1)*f_2=(\\frac {d}{dt}f_2)*f_1\\) 积分 \\(\\int_{-\\infty}^t f_1(x)*f_2(x)\\mathrm dx =[\\int_{-\\infty}^tf_1(x)\\mathrm dx]*f_2(t)=[\\int_{-\\infty}^tf_2(x)\\mathrm dx]*f_1(t)\\) 微积分综合 \\(f_1(t)*f_2(t)=\\frac{\\mathrm d}{\\mathrm dx}f_1(t)*\\int _{-\\infty}^tf_2(x)\\mathrm dx=\\frac{\\mathrm d}{\\mathrm dx}f_2(t)*\\int _{-\\infty}^tf_1(x)\\mathrm dx\\) 注意被求导函数在 -∞ 必须为0 延时性： \\(f_1(t)*f_2(t)=r(t)\\rightarrow f_1(t-t_1)*f_2(t-t_2)=r(t-t_1-t_2)\\) 与\\(\\delta (t)\\)的卷积：\\(f(t)*\\delta (t)=f(t)\\) \\(f(t)*\\delta ^{(n)}(t) = f^{(n)}(t)*\\delta(t)\\) \\(f(t)*(\\int_{-\\infty}^t)^n\\delta (t) = (\\int_{-\\infty}^t)^nf(t)*\\delta(t)\\) \\(f(t)*\\varepsilon(t)=\\int_0^tf(\\tau)\\mathrm d\\tau\\) \\(\\varepsilon(t)*\\varepsilon(t)=t\\varepsilon(t)\\) 有限区间上的卷积： 若\\(f_1(t):t\\in(t_1,t_2),f_2(t):t\\in(t_3,t_4)\\)则\\(y(t)=f_1(t)*f_2(t),t\\in(t_1+t_3,t_2+t_4)\\) 卷积定理： \\[ f_1(t)*f_2(t)=\\mathcal L^{-1}[F_1\\cdot F_2] \\] 线性时不变系统响应的求解 \\(r_{zi}\\)：特征方程→特征根 \\(r_{zs}(t)=e(t)*h(t)\\)","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"连续信号的正交分解「信号频域分析」","slug":"study/ComputerScience/Signals and Systems/Chapter 3 连续信号的正交分解/Chapter 3 连续信号的正交分解","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.638Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 3 连续信号的正交分解/Chapter 3 连续信号的正交分解/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%203%20%E8%BF%9E%E7%BB%AD%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3/Chapter%203%20%E8%BF%9E%E7%BB%AD%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3/","excerpt":"连续信号的正交分解「信号频域分析」","text":"连续信号的正交分解「信号频域分析」 Chapter 3 连续信号的正交分解「信号频域分析」 引言 信号的特性： 时域上： 函数\\(f(t)\\)单元信号\\(\\delta (t)\\)子响应\\(h(t)\\) 波形 频域上： 频域表示 信号在正交函数集中的分解 设有一个函数集\\(\\{g_0(t), g_1(t),...,g_n(t)\\}\\)在\\((t_1,t_1+T)\\)满足： \\[ &lt;g_i,g_j&gt;=0\\iff i\\ne j \\] Chapter 6 - 内积空间 若该函数集是「规范正交基」则所有函数都可以表示为\\(g_i\\)的线性组合。 若同时使得均方误差最小，则（正交分解） \\[ a_k=\\frac{\\int _{t_1}^{t_1+T} f(t)g_k(t)^*\\mathrm dt}{\\int_{t_1}^{t_1+T}|g_k(t)|^2\\mathrm dt} \\] Notes：在正交集中分解：分量系数\\(a_k\\)可以独立计算、平均功率=各个分量的平均功率和（Parseval 定理） Notes 正交函数集：三角函数集、指数函数集、Walsh 函数 信号的 Fourier 级数表示 三角形式 若周期信号\\(f(t)\\)满足 Dirichlet 条件（充分，非必要） 一个周期内有有限个间断点 一个周期内有有限个极值点 一个周期内能量有限（→ 功率信号）** 则可以展开为 FS： \\[ f(t)=\\frac{a_0}2+\\sum_{n=1}^\\infty (a_n\\cos n\\Omega t+b_n\\sin n\\Omega t), \\Omega =\\frac{2\\pi}{T} \\] 其中： \\(a_n=\\frac 2 T \\int _{t_1}^{t_1+T}f(t)\\cos n\\Omega t \\mathrm dt,\\quad n=0,1,\\cdots\\) \\(b_n=\\frac 2 T\\int_{t_1}^{t_1+T}f(t)\\sin n \\Omega t\\mathrm dt,\\quad n = 1, 2, \\cdots\\) 从而： \\[ f(t)=\\frac{A_0}2+\\sum_{n=1}^\\infty A_n\\cos (n\\Omega t + \\varphi_n) \\] → \\(f(t)\\)=直流+各次谐波分量 \\(A_n=\\sqrt{a_n^2+b_n^2}=A_{-n},\\quad n=0,1,2,\\cdots\\) \\(\\varphi_n=-\\arctg\\frac{b_n}{a_n}=-\\varphi_{-n}\\) 指数形式 利用欧拉公式，引入负频率 \\[ f(t)=\\frac {A_0}2+\\sum_{n=1}^\\infty \\frac {A_n}2 (e^{j(n\\Omega t+\\varphi n)}+e^{-j(n\\Omega t+\\varphi n)})=\\sum_{n=-\\infty}^\\infty \\frac{\\dot A_n}{2}e^{jn\\Omega t} \\] 其中傅里叶复系数： \\[ \\dot A_n=A_ne^{j\\varphi_n}=a_n-jb_n=\\frac 2 T \\int_{t_1}^{t_1+T}f(t)e^{-jn\\Omega t}\\mathrm dt \\] \\(\\dot A_n = \\dot A_{-n}^*\\)→ 共轭对称 指数函数集分解：正交完备\\(\\{ e^{jk\\Omega t}|k\\in Z \\}\\) 信号波形和傅立叶系数的关系 一般性的结论： 收敛性：\\(n\\uparrow\\Rightarrow a,b\\downarrow\\) 叠加过程 P93: 叠加项数大 →Gibss 现象（9%的过冲情况） 时域变化快 → 高频、时域变化慢 → 低频 若\\(f(t)\\)是偶函数，则级数中只有\\(a_n\\)项， 若\\(f(t)\\)是奇函数，则级数中只有\\(b_n\\)项 偶半波对称（偶谐）： \\(f(t+\\frac T 2)=f(t)\\)→ 只有偶次谐波项 → 实际周期为 \\(T/2\\) 奇半波对称（奇谐）：只有奇次谐波项 对于一般的信号， \\(f(t)\\)总可以分解 \\(f=f_o+f_e\\) 若 \\(f(t)\\rightarrow \\dot A_n\\)，\\(f(t-t_0)\\rightarrow \\dot A_n&#39;\\)则： \\[ \\dot A_n&#39;=\\dot A_n e^{-jn\\Omega t_0} \\] \\(\\mathrm{cf}:\\quad f(t-t_0)\\leftrightarrow F(s) e^{-st_0}\\) 周期信号的频谱 由三角形式\\(f(t)=\\frac {A_0}2+\\sum_{n=0}^\\infty A_n \\cos(n\\Omega t+\\varphi_n)\\) → 幅度谱 \\(A_n\\sim n\\Omega , n = 0 , 1, ...\\)（单边谱） → 相位谱 \\(\\varphi_n\\sim n\\Omega , n = 0 , 1, ...\\)（单边谱） 指数形式：双边谱 → 通常画单边谱 注意其幅度谱是 \\(A_n/2\\) 还是 \\(A_n\\) 例子：（周期矩形脉冲） \\[ \\dot A_n = \\frac {2A \\tau} T Sa(\\frac{n\\Omega \\tau}2) \\] 其中：\\(Sa(x) = \\sin x / x\\)称为抽样（Sample）函数 周期信号频谱的特点 离散性：离散频率（时域中的周期 → 离散频域） 谐波性：只在谐波频率 \\(n\\Omega\\)上出现 收敛性： \\(n\\)足够大，其余高频分量可以忽略 有效频宽/带宽\\(B\\) \\(A_n\\)最大值的 1/10 为限； 第一个过零点，例如\\(B=2\\pi /\\tau\\Rightarrow B\\tau =Constant\\) 总功率的 90%为限 → 帕斯瓦尔定理 波形变化时，频谱的变化 \\(T\\)不变，\\(\\tau\\)改变 → 间隔\\(\\Omega\\)不变，过零点\\(\\omega _0=\\frac {2\\pi}\\tau\\)改变 \\(\\tau\\)增加，\\(w_0\\)减少，有效频宽内的谱线数减小 \\(\\tau\\rightarrow T\\)，只剩下 \\(A_0\\)，只有直流分量 \\(\\tau\\)减小，谱线数增加，\\(\\tau \\rightarrow 0, \\omega_0\\rightarrow \\infty\\) \\(\\tau\\)不变，\\(T\\)改变 → \\(\\omega_0\\)改变， \\(\\Omega\\)改变 \\(T\\rightarrow \\tau\\Rightarrow \\omega_0=\\frac{2\\pi}{\\tau}=\\Omega\\)→ 直流 \\(T\\rightarrow\\infty,\\Omega \\rightarrow \\mathrm d\\omega ,\\dot A_n\\rightarrow 0\\)但是各个分量有相对大小，且 \\(f(t)\\rightarrow非周期信号\\) 非周期信号的频谱 傅里叶正、反变换 傅里叶复系数 \\[ \\dot A_n = \\frac 2 T \\int_{t_1}^{t_1+T}f(t)e^{-jn\\Omega t}\\mathrm dt \\] 反应了相对大小的量： \\[ F(jn\\Omega)=\\frac{\\dot A_n}{2/T} \\] 从而 频谱密度函数（频谱）： \\[ F(j\\omega) = \\lim_{T\\rightarrow \\infty} F(jn\\Omega) \\] 傅立叶变换： \\[ F(j\\omega)=\\int_{-\\infty}^\\infty f(t)e^{-j\\omega t}\\mathrm dt \\] 傅立叶反变换： \\[ f(t) = \\frac 1 {2\\pi} \\int _{-\\infty} ^\\infty F(j\\omega) e^{j\\omega t} \\mathrm d\\omega \\] 一般的， \\(F(j\\omega)=|F(j\\omega)| e^{j\\varphi(\\omega)}\\) 频谱密度函数 \\(F(j\\omega)\\) 密度函数 特点： 单个矩形脉冲的傅立叶变换： \\(f(t) = \\varepsilon(t+\\tau/2)-\\varepsilon(t-\\tau/2)\\) \\(F(j\\omega) = \\lim_{T\\rightarrow \\infty}\\dot A_n / (2/T) = A\\tau Sa(\\frac{\\omega \\tau}2)\\) 单边指数信号 \\(f(t) = e^{-\\alpha t}\\varepsilon(t)\\) \\(F(j\\omega)=\\frac 1 {\\alpha+j\\omega }\\) 三角脉冲 \\(f(t) = A[1-\\frac {|t|}{\\tau}][\\varepsilon(t+\\tau)-\\varepsilon(t-\\tau)]\\) \\(F(j\\omega ) = A \\tau Sa^2(\\frac{\\omega \\tau}{2})\\) 时域非周期 → 频域连续谱； 时域周期 → 频域离散谱 收敛性 ← 能量有限才存在 FT 有效带宽（频带）：（三种定义方法） 最大幅度的 1/10（对于单调递减的频谱） 第一个过零点（Sa） 总能量的 90%为界（帕斯瓦尔定理） 包络一致性： \\(F(j\\omega)\\)与 \\(\\dot A_n\\)包络一致 互换关系： \\[ F(j\\omega) = \\frac {\\dot A_n}{2/T}|_n \\] 共轭对称性：\\(F(j\\omega) = F^*(-j\\omega)\\)，即： \\[ \\begin{aligned} |F(j\\omega)| \\sim \\omega 偶对称\\\\\\varphi(\\omega) \\sim \\omega 奇对称 \\end{aligned} \\] 奇偶对称性： 实偶 ←→ 实偶 实奇 ←→ 虚奇 延时特性： 若 \\(f(t)\\leftrightarrow F(j\\omega)\\) 则 \\(f(t-t_0)\\leftrightarrow F(j\\omega)e^{-j\\omega t_0}\\) 广义傅立叶变换（广义谱） \\(\\delta(t)\\leftrightarrow \\mathcal F\\{\\delta(t)\\}=1\\) → \\(\\delta(t)\\) 的广义定义为 \\(\\displaystyle\\frac {1}{2\\pi} \\int_{-\\infty}^{\\infty}1\\cdot e^{j\\omega t}\\mathrm d\\omega\\) \\(\\varepsilon (t)\\leftrightarrow\\pi \\delta (\\omega ) + \\frac 1 { j \\omega }\\) \\(A\\leftrightarrow 2 \\pi A \\delta (\\omega)\\) \\(\\mathrm{sgn} (t) \\leftrightarrow 2/j\\omega\\) \\(e^{j\\omega_ct}\\leftrightarrow 2\\pi \\delta (\\omega - \\omega_c)\\) \\(e^{-j\\omega_ct}\\leftrightarrow 2\\pi \\delta (\\omega + \\omega_c)\\) \\(\\cos \\omega t = \\pi(\\delta (\\omega -\\omega _c ) + \\delta(\\omega +\\omega _c))\\) \\(\\sin \\omega t = j\\pi(\\delta (\\omega +\\omega _c ) - \\delta(\\omega -\\omega _c))\\) 周期信号：\\(f_T(t) = \\sum _{n=-\\infty}^\\infty \\frac{\\dot A_n}{2} e^{jn\\Omega t} \\leftrightarrow F(j\\omega) = \\pi \\sum_ {-\\infty} ^{\\infty} \\dot A_n\\delta(\\omega - n\\Omega)\\) 周期性冲激序列： \\(f(t) =\\sum _{n=-\\infty}^{\\infty}\\delta(t-nT)=\\sum\\frac 1 T e^{jn\\Omega t}\\) \\(F(j\\omega) = \\Omega \\sum \\delta (\\omega - n \\Omega)\\) 傅立叶变换的基本性质 前提：假设 FT 存在 线性性质： 齐次性+叠加性 延时特性： \\(f(t-t_0) \\leftrightarrow F(j\\omega) e^{-j\\omega t_0}\\) 调制（移频）性质： \\(f(t)e^{j\\omega t} \\leftrightarrow F(j\\omega ) |_{\\omega = \\omega - \\omega _c}\\) → \\(f(t)\\cos \\omega _c t \\leftrightarrow \\frac 1 2 [F(j\\omega - j\\omega_c) + F(j\\omega + j \\omega _c)]\\) → \\(f(t)\\sin \\omega _c t \\leftrightarrow \\frac 1 {2j} [F(j\\omega - j\\omega_c) - F(j\\omega + j \\omega _c)]\\) \\(1\\leftrightarrow 2 \\pi \\delta(\\omega)\\Rightarrow e^{-j\\omega_c t} \\leftrightarrow 2\\pi \\delta (\\omega + \\omega _c)\\) \\(\\cos (\\omega_c t )\\varepsilon(t) \\leftrightarrow \\cdots\\) 尺度变换（比例性质）： \\(f(at) \\leftrightarrow \\frac 1 {|a|} F(j\\omega /a)\\) \\(f(at-t_0) \\leftrightarrow \\frac 1 {|a|} F(j\\frac \\omega a)e^{-j\\frac \\omega a t_0}\\) 互易（对称）性质 [#important] \\[ f(t)\\leftrightarrow F(j\\omega)\\Rightarrow F(jt) \\leftrightarrow 2\\pi f(-\\omega) \\] \\(f\\)实偶 → \\(F(j\\omega)\\)也是实偶 \\(\\mathcal F\\{ F(t) \\}=2\\pi f(\\omega)\\Rightarrow f(t) = \\frac 1{2\\pi} \\mathcal F\\{ F(t)\\}|_{\\omega = t}\\) \\(F_3= \\varepsilon(\\omega + \\omega_1) - \\varepsilon (\\omega - \\omega_1) \\leftrightarrow f_3(t) = \\frac {\\omega_1}{\\pi} Sa(\\omega_1t)\\) 时域微积分性质（微积分组合性质更加常用） 微分性质： \\[ \\frac{\\mathrm d^nf(t)}{\\mathrm dt^n} \\leftrightarrow(j\\omega)^nF(j\\omega) \\] 积分性质： \\[ g(t)\\leftrightarrow G(j\\omega),\\\\ \\int_{-\\infty}^t g(\\tau)\\mathrm d\\tau\\leftrightarrow G( j\\omega)/j\\omega + \\pi G(0)\\delta (\\omega ),\\quad G(0) =\\int_{-\\infty}^{+\\infty } g(t) \\mathrm dt \\] 组合性质： \\[ f(t) \\leftrightarrow \\frac{\\mathcal F[\\frac{df(t)}{dt}]}{j\\omega} + \\pi (f(+\\infty) +f(-\\infty)) \\delta (\\omega) \\] 注意其中的加号： \\(\\displaystyle f(t) = \\int_{-\\infty}^{t} \\frac{df(\\tau)}{d\\tau}\\mathrm d\\tau+f(-\\infty)\\) 频域微（积）分性质 \\[ (-jt)^nf(t) \\leftrightarrow \\frac{\\mathrm d^n F(j\\omega)}{\\mathrm d\\omega^n} \\] 卷积定理[#important] 时域卷积定理： \\[ f_1*f_2\\leftrightarrow F_1\\times F_2 \\] 频域卷积定理： \\[ f_1\\times f_2\\leftrightarrow \\frac 1 {2\\pi}F_1*F_2 \\] 3.17(ac) 3.21(135) 3.23 3.24 Parseval 定理、能量频谱，功率谱和能量谱 周期信号的功率谱 功率谱的概念 \\[ P = \\frac 1 T \\int_{0}^Tf_T^2(t)\\mathrm dt=\\sum _{n=0}^\\infty P_n=\\sum_{n=0}^\\infty\\frac{\\dot A_n^2}{2} \\] 周期信号的有效值 \\[ I = \\sqrt{P} \\] 能量信号的能量谱 \\[ \\overline W = \\int_{-\\infty}^\\infty |f(t)|^2\\mathrm dt = \\int _{0}^\\infty \\frac{|F(j\\omega)|^2}{\\pi }\\mathrm d \\omega \\]","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"连续时间系统的频域分析","slug":"study/ComputerScience/Signals and Systems/Chapter 4 连续时间系统的频域分/Chapter 4 连续时间系统的频域分","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.638Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 4 连续时间系统的频域分/Chapter 4 连续时间系统的频域分/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%204%C2%A0%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A2%91%E5%9F%9F%E5%88%86/Chapter%204%C2%A0%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A2%91%E5%9F%9F%E5%88%86/","excerpt":"信号与系统-连续时间系统的频域分析","text":"信号与系统-连续时间系统的频域分析 # Chapter 4 连续时间系统的频域分析 Intro FT分析法 理想滤波器的频响和冲激响应 调制和解调→ 调幅 信号通过系统的频域分析方法（用傅里叶变换求零状态响应） 周期信号通过系统的响应→正弦稳态响应 非周期→ FT FT分析法 对\\(D(p)r(t) = N(p)e(t)\\)做傅里叶变换： \\[ R(j\\omega) = \\frac{N(j\\omega)}{D(j\\omega)}E(j\\omega) =H(j\\omega)E(j\\omega) \\] 其中\\(H(j\\omega)\\)为系统的频响。则 \\[ f(t) = \\mathcal F^{-1}\\{R(j\\omega)\\} = \\mathcal F^{-1} \\{H(j\\omega)E(j\\omega)\\} \\] 频响 \\(H(j\\omega)\\) 求法： 直接求： \\(H(j\\omega)=\\frac{N(j\\omega)}{D(j\\omega)}\\) 电路： \\(H(j\\omega) = \\frac{\\dot R(j\\omega)}{\\dot E(j\\omega)}|_{ZS}\\) \\(H(j\\omega) = \\frac{\\mathcal F\\{ r_{zs}(t) \\}}{\\mathcal F\\{e(t)\\}}\\) \\(H(j\\omega) = \\mathcal F\\{h(t)\\}\\) \\(H(j\\omega) = \\frac{e^{j\\omega t} 作用下的零状态响应}{e^{j\\omega t}}\\) 理想低通滤波器的冲激响应和阶跃响应 理想低通滤波器的频谱特性为： \\[ H(j\\omega) = K(\\varepsilon(\\omega + \\omega_{c0})-\\varepsilon(\\omega - \\omega_{c0}))e^{-j\\omega t_0} \\] 冲激响应为： \\[ h(t) = \\frac{\\omega_{c0}K}{\\pi} Sa(\\omega_{c0}(t-t_0)) \\] 特性： 延时： \\(t-t_0\\)（相频特性→群时延） 缓慢变化：上升时间 \\(\\displaystyle t_r\\approx \\frac \\pi {\\omega _{c0}}\\) 非因果性 *阶跃响应： \\[ r_\\varepsilon(t) = \\frac K 2 [1+\\frac 2 \\pi Si(\\omega_{c0} (t-t_0)],\\quad Si(x) =\\int_0^x \\frac {\\sin t}t\\mathrm dt \\] 佩利-维纳准则和物理可实现滤波器 因果系统必须满足 Paley-Wiener 条件 Paley-Wiener条件： \\[ \\int_{-\\infty}^\\infty\\frac{|\\ln |H(j\\omega)|}{1+\\omega ^ 2}\\mathrm d \\omega &lt; \\infty \\] 若满足平方可积条件的时候，可以证明系统满足因果性的充要条件是 Paley - Wiener 条件 常见滤波器： 巴特沃斯滤波器 切比雪夫滤波器 调制、解调 调制和解调的概念 主要是调幅波 载波：\\(a_0 = A_0\\cos (\\omega_ct+\\varphi_c)\\) 已调波：\\(a(t) = A(t) \\cos (\\omega_c(t) t + \\varphi_c(t))\\)（调幅、调相、调角） 考察重点： 调幅波的定义→波形 功率 频谱 定义：\\(a(t) = [A_0+e(t)]\\cos \\omega_ct,e(t) =\\sum E_{nm}\\cos(\\Omega_n t+\\varphi_n)\\) 上调幅系数：\\(m_上=\\frac{A_{\\max} - A_0}{A_0}\\) 下调幅系数：\\(m_下=\\frac{A_0-A_{\\min}}{A_0}\\) 若\\(e(t)\\)上下对称：\\(m_上=m_下=m=(A_{\\max}-A_{\\min})/(A_{\\max} +A_{\\min})\\) 部分调幅系数：\\(m_n=\\frac{E_{nm}}{A_0}\\) 调幅波的功率：（单个频率） 最大平均功率（额定功率）：\\(P_{\\max}=\\frac{1}{2}A_{\\max}^2=\\frac 1 2 A_0^2(1+m)^2=(1+m)^2P_c\\) 载波平均功率：\\(P_c=\\frac{A_0^2}{2}\\) 总平均功率：\\(\\bar P = \\frac 1 T \\int _0^TP_{Tc}\\mathrm dt=P_c(1+m^2/2)\\) 对于多频调幅： \\(P_c=A_0^2/2\\) \\(P_{\\max} = \\frac 1 2 A_0^2(1+m_{上})^2\\) \\(\\bar P = P_c(1+\\sum m_n^2/2)=载频功率+旁频功率\\) 调幅波的频谱： 抑制载波调幅（AM-SC） \\(a(t) = Ke(t)\\cos(\\omega_ct+\\phi_c)\\) 脉冲幅度调制（PAM） 频分复用和时分复用 频分复用 时分复用 信号通过线性系统不产生失真的条件 若 \\(r(t) = Ke (t - t_0)\\) \\(t_0\\)称为群时延（常数）→ 不失真 理想的： \\[ H(j\\omega) = Ke^{-j\\omega t_0} = |H(j\\omega)|e^{-j\\varphi(\\omega)} \\] 具体来说： 幅频是常数 相频是过原点的直线 实际上，在输入信号的频带范围内满足。","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"离散系统的时域分析","slug":"study/ComputerScience/Signals and Systems/Chapter 7 离散系统的时域分析/Chapter 7 离散系统的时域分析","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.578Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 7 离散系统的时域分析/Chapter 7 离散系统的时域分析/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%207%20%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/Chapter%207%20%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/","excerpt":"信号与系统- 离散系统的时域分析","text":"信号与系统- 离散系统的时域分析 Chapter 7 离散系统的时域分析 重点： 抽样定理 零输入相应 卷积和 引言-离散时间信号的描述 离散信号的描述 定义：只在离散时刻 \\(t_k\\) 才有定义 \\(f(t_k)\\)只讨论等间隔的情况 离散信号→时间离散 量化信号→幅度量化 数字信号→时间离散&amp;幅度离散 描述方式 闭式：写成时刻\\(t_k\\)的函数（等间隔的情况下，写成\\(k\\)的函数） 例如：\\(f(k) = \\frac 1 {2^k}\\) 数值序列：\\({1, .5, .25, ...}\\) → 离散信号也被称为一个序列 时域波形 常用序列 单位阶跃： \\[ \\varepsilon(k)=\\begin{cases} 1&amp;k\\ge 0\\\\0&amp;k&lt;0 \\end{cases} \\] 单位（样值）函数： \\[ \\delta(k)=\\begin{cases} 1&amp;k=0\\\\0&amp;k\\ne0 \\end{cases} \\] 关系： \\(\\delta(k) = \\varepsilon(k) - \\varepsilon(k-1)\\)一阶向后差分Chapter 4 多项式插值和函数最佳逼近 \\(\\varepsilon(k) = \\delta(k) + \\delta(k-1) + \\delta(k-2)+\\cdots\\) （单边）指数序列 \\[ \\nu^k\\varepsilon(k),\\quad \\nu\\in R \\] 收敛、发散、等幅 变幅正弦震荡：(\\(\\nu,\\nu^*\\)是共轭根） \\[ (C\\nu^k+C^*(v^*)^k)\\varepsilon(k)= 2|C||\\nu|^k\\cos(k\\varphi+\\theta) \\] 抽样定理 理想抽样 \\[ \\delta_T(t)=\\sum_{n=-\\infty}^{\\infty} \\delta(t-nT)\\rightarrow f_s(t) = f(t)\\delta_T(t)\\\\ F_S(j\\omega) = \\frac 1 {2\\pi} F(j\\omega) * \\delta_{ws}(\\omega)=\\sum _{n=-\\infty}^\\infty F(j(\\omega - n\\omega_s)) \\] 低频信号的抽样定理（带限信号，最高频率为\\(\\omega_m\\)） 理想抽样 奈奎斯特抽样定理： 当\\(\\omega_s \\ge 2 \\omega_m\\) 则\\(F_s\\)无混叠，可以完全恢复 内插公式： \\[ f(t) = \\sum_{k=-\\infty}^\\infty f(kT)Sa\\left[{\\frac{(t-kT)\\omega_s}{2}}\\right] \\] 工程上，若有效带宽为 \\(\\omega_m\\)则一般取3-5倍频率采样 实际上可以采用开关函数（窄脉冲序列） → 平顶抽样 \\(f(t)\\)→ 采样 → 保持 → 离散时间系统的描述和模拟 系统表示 连续 离散 IO 微分方程 差分方程 框图 三个基本单元 三个基本单元 系统函数 \\(H(s)\\) \\(H(z)\\) LTI中： 线性常系数微分方程 （也可以称为 线性移不变系统LSI）线性常系数差分方程 差分方程描述的离散系统 Def（差分）Chapter 4 多项式插值和函数最佳逼近 差分和等距节点的Newton插值多项式 \\(\\Phi\\{k,y(k),...,\\Delta^ny(k),e(k),...,\\Delta^n(k)\\}=0\\) 定义移序算子 \\(S\\)， \\(S^i[y(k)]=y(k+i)\\) \\[ (S^n+a_{n-1} S^{n-1} + \\cdots + a_0)y(k) = (b_mS^m + \\cdots + b_0)e(k) \\] 简记为： \\[ D(S)y(k) = N(S)e(k)\\\\ y(k) \\mathop{=}\\limits^\\Delta H(S)e(k) \\] 若 \\(\\forall a_i=0\\)→ 非递归系统 → FIR有限冲激响应 若 \\(\\exist a_i\\ne 0\\)→ 递归系统 → IIR 无限冲激响应 差分方程描述的LTI离散系统的框图模拟 基本运算单元 加法器 标量乘法器 延时器 框图 引入中间变量 \\(q(k)\\) 令 \\(D(S) q(k) = e(k)\\) 则 \\(y(k) = N(S) q(k)\\) 离散系统的零输入响应 \\(y_{zi}(k)\\) 求法 一阶系统： \\[ y(k+1)+a_0y(k) = 0 \\] \\[ \\Rightarrow (S+a_0) y(k) = 0 \\] 特征根为： \\(-a_0\\) 零输入响应为： \\(y(k) = (-a)^ky(0)\\) n 阶系统： 根据特征多项式求出特征根，从而求出解： 特征根均为单根： \\[ y_{zi}(k) = \\sum_i c_i\\nu_i^k \\] 有一个\\(l\\)重根： \\[ y_{zi}(k) = (c_1+c_2k+\\cdots+c_lk^{l-1})\\nu_1^k+\\sum_{j = l+1} ^ n c_j \\nu_j^k \\] 共轭根需要配对！ 离散系统的零状态响应 时域卷和法 \\[ e(k) = \\sum_{j=-\\infty}^\\infty e(j) \\delta(k-j)\\mathop=\\limits^\\Delta e(k)*\\delta(k) \\] 则： \\[ y_{zs}(k) = \\sum_{j=-\\infty}^\\infty e(j ) h(k-j) = e(k) * h(k) \\] 卷积和的计算 图解法，长乘法（列表法），解析法，性质，Z变换 解析法：针对无限长序列的卷积 $$ e(k) = a^k(k)h(k) = b^k(k)\\ \\[\\begin{aligned} a = b&amp;\\Rightarrow (k+1) a^k \\varepsilon(k)\\\\ a\\ne b&amp;\\Rightarrow \\frac {1}{b-a} [b^{k+1}- a^{k+1}]\\varepsilon(k) \\end{aligned}\\] $$ 卷积和的性质 代数运算： 交换律 结合律 分配律 有限长序列卷积： \\(A(k)\\) \\(B(k)\\) 项数为 \\(N_A,N_B\\) 项数为： \\(N_C=N_A+N_B\\) 上下限为：两个上下限之和 \\(\\sum C(j) = (\\sum A(j))(\\sum B(j))\\) \\(e*\\delta = e\\) 延时： \\(y(k-n_1-n_2) = e(k-n_1) * h(k-n_2)\\) 求 h(k) → 求出 \\(H(S)\\) 的部分分式分解，然后利用： \\[ \\frac 1 {S-v}\\leftrightarrow v^{k-1} \\varepsilon(k-1) \\]","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"连续时间系统的系统函数","slug":"study/ComputerScience/Signals and Systems/Chapter 6 连续时间系统的系统函/Chapter 6 连续时间系统的系统函","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.638Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 6 连续时间系统的系统函/Chapter 6 连续时间系统的系统函/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%206%20%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%87%BD/Chapter%206%20%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%87%BD/","excerpt":"","text":"信号与系统- 连续时间系统的系统函数 Chapter 6 连续时间系统的系统函数 引言 系统函数的三种表示法 零点和极点与响应的关系 稳定性判据（含反馈系统的稳定性）→罗斯准则 复杂系统 系统函数的极零图 系统函数的三种表示方法： 频率响应特性曲线→频响 幅相特性曲线→复轨迹 极零图 系统函数的频响 \\[ H(j\\omega ) = |H| e^{j\\varphi(\\omega)} \\] 共轭对称 对于因果系统： 幅频和相频不是相互独立的（希尔伯特变换） 幅相特性曲线（复轨迹） 用于反馈系统稳定性判据（奈氏图） 例如：二阶RC（极坐标） \\[ |H(jw) |=\\frac 1 G\\cos \\varphi \\] 对于实轴上下对称 \\(w=0\\)在正实轴上 实际系统中由于分布电容存在：\\(w\\rightarrow \\pm \\infty,~H\\rightarrow 0\\) 从而从原点开始，到原点结束 极零图 \\[ H(s) = \\frac{N(s)}{P(s)} = H_0 \\frac{(s-z_1)(s-z_2)\\cdots} {(s-p_1)(s-p_2)\\cdots} \\] 对实轴上下对称 广义上：极零点数目相等 系统函数极零点分布和时域响应的关系 \\[ \\sum_k k_k e^{p_k t},t\\ge 0\\leftrightarrow \\sum _k \\frac{k_k}{s-p_k} \\] 因果系统的极点→S都在左半开平面上 ROC包含虚轴→稳定 与全响应的关系： \\[ R(s) = \\frac{P(s)}{D(s)} + \\frac{N(s)}{D(s)} E(s) \\] P/D 和 N/D 贡献了自然响应，E贡献了受迫响应 例：全通系统：所有几点都有对虚轴镜像对称的零点 m=n 幅频特性=常数 例：最小相移系统（零点、极点都在左半平面上「相位比较小」）和非最小相移系统（零点镜像、极点不动） ## 波特图 ### 对数频率特性 增益： \\(G(\\omega)=20\\log |H(j\\omega)|\\) 一次因式的增益： \\[ G(w)=20\\log|z_1|+20\\log|1-j\\frac \\omega{z_1}|~\\mathrm{dB} \\] 用+号右边来研究，左侧放入 \\(H(jw)\\) 系统的稳定性 稳定因果系统的判别 BIBO：任意有界输入→有界零状态相应 原型低通滤波器的 \\(h(t)\\) 绝对可积（能量有限）→ 绝对稳定 或者 \\(\\lim_{t\\rightarrow \\infty} f(t) = 0\\)则（渐进）稳定 （因果系统的）系统函数H的极点都在左半开平面上（看虚轴是否在ROC中） 罗斯准则（Routh-Hurwitz）准则（可以不求出极点） 奈氏准则 例如：全反馈网络→（闭环传递函数为 \\(\\frac{G(s)}{1+G(s)H(s)}\\)开环传递函数为 \\(G(s)H(s)\\)） → 前向系统不稳定，但引入反馈后可能稳定。 罗斯准则 \\[ H(s) = \\frac{N(s)}{D(s)} = \\frac{\\sum_i^n b_is^i}{\\sum_i^na_is^i} \\] H(s) 的极点不落在s右半闭平面上的必要条件： \\(a_i\\)不缺项且同号 若 \\(a_0=0\\)其余 \\(a_i\\ne 0\\)最多临界稳定 极点都在虚轴上的必要条件：D(s)全奇次or全偶次→最多临界稳定 R-H准则： R-H数列变号的次数=\\(D(s)\\)在右半开平面的次数 先由特征多项式排成两行： \\[ \\begin{matrix} s^n&amp;|&amp;A_n&amp;B_n&amp;C_n&amp;D_n&amp;\\dots\\\\ s^{n-1}&amp;|&amp;A_{n-1}&amp;B_{n-1}&amp;C_{n-1}\\dots\\\\ s^{n-2}&amp;|&amp;A_{n-2}&amp;B_{n-2}&amp;\\dots\\\\ \\vdots&amp;|&amp;\\vdots\\\\ s^1&amp;|&amp;A_1&amp;B_1\\\\ s^0&amp;|&amp;A_0 \\end{matrix} \\] 依据递推公式求值 第一列 \\(A_i\\) 为罗斯数列，观察其变号次数。 若： 上一行的第一项为0，其余项不全为0 将0用无穷小量 \\(\\varepsilon\\)代替，判据不变 引入：(s+1)D(s) 倒排法：将i和n-i互换，判据不便 上一行全为0：D(s)有一个因式A(s)，称为辅助多项式，A(s)=全零行的上一行 从而：用A'(s)的系数代替当前行 Homework 6.14(3,5,6)","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"离散系统的变换域分析","slug":"study/ComputerScience/Signals and Systems/Chapter 8 离散系统的变换域分析/Chapter 8 离散系统的变换域分析","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.638Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 8 离散系统的变换域分析/Chapter 8 离散系统的变换域分析/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%208%20%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%98%E6%8D%A2%E5%9F%9F%E5%88%86%E6%9E%90/Chapter%208%20%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%98%E6%8D%A2%E5%9F%9F%E5%88%86%E6%9E%90/","excerpt":"信号与系统- 离散系统的变换域分析","text":"信号与系统- 离散系统的变换域分析 Chapter 8 离散系统的变换域分析 引言 时域卷和→z域乘法 差分方程→z域代数方程 重点： （双边）正反z变换 （单边）z变换性质 z域分析法 DTFT z变换定义及其收敛区 z变换的定义 \\(f(k) \\leftrightarrow F_d(z) \\mathop=\\limits^\\Delta \\sum_{k=-\\infty}^\\infty f(k) z^{-k} = Z[h(k)]\\) 如果\\(f(k)\\)本身是单边的，则\\(k\\)可以从0开始取 \\(z=e^{sT}\\)：z域到s域上的基本映射 \\(F(z)|_{z=e^{sT}} = F_s(s)\\)（理想抽样信号的LT） z变换的收敛区 有限长序列：\\(f(k)\\leftrightarrow F(z) = \\sum_{k = n_1}^{n_2} f(k) z^{-k}\\)→在整个z平面上收敛（可能不含\\(z=0,\\infty\\)） 单边序列（以右边为例）：\\(a^k\\varepsilon(k)\\leftrightarrow F(z) =\\frac z{z-a}\\quad |z|&gt;|a|\\) 如果是左边序列：\\(b^k\\varepsilon(-k-1) \\leftrightarrow F(z) = -\\frac{z}{z-b}\\) 常见的z变换 单位样本函数：\\(\\delta(k)\\leftrightarrow 1\\) ROC为整个z平面 单边指数序列：\\(a^k\\varepsilon(k)\\leftrightarrow \\frac {z} {z-a}\\)ROC为\\(|z|&gt;|a|\\) 单位阶跃序列：\\(\\varepsilon(k) \\leftrightarrow \\frac z {z-1}\\)ROC: \\(|z|&gt;1\\) 单位正弦： \\(\\cos \\beta^k \\varepsilon(k) \\leftrightarrow \\frac{z^2-z\\cos\\beta}{z^2-2z\\cos\\beta + 1}\\)ROC: \\(|z|&gt;1\\) \\(\\sin \\beta^k \\varepsilon(k) \\leftrightarrow \\frac{z^2-z\\sin\\beta}{z^2-2z\\cos\\beta + 1}\\)ROC: \\(|z|&gt;1\\) 特别的：\\(\\cos\\frac{k\\pi}{2}\\varepsilon(k)\\leftrightarrow \\frac{z^2}{z^2+1}\\)，\\(\\sin\\frac{k\\pi}{2}\\varepsilon(k)\\leftrightarrow \\frac{z}{z^2+1}\\) 斜变序列：\\(k\\varepsilon(k) \\leftrightarrow \\frac z {(z-1)^2}\\) 单边 z 变换的性质 线性性质： 移序性质： \\(f(k+n)\\varepsilon(k) \\leftrightarrow z^nF(z) -z^{n}f(0) - z^{n-1} f(1) - \\cdots -zf(n-1)\\) \\(f(k-n) \\varepsilon(k-n) \\leftrightarrow z^{-n} F(z)\\) \\(f(k-n)\\varepsilon(k) \\leftrightarrow z^{-n}F(z) + z^0f(-n) + \\cdots + z^{-(n-2)} f(-2) + z^{-(n-1)}f(-1)\\) 对于单边变换：\\(f(k\\pm n) \\leftrightarrow z^{\\pm n}F_d(z)\\) z 域尺度变换（序列指数加权）：\\(a^kf(k)\\leftrightarrow F(z/a)\\quad(a\\ne 0)\\) 卷积定理：\\(f*g\\leftrightarrow F\\cdot G\\) z 域微分（序列线性加权）：\\(kf(k) \\leftrightarrow (-z)\\frac{\\mathrm dF(z)}{\\mathrm dz}\\) 初值和终值定理：\\(F(z) = f(0) + f(1) z ^ {-1} + f(2) z ^{-2} + \\cdots\\) 初值：\\(f(0) = F(z) |_{z=\\infty},~f(1) = (zF(z) - zf(0)) |_{z=\\infty}, \\cdots\\) 终值：\\(f(+\\infty)=\\lim _{z\\rightarrow 1}(z-1)F(z)\\) （条件：\\(f(k)\\)存在终值、\\(F(z)\\) 的极点都在单位圆内，或者为\\(1\\) 反z变换 幂级数展开 借助泰勒公式： \\[ f(x) = f(0) + f&#39;(0) x + \\cdots\\quad(\\mathrm {by~Taylor~Series}) \\] 长除法： 对右边序列：分子分母降序排列相除 对左边序列：分子分母升序排列相除 部分分式法 将\\(F(z)/z\\)展开，设\\(F(z)\\)极点都是单阶的： \\[ \\frac{F(z)}z=\\frac{K_0}z+\\frac{K_1} {z-v_1}\\cdots + \\frac{K_n}{z-v_n} \\] 若有重根存在，可以考虑留数法 留数法 因为： \\[ F(z) = f(0) + f(1)z^{-1} + \\cdots \\] 从而： \\[ f(k) = \\frac{1}{2\\pi j}\\oint_cF(z)z^{k-1}\\mathrm dz \\] 双边正反Z变换 双边z变换 \\[ F_r(z)=F_{br}(z) = \\sum_{k=-\\infty}^{\\infty} f_r(k) z^{-k},\\\\ F_{bl}(z) = \\sum_{k=-1}^{-\\infty} f_l(k) z^{-k}=\\sum_{k=1}^\\infty f_l(-k)\\left(\\frac1 z\\right)^{-k}=\\mathcal Z\\{f_l(-k)\\}[1/z] \\] 双边反z变换 \\[ F_b(z) = F_{br}(z) + F_{bl}(z) \\] z变换和LT的关系 \\(f(t)\\) 时间离散化为 \\(f(k)\\)则\\(f_s(t) = f(t) \\delta_T(t)\\)\\(F(z)|_{z=e^{j\\omega T}}=F_s(j\\omega)\\) \\(z=e^{sT}\\) 映射关系设 \\(s=\\sigma + j\\omega\\) ，若 \\(z=re^{j\\theta}\\) 其中 \\(r = e^{\\sigma T},~\\theta = \\omega T\\) \\(F(z)\\)和\\(F(s)\\)的关系（只考虑单边）\\(f(k) = f(t) |_{t=kT}\\)，\\(F(z)=\\frac 1 {2\\pi j} \\int_{\\sigma-j\\infty}^{\\sigma + j\\infty} F(s)\\frac{z}{z-e^{sT}}\\mathrm ds\\) z 变换分析法 对于\\(n\\)阶系统： 零输入相应 对齐次方程取单边 z 变换 \\[ Y_{zi}(z) \\leftrightarrow y_{zi}(k) \\] 然后使用移序性质求解。 零状态响应 \\[ y_{zs}(k) = e(k) * h(k)\\leftrightarrow H(z) E(z) \\] 全响应 法 1: ZS+ZI 法 2: 对差分方程直接求单边 Z 变换 离散时间系统的频率响应特性 定义 离散系统频响的特点 \\(\\omega\\)的连续函数 幅频\\(\\omega\\)的偶函数，相频\\(\\omega\\)的奇函数（共轭对称） 以\\(\\omega_s\\)为周期 离散系统频响的图解 \\[ H(z) = b_m \\frac{\\prod_i (z-z_i)}{\\prod_r (z-p_r)} \\] 如果 Z 变换的零点或极点落在原点上，它们对 H 的幅值没有影响。 离散系统的系统函数和稳定性判据 系统函数 \\(H(z) = \\frac{N(S)}{D(S)}|_{S=z}\\) \\(H(z) = Y(z) / E(z) |_{ZS}\\) \\(H(z) = Y_{zs}(z) / E(z)\\) \\(H(z) = z^k 作用下的（零状态）响应/z^k\\) 框图（数字滤波器的结构） 并联型：注意共轭根配对 串联型 混联 通用方法：设 W 为中间变量，列方程求解 稳定性判据（因果系统） BIBO \\(h(k)\\) 绝对可和；（放宽到渐进条件：\\(\\lim_{k\\rightarrow\\infty}h(k)=0\\)） \\(H(z)\\) 极点在单位圆内； R-H 准则：使用双线性变换\\(z=\\frac{s+1}{s-1}\\)代入\\(D(z)\\) 信号与频谱的关系","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"连续时间系统的复频域分析","slug":"study/ComputerScience/Signals and Systems/Chapter 5 连续时间系统的复频域/Chapter 5 连续时间系统的复频域","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.638Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 5 连续时间系统的复频域/Chapter 5 连续时间系统的复频域/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%205%20%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%8D%E9%A2%91%E5%9F%9F/Chapter%205%20%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%8D%E9%A2%91%E5%9F%9F/","excerpt":"信号与系统- 连续时间系统的复频域分析","text":"信号与系统- 连续时间系统的复频域分析 Chapter 5 连续时间系统的复频域分析 Introduction 拉普拉斯变换Laplace Transform(LT) 重点： 正反LT及其性质 LT求响应 系统函数→框图 拉普拉斯变换 \\[ F_d(s) = \\int_{-\\infty}^\\infty f(t)e^{-st}\\mathrm dt\\\\f(t) = \\frac1{2\\pi j}\\int _{\\sigma -j\\infty}^{\\sigma + j\\infty}F_d(s)e^{st}\\mathrm ds \\] \\(s\\)取值要在收敛域中（ROC） 收敛区不包含虚轴→LT存在而FT不存在。 对于有始信号： \\(f(t)=f(t)\\varepsilon(t)\\leftrightarrow F(s)\\) \\[ F(s)=\\int_{0^-}^{+\\infty}f(t)e^{-st}\\mathrm dt,\\quad s\\in ROC\\\\f(t)=\\frac 1{2\\pi j}\\int_{\\sigma-j\\infty}^{\\sigma+j\\infty}F(s)e^{st}\\mathrm ds\\cdot \\varepsilon (t) \\] LT的含义：分解成无穷多个复指数分量的叠加 复频率和单元信号\\(e^{st}\\)的关系 \\(\\sigma\\)决定了信号幅度比那花的快慢 \\(\\omega\\)决定了振荡的频率 一对共轭根变为变幅正弦振荡 LT的收敛区 Def（指数阶）若\\(f(t)\\)仅有有限个极值点，\\(t\\rightarrow \\pm\\infty\\)\\(f(t)\\)是\\(\\sigma_0\\)指数阶的，即： 对于有始信号 \\(\\lim_{t\\rightarrow\\infty}f(t)e^{-\\sigma t}=0\\)→\\(\\sigma&gt;\\sigma_{0^+}\\) 对于左边信号 \\(\\lim_{t\\rightarrow-\\infty}f(t)e^{-\\sigma t}=0\\)→\\(\\sigma &lt; \\sigma_{0^-}\\) 对于双边信号 \\(\\lim_{t\\rightarrow\\pm\\infty}f(t)e^{-\\sigma t}=0\\)→\\(\\sigma_{0^+}&lt;\\sigma &lt; \\sigma_{0^-}\\) 则其LT在以上区域（ROC）内收敛，称 \\(s=\\sigma_0\\)是收敛轴。（ROC不包含边界） 分析 \\(f(t)=e^{\\alpha t}\\varepsilon(t)\\)→ \\(F(s)=\\frac 1{s-\\alpha}\\), \\(Re[s]&gt;Re[\\alpha]\\) 一个有始信号的ROC的收敛轴由最右边极点决定，ROC在收敛轴右侧。 对于左边信号，其结论相反。如 \\(f(t)=e^{\\beta t}\\varepsilon(-t)\\leftrightarrow F(s) = \\frac{1}{s-\\beta}\\) 一个左边信号的ROC的收敛轴由最左边极点决定，ROC在收敛轴左侧。 对于双边信号，一般是带状区域：如何通过极点图反求原信号（注意分析左右边信号） 若 \\(\\sigma_{0^-}\\le \\sigma_{0^+}\\)，双边LT不存在，例如： \\(\\cos\\)和 \\(\\sin\\) 双边变换一定要标出ROC，否则原信号不能判断 \\(\\varepsilon(t)\\leftrightarrow \\frac 1 s,\\quad ROC:Re[s]&gt;0\\) \\(-\\varepsilon(-t)\\leftrightarrow \\frac 1 s,\\quad ROC:Re[s]&lt;0\\) ROC内没有极点 一般的信号为指数阶的有始信号 对于有始信号而言， \\(\\sigma_{0^+}&lt;0\\)→ FT存在 \\(\\sigma_{0^+}&gt;0\\)→ FT不存在 \\(\\sigma_{0^+}=0\\)，经典FT不存在，但广义FT存在： \\[ \\sum\\frac{k_i}{s-\\lambda_i} \\rightarrow \\sum \\pi k_i\\delta(\\omega-\\omega_i)+k_i\\frac{1}{-\\alpha+j\\omega} \\] 常用LT 指数类 \\(e^{\\alpha t}\\varepsilon(t) \\leftrightarrow 1 /(s-\\alpha),\\sigma&gt;Re[\\alpha],p_1=\\alpha\\) \\(\\displaystyle \\cos(\\omega_ct)\\varepsilon(t)\\leftrightarrow \\frac{s}{s^2+\\omega_c^2},\\sigma &gt;0,p_{1,2}=\\pm j\\omega_c\\)（单边，余弦） \\(\\displaystyle \\sin(\\omega_ct)\\varepsilon(t)\\leftrightarrow \\frac{\\omega_c}{s^2+\\omega_c^2},\\sigma &gt;0,p_{1,2}=\\pm j\\omega_c\\)（单边，正弦） \\(\\displaystyle e^{\\alpha t}\\cos (\\omega_c t)\\varepsilon(t)\\leftrightarrow \\frac{s-\\alpha}{(s-\\alpha)^2+\\omega_c^2},\\sigma &gt;Re[\\alpha],p_{1,2}=\\alpha \\pm j\\omega_c\\) \\(\\displaystyle e^{\\alpha t}\\sin (\\omega_c t)\\varepsilon(t)\\leftrightarrow \\frac{\\omega_c}{(s-\\alpha)^2+\\omega_c^2}, \\sigma &gt;Re[\\alpha],p_{1,2}=\\alpha \\pm j\\omega_c\\) \\(\\ch \\beta t,\\sh\\beta t\\) t的正幂函数类 \\(t^n\\varepsilon(t)\\leftrightarrow \\frac{n!}{s^{n+1}},\\sigma&gt;0,p=0\\) \\(t^{nt}e^{\\alpha t}\\varepsilon(t)\\leftrightarrow \\frac{n!}{(s-\\alpha)^{n+1}},\\sigma&gt;Re[\\alpha],p=\\alpha\\) \\(\\delta(t)\\)有关 \\(\\delta(t)\\leftrightarrow1\\) \\(\\delta^{(n)}(t)\\leftrightarrow s^n\\) LT反变换 查表+性质 部分分式展开法 \\(m\\ge n\\)\\(F(s)=\\)真分式+多项式 \\(m&lt;n\\)\\(F(s)\\)真分式分解 单根： \\[ F(s) = \\sum _{i=1}^n{K_i\\over s-s_i} \\leftrightarrow f(t) \\sum_{i=1}^nK_ie^{-s_it}\\varepsilon(t),\\quad K_i=(s-s_i)F(s)|_{s=s_i} \\] 重根： \\[ F(s) = {K_{11}\\over (s-s_1)^l} + {K_{12}\\over (s-s_1)^{l-1}}+\\cdots \\] 围线积分法（留数法） \\[ f(t) = \\frac 1 {2\\pi j} \\int_{\\sigma - j\\infty}^{\\sigma + j\\infty} F(s) e^{st} \\mathrm ds,\\quad t &gt; 0 \\] 留数定理： \\[ \\oint G(s) \\mathrm ds = 2\\pi j\\sum_i\\mathrm{Res} [G(s_i)] \\] 约当引理：布洛维奇围道 \\(\\lim _{z\\rightarrow \\infty} g(z) = 0\\Rightarrow \\lim_{R\\rightarrow \\infty} \\oint_{CR}g(z)e^{azi}\\mathrm dz =0\\) 围线积分法：对于有始信号：\\(f(t) = \\sum \\mathrm{Res} [F(s), s_i]\\) 留数计算： \\(s=s_i\\)单根：\\(\\mathrm {Res}[s_i] = (s-s_i)F(s) e^{st}|_{s=s_i}\\) \\(l\\)重根：\\(\\mathrm{Res}= \\frac 1 {(l-1)!}\\frac{\\mathrm d^{l-1} }{\\mathrm ds^{l-1}}[(s-s_1)^lF(s)e^{st}]|_{s=s_i}\\) LT的主要性质 let \\(f(t)\\varepsilon(t)\\leftrightarrow F(s)\\quad Re(s)\\ge \\sigma_0\\) 线性性质 \\[ a_1f_1(t)+a_2f_2(t)\\leftrightarrow a_1F_1(s) + a_2F_2(s) \\] 收敛域一般来说是公共部分 尺度变换 \\[ f(at)\\varepsilon(t)\\quad a&gt;0\\leftrightarrow \\frac 1 a F(\\frac s a)\\quad Re(s/a)&gt;\\sigma_0 \\] 延时特性 \\[ f(t-t_0)\\varepsilon(t-t_0)\\mathop{\\leftrightarrow}F(s)e^{-st_0} \\] 频率平移 \\[ \\mathcal L\\{f(t)e^{s_0t}\\}=F(s-s_0) \\] 时域微分 \\[ f&#39;(t)\\varepsilon(t)\\leftrightarrow sF(s)-f(0^-)\\\\f^{(n)}(t)\\varepsilon(t) \\leftrightarrow s^nF(s)- s^{n-1} f(0^-)-s^{n-2}f&#39;(0^-)-......s^0f^{(n-1)}(0^-) \\] 时域积分 \\[ \\left(\\int_{-0^-}^tf(\\tau)\\mathrm d\\tau \\right) \\varepsilon(t)\\leftrightarrow F(s)/s \\] 复频域微积分 \\[ (-t)f(t)\\varepsilon(t)\\leftrightarrow \\frac{dF(s)}{ds}\\\\(-t)^nf(t)\\varepsilon(t)\\leftrightarrow \\frac{d^nF(s)}{ds^n} \\] \\[ {f(t)\\over t}\\varepsilon(t)\\leftrightarrow \\int_{s}^\\infty F(x)\\mathrm dx,\\quad\\mathrm{given}~\\lim_{t\\rightarrow 0}f(t)=0 \\] 初值和终值定理 已知 \\(F(s)\\)求 \\(f(0^+)\\) 条件： \\(F(s)\\) 是真分式，否则去除多项式部分 \\[ f(0^+)=\\lim_{s\\rightarrow \\infty}sF(s) \\] 求 \\(f(\\infty)\\)条件： \\(f(t)\\)存在终值，即\\(F(s)\\)的极点都在左半开平面上，则有终值 \\[ f(\\infty)=\\lim_{s\\rightarrow 0}sF(s) \\] 卷积定理 \\[ [f_1*f_2]\\varepsilon(t)\\leftrightarrow F_1(s)\\cdot F_2(s)\\quad ROC一般为公共部分 \\] \\[ f_1*f_2\\leftrightarrow F_{1d}(s)\\cdot F_{2d}(s)\\quad ROC一般为公共区域 \\] LT分析法 求响应 元器件→s域阻抗 信号→象函数 初态→等效源 由方程求响应 对于系统 \\[ D(p)r(t) = N(p)e(t) \\] 有初态： \\[ r(0^-),r&#39;(0^-)\\cdots \\] 直接求全响应：两边求LT，引入初态 \\[ D(s)R(s)-P(s) = N(s) E(s) \\] 即： \\[ R(s) = \\frac{P(s)}{D(s)} + \\frac{N(s)}{D(s)}E(s)\\leftrightarrow r(t) \\] 分别求零输入和零状态： 零输入：\\(R_{zi}(s) = \\frac {P(s)} {D(s)}\\leftrightarrow r_{zi}(t)\\) 零状态：\\(R_{zs}(s) =\\frac{N(s)}{D(s)}E(s)\\) LT求ZS的含义： e(t)→ZS→r(t) \\(e^{st}\\rightarrow H(s) e^{st}\\) 系统函数\\(H(s)\\) \\(H(s) =R(s)/E(S)\\quad ZS\\) 由I/O方程求解 由电路：\\(H(s) = H(p)\\) 由响应分解：\\(H(s) = \\mathcal L\\{r_{zs}(t)\\}/\\mathcal L\\{e(t)\\}\\) 由框图/流图求 由状态方程求 \\(H(s) = \\mathcal L \\{h(t)\\}\\)（包括双边变换） \\(H(s) = \\frac{e^{st}作用下的响应}{e^{st}}\\) 双边LT 双边LT 正变换 对于一个双边信号，可以分解为 \\[ f(t)=f(t)\\varepsilon(-t)+f(t)\\varepsilon(t)=f_l(t)+f_r(t)\\\\ \\Rightarrow F_d(s) = F_{dl} (s) + F_{dr} (s),\\sigma_1&lt; \\sigma &lt; \\sigma_2 \\] 对于\\(F_{dr}(s) = \\int _{0^-}^\\infty f_r(t)e^{-st}\\mathrm dt = F_r(s),\\sigma &gt;\\sigma _ 1\\) 对于\\(F_{dl}(s) = F_l(-s) =\\int_{0}^\\infty f_l(-t)e^{-st}\\mathrm dt, \\sigma &lt;\\sigma_2\\) 反变换 根据ROC分解$F_d(s) \\(，\\)f=f_l+f_r$ 双边LT的零状态响应 \\[ R_{zs}(s) = E_d(s) H_d(s) \\] 线性系统的（框图）模拟 系统表示法：四种 对于单输入单输出系统： IO方程：\\(D(p)r(t) = N(p) e(t)\\) 系统函数：\\(H(s) = \\frac{N(s)}{D(s)}\\) 框图/流图： 对于多输入多输出系统： 状态方程 框图模拟的基本运算单元 用基本运算构成： 加法（加法器） 用圆形符号（中间为\\(\\Sigma\\)） 时域上：\\(y = x_1+x_2\\) \\(s\\)域上：\\(Y= X_1 + X_2\\) 数乘（标量乘法器） 方框 积分 方框，中间为 \\(\\int\\)或 \\(1/s\\)，注意初始条件（在积分器后面紧接一个加法器，定义初态） 线性系统的框图 一阶系统： \\[ y&#39;(t) + a_0 y(t) = x(t) \\Rightarrow y&#39;(t) = x(t) - a_0 y(t) \\] → 反馈支路 二阶系统： 找到最高阶导数项，假设为加法器输出，然后依次构造各次导数作为反馈 n阶系统：（全奇点） 一般的n阶系统：（\\(m\\le n\\)） \\[ y^{(n)} + a_{n-1}y ^{(n-1)} + \\cdots + a_0 y = x^{(m)} + b_{m-1} + \\cdots + b_0 x \\] 添加前向部分。 框图的形式 \\(H(s) = \\prod_i H_i(s)\\)串联 \\(H(s) = \\sum_i H_i(s)\\)并联 &gt; 共轭根转化为二次实系数多项式 混联（非标准连接）","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"信号与系统-杂项","slug":"study/ComputerScience/Signals and Systems/一些笔记。/一些笔记。","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.577Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/一些笔记。/一些笔记。/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%E3%80%82/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%E3%80%82/","excerpt":"信号与系统 - 杂项","text":"信号与系统 - 杂项 一些笔记。 斜变序列：\\(k\\varepsilon(k) \\leftrightarrow \\frac z {(z-1)^2}\\) 单边 z 变换的性质 线性性质： 移序性质： \\(f(k+n)\\varepsilon(k) \\leftrightarrow z^nF(z) -z^{n}f(0) - z^{n-1} f(1) - \\cdots -zf(n-1)\\) \\(f(k-n) \\varepsilon(k-n) \\leftrightarrow z^{-n} F(z)\\) \\(f(k-n)\\varepsilon(k) \\leftrightarrow z^{-n}F(z) + z^0f(-n) + \\cdots + z^{-(n-2)} f(-2) + z^{-(n-1)}f(-1)\\) 对于单边变换：\\(f(k\\pm n) \\leftrightarrow z^{\\pm n}F_d(z)\\) z 域尺度变换（序列指数加权）：\\(a^kf(k)\\leftrightarrow F(z/a)\\quad(a\\ne 0)\\) 卷积定理：\\(f*g\\leftrightarrow F\\cdot G\\) z 域微分（序列线性加权）：\\(kf(k) \\leftrightarrow (-z)\\frac{\\mathrm dF(z)}{\\mathrm dz}\\) 初值和终值定理：\\(F(z) = f(0) + f(1) z ^ {-1} + f(2) z ^{-2} + \\cdots\\) 初值：\\(f(0) = F(z) |_{z=\\infty},~f(1) = (zF(z) - zf(0)) |_{z=\\infty}, \\cdots\\) 终值：\\(f(+\\infty)=\\lim _{z\\rightarrow 1}(z-1)F(z)\\) （条件：\\(f(k)\\)存在终值、\\(F(z)\\) 的极点都在单位圆内，或者为\\(1\\) 反z变换 幂级数展开 借助泰勒公式： \\[ f(x) = f(0) + f&#39;(0) x + \\cdots\\quad(\\mathrm {by~Taylor~Series}) \\] 长除法： 对右边序列：分子分母降序排列相除 对左边序列：分子分母升序排列相除 部分分式法 将\\(F(z)/z\\)展开，设\\(F(z)\\)极点都是单阶的： \\[ \\frac{F(z)}z=\\frac{K_0}z+\\frac{K_1} {z-v_1}\\cdots + \\frac{K_n}{z-v_n} \\] 若有重根存在，可以考虑留数法 留数法 因为： \\[ F(z) = f(0) + f(1)z^{-1} + \\cdots \\] 从而： \\[ f(k) = \\frac{1}{2\\pi j}\\oint_cF(z)z^{k-1}\\mathrm dz \\] 双边正反Z变换 双边z变换 \\[ F_r(z)=F_{br}(z) = \\sum_{k=-\\infty}^{\\infty} f_r(k) z^{-k},\\\\ F_{bl}(z) = \\sum_{k=-1}^{-\\infty} f_l(k) z^{-k}=\\sum_{k=1}^\\infty f_l(-k)\\left(\\frac1 z\\right)^{-k}=\\mathcal Z\\{f_l(-k)\\}[1/z] \\] 双边反z变换 \\[ F_b(z) = F_{br}(z) + F_{bl}(z) \\] z变换和LT的关系 \\(f(t)\\) 时间离散化为 \\(f(k)\\)则\\(f_s(t) = f(t) \\delta_T(t)\\)\\(F(z)|_{z=e^{j\\omega T}}=F_s(j\\omega)\\) \\(z=e^{sT}\\) 映射关系设 \\(s=\\sigma + j\\omega\\) ，若 \\(z=re^{j\\theta}\\) 其中 \\(r = e^{\\sigma T},~\\theta = \\omega T\\) \\(F(z)\\)和\\(F(s)\\)的关系（只考虑单边）\\(f(k) = f(t) |_{t=kT}\\)，\\(F(z)=\\frac 1 {2\\pi j} \\int_{\\sigma-j\\infty}^{\\sigma + j\\infty} F(s)\\frac{z}{z-e^{sT}}\\mathrm ds\\) z 变换分析法 对于\\(n\\)阶系统： 零输入相应 对齐次方程取单边 z 变换 \\[ Y_{zi}(z) \\leftrightarrow y_{zi}(k) \\] 然后使用移序性质求解。 零状态响应 \\[ y_{zs}(k) = e(k) * h(k)\\leftrightarrow H(z) E(z) \\] 全响应 法 1: ZS+ZI 法 2: 对差分方程直接求单边 Z 变换 离散时间系统的频率响应特性 定义 离散系统频响的特点 \\(\\omega\\)的连续函数 幅频\\(\\omega\\)的偶函数，相频\\(\\omega\\)的奇函数（共轭对称） 以\\(\\omega_s\\)为周期 离散系统频响的图解 \\[ H(z) = b_m \\frac{\\prod_i (z-z_i)}{\\prod_r (z-p_r)} \\] 如果 Z 变换的零点或极点落在原点上，它们对 H 的幅值没有影响。 离散系统的系统函数和稳定性判据 系统函数 \\(H(z) = \\frac{N(S)}{D(S)}|_{S=z}\\) \\(H(z) = Y(z) / E(z) |_{ZS}\\) \\(H(z) = Y_{zs}(z) / E(z)\\) \\(H(z) = z^k 作用下的（零状态）响应/z^k\\) 框图（数字滤波器的结构） 并联型：注意共轭根配对 串联型 混联 通用方法：设 W 为中间变量，列方程求解 稳定性判据（因果系统） BIBO \\(h(k)\\) 绝对可和；（放宽到渐进条件：\\(\\lim_{k\\rightarrow\\infty}h(k)=0\\)） \\(H(z)\\) 极点在单位圆内； R-H 准则：使用双线性变换\\(z=\\frac{s+1}{s-1}\\)代入\\(D(z)\\) 信号与频谱的关系 线性系统的状态分析 9.1-9.4 引言 前：单输入单输出 状态变量法 -&gt; 多输入多输出+内部状态数学方程矩阵形式 重点：状态、输出方程的建立 状态变量描述法 状态和状态变量 状态：（电路的）储能状态 状态变量：一组数量最少的代表系统状态的独立变量。 或者用状态矢量：\\(X(t)=[x_1(t),x_2(t),\\cdots,x_n(t)]^T\\) 状态空间 =&gt; 维数=独立储能元件的个数=系统阶数 状态变量分析法 作为求解变量、用状态变量描述、分析系统的方法。 Step 1 选状态变量，列、写状态方程和输出方程。 状态方程： \\[ \\nabla_t X(t) = AX(t) + Be(t) \\] \\[ X(k+1) = A X(k) + Be(k) \\] 输出方程： \\[ Y(t) = CX(t) + De(t) \\] \\[ Y(k)=CX(k) +De(k) \\] 建立状态方程时不需要考虑初始储能，将\\(X(t_0)\\)作为定解条件 状态变量的选取 对于具体电路：选择所有独立的电感、电流 对于 I/O 方程：系统函数-&gt;框图-&gt;选择所有的积分器、延时器的输出 由输入输出方程求状态方程 直接型：规范、相变量法 （单根、实数根）并联型：对角线变量法 其他 简单系统的状态方程 直接型 画框图 选状态变量（最后一个积分器为\\(x_1\\)） 列方程 写成标准形式 规律 A最后一行：特征多项式系数倒排 取负值 B最后一个元素为 1 其余为 0 C 前 m+1 个元素为分子多项式倒排，其余为 0 D=0 并联型框图 –– 对角线变量法 框图 选状态变量 \\(x_1, x_2, x_3\\) 列方程 写成标准形式 规律：（真分式、单阶实根） A 为对角阵，diag 为特征根 B=1 C 为部分分式分解的系数 D=0 一般连续系统的框图 若 m=n，将其化为真分式和常数的和。 直接型：C 和 D 需要变化 对角线变量法：C 不变，D 需要变为 \\(b_n\\)。 离散系统的状态方程和输出方程 积分器–延时器 x'– x(k+1) x(t) – x(k) y(t) – y(k) e(t) – e(k) 连续系统状态方程的复频域求解 复频域求解 \\[ X(s) =(sI-A)^{-1}x(0)+(sI-A)^{-1}B\\cdot E(s) \\] \\[ Y(s) = CX(s) + DE(s) = C(sI-A)^{-1} x(0) + [C(sI-A)^{-1}B+D]E(s) \\] 前一项是零输入响应、后一项是零状态响应 也可分解为自然响应和受迫响应：根据\\((sI-A)^{-1}\\)分 系统函数矩阵和自然频率 \\[ H(s) = C(sI-A)^{-1}B+D \\] 关注其中的分母多项式： \\[ |sI-A| \\] 即 A 的特征值即为 状态过渡矩阵 – 基本矩阵 零输入的情况下： \\[ \\Phi(s)=(sI-A)^{-1}\\Rightarrow X(s)= (sI-A)^{-1} x(0) = \\Phi(s) x(0) \\] 因此，反变换结果为： \\[ x(t) = \\phi(t) x(0) \\]","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"线性系统的状态分析","slug":"study/ComputerScience/Signals and Systems/Chapter 9 线性系统的状态分析/Chapter 9 线性系统的状态分析","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-06T03:32:23.638Z","comments":true,"path":"2021/06/13/study/ComputerScience/Signals and Systems/Chapter 9 线性系统的状态分析/Chapter 9 线性系统的状态分析/","link":"","permalink":"http://adversarr.github.io/2021/06/13/study/ComputerScience/Signals%20and%20Systems/Chapter%209%C2%A0%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90/Chapter%209%C2%A0%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90/","excerpt":"信号与系统- 线性系统的状态分析","text":"信号与系统- 线性系统的状态分析 Chapter 9 线性系统的状态分析 引言 前：单输入单输出 状态变量法 -&gt; 多输入多输出+内部状态数学方程矩阵形式 重点：状态、输出方程的建立 状态变量描述法 状态和状态变量 状态：（电路的）储能状态 状态变量：一组数量最少的代表系统状态的独立变量。 或者用状态矢量：\\(X(t)=[x_1(t),x_2(t),\\cdots,x_n(t)]^T\\) 状态空间 =&gt; 维数=独立储能元件的个数=系统阶数 状态变量分析法 作为求解变量、用状态变量描述、分析系统的方法。 Step 1 选状态变量，列、写状态方程和输出方程。 状态方程： \\[ \\nabla_t X(t) = AX(t) + Be(t) \\] \\[ X(k+1) = A X(k) + Be(k) \\] 输出方程： \\[ Y(t) = CX(t) + De(t) \\] \\[ Y(k)=CX(k) +De(k) \\] 建立状态方程时不需要考虑初始储能，将\\(X(t_0)\\)作为定解条件 状态变量的选取 对于具体电路：选择所有独立的电感、电流 对于 I/O 方程：系统函数-&gt;框图-&gt;选择所有的积分器、延时器的输出 由输入输出方程求状态方程 直接型：规范、相变量法 （单根、实数根）并联型：对角线变量法 其他 简单系统的状态方程 直接型 画框图 选状态变量（最后一个积分器为\\(x_1\\)） 列方程 写成标准形式 规律 A最后一行：特征多项式系数倒排 取负值 B最后一个元素为 1 其余为 0 C 前 m+1 个元素为分子多项式倒排，其余为 0 D=0 并联型框图 –– 对角线变量法 框图 选状态变量 \\(x_1, x_2, x_3\\) 列方程 写成标准形式 规律：（真分式、单阶实根） A 为对角阵，diag 为特征根 B=1 C 为部分分式分解的系数 D=0 一般连续系统的框图 若 m=n，将其化为真分式和常数的和。 直接型：C 和 D 需要变化 对角线变量法：C 不变，D 需要变为 \\(b_n\\)。 离散系统的状态方程和输出方程 积分器–延时器 x'– x(k+1) x(t) – x(k) y(t) – y(k) e(t) – e(k) 连续系统状态方程的复频域求解 复频域求解 \\[ X(s) =(sI-A)^{-1}x(0)+(sI-A)^{-1}B\\cdot E(s) \\] \\[ Y(s) = CX(s) + DE(s) = C(sI-A)^{-1} x(0) + [C(sI-A)^{-1}B+D]E(s) \\] 前一项是零输入响应、后一项是零状态响应 也可分解为自然响应和受迫响应：根据\\((sI-A)^{-1}\\)分 系统函数矩阵和自然频率 \\[ H(s) = C(sI-A)^{-1}B+D \\] 关注其中的分母多项式： \\[ |sI-A| \\] 即 A 的特征值即为 状态过渡矩阵 – 基本矩阵 零输入的情况下： \\[ \\Phi(s)=(sI-A)^{-1}\\Rightarrow X(s)= (sI-A)^{-1} x(0) = \\Phi(s) x(0) \\] 因此，反变换结果为： \\[ x(t) = \\phi(t) x(0) \\]","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"}]},{"title":"「凸优化」 引言","slug":"study/Math/ConvexOptimization/notes1","date":"2021-01-12T16:00:00.000Z","updated":"2022-03-03T04:30:41.515Z","comments":true,"path":"2021/01/13/study/Math/ConvexOptimization/notes1/","link":"","permalink":"http://adversarr.github.io/2021/01/13/study/Math/ConvexOptimization/notes1/","excerpt":"2020-2021-1 最优化方法","text":"2020-2021-1 最优化方法 引言 数学优化 数学优化问题：（数学规划） 从一个可行解集合中,寻找出最优元素。 数学形式： \\[ \\begin{aligned} &amp;\\min . &amp;f_0(x)\\\\ &amp;~\\mathrm{s.t.} &amp; f_i(x) \\leq b_i, i = 1,\\dots,m \\end{aligned} \\] 其中： 优化变量：\\(x\\) 目标函数：\\(f_0:\\mathrm{R}^n\\rightarrow\\mathrm{R}\\) 约束函数：\\(f_i:\\mathrm{R}^n\\rightarrow\\mathrm{R}\\) 最优解：在所有满足约束的向量中，向量 \\(x^*\\) 对应的目标函数值最小 应用 投资组合优化 优化变量：各资产分配的资本数 约束：总预算、每⼀份资产的资本范围、最⼩收益 ⽬标：总风险或回报 电⼦设计中的器件尺⼨ 优化变量：器件的长和宽 约束：⼯程约束、时间要求、最⼤⾯积 ⽬标：总功耗 数据拟合 优化变量：模型参数 约束：先验信息、参数限制 ⽬标：预测误差 求解优化问题 一般形式的优化问题 难以求解 折中：长时间的计算代价、找不到解 特定问题 最小二乘 线性规划 凸优化问题 最小二乘 形式：\\(\\displaystyle\\min.||Ax-b||_2^2\\) 有解析解 \\(x* = (A^TA)^{-1}A^Tb\\) 有可靠的求解算法和软件 计算时间：正比于 \\(n^2k(A\\in \\mathrm{R}^{k\\times n})\\) 技术成熟 最⼩⼆乘的使⽤ 判别⼗分简单 使⽤标准⽅法增强灵活性（加权、正则化） 线性规划问题 \\[ \\begin{aligned} &amp;\\min. &amp;c^Tx\\\\ &amp;\\mathrm{~s.t.} &amp;a_i^Tx\\le b_i \\end{aligned} \\] 没有解析解 具有可靠且有效的求解算法和软件 计算时间：正⽐于\\(n^2m~(if~m \\ge n)\\)，若具有特殊结构，求解更快。 成熟技术 判别难于最⼩⼆乘 ⼀些标准的技巧可⽤于将某些问题转化为线性规划（分段线性⽅程、包含范数的问题） 凸优化问题 $$ \\[\\begin{aligned} &amp;\\mathrm{minimize.}&amp;f_0(x)\\\\ &amp;\\mathrm{s.t.} &amp;f_i(x)\\le b_i,\\quad i = 1,\\dots,m \\end{aligned}\\] $$ 其中：目标函数和约束函数均为凸函数 最⼩⼆乘和线性规划均为特殊的凸优化问题 求解 没有解析解 有可靠、有效的算法 计算时间：\\(O(\\max\\{n^3, n^2m,F\\}\\)，\\(F\\)是求函数值、一阶导数、二阶导数的代价 几乎成熟 凸优化的使用 通常很难判别 具有很多技巧可以将其他问题转化为凸优化形式 很多问题可以通过凸优化进⾏求解 Example 在有约束的灯光下获取理想的照明强度 \\[ \\begin{aligned} &amp;\\mathrm{minimize.}&amp;\\max|\\log I_k-\\log I_{des}|\\\\ &amp;\\mathrm{s.t.} &amp;0\\le p_j\\le p_{max}\\quad i = 1,\\dots,m \\end{aligned} \\] 通过合理转化： 最小二乘 带权重的最小二乘 线性规划 都是近似解法 用凸优化求解 \\[ \\begin{aligned} &amp;\\mathrm{minimize.}&amp;\\max h(I_k/I_{des})\\\\ &amp;\\mathrm{s.t.} &amp;0\\le p_j\\le p_{max}\\quad i = 1,\\dots,m\\\\ &amp;h(x)= \\max\\{u,1/u\\} \\end{aligned} \\] 非线性规划 ⾮凸的优化问题求解思路 - 局部优化 - 在可⾏解中寻找近似最⼩的点 - 速度快 - 需要初始解 - 不能提供和全局最优解的差距信息 - 全局优化 - 计算时间和问题规模呈指数增长关系 - 上述⽅法⼤多基于求解凸的⼦问题","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://adversarr.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"「凸优化」 凸集","slug":"study/Math/ConvexOptimization/notes2","date":"2021-01-12T16:00:00.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2021/01/13/study/Math/ConvexOptimization/notes2/","link":"","permalink":"http://adversarr.github.io/2021/01/13/study/Math/ConvexOptimization/notes2/","excerpt":"凸集合","text":"凸集合 凸集 仿射集合 凸集 重要案例 保凸运算 ⼴义不等式 分离与⽀撑超平⾯ 对偶锥与⼴义不等式 仿射集合 直线方程 Def（直线方程）\\(x = \\theta x_1 + (1-\\theta)x_2\\quad(\\theta\\in \\R)\\), equivelant to: \\(x = x_2+\\theta(x_1-x_2)\\) 线段：\\(\\theta \\in [0,1]\\) 仿射集合的定义 Def（仿射集合）任意两个点的直线仍然在该集合中。即：经过 \\(x_1\\) 和 \\(x_2\\) 的直线所有点：\\(x=\\theta x_1 + (1-\\theta)x_2,~\\theta \\in \\R\\) 如果通过集合 \\(C\\) 中的任意两个不同点的直线仍在集合 \\(C\\) 中，那么称 \\(C\\) 是仿射的。 仿射组合 Def：（仿射组合）特殊的线性组合\\(\\theta_1+\\dots+\\theta_k=1,~\\theta_1x1+\\dots+\\theta_kx_k\\) 仿射集合的扩展定义： 包含集合中任意点的仿射组合的集合 子空间 仿射集合 C 内： \\(x_1\\) 和 \\(x_2\\) 则 \\(\\theta x_1 + (1-\\theta)x_2\\in C\\) Def（子空间）\\(V=C-x_0=\\{x-x_0|x\\in C\\}\\)：与C相关的子空间 子空间对于\\(\\alpha x_1 +\\beta x_2\\) 中的\\(\\alpha\\)，\\(\\beta\\)没有约束 经过 \\(0\\) 线性代数中子空间的定义 设W为数域F上的n维线性空间V的子集合（即W∈V），若W中的元素满足 对加法是封闭 对数乘也是封闭 包含 0 构造方法： \\(\\alpha(v_1+x_0) + \\beta(v_2+x_0) + (1-\\alpha - \\beta) x_0\\in C\\) 任何仿射集合都可以表示为一个线性方程组的解集 线性方程组与仿射集合 Review: \\(C=\\{x|Ax=b\\}\\) 线性方程组的解集是仿射集合 仿射集合可以表示为一个线性方程组的解集 利用定义证明 当然，它的子空间就是：\\(V = \\{x|Ax = 0\\}\\) 仿射包 任意集合\\(C\\)，构造尽可能小的仿射集 仿射包：\\(\\mathrm{aff}~C=\\{\\theta_1x_1+\\dots+\\theta_kx_k|x_1, ...,x_k\\in C\\}\\) 仿射维度与相对内部 相对内部：\\(\\mathrm{relint}~C=\\{x\\in C|B(x,r)\\cap \\mathrm{aff} C\\subseteq C,~for~some~r&gt;0\\}\\) 凸集 连接 \\(x_1\\) 和 \\(x_2\\) 的线段上所有的点 \\(x = \\theta x_1 + (1-\\theta)x_2,\\quad 0\\le \\theta \\le 1\\) 仍然在集合中 凸组合和凸包 点 \\(x_1,\\dots,x_k\\) 的凸组合是满足以下形式的点： \\(x = \\sum\\theta_i x_i,~\\sum \\theta_i=1\\) Def（凸包） \\(\\mathrm{conv}~S\\) S中所有点的凸组合的集合 锥 定义：\\(\\forall x \\in C\\wedge \\theta\\ge 0, \\theta x \\in C\\) 锥组合（非负线性组合）：\\(x = \\theta_1 x_1+\\theta_2 x_2\\) 锥包：集合中所有元素的锥组合的集合 \\(\\{\\theta_1x_1+\\cdots+\\theta_kx_k|x_i\\in C, \\theta_i\\ge 0, i = 0, 1\\dots,k\\}\\) 对比 组合 集合 类比 仿射组合 \\(\\sum \\theta_i = 1\\) 仿射集 直线 凸组合 \\(\\sum \\theta_i = 1, \\theta_i \\ge 0\\) 凸集 线段 锥组合 \\(\\theta_k\\ge 0\\) 凸锥集 射线 仿射集合是凸的 考虑单点集：\\(C = \\{x\\}\\) 仿射、凸 重要的凸集 \\(R^n\\)空间：仿射、凸、锥 \\(R^n\\)的子空间：仿射、凸的 直线：仿射 可能凸 线段 可能是 射线 可能是 超平面和半空间 Def（超平面）\\(\\{x|a^Tx=b\\}\\quad(a\\ne 0)\\) 仿射集合、凸集 Def（半空间）\\(\\{x|a^Tx\\le b\\}\\quad(a\\ne 0)\\) 凸集 注意证明方法：利用线性方程组 球和椭球 Def（Euclid 球）\\(B(x_c,r) = \\{x|~\\|x-x_c\\|_2\\le r\\}\\) 凸集 注意：所有通过距离定义，满足三角不等式，都构成凸集 Def（椭球）\\(\\{x|(x-x_c)^TP^{-1}(x-x_c) \\le 1\\}\\) 其中 \\(P\\) 为对称正定矩阵 其他表示：\\(\\{x_c+Au|||u||_2\\le1\\}\\) A 非奇异 范数球和范数锥 Def（范数） 范数满足 \\(\\|x\\|\\ge 0;\\|x\\|=0~iff~x=0\\) \\(\\|tx\\|=|t|\\|x\\|\\forall t\\) \\(\\|x+y\\|\\le \\|x\\|+\\|y\\|\\) 范数球：\\(\\{x|~\\|x-x_c\\|\\le r\\}\\) 范数锥：\\(\\{(x,t)|~\\|x\\|\\le t\\}\\) 例如： 一阶范数：\\(\\sum|x_i|\\) 二阶范数：\\(\\sqrt{\\sum x_i^2}\\) Def（范数球）\\(x_c\\) 为球心，\\(r\\) 为半径。 Def（范数锥）\\(\\{(x,t)|\\|x\\|\\le t\\}\\) 多面体 Def（多面体）有限个线性等式和不等式的解集：\\(Ax\\preceq b,\\quad Cx = d\\) 考虑仅由不等式组成的情况。 有限个半空间和超平面的交集 单纯形 Def（单纯形）\\(C=\\mathrm{conv}\\{v_0,\\dots,v_k\\}=\\{\\sum \\theta_i v_i|0\\preceq \\theta,~1^T\\theta =1\\}\\) 求解线性规划问题：单纯形法 解析 常见的单纯形：单位单纯形、概率单纯形 半正定锥 \\(\\mathbf{S}^n\\)：对称矩阵集合 \\(\\mathbf{S}^n_+= \\{X\\in\\mathbf{S}^n|X\\succeq 0\\}\\)：半正定\\(\\lambda_i\\ge 0\\) \\(\\mathbf{S}^n_{++}=\\{X\\in\\mathbf{S}^n|X\\succ 0\\}\\)：正定 \\(\\lambda_i &gt; 0\\) n = 2 时： 保凸运算 如何确定凸集： 定义 \\(\\forall x_1,x_2\\in C,0\\le \\theta\\le 1\\Rightarrow \\theta x_1+(1-\\theta)x_2\\in C\\) 保凸运算： 交集、仿射函数、透视函数、线性分式 交集 Thm：任意数目凸集的交集为凸集 包括无穷 仿射函数 \\(f(x) = Ax+b\\) 其中 \\(A\\in \\R^{m\\times n},b\\in \\R^m\\) 凸集在仿射函数下变为凸集 凸集在仿射函数下的原象为凸集 例如： 缩放、平移、投影 椭球是球的仿射映射 透视函数 Def（透视函数） \\(P:\\R^{n+1}\\rightarrow \\R^n\\) \\(P(x,t) = x/t,\\quad\\mathbf{dom} P = \\{(x,t)|t&gt;0\\}\\) 注意输入输出维度变化 凸集在透视函数下的象和原象为凸集 线性分式函数（投射函数） \\(\\displaystyle{f(x) = \\frac{Ax+b}{c^Tx+d},~where~\\mathbf{dom}~f=\\{x|c^Tx+d&gt;0\\}}\\) 仿射函数和透视函数的复合函数 \\(f = P\\circ g\\) \\[ g(x) = \\left[\\begin{matrix}A\\\\c^T \\end{matrix}\\right] x + \\left[\\begin{matrix} b\\\\d \\end{matrix}\\right] \\] 凸集在线性分式下的象和原象都是凸集。 例如： 条件概率 又如： 广义不等式 建立向量的不等关系 Def（正常锥） \\(K\\)是闭的（包含边界） \\(K\\)是实的（没有空的内部） \\(K\\)是尖的（不包含直线） 例如： 非负象限\\(K = R^n=\\{x\\in \\R^n|x_i\\ge 0,~i=1,\\dots,n\\}\\) 半正定锥 广义不等式定义 Def：\\(x\\preceq_Ky\\iff y-x\\in K\\,\\) \\(~x\\prec_K y\\iff y-x\\in \\mathbf{int}~K\\) 例如： 分量不等式：\\(x\\prec_{\\R^n_+} y\\iff x_i\\le y_i,~i = 1,...,n\\) 矩阵不等式：\\(X\\preceq_{\\mathrm S^n_+}Y\\iff Y-X为半正定\\) 偏序、但不满足线序 最小、极小元 最小元：\\(y\\in S\\Rightarrow x\\preceq_Ky\\) 极小元：\\(y\\in S,~y\\preceq_K x\\Rightarrow y = x\\) 例如：\\(x_1\\) 为 \\(S_1\\) 最小元，\\(x_2\\) 为 \\(S_2\\) 极小元 超平面分离定理 若C和D时两个不相交的凸集，则存在： \\(a\\ne 0, a^Tx \\le b~for~x\\in C,~~a^Tx\\ge b~for~x\\in D\\) 支撑超平面 Def（支撑超平面）\\(\\forall x\\in C,a^Tx\\le a^Tx_0 \\rightarrow \\{x|a^Tx=a^Tx_0\\}\\) Thm（支撑超平面存在定理）：若集合 \\(C\\) 为凸集，则在集合 \\(C\\) 的每一个边界点处都存在一个支撑超平面。 对偶锥和广义不等式 \\(K\\) 的对偶锥：\\(K^*=\\{y|y^Tx\\ge 0,\\forall x \\in K\\}\\) \\((K^*)^* = K\\) Thm：正常锥的对偶锥为正常锥，可以定义广义不等式： \\[ y\\succeq_{K^*}0\\iff y^Tx\\ge 0\\forall x\\succeq_{K^*}0 \\] 对偶不等式的最小和极小元 Def（最小元）\\(x\\) 为集合 \\(S\\) 的最小元，当且仅当 \\(\\forall \\lambda \\succ_{K^*}0\\)，\\(x\\) 为集合 \\(S\\) 中元素 \\(z\\) 上极小化 \\(\\lambda^T z\\) 的唯一最优解 Def（极小元）对于某些 \\(\\lambda \\succ_{K^*}0\\)，\\(x\\) 在集合 \\(S\\) 中元素 \\(z\\) 上极小化 \\(\\lambda^Tz\\)，则 \\(x\\) 为极小元。","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://adversarr.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"「凸优化」 凸函数","slug":"study/Math/ConvexOptimization/notes3","date":"2021-01-12T16:00:00.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2021/01/13/study/Math/ConvexOptimization/notes3/","link":"","permalink":"http://adversarr.github.io/2021/01/13/study/Math/ConvexOptimization/notes3/","excerpt":"凸函数","text":"凸函数 凸函数 基本性质和案例 保凸运算 共轭函数 拟凸函数 对数-凹函数和对数-凸函数 关于广义不等式的凸性 基本性质和案例 凸函数 \\(f:\\R^n\\rightarrow \\R\\) 为凸函数，则其满足定义域为凸集，且 \\(f(\\theta x+(1-\\theta) y)\\le \\theta f(x) + (1-\\theta)f(y), \\forall x, y \\in \\mathrm{dom}~f, 0\\le \\theta \\le 1\\) 若\\(f\\)为凹函数，则\\(-f\\)为凸函数 仿射函数 严格凸函数 \\(f:\\R^n\\rightarrow \\R\\) 为凸函数，则其满足定义域为凸集，且 \\(f(\\theta x+(1-\\theta) y) &lt; \\theta f(x) + (1-\\theta)f(y), \\forall x, y \\in \\mathrm{dom}~f, 0\\le \\theta \\le 1\\) 约束凸函数到直线 Thm：\\(f:\\R^n\\rightarrow\\R\\) 为凸函数\\(\\iff g(t)=f(x+tv)\\) 为凸函数，\\(\\forall x\\in\\mathrm{dom}f,v\\in \\R^n\\) 例如：\\(f:S^n\\rightarrow \\R,~where~f(X) = \\log\\det X,\\mathrm{dom} f = S^n_{++}\\) 为凹函数 扩展值延伸 用\\(\\tilde f(x) = f(x), x\\in \\mathrm{dom} , \\tilde f(x) = \\infty , x\\in \\mathrm{dom} f\\) 简化表示\\(0\\le\\theta\\le 1\\Rightarrow \\tilde f(\\theta x+(1-\\theta)y)\\le \\theta \\tilde f(x) + (1-\\theta)\\tilde sf(y)\\) 例：凸集的示性函数是凸函数 \\(I_c(x)=0~if~x\\in C~else~undefined.\\) \\(\\tilde I_c(x)=0~if~x\\in C~else~+\\infty.\\) 一阶条件 函数 \\(f\\) 可微，且满足\\(f\\)的定义域是开集，且梯度：\\(\\nabla f(x)\\) 处处存在 Thm（一阶条件）（定义域为凸集的可微函数）\\(f(y) \\ge f(x) +\\nabla f(x)^T(y-x),~\\forall x, y \\in \\mathrm{dom}~f\\) 是 f 为凸函数的充要条件。 函数 f 的一阶近似表示全局下估计 一阶条件的证明：\\(f为凸函数\\iff g(t) = f(x+tv)为凸函数\\iff g(t)\\ge g(\\tilde{t})+g(\\dot t)(\\tilde{t}-t)\\iff f(y)\\ge f(x) +\\nabla f^T(x) (y-x)\\) 二阶条件 Thm（二阶条件）f 二阶可微，即对于 \\(\\mathrm {dom}~f\\) 内的任意一点，Hessian 矩阵存在或 \\(\\nabla^2f\\) 存在，且函数定义域是开集，则：\\(f\\)是凸函数\\(\\iff\\)Hessian矩阵半正定，即 \\(\\forall x \\in \\mathrm{dom}~f,~\\nabla^2f(x)\\succeq 0\\) 正定 ==&gt; 严格凸函数（反之不成立） 例子 二次函数：\\(\\displaystyle f(x) = \\frac 1 2 x^TPx + q^Tx+r~(with P\\in S^n)\\) \\[ \\begin{aligned} &amp;\\frac{\\partial x^TAx}{\\partial x} = Ax+A^Tx,\\\\ &amp;\\frac{\\partial a^Tx}{\\partial x} = a \\end{aligned} \\] \\(f(x)=1/x^2\\)：注意定义域不是凸集 仿射函数：\\(ax+b\\) （指数函数）\\(e^{ax}\\) （幂函数）\\(x^a,x\\ge 0\\) （绝对值的幂函数）\\(|x|^p,p\\ge1\\) （对数函数「凹函数」）\\(\\log x\\)（\\(\\ln x\\)） （负熵）\\(x\\log x\\) （范数）\\(R^n\\) 中的范数 \\(P(x)\\) 注意：零范数（计算非零元素的数目）——不是范数 （极大值函数）\\(f(x)=\\max\\{x_1,...,x_n\\}\\) （指数和的对数）\\(f(x)=\\log(e^{x_1}+\\cdots+e^{x_n})\\)（Softmax) \\(\\max\\{x_1,\\dots,x_n\\}\\le f(x)\\le \\max\\{x_1,\\dots,x_n\\}\\log n\\) 利用柯西施瓦兹不等式证明：\\((a^Ta)(b^Tb)\\ge (a^Tb)^2\\) 几何平均函数：\\(f(x) = (\\Pi^{n}_{i=1}x_i)^{(1/n)}\\) \\(f=\\log \\det X\\) 凹函数 保凸运算 非负加权求和 Def（非负乘积）\\(\\alpha f\\) 不改变凸性 Def（求和）\\(+\\) 不改变凸性 Def（非负加权求和） 可拓展到无限项：\\(g(x)=\\int_A\\omega(y)f(x,y)\\mathrm dy\\) 其中，\\(f(x,y)\\) 对集合 A 中的每一个 y，为凸函数 复合仿射映射 Def（复合仿射映射）\\(f\\)是凸函数，则\\(f(Ax+b)\\) 是凸函数 例如： 线性不等式的对数惩罚函数 \\(\\displaystyle f(x)=-\\sum_{i=1}^m\\log(b_i-a_i^Tx)\\) 仿射函数的任意范数 逐点最大函数 Def（逐点最大）\\(f_i\\) 为凸函数，则\\(f(x) = \\max\\{ f_1, f_2,...,f_m\\}\\) 为凸函数 分段的线性函数 \\(f(x)=\\max(a_i^Tx+b_i)\\)为凸函数 最大 r 个分量之和：\\(f=\\sum_{i=1}^r x_{[i]}\\) 逐点上确界 Def（逐点上确界）若 \\(f\\) 为凸函数，\\(g(x)=\\sup_{y\\in A}f(x,y)\\) 为凸函数 例如： 在集合 C 中距离 \\(x\\) 最远点的距离函数 \\(f(x)=\\sup_{y\\in C}\\|x-y\\|\\) 对称矩阵的最大特征值 \\(\\lambda_{\\max}(X)=\\sup_{\\|y\\|_2=1}y^TXy\\) 函数复合 Thm：\\(g:R^n\\rightarrow R^k, h:R^k\\rightarrow R, f(x) = h(g(x))\\) h 凸，不减 &amp; g 凸 → f 凸函数 h 凸，不增 &amp; g 凹 → f 凸函数 h 凹，不减（增） &amp; g 凹（凸） → f 凹 例如： g 凸函数，则 \\(\\exp g(x)\\) 为凸函数 g 为凹函数，且为正，则\\(\\log g(x)\\) 为凹函数，\\(1/g(x)\\) 是凸函数 最小化 Thm：若 \\(f(x,y)\\) 是关于 \\((x,y)\\) 的凸函数，且集合 \\(C\\) 为凸集。则\\(g(x)=\\inf_{y\\in C}f(x,y)\\) 是凸函数 例如： \\[ \\begin{aligned} &amp;f(x,y)=x^TAx+2x^TBy+y^TCy\\\\ &amp;其中\\left[\\begin{matrix} A&amp;B\\\\ B^T&amp;C \\end{matrix}\\right]\\ge 0,C&gt;0 \\end{aligned} \\] 则 \\(g(x)=\\inf_{y}f(x,y)=x^T(A-BC^{-1}B^T)x\\) 为凸函数 透视函数 Def（透视函数）函数\\(f:R^n\\rightarrow R\\)的透视函数，形如 \\(g(x,t) = tf(x/t)\\) 且 \\(f\\) 为凸函数 例如： \\(f(x)=x^Tx,g(x,t)=tf(x/t)\\) 相对熵：\\(\\sum u_i\\log (u_i/v_i)\\) KL散度：\\(D_{kl}=\\sum(u_i\\log(u_i/v_i)-u_i+v_i)\\)（比较概率分布差异） More 下水平集： \\(f\\) 的 \\(\\alpha\\)-下水平集 \\(C_\\alpha=\\{x\\in \\mathrm {dom}~f|f(x)\\le \\alpha\\}\\) 凸函数的所有下水平集都是凸集 上境图： 共轭函数 \\(\\displaystyle f^*(y)=\\sup_{x\\in \\mathbf{dom}f}*(y^Tx-f(x))\\)： 可微\\(f\\)的共轭函数\\(f^*(y)=\\sup_{x\\in\\mathbf{dom}f}(y^Tx-f(x))\\) 为凸函数 凸函数\\(f\\)且为闭函数：\\((f^*)^*=f\\) 例如： 负对数 \\(f(x)=-\\log x\\) \\[ \\begin{aligned} f^*(y)&amp;=\\sup_{x&gt;0}(xy+\\log x)\\\\ &amp;=\\begin{cases} -1-\\log(-y)&amp;y&lt;0\\\\ \\infty&amp;otherwise \\end{cases} \\end{aligned} \\] 拟凸函数 Def（拟凸函数）\\(f\\) 为拟凸函数，当其定义域为凸集，且其下水平集对于所有\\(\\alpha\\)为凸集。 也就是说：\\(f(\\theta x+(1-\\theta)y)\\le \\max\\{f(x),f(y)\\}\\) 例如： 向量的长度（最后一个⾮零元素的位置） 线性分数函数 向量的零范数（非零元素的个数） 拟凸函数的二阶条件： 对数凸函数、对数凹函数 例如： 对数凹函数： 基于广义不等式的凸函数","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://adversarr.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"「凸优化」 凸优化问题","slug":"study/Math/ConvexOptimization/notes4","date":"2021-01-12T16:00:00.000Z","updated":"2022-03-03T04:30:41.515Z","comments":true,"path":"2021/01/13/study/Math/ConvexOptimization/notes4/","link":"","permalink":"http://adversarr.github.io/2021/01/13/study/Math/ConvexOptimization/notes4/","excerpt":"凸优化-凸优化问题","text":"凸优化-凸优化问题 凸优化问题 优化问题的标准形式 \\[ \\begin{aligned} &amp;\\min.&amp;f_0(x)\\\\ &amp;\\mathrm{s.t.}&amp;f_i(x)\\le 0, i = 1,...,m\\\\ &amp;&amp;h_i(x) =0 \\end{aligned} \\] 一些概念： \\(x\\in R^n\\) 优化变量 \\(f_0\\) 目标函数（代价函数） \\(f_i:R^n\\rightarrow R\\) 不等式约束函数 \\(h\\) 等式约束函数 优化问题的域：\\(D=\\bigcap \\mathbf{dom}~f_i\\cap \\bigcap \\mathbf{dom}h_i\\) 可行解集：\\(x\\in D\\) 为可行解，且满足所有的不等式约束、等式约束 最优值： \\(p^*=\\inf\\{f_0(x)|f_i(x)\\le 0, i = 1, ..., m,h_i(x) = 0, i = 1, ... ,p\\}\\) 没有可行解：\\(p^*=\\infin\\) 若问题没有下界，则：\\(p^*=\\infty\\) 最优解 \\(x^*\\)：若 \\(x^*\\) 可行，且 \\(f_0(x^*)=p^*\\) 最优解集：\\(X_{opt}=\\{x|f_i(x)\\le 0, i = 1,...,m, h_i(x) = 0, i = 1, ..., p, f_0(x)=p^*\\}\\) \\(\\epsilon-\\)次优解集：\\(\\epsilon&gt;0,f_0(x)\\le p^*+\\epsilon\\) 局部最优点 \\(x\\) 为局部最优点，若存在一个正实数 \\(R\\) 使得 \\[ \\begin{aligned} &amp;\\min.&amp;f_0(z)\\\\ &amp;\\mathrm{s.t.}&amp;f_i(z)\\le 0, i = 1,...,m\\\\ &amp;&amp;h_i(z) =0 &amp;&amp;||z-x||_2\\le R \\end{aligned} \\] 例如： \\(f(x) = 1/ x, p^* = 0\\) 无最优点 \\(f(x) = -\\log x, p^*=-\\infin\\) \\(f(x) = x\\log x,p^*=-1/e,x=1/e\\) 不等式约束 活动约束：\\(f\\le 0\\) 非活动约束：\\(f&lt;0\\) 等价问题 可行性优化问题的例子： 例 盒子约束 转化为 缩放 转化为 等价问题的解决方法 若有： \\[ \\begin{aligned} &amp;\\psi_0:R\\rightarrow R &amp;单调增\\\\ &amp;\\psi_1,...,\\psi_m:R\\rightarrow R&amp;\\psi_i\\le 0\\leftrightarrow u\\le 0\\\\ &amp;\\psi_{m+1},...,\\psi_{m+p}:R\\rightarrow R&amp;\\psi_{i}(u)=0\\leftrightarrow u=0\\\\ &amp;\\tilde f_i(x)=\\psi_i(f_i(x)),~\\tilde h_i(x)=\\psi_{m+i}(h_i(x)) \\end{aligned} \\] 则，将： 转化为： 例如： 转化为： 又如： \\(\\min.||Ax-b||_2\\iff\\min.||Ax+b||_2^2\\) 变量变换：\\(\\tilde{f}_i(z)=f_i(\\phi(z)),\\tilde{g}_i(z)=h_i(\\phi(z))\\) 目标函数和约束函数的变换：\\(\\tilde{f}_i(z)=\\varPhi_i(f_i(z)),\\tilde{g}_i(z)=\\varPhi_i(h_i(z))\\) 消除线性等式约束：\\(R(F)=N(A)\\) 凸优化问题 \\[ \\begin{aligned} &amp;\\min.&amp;f_0(x)\\\\ &amp;\\mathrm{s.t.}&amp;f_i(x)\\le 0, i = 1,...,m\\\\ &amp;&amp;a_i^Tx=b_i \\end{aligned} \\] \\(f_i\\) 为凸函数 \\((i=1...m)\\) 松弛变量 例如： 转化为： 局部和全局最优解 凸优化问题的任意局部最优解也是全局最优解 Thm（可微函数的最优性准则）\\(x\\)为最优解，iff \\(x\\) 是可行的，且 \\(\\nabla f_0(x)^T(y-x)\\ge 0,~\\forall y\\in D\\) 考虑凸函数的一阶条件 线性规划 线性规划问题 \\[ \\begin{aligned} \\min.~c^Tx+d\\\\ s.t.~Gx\\preceq h\\\\ \\qquad Ax=b \\end{aligned} \\] 线性分式规划 \\[ \\begin{aligned} \\min.&amp; f_0(x)&amp;\\\\ s.t.&amp; Gx\\preceq h\\\\ &amp;Ax=b&amp; \\end{aligned} \\] 其中 \\[ f_0(x)=\\frac{c^Tx+d}{e^Tx+f} \\] 为拟凸优化问题，等价于线性规划 二次规划问题 \\[ \\begin{aligned} \\min.&amp; \\frac{1}{2}x^TPx+q^Tx+r&amp;\\\\ s.t.&amp; Gx\\preceq h\\\\ &amp;Ax=b&amp; \\end{aligned} \\] 二次约束二次规划问题 \\[ \\begin{aligned} \\min.&amp; \\frac{1}{2}x^TPx+q^Tx+r&amp;\\\\ s.t.&amp; \\frac{1}{2}x^TP_ix+q_i^T+r_i\\le 0\\\\ &amp;Ax=b&amp; \\end{aligned} \\] 广义不等式约束 函数 \\(f_0:R^n\\rightarrow R\\) 为凸函数，\\(f_i:R^n\\rightarrow R^{k_i}\\) 为 \\(K_i\\) 凸函数。 锥形式问题：目标函数、约束函数为仿射函数的形式： 半定规划 其中不等式约束称为线性矩阵不等式 (LMI) 带有多个 LMI 约束的问题，等价于单个 LMI 例如： 向量优化 通用的向量优化问题： 目标函数 \\(f_0\\) 指在正常锥下最小化 凸向量优化问题： 其中，\\(f_0\\) 为 K-凸函数，其余为凸函数 最优解和Pareto最优解 Def（可达目标值集合）\\(\\mathcal O=\\{f_0(x)|x~\\mathrm{feasible}\\}\\) Def（最优解）\\(x\\) 若 \\(f_0(x)\\) 为 \\(\\mathcal O\\) 的最小元 Def（Pareto 最优解） \\(x\\) 若 \\(f_0(x)\\) 为 \\(\\mathcal O\\) 的极小元 Def（标量化）为了求得 Pareto 最优解，选择 \\(\\lambda \\succ_{K^*}0\\) 来求解标量问题 通过变化 \\(\\lambda\\succ_{K^*}0\\) 来找到所有的Pareto 最优点 例如：正则化最小二乘问题 \\[ \\min (w.r.t~R^2_+)\\quad(\\|Ax-b\\|^2_2,\\|x\\|^2_2) \\] 粗线表示 Pareto 最优点","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://adversarr.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"「复变函数」复数项级数的概念和性质","slug":"study/Math/ComplexFunctions/ch4","date":"2021-01-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.708Z","comments":true,"path":"2021/01/11/study/Math/ComplexFunctions/ch4/","link":"","permalink":"http://adversarr.github.io/2021/01/11/study/Math/ComplexFunctions/ch4/","excerpt":"复数项级数的概念和性质","text":"复数项级数的概念和性质 复数项级数的概念和性质 复数项级数 Def：无穷复数列 \\(\\{c_n\\}\\rightarrow_{n\\rightarrow \\infty} A \\iff \\forall \\varepsilon&gt;0,\\exist N,n&gt;N\\rightarrow |c_n-A|&lt;\\varepsilon\\) Thm（判别法则）\\(c_n=a_n+ib_n\\) 收敛于 \\(a+bi~\\iff~a_n\\rightarrow a, b_n\\rightarrow b\\) Def（复数项级数）\\(\\sum_{n=1}^\\infty c_n\\)，通项 \\(c_n\\)。 Def（前 n 项之和）\\(\\sum_{k=1}^n c_k\\) Thm：（必要条件）级数 \\(\\sum c_n\\) 收敛，则 \\(\\lim_{n\\rightarrow \\infty} c_n=0\\) Thm：（柯西收敛准则）\\(\\sum c_n\\) 收敛 \\(\\iff \\forall \\varepsilon&gt;0,\\exist N,\\forall p\\in N_+, n&gt;N\\rightarrow|S_{n+p} - S_n|\\le \\varepsilon\\) 按模收敛 Def（按模收敛）\\(\\sum |c_n|\\) Thm（绝对收敛准则）当 \\(\\sum |c_n|\\) 收敛时，\\(\\sum c_n\\) 收敛 Def（条件收敛）\\(\\sum |c_n|\\) 不收敛，\\(\\sum c_n\\) 收敛 性质： \\(\\sum c_n=s\\)，\\(k\\)为任意常数，则\\(\\sum kc_n=k\\sum c_n\\) 线性性质 去掉或加上有限项不改变级数的敛散性。 收敛级数添加括号或改变次序不改变敛散性 逆命题不成立 幂级数 函数项级数 若存在\\(\\sum u_n(z_0)\\) 收敛，则称\\(z_0\\) 为收敛点；收敛点的全体为收敛域 \\(D\\)。 对于任一 \\(z\\in D\\)，有一个确定的和 \\(S(z)\\) 称为和函数。 如等比级数：\\(\\sum z_n\\) 当 \\(|z|&lt;1\\) 时，\\(|z|=1,~\\theta = 2k\\pi\\) 时收敛，其他情况下发散。 幂级数的收敛性 Def（\\((z-z_0)\\) 的幂级数）\\(\\sum c_i(z-z_0)^i\\) Thm（Abel 定理） 若\\(\\sum c_i(z-z_0)^i\\) 在 \\(z=z_0\\ne 0\\) 收敛，则对\\(\\forall |z|&lt; |z_0|\\) 绝对收敛 若\\(\\sum c_i(z-z_0)^i\\) 在 \\(z=z_0\\ne 0\\) 发散，则对\\(\\forall |z|&gt; |z_0|\\) 发散 Thm：若\\(\\lim |c_{n+1}/c_n|=\\lambda \\ne 0\\) or \\(\\lim |c_n|^{1/n}=\\lambda \\ne 0\\) 则 \\(R=1/\\lambda\\) 性质： 代数运算（线性性质） 柯西乘积 幂级数的收敛圆和收敛半径 仅有三种情况： 在 \\(z=0\\) 收敛 在圆域内收敛 在复平面内收敛 求法 Thm：若： \\[ \\begin{aligned} &amp;\\lim_{n\\rightarrow \\infty}\\left|\\frac{c_{n+1}}{c_n}\\right|=\\lambda\\ne 0\\\\ &amp;\\quad or\\\\ &amp;\\lim_{n\\rightarrow \\infty}\\sqrt[n]{|c_n|}=\\lambda\\ne 0 \\end{aligned} \\] 则其收敛半径为\\(\\displaystyle R=\\frac{1}{\\lambda}\\) Thm：设\\(\\sum c_nz^n\\)的收敛半径为 \\(R&gt;0\\) 和函数为 \\(S(z)\\) 则： 和函数在 \\(|z|&lt;R\\) 解析 \\(S(z)\\) 可以逐项求导、逐项积分 Taylor 级数 Def（展开为幂级数）若 \\(f\\) 在 \\(z_0\\) 邻域内有任意阶导数，则\\(\\sum \\frac{f^{(n)}(z_0)}{n!}(z-z_0)^n\\) 为 \\(f\\) 在 \\(z_0\\) 的 Taylor 级数，当 \\(z_0=0\\) 时，为麦克劳林级数。 Thm：\\(f\\) 在 \\(D\\) 内解析，\\(z_0\\in D\\) 则当 \\(|z-z_0|&lt;R\\) 时，\\(f(z)\\) 都可以唯一的展开为 \\(z-z_0\\) 的幂级数。（\\(R\\) 为 \\(x_0\\) 到边界的最小距离） Thm：\\(f\\) 在 \\(D\\) 内解析，\\(z_0\\in D\\)，\\(d\\)为到边界上各个点的最短距离，当 \\(|z-z_0|&lt;d\\) 时，\\(f(z)\\) 可以唯一的展开为幂级数 Inference：\\(f\\) 在 \\(D\\) 内解析，\\(z_0\\in D\\)，\\(\\alpha\\) 为距离 \\(z _ 0\\) 最近的一个奇点，则使得展开成立的 \\(R=|\\alpha-z_0|\\) 洛朗级数 解析函数的洛朗展开定理 Def（双边幂级数）\\(\\sum_{-\\infty}^{\\infty}c_n(z-z_0)^n\\) （其在收敛圆环域\\(R_1&lt;|z-z_0|&lt;R_2\\) 内解析） Thm：\\(f(z)\\) 在圆环域内解析，则在圆域内 \\(f(z)\\) 可以唯一的表示为双边幂级数 \\(f(z)=\\sum_{-\\infty}^{\\infty}c_n(z-z_0)^n\\) 其中：\\(\\displaystyle c_n=\\frac{1}{2\\pi i}\\int\\frac{f(z)}{(z-z_0)^{n+1}}\\mathrm dz \\quad(n=0,\\pm 1, \\pm 2,...)\\) 求展开的方法： 直接展开法 简介展开法","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"「复变函数」留数及其应用","slug":"study/Math/ComplexFunctions/ch5","date":"2021-01-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.745Z","comments":true,"path":"2021/01/11/study/Math/ComplexFunctions/ch5/","link":"","permalink":"http://adversarr.github.io/2021/01/11/study/Math/ComplexFunctions/ch5/","excerpt":"留数及其应用","text":"留数及其应用 留数及其应用 孤立奇点 Def（孤立奇点）\\(f(z)\\) 在 \\(z_0\\) 不解析，在其某个去心邻域内解析，则称\\(z_0\\)为 \\(f(z)\\) 的孤立奇点 可去奇点：Laurent 级数不含有负幂项 -&gt; 令 \\(f(z_0)=c_0\\) 只需要重新定义 \\(f(z_0)=c_0\\) 就可以解析，例如 \\((e^z-1) / z,\\quad z=0\\) （m 阶）极点：负幂项只有有限个。 \\(\\lim_{z\\rightarrow z_0} f(z)=\\infin\\) 本性奇点：负幂项有无穷多项。 Thm：设函数 \\(f(z)\\) 在 \\(0&lt;|z-z_0|&lt;\\delta\\) 内解析，若 \\(z_0\\) 为本性奇点，则 \\(\\forall a,\\exists\\{z_n\\},\\lim_{z_n\\rightarrow z_0}f(z_0) = a\\) 零点和极点的关系 Def（零点）\\(f(z_0)=0\\) 则称 \\(z_0\\) 为 \\(f(z_0)\\) 的零点 Def（m 级零点）若 \\(f(z)=(z-_0)^m\\varphi(z)\\) 在 \\(z_0\\) 处解析，且 \\(\\varphi(z)\\) 在 \\(z_0\\) 处解析 \\(\\varphi(z_0)\\ne0\\) 则称 \\(z_0\\) 为 \\(f(z)\\) 的 m 级零点 Thm：若 \\(f\\) 在 \\(z_0\\) 解析，则： \\(z_0\\) 为 m 阶零点 \\(\\iff f^{(n)}(z_0)=0, (n &lt; m)~,f^{(m)}\\ne 0\\) Thm：若 \\(z_0\\) 是 \\(f(z)\\) 的 m 阶极点 \\(\\iff\\) \\(z_0\\) 是 \\(1/f(z)\\) 的 m 阶零点。 Thm：若 \\(z_0\\) 为 \\(f,g\\) 的 \\(m, n (m&lt;n)\\) 级零点，则 \\(z_0\\) 为 \\(f(z)/g(z)\\) 的 \\(m - n\\) 阶零点，为 \\(f(z)g(z)\\) 的 \\(m+n\\) 阶零点。 在无穷远点的形态 Def：若 \\(f(z)\\) 在无穷远点\\(z=\\infin\\) 的去心邻域 \\(U(\\infty)=\\{z|0&lt;R&lt;|z|&lt;\\infty\\}\\) 内解析，则称 \\(\\infin\\) 为 f 的孤立奇点。 Def：若 \\(t=0\\) 是 \\(\\displaystyle\\varphi(t)=f(\\frac 1 t)\\) 的可去奇点，m 级极点，本性极点，则 \\(t=\\infin\\) 是 \\(f(z)\\) 的可去奇点，m 级极点，本性极点。 留数和留数定理 Def（留数）设\\(z_0\\)为 \\(f(z)\\) 的有限孤立奇点，我们把 \\(f(z)\\) 在 \\(z_0\\) 的去心邻域内的洛朗级数展开式两端逐项积分留下的积分值除以 \\(2\\pi i\\) 后得到的数称为 \\(f(z)\\) 在 \\(z_0\\) 的留数：\\(\\mathrm{Res}[f(z),z_0]=\\frac{1}{2\\pi i}\\oint f(z) dz=c_{-1}\\) Def（无穷远处的留数）\\(Res[f(z),+\\infin]=\\frac{1}{2\\pi i}\\oint_{L-}f(z)=-C_{-1}\\)（f 在圆环域 \\(0&lt;R&lt;|z|&lt;\\infin\\) 解析） 留数计算方法： 若 \\(z_0\\) 为可去奇点：\\(Res[f,z_0]=c_{-1}=0\\) 1 级极点：\\(Res[f,z_0]=\\lim_{z\\rightarrow z_0}(z-z_0)f(z)\\) m 级极点：\\(Res[f,z_0]=\\frac{1}{(m-1)!}]\\lim_{z-z_0}\\frac{\\mathrm d^{m-1}}{\\mathrm dz^{m-1}}[(z-z_0)^mf(z)]\\) 若 \\(f(z)=P(z)/Q(z)\\)，\\(P,Q\\) 解析，且 \\(P(z_0)\\ne 0,~Q(z_0) = 0,~Q&#39;(z_0)\\ne 0\\) 则 \\(\\displaystyle Res=\\frac{P(z_0)}{Q&#39;(z_0)}\\) \\(\\displaystyle Res[f(z),\\infty]=-Res[-\\frac{1}{z^2}f(\\frac{1}{z}),0 ]\\) Thm（留数定理）设函数 \\(f(z)\\) 在 \\(D\\) 内除了有限个孤立奇点外处处解析，\\(L\\)是\\(D\\) 内的一个逆时针的简单闭曲线，则\\(\\displaystyle\\oint f(z)\\mathrm dz =2\\pi i\\sum_{k=1}^m\\mathrm{Res}[f(z),z_k]\\) Thm：若函数\\(f(z)\\) 在扩充复平面内处有限个孤立奇点外解析，则 \\(f(z)\\) 在各个极点的留数和为 0：\\(\\displaystyle\\mathrm{Res}[f(z),+\\infin]+\\sum\\mathrm{Res}[f(z),z_k]=0\\) 利用留数计算某些实积分 ∫R(cos θ, sin θ) dθ 设 \\(z=e^{i\\theta}\\) 则： \\[ \\oint_{0}^{2\\pi}R(\\cos \\theta,\\sin\\theta)\\mathrm d\\theta=\\oint_{|z|=1}\\frac{1}{iz}R(\\frac{z+z^{-1}}{2},\\frac{z-z^{-1}}{2i})\\mathrm dz \\] ∫R(x) dx 其中 \\[ R(x)=\\frac{P_m(x)}{Q_n(x)}=\\frac{a_0+a_1x+\\cdots+a_mx^m}{b_0+b_1x+\\cdots+b_nx^n} \\] 满足： \\(n-m\\ge2\\) 在实轴上\\(Q_n(z)\\ne 0\\) 则： \\[ \\int_{-\\infty}^{\\infty}R(x)\\mathrm dx =2\\pi i\\sum Res[R(z),z_k] \\] 其中 \\(z_k\\) 为上半平面内所有奇点 ∫ R(x) · exp(i·a·x) dx \\[ R=P(x)/Q(x) \\] 其中 \\(m-n\\ge 1,Q(x)\\ne 0\\) 则： \\[ \\int_{-\\infty}^{\\infty}R(x)e^{iax}\\mathrm dx = 2\\pi i\\sum Res(R(z)e^{iax},z_k) \\] 其中 \\(z_k\\) 为上半平面内所有奇点 也就是： \\[ \\int_{-\\infty}^{\\infty}R(x)\\cos ax\\mathrm dx+i\\int_{-\\infty}^{\\infty}R(x)\\sin ax\\mathrm dx = 2\\pi i\\sum Res(R(z)e^{iax},z_k) \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"「复变函数」共形映射","slug":"study/Math/ComplexFunctions/ch6","date":"2021-01-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2021/01/11/study/Math/ComplexFunctions/ch6/","link":"","permalink":"http://adversarr.github.io/2021/01/11/study/Math/ComplexFunctions/ch6/","excerpt":":no_mouth:","text":":no_mouth: 共形映射 共形映射的概念 解析函数导数的几何意义 复平面上有向曲线的切向量：\\(z=z(t)\\) 的切向量为 \\(z&#39;(t)\\) 导数幅角的几何意义：表示曲线 \\(C\\) 经过 \\(w=f(z)\\) 后在 \\(z_0\\) 的转动角，且大小和方向仅与 \\(z_0\\) 有关，而与 \\(C\\) 无关。 旋转角的不变性： 函数 \\(w=f(z)\\) 在 D 内解析，且 \\(f&#39;\\ne0\\) 则曲线 \\(L\\) 的象曲线方程为： \\(\\Gamma:w=f(z(t)),~t\\in[\\alpha,\\beta]\\)，\\(\\Gamma\\) 在 \\(w=w(t_0)\\) 的邻域内光滑，且： \\(w&#39;(t_0)=f&#39;(z)z&#39;(t_0)\\ne 0\\) 则\\(\\Gamma\\) 在\\(w_0=f(z_0)\\) 的切向量为 \\(w&#39;(t_0)\\) 则：\\(Arg~w&#39;(t_0)=Arg~f&#39;(z_0)+Arg~z&#39;(t_0)\\) 导数模的几何意义：经过映射后 \\(z_0\\) 的任何曲线在 \\(z_0\\) 的伸缩率。\\(|f&#39;(z_0)|=\\lim_{z\\rightarrow z_0} \\left|\\frac{w-w_0}{z-z_0}\\right|\\) 伸缩率不变性：解析函数，伸缩率与曲线 \\(C\\) 无关，具有伸缩率不变性。 Thm：设函数 \\(f\\) 在 D 内解析，且 \\(z_0\\in D,~f&#39;(z_0)\\ne 0\\) 则该映射在该点处有保角性和伸缩率不变性 共形映射的概念和单叶解析函数的共形性 Def（保角） 函数在某一点处具有保角性和伸缩率不变性 \\(\\implies\\) 保角的 函数在 \\(D\\) 内每一点处都是保角的 \\(\\implies\\) 保角映射 \\(D\\)内的单叶、保角映射 \\(\\implies\\) 共形映射 Thm：\\(f\\) 为 \\(D\\) 内的解析函数，\\(z_0\\in D\\) 若 \\(f&#39;\\ne 0\\) 则在\\(z_0\\)是保角的。若对任何 \\(z\\in D\\) 都有 \\(f&#39;\\ne 0\\) 则为保角映射 Thm：\\(w=f(z)\\) 是 \\(D\\) 内的单叶映射，则它将 \\(z\\) 平面上的区域 \\(D\\) 共形映射为 \\(w\\) 平面上的区域 \\(G=f(D)\\) 它的反函数 \\(z=f^{-1}(w)\\) 在 \\(G\\) 内单叶解析，且：\\([f^{-1}(w)]&#39;=\\frac{1}{f&#39;(z)}\\) review伸缩率：\\(\\|f&#39;\\|\\)旋转角：\\(Arg~f&#39;\\)解析 &amp; f‘≠ 0 =&gt; 保角性","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"「凸优化」 对偶","slug":"study/Math/ConvexOptimization/notes5","date":"2020-12-25T16:00:00.000Z","updated":"2022-03-03T04:30:41.515Z","comments":true,"path":"2020/12/26/study/Math/ConvexOptimization/notes5/","link":"","permalink":"http://adversarr.github.io/2020/12/26/study/Math/ConvexOptimization/notes5/","excerpt":"凸优化-对偶","text":"凸优化-对偶 对偶 Lagrange 对偶问题 Lagrange 函数 考虑标准形式的优化问题，拉格朗日函数定义为： \\[ \\begin{aligned} &amp;L:R^n\\times R^m\\times R^p\\rightarrow R\\\\ &amp;L(x, \\lambda, \\nu)=f_0(x)+\\sum_{i=1}^m \\lambda_if_i(x)+\\sum_{i=1}^p \\nu_ih_i(x)\\\\ \\end{aligned} \\] 定义域为：\\(D\\times R^m\\times R^p\\) 目标函数和约束函数的加权和 \\(\\lambda_i\\) 为第 i 个不等式约束的拉格朗日乘子 \\(\\nu_i\\) 为第 i 个不等式约束的拉格朗日乘子 Lagrange 对偶函数 \\[ \\begin{aligned} &amp;g:R^m\\times R^p\\rightarrow R\\\\ &amp;g=\\inf_{x\\in D} L(x,\\lambda, \\nu) \\end{aligned} \\] 函数 \\(g\\) 为凹函数（任何优化问题的 Lagrange 对偶函数为凹函数） \\(\\sup L(x,\\lambda, \\nu)\\) 为凸函数 最优值下界：若 \\(\\lambda \\ge 0\\)，则 \\(g(\\lambda, \\nu)\\le p^ *\\)（\\(p^ *\\) 为原优化问题最优值） 例：线性方程组的最小二乘解 \\[ \\begin{aligned} \\min~~&amp;x^Tx\\\\ s.t.~~&amp;Ax=b \\end{aligned} \\] 下界性质：\\(p^*\\ge -\\frac 1 4 \\nu^TAA^T\\nu-b^T\\nu,\\quad \\forall \\nu\\) 例：标准形式的线性规划 下界性质：\\(p^*\\ge-b^T\\nu,\\quad if~A^T\\nu +c\\succeq 0\\) 例：双向划分问题 \\[ \\begin{aligned} \\min~~&amp;x^TWx\\\\ s.t.~~&amp;x_i^2=1,\\quad i = 1,...,n \\end{aligned} \\] 下界性质：\\(p^*\\ge -\\mathbf 1^T\\nu, \\quad if~W+\\mathbf{diag}(\\nu)\\succeq 0\\) Lagrange 对偶函数与共轭函数 共轭函数 \\(f^*=\\sup_{x\\in D}(y^Tx-f(x))\\) 而对偶函数满足： 若已知共轭函数，可以简化对偶函数的表达 例如：熵的最大化 对偶问题 \\[ \\begin{aligned} \\max~~&amp;g(\\lambda,\\nu)\\\\ s.t.~~&amp;\\lambda\\succeq 0 \\end{aligned} \\] 凸优化问题的最优值表示为 \\(d^*\\) 通过 Lagrange 对偶函数获取 \\(p^*\\) 的最佳下界 凸优化问题：\\(d^*\\le p^*\\) 例：线性规划 \\[ \\begin{aligned} \\min.&amp;c^Tx\\\\ s.t.&amp;Ax=b\\\\&amp;x\\succeq 0 \\end{aligned} \\] 对偶问题为： \\[ \\begin{aligned} \\max.&amp;-b^Tv\\\\ s.t.&amp;A^Tv+c\\succeq0 \\end{aligned} \\] 对于一个线性规划问题，其对偶问题也是线性规划问题 弱对偶与强对偶 Thm（弱对偶）对于凸优化和非凸优化都有：\\(d^*\\le p^*\\) 可以⽤来寻找困难问题的⾮平凡下界 Thm（强对偶）对偶间隙 \\(p^*-d^* =0\\) 并非总是满足，但在凸优化问题中常常满足 凸优化问题中保证强对偶的条件称为约束准则。 几何解释 考虑只有一个约束 \\(f_1(0)\\le 0\\) 的问题 定义集合：\\(G=\\{(f_0(x),f_1(x)|x\\in D\\}\\) 如果是凸的： 最优性条件 Def（相对内部）\\(\\mathrm{Rel~int}~D=\\{x\\in D|B(x,r)\\cap\\mathrm{aff~}D\\sub D,\\exist r&gt;0\\}\\) Slater 约束准则 Thm：若某个凸优化问题中，存在一点 \\(x\\in \\mathrm{relint}~D=\\{x\\in D|B(x,r)\\cap \\mathrm{aff}D\\subset D\\}\\) 使得该问题是严格可行的（\\(x\\in relint~D,f_i(x)&lt;0,Ax=b\\)）则为强对偶问题。 弱化后：若不等式约束时仿射的，只要可行域非空，则必有\\(d^*=p^*\\) KKT 最优性条件 KKT 条件 一般可微优化问题，对偶间隙为 0 需要满足 KKT 条件，包含以下四个部分： （互补松弛性）\\(\\lambda^*_if_i(x^*)=0\\) （原始可行性）\\(f_i(x)\\le 0, h_i(x)=0\\) （对偶可行性）\\(\\lambda_i\\ge 0\\) （稳定性条件）\\(\\displaystyle\\frac{\\partial}{\\partial x}L(x,\\lambda,\\nu)=0\\) 例：注水 互补松弛性 若对偶问题满足 \\(p^*=d^*\\) 且所有函数可微，则最优解满足： \\[ \\lambda_i^*f_i(x^*)=0 \\] 稳定性 \\[ \\inf L=L(x^*,\\lambda^*,\\nu^*) \\] 则： \\[ \\frac{\\partial L(x,\\lambda^*,\\nu^*)}{\\partial x}|_{x=x^*}=0 \\] 对偶、问题重形式化 常用方法： 引入新的变量和对应的约束 将显示约束转换为隐式表达（反之亦然） 变换目标或约束函数变换 引入新的变量和对应的约束 例如：\\(\\min~~f_0(Ax+b)\\) 对偶问题：\\(g=\\inf_xf_0(Ax+b)=p^*\\) 重形式化后： \\[ \\begin{aligned} \\min~~&amp;f_0(y)&amp;\\\\ s.t.~~&amp;Ax+b-y=0&amp;\\\\ \\rightarrow~~ &amp;g(\\nu)= \\begin{cases} -f_0^*(\\nu)+b^T\\nu &amp;A^T\\nu = 0\\\\ -\\infty&amp;otherwise \\end{cases} \\end{aligned} \\] 例：范数逼近问题 \\[ \\begin{aligned} \\min~~&amp;\\|Ax-b\\|\\\\ \\rightarrow\\min~~&amp;\\|y\\|\\\\ s.t.~~&amp;y=Ax-b \\end{aligned} \\] 隐式约束 例如：带框的线性规划 扰动、灵敏度分析 优化问题及其对偶问题的形式为： 则其扰动问题及其对偶 其中，\\(x\\) 为原问题的优化变量，\\(u,~v\\) 为参数 得到的 \\(p^*(u,v)\\) 为最优值，是 \\(u\\) 和 \\(v\\) 的函数 扰动问题的性质 Thm：若原问题是凸的，则 \\(p^*(u,v)\\) 是凸函数 Thm：若原问题为凸，且对偶间隙为 0，\\(\\lambda^*,w^*\\) 为原问题的最优解，则：\\(p^*(u,v)\\ge p^*(0,0)-\\lambda^{*T}u-w^{*T}v\\) 灵敏度分析 \\(p^*(u,v)\\ge p^*(0,0)-\\lambda^{*T}u-w^{*T}v\\) 局部灵敏度分析 Thm：若原问题是凸的，且强对偶性成立， \\(p^*(u,v)\\) 在 \\((0,0)\\) 可微，则有 \\[ \\lambda_i^*=-\\frac{\\partial p^*(0,0)}{\\partial u_i},\\quad \\nu_i^*=-\\frac{\\partial p^*(0,0)}{\\partial v_i} \\] 广义不等式 不等式约束的 Lagrange 乘子为向量 \\(\\lambda_i\\in R^{k_i}\\) 拉格朗日函数为：\\(L=f_0(x)+\\sum_{i=1}^m\\lambda_i^Tf_i(x)+\\sum_{i=1}^p\\nu_ih_i(x)\\) Thm（下界性质）若 \\(\\lambda_i\\succeq_{K_i^*}0\\) 则 \\(g\\le p^*\\) 例：半定规划","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://adversarr.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"「随机数学与数理统计」7 - 参数估计","slug":"study/Math/Probabilities/notes7","date":"2020-12-22T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/12/23/study/Math/Probabilities/notes7/","link":"","permalink":"http://adversarr.github.io/2020/12/23/study/Math/Probabilities/notes7/","excerpt":"矩估计 极大似然估计 评判估计量的方法","text":"矩估计 极大似然估计 评判估计量的方法 参数估计 两种常用的参数估计方法 矩估计法 辛钦大数定律：样本较大时，\\(A_r=\\frac{1}{n}\\sum_{i=1}^nX_i^r\\rightarrow EX_r\\) 格里汶科定理：格里汶科定理是指当样本容量n→∞时，经验分布函数以概率1一致收敛于总体的分布函数。 Def（矩估计）设总体 \\(X\\) 的分布 \\(f(x;\\theta_1,...,\\theta_k)\\) 中有 \\(k\\) 个位置的参数 \\(\\theta_{1..k}\\)，\\((X_1,...,X_n)\\) 时总体 \\(X\\) 的样本。若总体 \\(X\\) 的\\(k\\) 阶原点矩 \\(EX_k\\) 存在，并且 \\(\\alpha_r(\\theta_1,...\\theta_k)=EX^r\\) 时总体 \\(X\\) 的 \\(r\\) 阶原点矩，记 \\(A_r\\) 为样本的 \\(r\\) 阶原点矩，由： \\[ \\alpha_r(\\theta_1,\\dots, \\theta_k)=A_r(\\theta_1,\\dots,\\theta_r)\\qquad r=1,...,k \\] 解得的 \\(\\hat\\theta_r=\\hat\\theta_r(X_1,...,X_k)\\)，并以 \\(\\hat\\theta_r\\) 作为参数的估计量，称 \\(\\hat\\theta_r\\) 为参数 \\(\\theta_r\\) 的估计量。 不唯一（依赖于 r） \\(EX^k\\) 有限 要求 \\(n\\) 比较大 极大似然估计 基本思想：\\(X\\sim P(X;\\theta)\\rightarrow P(X=x)\\) 使得：\\(\\hat\\theta\\) 能使得出现样本 \\(X_{1..k}\\) 的概率最大 Def（似然函数）设总体 \\(X\\) 的分布为 \\(f(x;\\theta_1,\\dots,\\theta_k)\\)，其中 \\(\\theta_{1\\dots k}\\) 为未知参数，\\((X_1,\\dots,X_n)\\) 为简单随机样本，称 \\[ L(\\theta_1,...,\\theta_k)=\\prod_{i=1}^nf(x_i;\\theta_1,...,\\theta_k) \\] Def（MLE-极大似然估计）称 \\(\\hat\\theta =\\mathrm{argmax} L(\\theta)\\) 为 \\(\\theta\\) 最大似然估计量 求法： 1. 写似然函数 2. 优化似然函数 例如：假设总体服从参数为 \\(p\\) 的 0-1 分布，\\((X_1,...,X_n)\\) 为样本，求 \\(p\\) 的最大似然估计 似然函数为：\\(L(x_1,...,x_n;p)=p^{n\\bar X}(1-p)^{n-n\\bar X}\\) 取对数：\\(\\ln L=n\\bar X\\ln p+n(1-\\bar X)\\ln (1-p)\\) 对 \\(p\\) 求偏导，取得极值 \\(\\hat p=\\bar X\\) 常见的有： \\(\\displaystyle X\\sim P(\\lambda)\\Rightarrow \\hat \\lambda=\\bar X\\) \\(\\displaystyle X\\sim e(\\lambda)\\Rightarrow \\hat \\lambda=\\frac{1}{\\bar{X}}\\) 0-1 分布：\\(\\hat p = \\bar X\\) \\(X\\sim U(a,b)\\Rightarrow,a=\\min x_i,b=\\max x_i,\\quad i = 1,...,n\\) 对于正态分布 \\(\\displaystyle X\\sim N(\\mu, \\sigma^2)\\)，注意对于 \\(\\sigma^2\\) 整体求导，得到： \\[ \\begin{cases} \\hat \\mu=\\bar X\\\\ \\hat{\\sigma^2} = \\frac{1}{n}\\sum_{i=1}^n(X_i-\\bar X)^2=B_2 \\end{cases} \\] Thm（最大似然估计的不变性） 评选估计量的标准 无偏性 有效性 相合性 无偏性 Def（无偏性）若 \\(\\hat\\theta(X_1,...,X_n)\\) 为 \\(\\theta\\) 的估计量，若\\(\\hat \\theta(X_1,..,X_n)\\) 的数学期望 \\(E\\hat\\theta\\) 存在，且对于任一的 \\(\\theta \\in \\Theta\\)，\\(E\\hat\\theta=\\theta\\) 则称 \\(\\hat\\theta\\) 为 \\(\\theta\\) 的一个无偏估计量 \\(EX\\) 为\\(\\mu\\) 的无偏估计 \\(A_k\\) 为 \\(EX^k\\) 的无偏估计 \\(ET^2\\) 为 \\(\\sigma^2\\) 的渐进无偏估计 \\(ES^2\\) 为 \\(\\sigma^2\\) 的无偏估计 注意： 若 \\(\\hat\\theta\\) 是 \\(\\theta\\) 的无偏估计，\\(\\hat{g(\\theta)}\\) 不一定是 \\(g(\\theta)\\) 的无偏估计。（除非 \\(g(\\theta)\\) 是线性的） 同一个参数的无偏估计不一定唯一 有效性 Def（有效性）若 \\(\\hat\\theta_1,\\hat\\theta_2\\) 都是 \\(\\theta\\) 的无偏估计，若\\(D\\hat\\theta_1\\le D\\hat\\theta_2\\) 则称 \\(\\hat\\theta_1\\) 比 \\(\\hat\\theta_2\\) 有效。 相合性 Def（相合性）若\\(\\hat\\theta(X_1,...,X_n)\\) 是 \\(\\theta\\) 的一个估计量，若对于任一 \\(\\varepsilon&gt;0\\) 有： \\[ \\lim_{n\\rightarrow\\infty}P(|\\hat\\theta-\\theta|\\ge \\varepsilon)=0 \\] 则称 \\(\\hat\\theta\\) 为 \\(\\theta\\) 的相合估计量 Def（均方误差）设 \\(\\hat\\theta\\) 为 \\(\\theta\\) 的一个估计量， 称 \\(E(\\hat\\theta - \\theta)^2\\) 为 \\(\\hat \\theta\\) 估计 \\(\\theta\\) 时的均方误差 称 \\(b=E(\\hat\\theta - \\theta)\\) 为 \\(\\hat \\theta\\) 估计 \\(\\theta\\) 时的偏差 Thm：若 \\(D\\hat\\theta\\) 存在，则 \\(E(\\hat\\theta-\\theta)^2=D\\hat\\theta +b(\\theta)^2\\) Thm（Markov 不等式）\\(E|X|^k\\) 则对与任意的 \\(\\varepsilon&gt;0\\)，有\\(\\displaystyle P(|X|&gt;\\varepsilon)\\le \\frac{E|X|^k}{\\varepsilon^k}\\) Thm（相合性判定定理）若\\(\\lim D\\hat\\theta=\\lim b(\\theta)=\\lim E(\\hat\\theta-\\theta)=0\\) 则称 \\(\\hat\\theta\\) 是 \\(\\theta\\) 的相合估计量 例如：证明 \\(X_1,...\\) 是来自总体\\(N(\\mu,\\sigma^2)\\) 的容量为 n 的简单随机样本，则\\(S^2=\\frac1{n-1}\\sum(X_i-\\bar X)^2\\) 和 \\(B_2=\\frac1{n}\\sum(X_i-\\bar X)^2\\) 都是 \\(\\sigma\\) 的相合估计 Thm：用矩估计得到的估计量都具有相合性 区间估计 Def（置信区间）设 \\(X_1,...\\) 是来自总体\\(X\\) 容量为 n 的简单随机样本，\\(\\theta\\) 是一个参数，\\(\\hat\\theta_1,\\hat\\theta_2\\) 是两个统计量，若给定\\(\\alpha\\) 满足：\\(P(\\hat\\theta_1&lt;\\theta &lt; \\hat\\theta_2)=1-\\alpha\\) 则称区间 \\((\\hat\\theta_1,\\hat\\theta_2)\\) 是参数 \\(\\theta\\) 的置信度为 \\(1-\\alpha\\) 的区间估计，\\(\\hat\\theta_1,\\hat\\theta_2\\) 为置信区间的下限、上限。 对于离散型随机变量，若无法达到 \\(P=1-\\alpha\\) 则我们找到尽量接近的值使得\\(P\\ge 1-\\alpha\\) （已知 σ） 如何求参数 \\(\\theta\\) 的置信区间？若 \\(X\\sim N(\\mu,\\sigma^2)\\) \\(\\sigma^2\\) 已知，\\(\\mu\\) 未知，求 \\(\\mu\\) 置信水平为 1-α 的置信区间注意到：\\(\\displaystyle\\frac{\\barX-\\mu}{\\sigma/\\sqrt n}\\sim N(0,1)\\)则：\\(P(\\displaystyle|\\frac{\\barX-\\mu}{\\sigma/\\sqrt n}|&lt;z_{\\alpha/2})=1-\\alpha\\)即：\\(P(\\bar X-\\frac{\\sigma}{\\sqrtn}z_{\\alpha/2}&lt;\\mu&lt;\\bar X+\\frac{\\sigma}{\\sqrtn}z_{\\alpha/2})=1-\\alpha\\)，其中\\(z_{\\alpha}\\) 为上侧 α 分位点 置信区间越短 → 精度高 寻求样本和 \\(\\theta\\) 的函数 \\(W(X_1,...,X_n;\\theta)\\) 其分布不依赖于\\(\\alpha\\)和其他位置参数。（枢轴量）构造常数 \\(a,b\\) 使得 \\(P(a&lt;W&lt;b)=1-\\alpha\\)从中解出 \\(\\hat\\theta_1(X_1,...,X_n),\\hat\\theta_2(X_1,...,X_n)\\)得到置信区间 单个正态总体的置信区间 μ 的置信区间 \\(\\sigma^2\\) 已知，利用 \\(W=\\frac{\\bar X-\\mu}{\\sigma/\\sqrt n}\\sim N(0,1)\\) 置信区间为： \\[ \\left(\\bar X-\\frac{\\sigma}{\\sqrt n}z_{\\alpha/2},\\bar X+\\frac{\\sigma}{\\sqrt n}z_{\\alpha/2}\\right) \\] \\(\\sigma^2\\) 未知，利用 \\(W=\\frac{\\bar X-\\mu}{S/\\sqrt n}\\sim t(n-1)\\) \\[ \\left(\\bar{X}-\\frac{S}{\\sqrt{n}}t_{\\alpha/2} (n-1),\\bar{X}+\\frac{S}{\\sqrt{n}}t_{\\alpha/2} (n-1)\\right) \\] σ2 的置信区间 μ未知，利用 \\(\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)\\)，置信区间为： \\[ \\left(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)},\\frac{(n-1)S^2}{\\chi^2_{1-\\alpha/2}(n-1)}\\right) \\] μ已知，在上式 \\(S^2\\) 中用 \\(\\mu\\) 代替 \\(\\bar X\\) \\[ \\left(\\frac{\\sum (X_i-\\mu)^2}{\\chi^2_{\\alpha/2}(n-1)},\\frac{\\sum (X_i-\\mu)^2}{\\chi^2_{1-\\alpha/2}(n-1)}\\right) \\] 两个正态总体的均值差和方差比的置信区间 μ1-μ2 的置信区间 σ1, σ2 已知，利用： \\[ \\frac{\\bar X-\\bar Y-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{m}+\\frac{\\sigma_2^2}{n}}}\\sim N(0,1) \\] 则： \\[ \\left( \\bar X-\\bar Y -u_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{m}+\\frac{\\sigma_2^2}{n}},\\bar X-\\bar Y + u_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{m}+\\frac{\\sigma_2^2}{n}} \\right) \\] \\(\\sigma_1^2=\\sigma_2^2=\\sigma^2\\) 未知，利用： \\[ \\frac{\\bar X-\\bar Y-(\\mu_1-\\mu_2)}{S_w\\sqrt{\\frac{1}{m}+\\frac{1}{n}}}\\sim t(m+n-2) \\] 因而，置信区间为： \\[ \\left(\\bar X-\\bar Y-t_{\\frac{\\alpha}{2}}(m+n-2)S_w\\sqrt{\\frac{1}{m}+\\frac{1}{n}},\\bar X-\\bar Y+t_{\\frac{\\alpha}{2}}(m+n-2)S_w\\sqrt{\\frac{1}{m}+\\frac{1}{n}}\\right) \\] 两个正态总体方差比 σ12/σ22 的置信区间 μ1, μ2 未知，利用： \\[ \\frac{S_{1m}^2}{S^2_{2n}}\\frac{\\sigma_2^2}{\\sigma_1^2}\\sim F(m-1,n-1) \\] 置信区间为： \\[ \\left(\\frac{1}{F_{\\alpha/2}(m,n)}\\frac{n}{m}\\frac{\\sum(X_i-\\mu_1)^2}{\\sum(Y_i-\\mu_2)^2},\\frac{1}{F_{1-\\alpha/2}(m,n)}\\frac{n}{m}\\frac{\\sum(X_i-\\mu_1)^2}{\\sum(Y_i-\\mu_2)^2}\\right) \\] 同样的，用\\(S^2\\) 代替其中的 \\(\\sum (X_i-\\mu_1)^2\\)： μ1, μ2 已知，利用： \\[ \\frac{S_{1m}^2}{S_{2n}^2}\\frac{\\sigma_2^2}{\\sigma_1^2}\\sim F(m-1,n-1) \\] 有： \\[ \\left(\\frac{1}{F_{\\alpha/2}(m-1,n-1)}\\frac{n}{m}\\frac{S_{1m}^2}{S_{2n}^2},\\frac{1}{F_{1-\\alpha/2}(m-1,n-1)}\\frac{n}{m}\\frac{S_{1m}^2}{S_{2n}^2}\\right) \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「随机数学与数理统计」8 - 假设检验","slug":"study/Math/Probabilities/notes8","date":"2020-12-22T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/12/23/study/Math/Probabilities/notes8/","link":"","permalink":"http://adversarr.github.io/2020/12/23/study/Math/Probabilities/notes8/","excerpt":"假设检验","text":"假设检验 假设检验 假设检验的基本概念 假设检验的基本步骤： 建立假设： 在假设检验中，通常把一个被检验的假设称为原假设 \\(H_0\\)，将不应轻易加以否定的假设作为原假设。当 \\(H_0\\) 被拒绝时而接受的假设称为备择假设 \\(H_1\\)，它们常常成对出现。 例如：\\(H_0:\\theta \\ge 10,H_1:\\theta &lt; 10\\) 选择检验统计量，给出拒绝域形式 由样本对原假设进行判断总是通过一个统计量完成的，该统计量被称为检验统计量。使得原假设被拒绝的样本观测值所在的区域称为拒绝域 \\(W\\)。例如：\\(W=\\{(x_1,x_2,...,x_n):\\bar x \\le c\\}\\) 选择显著性水平 \\(\\alpha\\) 预先给定数 \\(\\alpha\\)（显著性水平），根据：\\(P(reject~H_0|H_0~right)\\le\\alpha\\) 给出拒绝域，确定显著性水平后，可以给出检验的拒绝域 \\(W\\) 做出判断 给出了观察值 \\(x_1,...,x_n\\) 若 \\((x_1,...,x_n)\\in W\\) 则拒绝 \\(H_0\\)；反之接受 \\(H_0\\) 两类错误： 第一类错误（\\(H_0\\) 成立，而样本满足拒绝域）的概率 \\(\\alpha\\) 第二类错误（\\(H_0\\) 不成立，而样本不满足拒绝域）的概率 \\(\\beta\\) 单个正态总体参数的假设检验 均值 μ 的检验 （σ 已知） 检验统计量：\\(\\displaystyle U=\\frac{\\bar x-\\mu_0}{\\sigma/\\sqrt n}\\) 双边检验：\\(H_0:\\mu=\\mu_0\\leftrightarrow H_1:\\mu\\ne\\mu_0\\) \\[ \\begin{aligned} &amp;U=\\frac{\\bar{X}-\\mu_0}{\\sigma/\\sqrt n}\\sim N(0,1)\\\\ &amp;P(reject~H_0|H_0~right)\\le \\alpha \\end{aligned} \\] \\(\\bar X\\) 为 \\(\\mu\\) 的无偏估计则：\\(\\displaystyle P(reject~H_0|H_0~right)=P(\\frac{|\\bar{X}-\\mu_0|}{\\sigma/\\sqrt n}\\ge \\frac{k}{\\sigma/\\sqrt n})\\) 拒绝域为： \\[ W=\\left\\{ (x_1,...,x_n)||\\bar x-\\mu_0|\\ge \\frac{\\sigma}{\\sqrt n}u_{\\alpha/2} \\right\\} \\] 单边右检验：\\(H_0:\\mu\\le \\mu_0\\) \\[ P(\\frac{\\bar X-\\mu_0}{\\sigma /\\sqrt n}\\ge \\frac{k}{\\sigma /\\sqrt n})\\le \\alpha \\] 拒绝域为： \\[ S=\\left\\{ (x_1,...,x_n)|\\bar x-\\mu_0 \\ge \\frac{\\sigma}{\\sqrt n}u_\\alpha \\right\\} \\] 单边左检验：\\(H_0:\\mu\\ge \\mu_0\\) 拒绝域为 \\(\\displaystyle S=\\left\\{ (x_1,...,x_n)|\\bar x-\\mu_0 \\le -\\frac{\\sigma}{\\sqrt n}u_\\alpha\\right\\}\\) 均值 μ 的检验 （σ 未知） 使用 t 检验法，将上述的 \\(\\sigma\\) 替换为 \\(S_n=\\sqrt{\\frac{1}{n-1}\\sum(x_i-\\bar x)^2}\\)，正态分布替换为自由度为 n-1 的 t - 分布，检验统计量为：\\(\\displaystyle T=\\frac{\\bar x-\\mu_0}{s_n/\\sqrt n}\\) 双侧检验，拒绝域为： \\[ W=\\left\\{ (x_1,...,x_n)||\\bar x-\\mu_0|\\ge \\frac{s_n}{\\sqrt n}t_{\\alpha/2}(n-1) \\right\\} \\] 单侧右检验，拒绝域为： \\[ S=\\left\\{ (x_1,...,x_n)|\\bar x-\\mu_0 \\ge \\frac{s_n}{\\sqrt n}t_\\alpha(n-1) \\right\\} \\] 单侧左检验，拒绝域为： \\[ S=\\left\\{ (x_1,...,x_n)|\\bar x-\\mu_0 \\le -\\frac{s_n}{\\sqrt n}t_\\alpha(n-1) \\right\\} \\] 方差 σ2 的检验 μ未知 利用： \\[ \\frac{(n-1)S_n^2}{\\sigma_0^2}\\sim \\chi^2(n-1) \\] μ已知 \\[ \\frac{\\sum(X_i-\\mu)^2}{\\sigma_0^2}\\sim\\chi^2(n) \\] Summary 情况 分布 σ已知 U~N(0,1) σ未知 T~t(n-1) μ已知 χ2~χ2(n) μ未知 χ2~χ2(n-1) 两个正态总体参数的假设检验 均值μ1，μ2的检验（σ12 σ22已知） 检验 \\(μ_1~\\underline{~~}~μ_2\\) \\[ U=\\frac{\\bar X-\\bar Y}{\\sqrt{\\sigma_1^2/m+\\sigma_2^2/n}}\\sim N(0,1) \\] 均值μ1，μ2的检验（σ12 σ22未知） \\[ T=\\frac{\\bar X-\\bar Y}{S_w\\sqrt{1/m+1/n}}\\sim t(m+n-2),\\\\ S_w=\\sqrt{\\frac{(m-1)S_{1m}^2+(n-1)S_{2n}^2}{m+n-2}} \\] \\(H_0\\) 拒绝域 \\(\\sigma_1, \\sigma_2\\) 已知 \\(\\mu_1 =\\mu_2\\) \\(abs(u)\\ge u_{\\alpha/2}\\) \\(\\mu_1 =\\mu_2\\) \\(u\\ge u_{\\alpha}\\) \\(\\mu_1 \\ge\\mu_2\\) \\(u\\le u_{1-\\alpha}=u_{-\\alpha}\\) \\(\\sigma_1, \\sigma_2\\) 未知 \\(\\mu_1=\\mu_2\\) \\(abs(t) \\ge t_{\\alpha/2}(m+n-2)\\) \\(\\mu_1\\le \\mu_2\\) \\(t\\ge t_\\alpha(m+n-2)\\) \\(\\mu_1\\ge \\mu_2\\) \\(t\\le -t_\\alpha(m+n-2)\\) 方差 σ12，σ22 的检验（μ1，μ2未知） 检验 \\(\\sigma_1^2 ~ \\mathrm{\\underline{~~~}} ~\\sigma_2^2\\) \\[ F=\\frac{S_{1m}^2}{S_{2n}^2}\\sim F(m-1, n-1) \\] 方差 σ12，σ22 的检验（μ1，μ2已知） \\[ F=\\frac{\\sum_{i=1}^m (x_i-\\mu_1)^2/m}{\\sum_{i=1}^n (y_i-\\mu_1)^2/n}\\sim F(m, n) \\] Summary: \\(H_0\\) 拒绝域 \\(\\mu_1,\\mu_2\\) 已知 \\(\\sigma_1^2=\\sigma_2^2\\) \\(f\\le F_{1-\\alpha/2}(m,n)\\) 或 \\(f\\ge F_{\\alpha/2}(m,n)\\) \\(\\sigma_1^2\\le \\sigma_2^2\\) \\(f\\ge F_\\alpha(m,n)\\) \\(\\sigma_1^2\\ge \\sigma_2^2\\) \\(f\\le F_{1-\\alpha}(m,n)\\) \\(\\mu_1,\\mu_2\\) 未知 \\(\\sigma_1^2=\\sigma_2^2\\) \\(f\\le F_{1-\\alpha/2}(m,n)\\) 或 \\(f\\ge F_{\\alpha/2}(m,n)\\) \\(\\sigma_1^2\\le \\sigma_2^2\\) \\(f\\ge F_\\alpha(m,n)\\) \\(\\sigma_1^2\\ge \\sigma_2^2\\) \\(f\\le F_{1-\\alpha}(m,n)\\) 总体分布的 χ2-拟合优度检验 理论分布完全已知 理论分布 F0 是取有限个值的离散分布 Thm（K · 皮尔逊）若假设 \\(H_0\\) 成立，则当样本容量 \\(n\\rightarrow \\infty\\) 时，则 $^2=_{i=1}^2 $ 渐进分布为 \\(\\chi^2(r-1)\\)。 若理论分布律为：\\(P(X=a_i)=p_i\\)，原假设可以写为：\\(H_0:P(X=a_i)=p_i\\)，\\(r\\) 为x取值的个数 使用： \\[ \\chi^2=\\sum_{i=1}^2\\frac{(\\gamma_i-np_i)^2}{np_i} \\] 拟合优度：\\(p(\\chi^2_0)=P(\\chi^2\\ge \\chi^2_0)\\) 利用：\\(\\chi^2=\\sum\\frac{(\\gamma_i-np_i)^2}{np_i}\\) 在 \\(n\\rightarrow \\infin\\) 时，其渐进分布为 \\(\\chi^2(r-1)\\) 当 \\(\\chi^2\\ge\\chi^2_\\alpha(r-1)\\) 则拒绝假设。 理想分布为一般情况 假设可以写为：\\(H_0:F(x)=F_0(x)\\) 选择常数，将区间分割成：\\((-\\infty, a_1],...,(a_{i-1},a_i],...,...(a_r-1,\\infty]\\) 计算 \\(p_i=F_0(a_i)-F_0(a_{i-1})\\) 计算统计量 \\(\\chi^2=\\sum\\frac{(\\gamma_i-np_i)^2}{np_i}\\) 计算出观察值 \\(\\chi^2\\) 若 \\(\\chi^2\\ge\\chi^2_\\alpha(r-1)\\) 则拒绝假设。 理论分布 F0 含有未知参数的情况 我们的假设为： \\[ H_0:F(x)=F_0(x:\\theta_1,...,\\theta_k)\\leftrightarrow H_0:F(x)\\ne F_0(x:\\theta_1,...,\\theta_k) \\] 使用最大似然估计确定参数 统计量 \\(\\chi^2=\\sum\\frac{(\\gamma_i-np_i)^2}{np_i}\\sim \\chi^2(r-k-1)\\) k 为未知参数个数 当 \\(\\chi^2\\ge\\chi^2_\\alpha(r-1)\\) 则拒绝假设。","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「概率统计与随机过程」 6 - 抽样分布","slug":"study/Math/Probabilities/notes6","date":"2020-12-17T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/12/18/study/Math/Probabilities/notes6/","link":"","permalink":"http://adversarr.github.io/2020/12/18/study/Math/Probabilities/notes6/","excerpt":"Chapter 6 抽样分布","text":"Chapter 6 抽样分布 抽样分布 基本概念 总体：在一个统计问题中，研究对象的全体。（所研究对象的某个（某些）数量指标的全体，一个随机变量（多维随机变量）记为 \\(X\\)） 样本： 分组样本 完全样本 Def（简单随机样本）设总体 \\(X\\) 的分布为 \\(F(X)\\)，\\(X_1, X_2,...,X_n\\) 是是相互独立和总体同分布的随机变量，则称其为来自总体 X 容量为 n 的简单随机样本。 性质： 样本联合分布函数为 \\(F(x_1,\\dots,x_n)=\\prod F(x_i)\\) 简单随机样本的联合分布律：\\(P(X_1=x^{(1)}, \\dots, X_n=x^{(n)})=\\prod P(X_i=x^{(i)})\\) 统计量 Def（统计量）设 \\(X_1, \\dots, X_n\\) 为取自总体的样本，若样本函数 \\(T=T(X_1, \\dots, X_n)\\) 不含有任何未知的参数。则称 \\(T\\) 为统计量。统计量的分布称为抽样分布。 例如： Def（样本均值）\\(\\bar X=\\frac{1}{n}\\sum_1^nX_i\\) 为样本均值 Def（样本方差）\\(S_n^2=\\frac{1}{n-1}\\sum_{i=1}^n(X_i-\\bar X)^2\\) 为样本方差。\\(S=\\sqrt{S_n^2}\\) 为样本标准差 Def（偏差平方和）：\\(\\sum(X_i-\\bar X)^2=\\sum X_i^2-\\frac{1}{n}(\\sum X_i)^2=\\sum X_i^2-n\\bar X^2\\) Def（原点矩、中心矩）\\(A_k=\\frac{1}{n}\\sum X_i^k,~B_k=\\frac{1}{n}\\sum (X_i-\\bar X)^k\\) Thm：对于总体 \\(X\\)，均值为 \\(\\mu=EX\\) 方差 \\(\\sigma^2\\) 都存在，\\(X_1,\\dots,X_n\\) 是来自总体容量为 \\(n\\) 的简单随机样本。则 - \\(E\\bar X=\\mu\\) - \\(D\\bar X=\\sigma^2/n\\) - \\(ES_n^2=\\sigma^2\\) 常用分布 卡方分布 Def：设\\(X_1,\\dots,X_n\\) iid，\\(N(0,1)\\) 的随机变量，则 \\(\\chi^2=\\sigma_{i=1}^nX_i^2\\) 服从自由度为 \\(n\\) 的 \\(\\chi^2\\)-分布。 Thm：\\(\\chi^2\\sim \\chi^2(n)\\) 则：\\(f(x)=\\frac{1}{2^{n/2}\\Gamma(n/2)}e^{n/2-1}e^{-x/2},~x&gt;0\\) Thm（可加性）若\\(X_1\\sim \\chi^2(n),~X_2\\sim \\chi^2(n)\\) 且 \\(X_1,X_2\\) 独立，则\\(X_1+X_2\\sim\\chi^2(m+n)\\) Thm（数字特征）若\\(X\\sim \\chi^2(m)\\) 则：\\(EX=n,DX=2n\\) Def（上侧 \\(\\alpha\\) 分位点）：\\(P(\\chi^2\\ge\\chi^2_\\alpha(n))=\\alpha\\) 则称 \\(\\chi^2(n)\\) 为自由度为 n 的 \\(\\chi^2\\)-分布的上侧\\(\\alpha\\)-分位点 t-分布 Def：\\(X\\) 是标准正态分布，\\(Y\\)服从自由度为 \\(n\\) 的 \\(\\chi^2\\) 分布且相互独立，称随机变量 \\(T=\\frac{X}{\\sqrt{Y/n}}\\) 服从自由度为 \\(n\\) 的 t-分布。 Thm：概率密度为 \\[ f(t)=\\frac{\\Gamma(\\frac{n+1}{2})}{\\Gamma(\\frac{n}{2})\\sqrt{n\\pi}}(1+\\frac{t^2}{n})^{-\\frac{n+1}{2}} \\] Def（分位点）上侧\\(\\alpha\\)-分位点 F-分布 \\(X\\sim \\chi^2(m),~Y\\sim\\chi^2(n)\\) idd. 称\\(F=\\frac{X/m}{Y/n}\\)服从自由度为 F-分布 Thm：密度函数、分位点 \\(F_{1-\\alpha}(m,n)=1/F_\\alpha(n,m)\\) 正态总体中统计量的分布 Thm（单个正态总体统计量的分布）：设\\(X\\) 服从正态 分布 \\(N(\\mu,\\sigma^2),X_1,\\dots,X_n\\) 是来自总体 \\(X\\) 容量为 \\(n\\) 的简单随机样本： \\(\\displaystyle U=\\frac{\\bar X-\\mu}{\\sigma/\\sqrt{n}}\\sim N(0,1)\\) \\(\\displaystyle\\bar X\\) 与 \\(S^2\\) 独立 \\(\\displaystyle W=\\frac{(n-1)S^2}{\\sigma^2}=\\sum (\\frac{X-\\bar X}{\\sigma})^2\\sim \\chi^2(n-1)\\) \\(\\displaystyle T=\\frac{\\bar X-\\mu}{S}\\sqrt{n}\\sim t(n-1)\\) Thm（两个正态总体统计量的分布）： \\(\\displaystyle\\frac{\\bar X-\\bar Y-(\\mu_1-\\mu_2)}{\\sqrt{\\sigma_1^2/m+\\sigma_2^2/n}}\\sim N(0,1)\\) \\(\\displaystyle\\frac{(m-1)S_{1m}^2}{\\sigma^2_1}+\\frac{(n-1)S_{2n}^2}{\\sigma^2_2}\\sim\\chi^2(m+n-2)\\) \\(\\displaystyle\\sigma_1=\\sigma_2=\\sigma\\) 则 \\(\\frac{\\bar X-\\bar Y-(\\mu_1-\\mu_2)}{S_\\omega\\sqrt{1/m+1/n}}\\sim t(m+n-2)\\) 其中 \\(S_\\omega=\\frac{(m-1)S_{1m}^2+(n-1)S_{2n}^2}{m+n-2}\\) \\(\\displaystyle\\frac{S_{1m}^2/\\sigma_1^2}{S^2_{2n}/\\sigma_2^2}\\sim F(m-1,n-1)\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「概率统计与随机过程」 10 - 马尔科夫链","slug":"study/Math/Probabilities/notes10","date":"2020-12-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/12/11/study/Math/Probabilities/notes10/","link":"","permalink":"http://adversarr.github.io/2020/12/11/study/Math/Probabilities/notes10/","excerpt":"马尔科夫链","text":"马尔科夫链 马尔科夫链 马尔科夫链的基本概念 Def（马尔科夫链）随机过程 \\(\\{X_n,n\\ge 0\\}\\) 如果满足如下条件： 状态空间 \\(I=\\{x_0, x_1, ..., x_n,...\\}\\) 为可数集 对于一切 \\(n\\ge 1\\) 和所有的 \\(x\\), \\(x_{i_0}, x_{i_1},...,x_{i_{n-1}}\\in I\\) 都有 \\[ P(X_n=x|X_0=x_{i_0},X_1=X_{i_1},...,X_{n-1}=x_{i_{n-1}})=P(X_n=x|X_{n-1}=x_{n-1}) \\] 则称 \\(\\{X_n,n\\ge 0\\}\\) 是马尔科夫链。 Def（n 步转移概率）设 \\(\\{X_n,n\\ge 0\\}\\) 是一个马尔科夫链，称 \\(p_{ij}(m,m+n)=P(X_{m+n}=j|X_m=i)\\) 为马氏链的 n 步转移概率（\\(\\forall i,j\\in I\\)）。 由 \\(p_{ij}(m,m+n)\\) 组成的矩阵 \\(P(m,m+n)=(p_{ij}(m,m+n))\\) 称为 \\(\\{X_n,n\\ge 0\\}\\) 的 n 步转移概率矩阵。 Def（齐次的马尔科夫链）设 \\(\\{X_n,n\\ge 0\\}\\) 为一马尔科夫链，如果对所有的 \\(m\\ge 0\\)，\\(n\\ge 1, i,j\\in I\\) 有 \\(P(X_{m+n}=j|X_m=i)=P(X_n=j|X_0=i)\\) 则称为齐次的马氏链。 此时，一步转移概率矩阵记为 \\(P=P(1)=(p_{ij})\\)。 Thm：若对于一切的 \\(n\\) 和 \\(i,j\\in I\\) 有： \\[ P(X_{n+1}=j|X_n=i)=P(X_1=j|X_0=i) \\] 则 \\(\\{X_n,n\\ge 0\\}\\) 是齐次的马氏链 Thm：齐次的马氏链的 \\(P(n)\\) 有： \\[ \\begin{cases} p_{ij}\\ge 0,\\\\ \\sum p_{ij}=1 \\end{cases} \\] 齐次马尔科夫链的有限维分布 Def（分布律）设 \\(\\{X_n,n\\ge0\\}\\) 是一个齐次的马尔科夫链，状态空间为 \\(I=\\{0,1,2,...\\}\\) 对于任意时刻 \\(n\\ge 0\\)，称离散型随机变量的分布律为齐次马氏链的一维分布律，记为 \\(\\mathbb p(n)=(p_0(n),....)\\) 当 \\(n=0\\) 时，称为初始分布律。 Thm：\\(p(n)=p(0)P(n)\\)，其中 \\(P(n)\\) 为多步转移概率矩阵。 多步转移概率的确定 Pre（条件的全概率公式）设随机事件 \\(A_1,...A_n,...\\) 构成完备事件组： \\[ \\bigcup_{i=1}^\\infty A_i=\\Omega,A_iA_j=\\varnothing \\] 则：\\(P(B|C)=\\sum_{i=1}^\\infty P(A_i|C)P(B|A_iC)\\) Thm：设 \\(\\{X_n,n\\ge 0\\}\\) 是齐次马尔科夫链，其状态空间为 \\(I=\\{0,1,...\\}\\) n 步转移矩阵为 \\(P(n)\\)。则对于任意时刻 \\(m,n\\ge 1\\)，有\\(P(m+n)=P(m)P(n)\\)（C-K 方程） 根据 C-K 方程：\\(P(n)=P^n\\) 遍历性 Def（极限分布）设 \\(\\{X_n,n\\ge 0\\}\\) 是齐次马氏链，状态空间为 \\(I=\\{0, 1,2,...\\}\\)，对于所有的 \\(i,j\\) 而言，n 步转移概率极限存在且与 \\(i\\) 无关， \\[ P(n)=P^n\\rightarrow^{n\\rightarrow\\infty}\\left[ \\begin{matrix} \\pi_0&amp;\\pi_1&amp;\\cdots&amp;\\pi_j&amp;\\cdots\\\\ \\pi_0&amp;\\pi_1&amp;\\cdots&amp;\\pi_j&amp;\\cdots\\\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ \\pi_0&amp;\\pi_1&amp;\\cdots&amp;\\pi_j&amp;\\cdots\\\\ \\vdots&amp;\\vdots&amp;&amp;\\vdots \\end{matrix} \\right] \\] 则称此链具有遍历性。 \\(P^n\\) 求法： 求出矩阵的特征值分解 \\(A=V\\Lambda V^{-1}\\) 求 \\(P^n\\) Thm：若 \\(\\{X_n,n\\ge 0\\}\\) 是齐次马氏链，一部转移概率为 \\(P\\) 若存在 n 步转移概率矩阵 \\(P(n)\\) 无零元，则此链具有遍历性，其极限分布 \\(\\pi\\) 是： \\[ \\pi P=\\pi \\] 满足归一性条件（\\(\\mathbf 1^T\\pi=1\\)）的唯一解。","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「概率统计与随机过程」 5 - 极限定理","slug":"study/Math/Probabilities/notes5","date":"2020-12-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/12/11/study/Math/Probabilities/notes5/","link":"","permalink":"http://adversarr.github.io/2020/12/11/study/Math/Probabilities/notes5/","excerpt":"极限定理","text":"极限定理 极限定理 大数定律 Def（依概率收敛）设 \\(X_1, X_2, X_3, ...\\) 为一随机变量序列，若存在随机变量 X，使得对于任意整数 \\(\\varepsilon &gt; 0\\) 总有: \\(\\lim_{n\\rightarrow \\infty} P(|X_n-X|\\ge \\varepsilon)=0\\) 则称随机变量序列 \\(\\\\{X_n\\\\}_{n\\ge 1}\\) 依概率收敛于 \\(X\\) \\(\\lim_{n\\rightarrow \\infty} X_n=X(P)\\) \\(X_n\\mathop\\longrightarrow\\limits^PX.\\) Def（大数定律）设 \\(X_1, X_2, \\dots\\) 为一随机变量序列，数学期望 \\(EX_n\\) 存在，记 \\(\\bar X = \\frac 1 n \\sum X_i\\) 若 \\(\\displaystyle\\lim_{n\\rightarrow\\infty}\\bar X_n=E\\bar X_n\\quad(P)\\)则称随机变量序列 \\(\\{X_n\\}\\) 服从大数定律，或者说大数法则成立 Thm（切比雪夫大数定律）设 \\(X_1, X_2, \\dots\\) 为一相互独立的随机变量序列，数学期望 \\(EX_n\\)，方差 \\(DX_n\\) 存在，且方差一致有界，则 \\(\\{X_n\\}\\) 服从大数定律，对于任意的 \\(\\varepsilon&gt;0,\\lim P(|\\frac 1 n \\sum X_i - \\frac 1 n \\sum EX_i|\\ge \\varepsilon)=0\\) Thm（辛钦大数定律）设 \\(X_i\\) 是独立同分布的随机变量序列，公共数学期望为\\(\\mu\\) 则其满足大数定律:\\(\\lim_{n\\rightarrow \\infty}P(|\\frac 1 n \\sum X_i-\\mu|\\ge \\varepsilon)=0\\) Thm（伯努利大数定律）设 \\(n_A\\) 是 \\(n\\) 次独立重复试验中 \\(A\\) 发生的次数，\\(p\\)为发生概率，则对于任意正数 \\(\\varepsilon &gt; 0\\) 有 \\(\\lim_{n\\rightarrow \\infty}P(|\\frac{n_A}{n}-p|&lt;\\varepsilon)=1\\) 中心极限定理 Def（中心极限定理）设 \\(X_i\\) 为相互独立的随机变量序列，数学期望 \\(EX_n=\\mu_n\\) 方差 \\(DX_n=\\sigma_n^2, n= 1, 2, ...\\)都存在，记： \\[B_n^2=\\sum_{i=1}^2\\sigma_i^2,\\quad Y_n=\\sum_{i=1}^n \\frac{X_i-\\mu_i}{B_n},\\quad n = 1,2,...\\] 则 \\(Y_n\\) 依概率收敛到标准正态分布 \\(N(0,1)\\)： \\[\\lim_{n\\rightarrow \\infty} P(Y_n\\le x)=\\lim_{n\\rightarrow \\infty}P(\\frac{(\\sum X_i-\\sum EX_i)}{\\sqrt{\\sum DX_i}}\\le x)=\\varPhi(x)\\] Thm（林德伯格定理）设 \\(X_1, X_2,...\\) 为相互独立的随机变量序列，且满足： \\[\\forall \\varepsilon,\\displaystyle\\lim _{n\\rightarrow \\infty}\\frac 1 {B_n^2}\\sum\\int_{|x-\\mu_k|\\ge \\varepsilon B_n}(x-\\mu_k)^2\\mathrm dF_k(x)=0\\] 其中 \\(F_k(x)\\) 为分布函数，\\(\\mu_k=EX_k,\\sigma_k^2=DX_k,B_n^2=\\sum \\sigma_k^2\\)，则 \\(\\{X_n\\}\\) 服从中心极限定理 Thm（列维-林德伯格定理）设 \\(X_1,...\\) 为相互独立同分布的随机变量序列，且 \\[EX_n=\\mu, DX_n=\\sigma^2&lt;+\\infty\\] 则随机变量序列 \\(\\{X_n\\}\\) 服从中心极限定理。 从而，\\(n\\) 充分大时：\\(\\displaystyle P(x_1&lt;\\sum X_i\\le x_2)\\approx\\varPhi(\\frac{x_2-n\\mu}{\\sigma\\sqrt n})-\\varPhi(\\frac{x_1-n\\mu}{\\sigma\\sqrt n})\\) Thm（棣莫弗-拉普拉斯中心极限定理）若 \\(\\mu_1, ...\\) 服从二项分布 \\(b(n,p),q=1-p\\) 则： \\[\\displaystyle\\lim_{n\\rightarrow \\infty}P(\\frac{\\mu_n-np}{\\sqrt{npq}}\\le x)=\\varPhi(x)\\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「概率统计与随机过程」 9 - 随机过程的基本概念","slug":"study/Math/Probabilities/notes9","date":"2020-12-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/12/11/study/Math/Probabilities/notes9/","link":"","permalink":"http://adversarr.github.io/2020/12/11/study/Math/Probabilities/notes9/","excerpt":":no_mouth:","text":":no_mouth: 随机过程 随机过程的基本概念 Def（随机过程）设 \\(\\Omega=\\{\\omega\\}\\) 是随机试验 \\(E\\) 的样本空间，\\(T\\subset (-\\inf,+\\inf)\\) 如果对于一个固定的 \\(t\\in T\\)，有定义在 \\(\\Omega\\) 上的随机变量，\\(X(\\omega,t),\\omega\\in \\Omega\\) ,令 \\(t\\) 在 \\(T\\) 中变动，得到依赖于 \\(t\\) 的一族随机变量 \\(\\{X(\\omega, t), t\\in T\\}\\) 称为随机过程。 有限维的分布函数族 Def（随机过程分布函数）\\(F(t; x)=P(X(t, w)\\le x)\\) 为 \\(X(t, w)\\) 的分布函数。（一维） Def（随机过程分布函数）\\(F(t _ 1,t _ 2...,t _ n; x _ 1, x _ 2,...,x _ n)=P(X(t_1, w)\\le x _ 1,X(t _ 2, w)\\le x _ 2,...)\\) 为 \\(X(t, w)\\) 的分布函数。 随机过程的数字特征 均值函数： \\[ m_X(t)=EX(t) \\] 均方值函数： \\[ \\varPsi^2(t)=EX^2(t) \\] 方差函数： \\[ D_X(t)=E(X(t)-m_X(t))^2 \\] 相关函数： \\[ R_X(s,t)=EX(s)X(t) \\] 协方差函数： \\[ \\begin{aligned} C_X(s,t)&amp;=Cov(X(s),X(t))\\\\ &amp;=R_X(s,t)-m_X(s)m_X(t) \\end{aligned} \\] 泊松过程和维纳过程 独立增量过程 Def（独立增量过程）设 \\(\\{X(t) ,t\\in T\\}\\) 是一个随机过程，对于任意的 \\(t_1,...,t_n\\) 增量 \\(X(t_2)-X(t_1) ...\\) 是独立的，则称 \\(X(t)\\) 是一个独立增量过程。 增量 \\(X(t+h)-X(t)\\) 的分布仅依赖于\\(h\\) 而不依赖于 t，则称 \\(X(t)\\) 是齐次的。 例如： \\(X_n\\) 是独立同分布的随机变量序列，部分和序列 \\(S_n=\\sum X_i\\) 是齐次的独立增量过程。 Thm：独立增量过程在 \\(P(X(0)=0)=1\\) 的条件下，\\(X(t)\\)的任意有限维分布函数族可以由增量 \\(X(t)-X(s)\\) 的分布唯一确定。 Thm：独立增量过程 \\(\\{X(t),t\\in T\\}\\) 的均值函数 \\(m_X(t)\\) 和方差函数 \\(X_X(t)\\) 存在，在 \\(P(X(0)=0)=1\\) 的条件下，其协方差函数： \\[ C_X(s,t)=D_X(min\\{s,t\\}). \\] 泊松过程 Def（泊松过程）设 \\(\\{N(t), t\\ge 0\\}\\) 表示 \\([0, t]\\) 内随机点发生的数目，\\(N(t)\\) 有以下性质，则称其为一个强度为 \\(\\lambda,\\lambda\\ge 0\\) 的泊松过程： 齐次性（平稳性） 独立增量性（无后效性） 普通性 \\(P(N(0)=0)=1\\) 泊松过程的有限维分布和数字特征 有限维分布：\\(\\{N(t) ,t\\ge 0\\}\\) 是一个强度为 \\(\\lambda\\) 的泊松过程，则 \\(N(t)\\) 的一维分布是参数为 \\(\\lambda t\\) 的泊松分布，即：\\(N(t)\\sim P(\\lambda t)\\) 数字特征： \\(m_N(t)=\\lambda t\\) \\(D_N(t)=\\lambda t\\) \\(C_N(s,t)=\\lambda \\min \\{s,t\\}\\) 设 \\(\\{N(t) ,t\\ge 0\\}\\) 是一个强度为 \\(\\lambda\\) 的泊松分布，则 \\(N(s)-N(t)\\) 是一个参数为 \\(\\lambda(s-t)\\) 的泊松分布 同时，我们把强度为 \\(\\lambda\\) 的泊松过程 \\(\\{N(t),t\\ge 0\\}\\) 中机点出现的时刻 \\(W_1,...,W_n,...\\) 为强度为 \\(\\lambda\\) 的泊松流。 记 \\(T_i=W_i-W_{i-1}\\) 其表示的第 \\(i-1\\) 个随机点与第 \\(i\\) 个随机点在时刻 \\(t_{i-1}\\) 出现的间隔时间。则 \\(T\\sim e(\\lambda)\\)，反之： Thm：如果任意相邻两个随机点出现的间隔时间相互独立同服从于参数为 \\(\\lambda\\) 的指数分布，则随机点流构成强度为 \\(\\lambda\\) 的泊松过程。 维纳过程 Def（维纳过程 / 布朗运动）随机过程满足如下条件： \\(W(0)=0\\) \\(W(t)\\) 是齐次增量过程 \\(t&gt;s\\ge0\\) 时，\\(W(t)-W(s)=h(X_{[s/\\delta]+1}+...+X_{[s/\\delta]})\\)是独立同分布的随机变量。 \\(EW(t)=0,t&gt;0\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「概率统计与随机过程」 4 - 随机向量的数字特征","slug":"study/Math/Probabilities/notes4","date":"2020-12-01T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/12/02/study/Math/Probabilities/notes4/","link":"","permalink":"http://adversarr.github.io/2020/12/02/study/Math/Probabilities/notes4/","excerpt":"随机向量的数字特征","text":"随机向量的数字特征 随机向量的数字特征 随机变量的数学期望 数学期望的定义 Def（离散型随机变量期望的定义）设离散随机变量的分布列为：\\(P(X=x_i)=p_i\\) 若级数 \\(\\sum x_ip_i\\) 绝对收敛，则称该级数为 \\(X\\) 的数学期望，记为 \\(E(X)=\\sum x_ip_i\\) 与项的排列顺序无关 有限个值 → 必然存在 连续型随机变量 Def（连续型随机变量期望的定义）设连续型随机变量，其密度函数为：\\(f(x)\\) 若积分 \\(\\int_{-\\infty}^\\infty xf(x)\\mathrm dx\\) 绝对收敛，则称该积分为 \\(X\\) 的数学期望，记为\\(E(X)=\\int_{-\\infty}^{+\\infty}xf(x)\\mathrm dx\\) 例如柯西分布：\\(F(x)=\\frac{1}{\\pi}(\\arctan x+\\frac{\\pi}{2})\\) 不存在数学期望 随机变量函数的数学期望 Thm：若 \\(Y\\) 是 \\(X\\) 的函数 \\(Y=g(X)\\)，绝对收敛的情况下： \\(E(Y)=\\sum g(x_i)P(X=x_i)\\) \\(E(Y)=\\int g(x)f(x)\\mathrm dx\\) Thm：若 \\(Z=g(X,Y)\\)，则： \\(Eg(X,Y)=\\sum\\sum g(x _ i,y _ j)p_{ij}\\) \\(Eg(X,Y)=\\iint g(x,y)f(x,y)\\mathrm dx\\mathrm dy\\) 期望的性质： \\(E(·)\\)是线性的：\\(E(aX+bY+c)=aEX+bEY+c\\) \\(X,Y\\) 独立 则：\\(E(XY) = E(X)E(Y)\\) 随机变量的方差 方差的定义 Def（方差）若随机变量 \\(X\\) 的数学期望存在，则 \\(E(X-EX)^2\\) 为 \\(X\\) 的方差随机变量偏离中心的程度 \\(DX=Var(X)=E(X-EX)^2\\) 标准差：\\(\\sigma(X)\\) 计算方法：\\(DX=EX^2-(EX)^2\\) 方差的性质 对于常数 c \\(Dc=0\\) \\(D(aX+b)=a^2DX\\) \\(X,Y\\) 独立，则 \\(D(X\\pm Y)=DX+DY\\) \\(D(\\sum c_iX_i)=\\sum c_i^2DX_i\\) \\(DX=E(X^2)-(EX)^2\\) \\(DX=0\\iff P(X=EX=c)=1\\) \\(X_i\\sim N(\\mu_i,\\sigma_i^2)\\) 则：\\(\\sum c_iX_i\\sim N(\\sum c_iu_i, \\sum c_i^2 \\sigma_i^2)\\) Thm 切比雪夫不等式：\\(\\forall\\varepsilon&gt;0, E(X)=\\mu,DX=\\sigma^2\\Rightarrow P(|X-\\mu|&gt;\\varepsilon)\\le \\sigma^2/\\varepsilon^2\\) 协方差与相关系数 定义 Def（协方差）设 \\(X，Y\\) 是两个随机变量，\\(E(X-EX)(Y-EY)\\) 存在，则\\(\\displaystyle Cov(x,y)=E(X-EX)(Y-EY)\\) Def（相关系数）\\(\\displaystyle\\rho_{XY}=\\frac{Cov(X,Y)}{\\sqrt{DX}\\sqrt{DY}}\\) Thm：\\(D(X\\pm Y)=DX+DY+2Cov(X,Y)\\) 推广至 n 个：\\(D(\\sum c_iX_i)=\\sum c_i^2DX_i+2\\sum c_ic_jCov(X_i,X_j)\\) 常用计算公式：\\(Cov(X,Y)=EXY-EX\\cdot EY\\) 性质 \\(Cov(X,Y)=Cov(Y,X)\\) \\(DX=Cov(X,X)\\) \\(Cov(X,const)=0\\) \\(Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)\\) \\(Cov(\\sum c_iX_i,Y)=\\sum c_i Cov(X_i,Y)\\) \\(Y_i=a_iX+b_i\\rightarrow \\rho_{Y_1Y_2}=\\frac{a_1a_2}{|a_1a_2|}\\rho_{X_1X_2}\\) \\(Y=aX+b\\rightarrow \\rho_{XY}=\\pm1\\) \\(|\\rho_{XY}|=1\\) 的充要条件为 \\(X\\) 与 \\(Y\\) 以概率 \\(1\\) 线性相关： 存在常数 \\(a,b,a\\ne0\\) 使得 \\(P(Y=aX+b)=1\\) 独立与不相关的关系 Def（不相关）：若\\(\\rho_{XY}=0\\) （\\(Cov(X,Y)=0\\)） 则称 \\(X,Y\\) 不相关。 Thm：相互独立 则 不相关 （反之不一定成立） 特殊的： 二维正态随机变量：相关\\(\\iff\\)独立\\(\\iff\\rho=0\\) \\((0-1)\\) 分布：相关\\(\\iff\\)独立\\(\\iff\\rho=0\\) 协方差矩阵 矩 Def（矩）若 \\(X,Y\\) 为随机变量 1. \\(\\alpha_k=EX^k\\) 称为 \\(X\\) 的 \\(k\\) 阶原点矩 \\(\\alpha_1=EX\\) \\(\\beta_k=E(X-EX)^k\\) 称为 \\(X\\) 的 \\(k\\) 阶中心矩 \\(\\beta_1=0,\\quad\\beta_2=DX\\) \\(k,l\\in N_+\\) 则 \\(\\gamma_{kl} = E(X-EX)^k(Y-EY)^l\\) 称为 \\(X\\) 与 \\(Y\\) 的 \\(k+l\\) 阶混合中心矩 \\(\\gamma_{11} = Cov(X,Y)\\) 协方差矩阵 Def（协方差矩阵）\\(\\mathbf X=(X_1,X_2,\\dots,X_n)^T\\) 为 n 维随机向量 \\(\\mu=(\\mu_1,\\mu_2,\\dots)^T\\) 为随机向量 \\(X\\) 的数学期望 \\(\\sigma^2=(\\sigma_1^2, \\sigma_2^2,\\dots)^T\\)为随机向量 \\(X\\) 的方差 协方差矩阵为： \\[ \\varSigma=\\left(\\begin{matrix} \\sigma_{11}&amp; \\sigma_{12}&amp;\\dots&amp; \\sigma_{1n}\\\\ \\sigma_{21}&amp; \\sigma_{22}&amp;\\dots&amp; \\sigma_{2n}\\\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ \\sigma_{n1}&amp; \\sigma_{n2}&amp;\\dots&amp; \\sigma_{nn}\\\\ \\end{matrix}\\right) \\] 性质 \\(\\mathbf{diag}\\varSigma=\\sigma^2\\) 半正定的对称阵，即\\(\\varSigma\\in S_+\\) \\(\\sigma^2_{ij}\\le \\sigma_{ii}\\sigma_{jj}\\) n 维正态分布：\\(f(\\mathbb{x})=\\frac{1}{(2\\pi)^{n/2}|\\sigma|^{1/2}}\\exp\\{-\\frac{1}{2} (x-\\mu)^T\\Sigma^{-1}(x-\\mu)\\}\\) Summary0 - 1 分布形式：\\(P(X=0)=1-p, P(X=1)=p\\)期望：\\(EX=p\\)方差：\\(DX=p(1-p)\\)二项分布 \\(b(n,p)\\)形式：\\(P(X=k) =C_n^kp^k(1-p)^k\\)期望：\\(EX=np\\)方差：\\(DX=np(1-p)\\)泊松分布 \\(P(\\lambda)\\)形式：\\(P(X=k)=\\frac{\\lambda^ke^{-\\lambda}}{k!}\\)期望：\\(EX=\\lambda\\)方差：\\(DX=\\lambda\\)超几何分布 \\(H(N,M,n)\\)-- not important形式：\\(P(X=k)=\\frac{C_M^kC_{N-M}^{N-k}}{C_N^n}\\)期望：\\(EX=nM/N\\)方差：\\(DX=\\frac{nM(N-n)(N-M)}{N^2(N-1)}\\)均匀分布 \\(U(a,b)\\)形式：\\(P(X=x) = 1/(b-a)\\quad if ~ ~ x \\in[a,b]\\)期望：\\(EX=\\frac{1}{2}(a+b)\\)方差：\\(DX=\\frac{(b-a)^2}{12}\\)指数分布 \\(e(\\lambda)\\)形式：\\(P(X=x)=\\lambda e^{-\\lambdax}\\)期望：\\(EX=1/\\lambda\\)方差：\\(DX=1/\\lambda^2\\)高斯分布（正态分布） \\(N(\\mu,\\sigma^2)\\)形式：\\(P(X=x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp[-\\frac{(x-\\mu)^2}{2\\sigma^2}]\\)期望：\\(EX=\\mu\\)方差：\\(DX=\\sigma^2\\)卡方分布 \\(\\chi^2(n)\\)形式（自由度为 n）：\\(\\chi^2=\\sum_{i=1}^nX_i^2,~X_i\\simN(0,1)\\)期望：\\(E\\chi^2=n\\)方差：\\(E\\chi^2=2n\\)t-分布形式（自由度为 n）：\\(T=\\frac{X}{\\sqrt{Y/n}},~X\\sim N(0,1),~Y\\sim\\chi^2(n)\\)F-分布形式（自由度为 m, n）：\\(F=\\frac{X/m}{Y/n},~X\\sim\\chi^2(m),~Y\\sim\\chi^2(n)\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「复变函数」","slug":"study/Math/ComplexFunctions/ch1","date":"2020-11-19T16:00:00.000Z","updated":"2022-03-03T04:30:41.746Z","comments":true,"path":"2020/11/20/study/Math/ComplexFunctions/ch1/","link":"","permalink":"http://adversarr.github.io/2020/11/20/study/Math/ComplexFunctions/ch1/","excerpt":"复数与复变函数","text":"复数与复变函数 Ch1 复数与复变函数 复数的概念与运算 复数的概念 Def（复数）\\((x,y)\\) -&gt; \\(z=x+iy,i^2=-1\\) \\(\\mathrm{Re}(z)\\) \\(\\mathrm{Im}(z)\\) 相等：实部虚部对应相等 复数的代数运算 加减 乘除 满足的运算规律： 交换 结合 分配 共轭复数 \\(\\bar z = x - iy\\) 共轭复数的性质： \\(z \\bar z = |z|\\) \\(\\overline{z_1\\pm z_2} = \\bar{z_1}\\pm\\bar{z_2}\\) \\(\\overline{z_1z_2} = \\bar{z_1}\\bar{z_2}\\) \\(z+\\bar z = \\mathrm{Re}(z)\\) \\((z-\\bar z)/i = \\mathrm{Im}(z)\\) 复数的几何表示 点表示：\\(z=x+iy\\leftrightarrow (x,y)\\) 复平面、实轴、虚轴 向量表示 三角表达：\\(z=r(\\cos\\theta+i\\sin \\theta)\\) 复数的模和辐角 模 \\(|z| = r = \\sqrt{x^2+y^2}\\) 辐角 \\(\\mathrm{Arg}~z = \\theta\\) 利用欧拉公式： \\(z = re^{i\\theta}\\) \\(z = 0\\) 辐角不确定 辐角的主值 \\(-\\pi&lt;\\theta_0\\le\\pi\\) 辐角主值计算： 求 \\(\\arctan \\frac y x\\) 求 \\(\\theta_0\\)，注意：\\(\\theta_0\\in(-\\pi,\\pi]\\) \\(\\mathrm{Arg}(z_1z_2)=\\mathrm{Arg}z_1+\\mathrm{Arg}z_2\\)\\(\\mathrm{Arg}(z_1/z_2)=\\mathrm{Arg}z_1-\\mathrm{Arg}z_2\\)注意这里指的是集合相等\\(|z_1z_2|=|z_1||z_2|\\)\\(|z_1/z_2|=|z_1|/|z_2|\\) 复数的乘幂和方根 复数的乘幂 \\[ \\begin{aligned} &amp;z=re^{i\\theta} = r(\\cos\\theta+i\\sin\\theta)\\\\ &amp;z^n = z\\cdot z\\cdot z\\cdot\\dots\\cdot z\\\\ &amp;z^n=re^{in\\theta}=r(\\cos n\\theta+i\\sin n\\theta) \\end{aligned} \\] Thm（棣莫弗公式）\\(|z|=r=1\\) 时：\\((\\cos \\theta+i\\sin \\theta)^n=\\cos n\\theta + i \\sin n\\theta\\) 复数的方根 \\[ \\begin{aligned} &amp;z=re^{i\\theta} = r(\\cos\\theta+i\\sin\\theta)\\\\ &amp;\\sqrt[n]z= \\sqrt[n]r(\\cos\\frac{\\theta + 2k\\pi}n+i\\sin\\frac{\\theta + 2k\\pi}n)\\\\ \\end{aligned} \\] 复数在几何上的应用举例 求解：\\(z^n=1\\) 复数表示复平面上的过\\(z_1,~z_2\\)的直线方程：\\(z-z_1=t(z_2-z_1)\\) 复数表示圆方程：\\(|z-z_0| = R\\) 中垂线：\\(|z-z_1|=|z-z_2|\\)特殊直线：\\(\\mathrm{Im}(i+z)=4\\) 复球面与无穷远点 引入无穷远点，表达复数：扩充复平面 复变函数的极限与连续性 复平面上的区域 区域的概念 Def（开集）所有点都是集合的内点 Def（区域）连通的开集 开集：\\(\\forall z\\in A,\\exists U(z)\\subset A\\)，即\\(\\mathrm{int}A = A\\) 内点、外点、边界点 连通：折线连接 单连通、复连通（用闭曲线包围部分是否都在原集合内定义） \\(z_0\\) 的 \\(\\delta\\) 邻域 去心邻域 同理定义 \\(\\infin\\)的邻域和去心邻域 简单曲线、单连通、多连通 简单曲线： 连续 导函数连续，且 \\((x&#39;)^2+(y&#39;)^2 \\ne 0\\) 不相交（没有重点）：\\(t_1=t_2\\Leftrightarrow z(t_1)=z(t_2)\\) 连通区域： 单连通 多连通 复变函数的概念 Def（复变函数）可以是多值的 映射下的象和原象 复变函数的集合表示 复变函数的极限和连续性 Def（极限） Thm：设\\(f\\)在\\(z_0\\)的某个去心领域有定义，则： \\[ \\lim f(z) = A\\iff \\begin{cases} \\lim u = \\mathrm{Re}(A)\\\\ \\lim v = \\mathrm{Im}(A) \\end{cases} \\] 极限的性质： 唯一性 局部有界性 有理运算法则 Def（连续、在区域内连续） Thm：\\(f\\) 在 \\(z_0\\) 连续. \\(\\iff\\) \\(u\\)，\\(v\\) 在 \\((x_0,y_0)\\) 同时连续 有理运算不改变连续性 函数复合不改变连续性","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"「复变函数」复变函数的导数和解析函数","slug":"study/Math/ComplexFunctions/ch2","date":"2020-11-19T16:00:00.000Z","updated":"2022-03-03T04:30:41.745Z","comments":true,"path":"2020/11/20/study/Math/ComplexFunctions/ch2/","link":"","permalink":"http://adversarr.github.io/2020/11/20/study/Math/ComplexFunctions/ch2/","excerpt":"复变函数的导数和解析函数","text":"复变函数的导数和解析函数 Ch2 复变函数的导数和解析函数 解析函数的概念及其判定 复变函数的导数、微分 Def：复变函数的导数、可导、在 D 内可导 求导公式：有理运算求导、反函数求导 复变函数的可微性： Def（可微）\\(\\mathrm dw=f&#39;(z_0)\\Delta z\\) Thm：可微 \\(\\iff\\) 可导 Thm（可导的必要条件）C-R 方程： \\[ \\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y}, \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}, \\] Thm（可导的充要条件） \\(u,~v\\) 在\\((x,y)\\)可微 \\(u,~v\\) 在\\((x,y)\\)满足 C-R 方程 解析函数 Def（解析、在区域D内解析）在 \\(z_0\\in C\\) 及其某个邻域内处处可导--&gt;解析 Thm 设函数 \\(f(z)=u(x,y)+iv(x,y)\\) 定义在区域 D 内，若它的任意一点 \\(z\\in D\\) 可导，则必有 \\(u,v\\) 偏导数在 \\((x,y)\\) 出存在 满足 C-R 方程 Inference：在上述定理的条件下，\\(f(z)\\) 在点 \\(z\\) 处的导数为 \\[ f&#39;(z)=\\frac{\\partial u}{\\partial x}+i\\frac{\\partial v}{\\partial x}= \\frac{1}{i}\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial y} \\] Thm：在区域 D 内解析 \\(\\iff\\) \\(u,~v\\) 在 D 可微 \\(u,~v\\) 在 D 内任一点处满足 C-R 条件 解析函数和调和函数 若二元实函数在D内由二阶连续偏导数，且满足Laplace方程\\(\\displaystyle\\frac{\\partial^2\\varphi}{\\partial x^2}+\\frac{\\partial^2\\varphi}{\\partial y^2} = 0\\)，则称其为D内的调和函数。 Thm：\\(f\\)解析，则\\(u,~v\\) 是 D 内的调和函数 Def（共轭调和函数）解析函数的虚部 \\(v\\) 称为实部 \\(u\\) 的共轭调和函数。 \\(f = v+iu\\)不一定解析。 基本初等函数 指数函数 \\(\\displaystyle w = e^z = e^x(\\cos y + i \\sin y)\\) 性质： \\(|e^z| = e^x, Arg~e^z = y+2k\\pi\\) 加法定理：\\(e^{z_1}e^{z_2}=e^{z_1+z_2}\\) 周期性：\\(e^{z+2k\\pi i} = e^z\\) 处处解析：\\((e^z)&#39;=e^z\\) \\(y = 0\\Rightarrow w = e^x\\)\\(x = 0\\Rightarrow w = e^{iy}=\\cos y+i\\siny\\) 对数函数 \\(\\displaystyle w=\\mathrm{Ln} z = \\ln |z| + i \\mathrm{Arg}z =\\ln |z| + i (\\mathrm{arg}z + 2k\\pi)\\) 性质： \\(\\mathrm{Ln}z\\) 为无穷多值函数 \\(\\mathrm{Ln}(-1) = (2k+1)\\pi i\\) 运算同 \\(\\ln\\) 解析性：除原点和负实轴外的其他点处解析 （对数函数）主值：\\(\\ln z\\) 连续（解析）分支：使得其成为连续（解析）函数。 这里就是选取一个合适的 \\(k\\) 幂函数 \\(w = z^\\alpha = e^{a\\mathrm{Ln} z}\\) 可能是多值函数：考虑\\(\\alpha\\)对于\\(\\mathrm{Ln}z = \\ln|z| +i(\\arg~z+2k\\pi)\\) 中 \\(k\\) 的影响 \\(\\alpha\\) 是整数：单值函数 \\(\\alpha = p/q\\) 是有理数：取\\(k = 0,1,2,\\dots,q-1\\)的\\(q\\)个值 其他：无穷多个 \\(\\mathrm{Ln}z = \\ln z\\) 时，\\(z^\\alpha = e^{\\alpha \\ln z}\\) 称为（幂函数的）主值 解析性：除原点和负实轴外的其他点处解析 三角函数 \\(\\sin z = \\frac{e^{iz}-e^{iz}}{2i},\\qquad\\cos z = \\frac{e^{iz}+e^{-iz}}{2}\\) 以 \\(2\\pi\\) 为周期 三角恒等式成立 在复平面上处处解析 没有有界性 复数的欧拉公式 \\(e^{iz} = \\cos z + i\\sin z\\) 成立 \\(\\sin z\\) 的零点为 \\(z= k\\pi\\) \\(\\cos z\\) 的零点为 \\(z = k\\pi + \\frac{\\pi}{2}\\) 双曲函数 \\(\\sh z=\\frac{e^z-e^{-z}}{2},\\qquad\\ch z=\\frac{e^z+e^{-z}}{2}\\) 周期性、奇偶性、解析性 反三角函数、反双曲函数 \\[ \\begin{cases} \\mathrm{Arccos}~z =-i\\mathrm{Ln}(z+\\sqrt{z^2-1})\\\\ \\mathrm{Arcsin}~z =-i\\mathrm{Ln}(iz+\\sqrt{1-z^2})\\\\ \\mathrm{Arch}~z =\\mathrm{Ln}(z+\\sqrt{z^2+1})\\\\ \\mathrm{Arsh}~z =\\mathrm{Ln}(z+\\sqrt{z^2-1})\\\\ \\end{cases} \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"「复变函数」复变函数积分","slug":"study/Math/ComplexFunctions/ch3","date":"2020-11-19T16:00:00.000Z","updated":"2022-03-03T04:30:41.708Z","comments":true,"path":"2020/11/20/study/Math/ComplexFunctions/ch3/","link":"","permalink":"http://adversarr.github.io/2020/11/20/study/Math/ComplexFunctions/ch3/","excerpt":"复变函数的积分","text":"复变函数的积分 复变函数的积分 复变函数积分的概念及其计算 Def（复变函数的积分）同实函数定义：分割求和 \\(\\displaystyle\\int_C f(z)\\mathrm dz = \\lim \\limits_{\\delta \\rightarrow 0}\\sum f(\\gamma_k)\\delta z_k\\) Thm：设 \\(f(z)\\) 是区域 \\(D\\) 内的连续函数，则复变函数 \\(f(z)\\) 沿 \\(D\\) 内简单光滑有向曲线 \\(C\\) 的积分一定存在，且公式 \\(\\int f(z)\\mathrm dz=\\int u\\mathrm dx-v\\mathrm dy + i\\int v\\mathrm dx+u\\mathrm dy\\) 成立 性质： \\(\\displaystyle\\int_Lf\\mathrm dz=\\int_{L_1}f\\mathrm dz+\\int_{L_2}f(z)\\mathrm dz\\) 方向性 线性性质 （积分估值不等式）\\(\\displaystyle|\\int_Lf\\mathrm dz| \\le \\int_L|f||\\mathrm dz|\\le MS\\) 计算方法——参数方程法： \\(\\displaystyle let~z=x(t) + iy(t)\\rightarrow \\int_Lf\\mathrm dz=\\int f(z(t)) z&#39;(t)\\mathrm dt\\) 例： \\[\\displaystyle\\oint_L\\frac{1}{(z-z_0)^n}\\mathrm dz= \\begin{cases}2\\pi i,&amp;n=1,\\\\0,&amp;n\\ne 1.\\end{cases}\\] 其中 \\(L\\) 为圆 利用：\\(z-z_0=\\rho\\cdot e^{i\\theta}\\)，并且注意方向！（\\(\\theta\\)的积分方向上） 柯西-古萨基本定理及其推广 Thm（Cauchy 积分定理）若 \\(f(z) = u(x,y)+iv(x,y)\\)在单连通域 \\(D\\) 内解析，\\(f&#39;\\) 连续且\\(u,v\\) 有一节连续偏导数，满足 \\(C-R\\) 方程。则对于任一分段光滑的简单闭曲线 \\(L_ 1\\) 有 \\[ \\displaystyle \\int _ {L _ 1} f(z)\\mathrm dz = 0 \\] Thm：若 \\(f\\) 在单连通区域 \\(B\\) 内处处解析，那么 \\(f\\) 沿着任何 \\(B\\) 内的闭曲线的积分等于 0 Thm：\\(f(z)\\) 在单连通域 \\(D\\) 内解析，\\(f&#39;\\) 在 \\(D\\) 内连续时，复积分 \\(\\displaystyle \\int _Lf(z)\\mathrm dz\\) 与路径无关 复合闭路定理 Thm：设 \\(f(z)\\) 在单连通域 \\(D\\) 内解析，对于 \\(D\\) 内任一分段光滑的闭曲线 \\(L _ 1\\)：\\(\\displaystyle\\int _{L_1} f(z)\\mathrm dz = 0\\) Thm（复合闭路定理）设 \\(L, L_k\\) 为n+1条取逆时针方向的简单闭曲线，\\(L_k\\) 互不相交，互不包含，\\(L, L_k\\) 围成复连通域\\(D\\)，\\(f(z)\\) 在\\(\\bar D\\) 上解析，则： \\[\\displaystyle\\oint_Lf(z)\\mathrm dz = \\sum_{k=1}^n\\oint_{L_k}f(z) \\mathrm dz\\] 注意曲线的性质：简单闭曲线、闭曲线 例 \\[\\displaystyle\\oint_L\\frac{1}{(z-z_0)^n}\\mathrm dz= \\begin{cases}2\\pi i,&amp;n=1,\\\\0,&amp;n\\ne 1.\\end{cases}\\] 其中 \\(L\\) 为圆 利用：\\(z-z_0=\\rho\\cdot e^{i\\theta}\\)，并且注意方向！（\\(\\theta\\)的积分方向） 利用复合闭路定理：\\(L\\) 可以为任意包含\\(z_0\\)的闭曲线。 Thm：闭路变形定理 重要结论： \\[ \\oint_L\\frac{1}{(z-z_0)^n}\\mathrm dz= \\begin{cases}2\\pi i,&amp;n=1,\\\\0,&amp;n\\ne 1,n\\in \\mathrm Z.\\end{cases} \\] 原函数与不定积分 Thm：设 \\(f(z)\\) 在单连通域 \\(D\\) 内解析，则复函数 \\(F(z)=\\int_{z_0}^zf(z)\\mathrm dz\\) 在 \\(D\\) 内解析，且 \\(F&#39;=f\\) Def（原函数）若存在\\(\\Phi(z),\\forall z\\in D,\\Phi &#39;(z)=f(z)\\) 称 \\(\\Phi(z)\\) 为 \\(f(z)\\) 在 \\(D\\) 内的一个原函数 性质： 单连通域 \\(D\\) 内的解析函数存在原函数 表示全体原函数的表达式：\\(\\int f(z)\\mathrm dz\\)称为\\(f\\)的不定积分 Thm：对于解析函数 \\(f\\)，\\(\\Phi(z)\\) 是其原函数，则\\(\\int_{z_1}^{z_2}=\\Phi(z_2)-\\Phi(z_1)\\) 柯西积分公式、高阶导数公式 Thm（Cauchy积分公式）\\(f(z)\\) 在 \\(D\\) 和 \\(D\\) 的边界上解析，则 \\(\\forall z\\in D, f(z) = \\frac{1}{2\\pi i}\\oint_L\\frac{f(\\varsigma)}{\\varsigma - z}\\mathrm d \\varsigma\\) Thm（解析函数的平均值公式）\\(\\displaystyle L:|z-z_0|=R\\Rightarrow f(z_0) = \\frac{1}{2\\pi}\\int_0^{2\\pi}f(z_0+Re^{i\\theta})\\mathrm d\\theta\\) Thm（高阶导数公式）设 \\(f\\) 在 \\(D\\) 及其边界上解析，则\\(f\\)在D内有任意阶导数，且\\(\\forall z\\in D\\),\\(\\displaystyle f^{(n)}(z) = \\frac{n!}{2\\pi i}\\oint_L\\frac{f(\\varsigma)}{(\\varsigma-z)^{n+1}}\\mathrm d\\varsigma\\) 不等式 Thm（柯西不等式）设 \\(f\\) 在 \\(D\\) 内解析，\\(z_0\\in D\\)，圆周 \\(K_R\\) 及其内部均含于 \\(D\\)，则\\(|f^{(n)}(z_0)|\\le \\frac{n! M(R)}{R^n}\\)，\\(M(R) = \\max_{|z-z_0|=R}|f(z)|\\) Thm（柳维尔定理）\\(f(z)\\) 在整个复平面上解析且有界，则 \\(f(z)\\) 在复平面上恒为常数。 Thm（莫雷拉定理）\\(f(z)\\) 在单连通区域 \\(D\\) 内解析且有界，且对于任一简单闭曲线\\(L\\)上：\\(\\int_Lf(z)\\mathrm dz =0\\)，则\\(f(z)\\) 在 \\(D\\) 内解析。","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"「概率统计与随机过程」 1 - 随机事件及其概率","slug":"study/Math/Probabilities/notes1","date":"2020-11-17T16:00:00.000Z","updated":"2022-03-03T04:30:43.596Z","comments":true,"path":"2020/11/18/study/Math/Probabilities/notes1/","link":"","permalink":"http://adversarr.github.io/2020/11/18/study/Math/Probabilities/notes1/","excerpt":"随机事件及其概率","text":"随机事件及其概率 随机事件及其概率 随机事件 Def：样本空间 Def：随机事件 随机事件的概率 事件的概率 Def：频率 Thm：频率满足 \\(0\\le f_n(A)\\le 1\\) \\(f_n(\\varOmega)=1\\) 互不相容的随机事件，\\(f_n(\\cup A_i)=\\sum f_n(A_i)\\) 概率的公理化定义 Def：设\\(E\\)是随机试验，\\(\\varOmega\\) 是 \\(E\\) 的样本空间，对于每一个随机事件，赋予唯一的实数\\(P(A)\\)，满足：非负性、规范性、可列可加性，则称集合函数\\(P(\\cdot)\\)为概率测度。 Thms 不可能事件的概率为 0 有限可加性：不相容的随机事件，和的概率等于概率的和 对立事件的概率：\\(P(\\bar A)=1-P(A)\\) 概率的加法公式：\\(P(A+B)=P(A)+P(B)-P(AB)\\) 概率的减法公式：若 A 包含 B，\\(P(A-B)=P(A)-P(B)\\) 概率的单调性：若 A 包含于 B，\\(P(A)\\le P(B)\\) 古典概型 Def：一个古典概型 \\(E\\) 满足： 样本空间只有有限个基本事件 每个基本事件出现可能性相同 条件概率 条件概率的定义 Def：（有穷划分）设 \\(\\varOmega\\) 是随机试验 \\(E\\) 的样本空间，\\(A_1,A_2,\\dots, A_n\\) 是随机事件，若满足： 1. \\(A_iA_j = \\emptyset,~\\forall i\\ne j\\) 2. \\(\\cup A_j = \\varOmega\\) 则称\\(A_1,A_2,\\dots, A_n\\) 是\\(\\varOmega\\) 的一个有穷划分。 相同定义 可列无穷划分 Def（条件概率）设 \\(A,B\\) 是两个随机事件，\\(P(B)&gt;0\\) 则称 \\(P(A|B)=P(AB)/P(B)\\) 为事件 \\(B\\) 发生条件下，事件 \\(A\\) 发生的概率 概率的乘法公式 Thm：设 \\(A_1, ...,A_n\\) 为 n 个随机事件，且 \\(P(\\bigcap A_i)&gt;0\\)，则 \\(P(\\bigcap A_i)=P(A_1)P(A_2|A_1)...P(A_n|\\bigcap_{i=1}^{n-1}A_i)\\) 全概率公式和贝叶斯公式 Thm（全概率公式）设随机事件组是 \\(\\varOmega\\) 的一组可列无穷划分 \\(P(A_i) &gt; 0,\\forall i\\)，则对于任意随机事件 \\(B\\)，有：\\(P(B) = \\sum P(A_i)P(B|A_i)\\) Thm（Bayes 公式）设\\(A_1, A_2,\\dots\\) 是样本空间\\(\\varOmega\\) 的一组可列无穷划分，\\(P&gt;0,B\\subset \\varOmega\\) 则： \\[ P(A_i|B) = \\frac{P(A_i)P(B|A_i)}{\\sum P(A_i)P(B|A_i)}, i = 1, 2,\\dots \\] 随机事件的独立性 两个随机事件的独立性 Def（独立性）设\\(A,B\\)是两个随机事件，若：\\(P(AB) = P(A)P(B)\\)则称 \\(A, B\\) 是两个相互独立的随机事件 \\(\\varOmega,~\\emptyset\\) 与任一事件相互独立 Thm：\\(P(A),P(B)&gt;0\\) 时 \\(A,B独立\\iff P(A|B)=P(A), P(B|A)=P(B)\\) Thm（独立扩张定理）\\(A,B独立\\iff \\bar A,B~A,\\bar B~ \\bar A,\\bar B 独立\\) 多个随机事件的独立性 Def：三个独立的随机事件，满足： \\[ \\begin{cases} 两两独立\\\\ P(ABC) = P(A)P(B)P(C) \\end{cases} \\] Def（n 个事件的独立性） 独立的多个随机事件满足： \\(P(\\cap A_i) = \\prod P(A_i)\\) \\(P(\\cup A_i) = 1 - \\prod[1-P(A_i)]\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「概率统计与随机过程」 3 - 随机向量及其概率分布","slug":"study/Math/Probabilities/notes3","date":"2020-11-17T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/11/18/study/Math/Probabilities/notes3/","link":"","permalink":"http://adversarr.github.io/2020/11/18/study/Math/Probabilities/notes3/","excerpt":"随机向量及其概率分布","text":"随机向量及其概率分布 随机向量及其概率分布 二维随机向量的联合分布 Def（二维随机向量）假设 \\(\\Omega = \\{\\omega\\}\\) 是随机试验 E 的样本空间，\\(X(\\omega),~Y(\\omega)\\) 是定义在\\(\\Omega\\) 上的两个随机变量，由他们构成一个二维向量\\((X,Y)\\)称为随机试验 E 的一个二维向量。 Def（二维随机变量的联合分布函数）假设\\((X,Y)\\)是二维随机向量，对于任意实数\\(x,y\\)，二元函数\\(F(x,y)=P(X\\le x,Y\\le y)\\) 称为二维随机向量\\((X,Y)\\) 的联合分布函数（分布函数）。 联合分布函数的性质： \\(0\\le F\\le 1\\) \\(F\\) 是变量 \\(x,~y\\) 的不降函数。 右连续性 \\(\\forall x_1&lt;x_2, y_ 1 &lt; y _ 2:~P(x\\\\_1\\le X \\le x\\\\_2,y\\\\_1\\le X \\le y\\\\_2) = F(x\\\\_2,y\\\\_2) +F(x\\\\_1, y\\\\_1) - F(x\\\\_1,y\\\\_2) - F(x\\\\_2, y\\\\_1)\\ge0\\) 二维离散型随机向量 Def（二维离散型随机向量）若随机向量 \\((X,Y)\\) 最多取可列无穷多个点 \\((x_i, y_j), i, j\\in \\mathrm N\\)，则称 \\(P(X=x_i,Y=y_j)=p_{ij}\\) 为 \\((X,Y)\\) 的联合分布律。 表格表示： X\\Y y1 ... x1 p11 ... ... ... ... Def（离散型随机向量的联合分布律）\\(F(x,y) = \\sum_{y_j\\le y} \\sum_{x_j\\le x} p_{ij}\\) \\(p_{ij}\\ge 0\\) \\(\\sum_{j=1}^\\infty \\sum p{ij}=1\\) 二维随机连续向量 Def（连续型随机向量）\\(F(x,y)\\) 是二维随机向量\\((X, Y)\\) 的联合分布函数，若存在非负可积函数 \\(f(x,y)\\) ，有 \\(F(x,y)=\\int_{-\\infty}^y\\int_{-\\infty}^0\\) 则称\\((X,Y)\\) 的二维连续型随机向量，\\(f(x,y)\\) 称为概率密度函数（PDF） 相关性质： 1. 非负性 2. 规范性 3. \\(f(x,y) =\\frac{\\partial^2}{\\partial x\\partial y}F(x,y)\\) 4. \\(P((X,Y)\\in G) = \\iint_G f\\mathrm dx \\mathrm dy\\) 二维连续型随机向量 Def（二维连续型随机向量的联合概率密度函数）设 \\(F(x,y)\\) 是二维随机向量 \\((X,Y)\\) 的联合分布函数，若存在非负可积函数 \\(f(x,y)\\) 有，\\(F(x,y)=\\int\\int f(x,y)dxdy\\) 则称 \\((X,Y)\\) 为二维连续性随机向量 \\(f\\) 为密度函数 例： 二维均匀分布： 面积为 \\(A\\) 若 \\((X,Y)\\) 具有概率密度：\\(f(x,y) = 1/A~if~(x,y)\\in G~else~0\\) 二维正态分布 \\[f(x,y) = \\frac{1}{2\\pi \\sigma_1\\sigma_1\\sqrt{1-\\rho^2}}\\exp\\{-\\frac{1}{2(1-\\rho^2)}[\\frac{(x-\\mu_1)^2}{\\sigma_1^2}-2\\rho\\frac{(x-\\mu_1)(y-\\mu_2)}{\\sigma_1\\sigma_2}+\\frac{(y-\\mu)2)^2}{\\sigma_2^2} ]\\}\\] 边缘分布 Def（边缘分布函数）假设二维随机向量\\((X,Y)\\) 的联合概率分布函数 \\(F(x,y)\\)，令\\(F_1(x) = F(x,+\\infty),F_2(y) = F(+\\infty, y)\\)为关于 \\(X\\) 和 \\(Y\\) 的边缘分布函数 Thm：二维随机向量的联合分布函数为 \\(F(x,y)\\)，分布函数为 \\(F_X, F_Y\\)，则 \\(F_X(x) = F_1(x),~F_Y(y) = F_2(y)\\) 离散型-边缘分布律 ： \\(\\displaystyle F_X(x) = \\sum_{x_i\\le x}\\sum p_{ij}\\) \\(P(X = x_i) = \\sum_{j=1}^\\infty p_{ij},~P(X = x_j) = \\sum_{i=1}^\\infty p_{ij}\\) \\(p_{i\\cdot}=P(X=x_i),~p_{\\cdot j}=P(Y=y_j)\\) 连续型-边缘分布密度 根据 \\(F_X(x) = F(x, +\\infty) = \\int_{-\\infty}^x\\int_{-\\infty}^{+\\infty}f(x,y)\\mathrm dy\\mathrm dx=\\int_{-\\infty}^{x}f_1(x)\\mathrm dx\\) \\(f_X(x) = \\int_{-\\infty}^\\infty f(x,y)\\mathrm dy\\) \\(f_Y(Y) = \\int_{-\\infty}^\\infty f(x,y)\\mathrm dx\\) 条件概率 Def：(条件分布函数）假设\\(X,~Y\\) 是两个随机变量， 若对于固定的 \\(x\\) 有 \\(P(X=x)\\ge 0\\) 则对于任意的 \\(y\\in R\\) 称：\\(P(Y\\le y|X=x)=\\frac{P(X=x, Y\\le y)}{P(X = x)}\\) 为 \\(X = x\\) 条件下，\\(Y\\) 的条件分布函数，记为 \\(F_{Y|X}(y|x)\\) 若对于固定的 \\(y\\) 有 \\(P(Y=y)\\ge 0\\) 则对于任意的 \\(x\\in R\\) 称：\\(P(X\\le x|Y=y)=\\frac{P(Y=y, X\\le x)}{P(Y = y)}\\) 为 \\(Y = y\\) 条件下，\\(X\\) 的条件分布函数，记为 \\(F_{Y|X}(x|y)\\) 连续型随机变量的条件分布函数：对于连续型随机变量，考虑极限： \\(\\displaystyle\\lim_{\\Delta x\\rightarrow 0}\\frac{P(x-\\Delta x&lt; X\\le x,Y\\le y)}{P(x-\\Delta x &lt; X\\le x)}=\\frac{\\int_{-\\infty}^yf(x,y)\\mathrm dy}{f_X(x)}~-\\infty &lt; y &lt; +\\infty\\) 离散型随机变量的条件分布律 设 \\((X,Y)\\) 是二维离散型随机变量，联合分布律为\\(P(X=x_i,Y=y_j)=p_{ij},~i,j=1,2,\\dots\\) 可知：\\(P(Y=y_j|X=x_i)=\\displaystyle\\frac{p_{ij}}{p_{i\\cdot}}\\) 类似地，条件分布律为：\\(\\displaystyle F_{Y|X} (y|x) = \\frac{\\sum_{y_j\\le y}P_{ij}}{p_{i\\cdot}}\\) 连续型随机变量的条件分布、条件分布密度 设二维连续型随机变量\\((X,Y)\\) 的连续概率密度函数为\\(f(x,y)\\) 对于固定的 \\(x\\)，\\((X,Y)\\) 关于边缘概率密度 \\(f_X(x)&gt;0\\) 则在\\(X=x\\)条件下，\\(Y\\) 的条件分布函数： \\(\\displaystyle\\lim_{\\Delta x\\rightarrow 0}\\frac{P(x-\\Delta x&lt; X\\le x,Y\\le y)}{P(x-\\Delta x &lt; X\\le x)}=\\frac{\\int_{-\\infty}^yf(x,y)\\mathrm dy}{f_X(x)}=\\int_{-\\infty}^y\\frac{f(x,y)}{f_X(x)}\\mathrm dy=\\int_{-\\infty}^yf_{Y|X}(y|x)\\mathrm dy\\) 则，条件分布密度为： \\[ \\displaystyle f_{X|Y}(x|y)=\\frac{f(x,y)}{f_Y(y)}\\\\ \\displaystyle f_{Y|X}(y|x)=\\frac{f(x,y)}{f_X(x)} \\] 类似于乘法公式：\\(f_{X,Y}(x,y)=f_Y(y)f_{X|Y}(x|y)\\) 随机变量的独立性 随机变量 X Y 独立是指：与 X 相关的任一事件发生与否与 Y 有关的任一事件发生与否无关。 Def（随机变量间的独立性）设随机向量的联合分布函数为\\(F(x,y)\\)，而\\(F_X(x),F_Y(y)\\) 分别为随机变量 X, Y 的分布函数，若 \\(\\forall (x,y)\\in R^2, F(x,y)=F_X(x)F_Y(y)\\) 则 X Y 相互独立 Thm：若\\((X,Y)\\) 为二维离散型随机向量，其联合分布律为：\\(P(X=x_i,Y=y_i)=p_{ij}\\) 则 X Y 相互独立的充要条件是 \\(\\forall (x_i,y_i),p_{ij}=P(X=x_i)P(Y=y_j)\\) Thm：若\\((X,Y)\\) 为二维连续型随机向量，其联合概率密度函数为：\\(f(x,y)\\) 则 X Y 相互独立的充要条件是 \\(\\forall (x,y),f(x,y) = f_X(x)f_Y(y)\\) 例 正态变量 \\((X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)\\) \\(\\rho\\)：相关系数 独立 \\(\\iff\\rho=0\\) 矩形区域的均匀分布 → 独立 若联合密度 \\(f(x,y)\\) 可分离变量，即 \\(f(x,y)=g(x)h(y)\\) 且定义域互不影响，则 \\(X\\) 与 \\(Y\\) 相互独立。 独立 → 条件分布与边缘分布相同。 n 维随机向量 Def（联合分布）n维随机向量的联合分布 Def（概率分布律） Def（联合概率密度函数）\\(F=\\int\\int\\dots\\int f\\) Thm：规范性 Def（k维边缘分布）\\(F_{X_1,..,X_k}=F(X_1, ..,X_k,+\\infty,+\\infty,...,+\\infty)\\) Def（1维边缘分布、密度函数） Def（条件分布） Def（n维随机向量的独立性）\\(F(x_1,x_2,...,x_n)=\\Pi F_{X_i}\\) Def（独立性）X，Y独立，则\\(\\bar X,S^2, \\bar Y,S^2\\)独立 随机向量函数的分布 课程中主要考虑： \\(Z=g(X,Y)=X+Y\\) \\(Z=XY\\) \\(Z=Z/Y\\) \\(Z=\\min\\{X,Y\\}~(or~\\max\\{X,Y\\})\\) \\(Z=\\sqrt{X^2+Y^2}\\) 二维离散型随机向量函数的分布 \\[ P(Z=z_k)=\\sum_{Z=z_k}P(X=x_i,Y=y_i) \\] 例如，一些分布的可加性： \\(X\\sim P(\\lambda_1),Y\\sim P(\\lambda_2)\\) 且独立，则 \\(X+Y\\sim P(\\lambda_1+\\lambda_2)\\) \\(X\\sim b(n,p),Y\\sim b(m,p)\\) 且独立，则 \\(X+Y\\sim b(n+m,p)\\) Thm（离散场合的卷积公式）通常的：X，Y 独立，则对于\\(Z=X+Y\\)，有\\(\\displaystyle P(Z=z_i)=\\sum_{j=1}^\\infty P(x=z_j-y_j)P(Y=y_j)\\) 二维连续型随机向量函数的分布密度 review: \\(x\\sim f(x)\\) 求 \\(Y=h(X)\\) 密度：\\(F_X(y)=P(h(x)\\le y) = \\int f(y)\\mathrm dy\\) solution: \\(F_Z(z)=P(Z\\le z)=\\iint_{g(x,y)\\le z} f(x,y)\\mathrm dx\\mathrm dy\\) z=x+y \\[ \\begin{aligned} F(z)&amp;=P(X+Y\\le Z)&amp;\\\\ &amp;=\\int_{-\\infty}^{+\\infty}\\int^{z-y}_{-\\infty} f(x,y)\\mathrm dx\\mathrm dy\\\\ \\Rightarrow\\qquad&amp; p(z) = \\int_{-\\infty}^{+\\infty} p(x,z-x)\\mathrm dx = \\int_{-\\infty}^{+\\infty} p(z-y, y)\\mathrm dy \\end{aligned} \\] Thm（卷积公式）X，Y 相互独立，则对于\\(Z=X+Y\\)：\\(p_Z(z)=\\int_{-\\infty}^{+\\infty}p(x)p(z-x)\\mathrm dx=\\int_{-\\infty}^{+\\infty}p(z-y)p(y)\\mathrm dy\\) 正态分布具有可加性：\\(X_1\\sim N(\\mu_1, \\sigma_1), X_2\\sim N(\\mu_2,\\sigma_2),...\\) 则 \\(\\sum c_iX_i\\sim N(\\sum c_i\\mu_i,\\sum c_i^2\\sigma_i^2)\\) \\(\\Gamma\\) 函数与卡方分布 \\(X\\sim\\chi(n) = P(n/2, 1/2)\\)，\\(x_1...x_n~\\sim N(0,1)\\)，\\(\\sum x_i^2\\sim \\chi(n)\\) \\(X,Y\\sim \\Gamma(\\alpha_{1,2},\\beta)\\rightarrow X+Y\\sim\\Gamma(\\alpha_1+\\alpha_2,\\beta)\\) 一般步骤 先求出分布函数 关于 z 求导数得到结果 最大值最小值函数 相互独立情况下： \\[ \\begin{aligned} &amp;N=\\min\\{X_i\\}, M = \\max\\{X_i\\}\\\\ &amp;F_{\\min}(z)=1-\\Pi[1-F_{X_i}(z)]\\\\ &amp;F_{\\max}(z)=\\Pi F_{X_i}(z) \\end{aligned} \\] 独立同分布的情况下： \\[ \\begin{aligned} &amp;F_{\\min}(z)=1-[1-F(z)]^n\\\\ &amp;F_{\\max}(z)=F(z)^n\\\\ &amp;f_{\\min}(z) =n[1-F(z)]^{n-1} f(z)\\\\ &amp;f_{\\max}(z) =nF(z)^{n-1} f(z) \\end{aligned} \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"「概率统计与随机过程」 2 - 随机变量及其概率分布","slug":"study/Math/Probabilities/notes2","date":"2020-11-17T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/11/18/study/Math/Probabilities/notes2/","link":"","permalink":"http://adversarr.github.io/2020/11/18/study/Math/Probabilities/notes2/","excerpt":"随机变量及其概率分布","text":"随机变量及其概率分布 随机变量及其概率分布 随机变量 Def：设 \\(E\\) 时一个随机试验，\\(\\varOmega\\) 是其样本空间，如果对于每一个试验的结果 \\(\\omega\\in \\varOmega\\)，由唯一的实数\\(X(\\omega)\\)与之对应，这个定义在试验样本空间上的实值函数\\(X(\\omega)\\)称为\\(E\\)的随机变量。 随机变量的分布函数 Def（随机变量的分布函数）设 \\(X(\\omega)\\)是随机变量，称 \\(F(x) = P(X\\le x),~-\\infty&lt;x&lt;\\infty\\) Thm：一些定义 \\(P(x_1 &lt; X\\le x_2) = F(x_2) - F(x_1)\\) \\(P(x_1\\le X&lt; x2) = F(x_2-0) - F(x_1-0)\\) \\(P(x_1 &lt; X&lt; x2) = F(x_2-0) - F(x_1)\\) \\(P(x_1\\le X\\le x2) = F(x_2) - F(x_1-0)\\) Thm：分布函数的性质 \\(0\\le F(x) \\le 1\\) 单调不降 右连续函数：\\(F(x+0)=F(x)\\) 有可数个间断点 离散型随机变量 离散型随机变量的分布律 Def（概率函数）设离散随机变量\\(X\\)可能取得一切之为 \\(x_1, x_2,\\dots, x_n\\) 称为 \\(X\\) 分布律（列），也称为 \\(X\\) 的概率函数。 分布律也可以用表格的形式表示： |X|x1|x2|x3|...| |---|---|---|---|---| |P|p1|p2|p3|...| \\(X\\) 的分布函数 \\(F(x) = \\sum\\limits_{x_k\\le x} p_k\\) 常见的离散分布 0 - 1 分布 Def：\\(0 - 1\\)分布：\\(X\\) 只取 \\(0\\) 和 \\(1\\) 两个值，且\\(P(X=1)=p,~P(X=0)=1-p\\)，则称 \\(X\\) 服从 \\((0-1)\\) 分布。 二项分布 Def：n次独立试验概型 伯努利试验只有两个可能结果，\\(A,~\\bar A\\)，且\\(P(A)=p\\) - \\(n\\) 重伯努利试验是指将试验独立重复 \\(n\\) 次。 - \\(X\\) 表示 \\(n\\) 重伯努利试验中事件 \\(A\\) 发生的次数 称随机变量\\(X\\)服从参数为\\(n,~p\\) 的二项分布，\\(X\\sim B(n,p)\\) - \\(P(X=k) = C_n^k p^k (1-p)^{n-k}\\) Thm：\\(X\\)是伯努利试验中\\(A\\)发生的次数，\\(p\\)是每次试验中 \\(A\\) 发生的概率，则 \\(X\\sim b(n,p)\\) Def：最可能成功次数\\(k = \\lfloor (n+1)p \\rfloor~(n+1)p不是整数\\) 泊松分布 Def（泊松分布）\\(\\displaystyle P(X=k) = \\frac{\\lambda^ke^{-\\lambda}}{k!},~X\\sim P(\\lambda)\\) Thm（泊松定理）设 \\(\\lambda &gt;0\\)是一个常数，\\(n\\) 是任意正整数，设\\(np_n=\\lambda\\)。则对于任意固定的非负整数\\(k\\)有 \\(\\displaystyle\\lim_{n\\rightarrow \\infty}C_n^kp_n^k(1-p_n)^{n-k}=\\frac{\\lambda^ke^{-\\lambda}}{k!}\\) 几何分布 \\(\\displaystyle P(X=k) = q^{k-1} p, k=1,2,\\dots\\) 超几何分布 \\(\\displaystyle P(X=k) = \\frac{C_M^k\\cdot C_{N-M}^{n-k}}{C_N^n}, k = 0, 1, 2, \\dots, l=\\min\\{n,M\\}\\) \\(X\\sim H(N,M,n)\\) 负二项分布** \\(\\displaystyle P(X=k) = C_{k-1}^{r-1}p^r(1-p)^{k-r}\\) - \\(X\\sim Nb(r,p)\\) 连续型随机变量 Def（连续性随机变量）\\(F(x) = \\int_{-\\infty}^xf(x)\\mathrm dx,-\\infty &lt; x &lt; \\infty\\) - 其中\\(f(x)\\) 是非负可积函数，称为\\(X\\)的概率分布密度函数（概率密度函数Probability Density Function） - 规范性：\\(\\displaystyle\\int_R f(x) \\mathrm dx =1\\) - \\(P(x&lt; X \\le x+\\Delta x)\\approx f(x)\\Delta x\\) - 连续性，\\(F(-\\infty) = 0\\)，\\(F(\\infty)=1\\) Def（累积分布函数）\\(\\displaystyle P(a&lt;X\\le b) = \\int_a^bf(x)\\mathrm dx\\) 均匀分布 \\[ f(x)=\\begin{cases} \\displaystyle\\frac{1}{b-a},&amp;a\\le x\\le b,\\\\ 0,&amp;otherwise \\end{cases}\\\\ \\\\ F(x) = P(X\\le x) = \\begin{cases} 0,&amp;x &lt; a\\\\ \\displaystyle\\frac{x-a}{b-a}, &amp;a\\le x \\le b\\\\ 1, &amp;x&gt;b \\end{cases} \\] \\(X\\sim U[a,b]\\) 指数分布 \\[ f(x) = \\begin{cases} \\lambda e^{-\\lambda x}, &amp;x&gt;0\\\\ 0, &amp; x\\le 0 \\end{cases} \\\\ F(x) = \\begin{cases} 1- e^{-\\lambda x}, &amp;x&gt;0\\\\ 0, &amp;x\\le 0 \\end{cases} \\] \\(X\\sim e(\\lambda)\\) 正态分布 Def：\\(\\displaystyle f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\) - \\(X\\sim N(\\mu, \\sigma^2)\\) - \\(\\mu\\) 为位置参数，\\(\\sigma\\) 为尺度参数 - 关于\\(\\mu\\)对称，最大值 - \\(\\sigma\\)固定，形状保持不变 - 拐点为：\\(x=\\mu\\pm\\sigma\\) - \\(erf(x)=F(x)= \\int_{-\\infty}^{x}\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\mathrm dx\\) - \\(3\\sigma,~6\\sigma\\)理论 Def（标准正态分布）\\(N(0,1)\\) \\(\\mu = 0, \\sigma = 1\\) 的正态分布称为标准正态分布 密度函数和分布函数通常用 \\(\\varphi(x),\\Phi(x)\\) 表示 \\(\\Phi(0)=0.5,~\\Phi(-x) = 1-\\Phi(x)\\) \\[ \\begin{aligned} &amp;\\varphi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{\\frac{-x^2}{2}}\\\\ &amp;\\Phi(x) = \\int_{-\\infty}^x\\varphi(x)\\mathrm dx \\end{aligned} \\] Thm（一般正态分布的标准化）：若\\(X\\sim N(\\mu, \\sigma^2)\\)，则\\(U=\\frac{X-\\mu}{\\sigma}\\sim N(0,1)\\) Def：（\\(\\alpha\\)分位点）\\(P(X&gt;\\mu_\\alpha) = \\alpha,\\quad0&lt;\\alpha&lt;1\\) 随机变量函数的分布 已知离散随机变量X的分布，求函数 Y = g(X) 的分布 \\[ P(Y=y_j) = P(g(X)=y_j) = \\sum_{\\{x_k|g(x_k) = y_j\\}}P(X=x_k), j = 1, 2, \\dots, \\] 离散型均匀分布： \\[ Y = [NX+1],\\quad where~X\\sim U(0, 1) \\] 一致连续型随机变量X的概率密度，求 g(X) 的概率密度 分布函数法 Key Point：\\(F_Y(y)=P(Y\\le y)=P(g(x)\\le y)=\\displaystyle\\int_{\\{x|g(x)&lt;y\\}}f_X(x)\\mathrm dx\\) \\[ Y = aX+b\\Rightarrow f_Y(y)=\\frac{\\mathrm d}{\\mathrm dy}F_Y(y) =\\begin{cases} \\frac 1 a f_X(\\frac{y-b}{a}),&amp;a&gt;0\\\\ -\\frac{1}{a} f_X(\\frac{y-b}{a}),&amp;a&lt;0\\\\ \\end{cases} \\] 「例」：\\(X\\sim N(0,1),~Y=X^2\\) \\[ f_Y(y) = F&#39;_Y(y) =\\begin{cases} \\frac{1}{\\sqrt{2\\pi y}}e^{-\\frac{y}{2}},&amp; y&gt;0\\\\ 0,&amp;y\\le 0 \\end{cases} \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"数学在计算机图形学中的应用","slug":"CG/Application_of_math _in_CG","date":"2020-09-25T16:00:00.000Z","updated":"2022-04-10T06:45:09.975Z","comments":true,"path":"2020/09/26/CG/Application_of_math _in_CG/","link":"","permalink":"http://adversarr.github.io/2020/09/26/CG/Application_of_math%20_in_CG/","excerpt":"摘抄自 http://staff.ustc.edu.cn/~lgliu 老板～捞捞～","text":"摘抄自 http://staff.ustc.edu.cn/~lgliu 老板～捞捞～ 【注】 本文由Greg Turk. “Mathematics for Computer Graphics, August 1997.” 及网上的中文翻译整理及扩充而得。 “学习计算机图形学需要多少的数学？”这是初学者最经常问的问题。狭义的计算机图形学指的是传统的三维建模，绘制，动画等，而广义的计算机图形学还包括计算机图像处理，视频处理，计算机视觉和机器学习等 交叉领域。 答案取决于你想在计算机图形学领域钻研多深： 如果仅仅使用周围唾手可得的图形软件，如Photoshop, 3D Studio Max, Maya, AutoCAD, Rhino (Grasshoper)等，你不需要知道多少数学知识；通过掌握简单的概念和阅读使用教程你就能使用这些软件的基本功能；但是如果你想精通这些软件，你还是需要学习计算机图形学的一些入门知识的； 如果想学习计算机图形学的入门知识，你至少需要掌握数学分析（微积分）、线性代数和解析几何学的一些基本知识（这些都是大学一年级所学的数学知识）；这也是要成为图形软件高手所必需掌握的； 如果想成为一名计算机图形学的研究工作者，那么对数学的学习将是“活到老，学到老”。重要的是，从以前看似枯燥的数学到看到它的实际应用的过程中，你会更容易享受数学的美妙。在你不断进行计算机图形学的研究的过程中，你会感觉到你的数学知识越来越不够用，从而真正理解“数学不是没有用，而是不够用！” 如果你并不特别喜欢数学，是否仍有在计算机图形学领域工作的机会？是的，计算机图形学的确有一些方面不需要考虑太多的数学问题。你不应该因为数学成绩不好而放弃它，如果你对计算机图形学具有强烈兴趣和好奇心的话，而且你还特别喜欢和擅长计算机编程的话。不过，如果学习了更多的数学知识，那么你将在研究课题上有更多的选择余地。如果你要做很好的计算机图形学的研究工作，则建议你还是多学习些数学。 对于在计算机图形学中哪些数学才是重要的？这个问题是没有明确的答案的。这领域里不同的方面要求掌握不同的数学知识，也许兴趣将会决定了你的方向。那些基本的数学知识和分析能力是最重要的，而其他的数学则是根据你所从事的方向相关。 下面将介绍我们认为对于计算机图形学有用的数学。别以为想成为一名计算机图形学的研究者就必须精通各门数学！在大学里，你所学的那些数学看起来都很抽象，枯燥无味，这是因为你并不知道它们的用处，甚至连讲课的老师也不知道，而你们的目的只是记住那些定理和公式，考个好分数。与大学学习数学不一样的是，你在计算机图形学的学习和研究过程中会感受到数学的用处和美妙，这时你学习数学的目的将更加明确，兴趣将更加浓厚，学习方法将更加有效。因为你是在使用数学的过程中在学习数学！想想看你是如何学会中文说话的？为了对用于计算机图形学的数学有一个全面的看法，这里特地列出了很多方面。注意，不是这里提到的每个方面你都必须熟悉，许多研究工作者从不需要考虑下面提到的某些数学知识，成功的研究者总是将某一方面的数学知识和数学工具用到极致！ 最后，虽然读了这篇文章后，你应该会对数学在计算机图形学中的应用有所了解，不过这也是一家之言。也许你应该阅读更多的此类文章，或者至少从其他从事计算机图形学工作的人那里了解不同的学习重点。 初等代数和三角学 对于计算机图形学的初学者来说，高中的代数和三角学可能是最重要的数学。日复一日，我从简单的方程解出一个或更多的根。我时常还要解决类似求一些几何图形边长的简单三角学问题。代数和三角学是计算机图形学的最基础的知识。 那么高中的几何学怎么样呢？可能让人惊讶，不过在多数计算机图形学里，高中的几何学并不经常被用到。原因是许多学校教的几何学实际上是如何建立数学证明的课程。虽然证明题对提高智力显然是有效的，但对于计算机图形学来说，那些与几何课有关的定理和证明并不常被用到。如果你毕业于数学相关领域（包括计算机图形学），就会发现虽然你在证明定理，不过这对开始学习图形学不是必要的。 如果精通代数和三角学，就可以开始读一本计算机图形学的入门书了。下一个重要的用于计算机图形学的数学——线性代数，多数此类书籍至少包含了一个对线性代数的简要介绍。 推荐的参考书: Computer Graphics: Principles and Practice James Foley, Andries van Dam, Steven Feiner, John Hughes Addison-Wesley 线性代数 线性代数的思想贯穿于计算机图形学。事实上，只要牵涉到几何数值表示法，就常常抽象出例如x,y,z坐标之类的数值，我们称之为矢量。计算机图形学自始至终离不开矢量和矩阵。用矢量和矩阵来描述旋转，平移，或者缩放是再好不过了。高中和大学都有线性代数的课程。只要想在计算机图形学领域工作，就应该打下坚实的线性代数基础。我刚才提到，许多图形学的书都有关于线性代数的简要介绍——足够教给你图形学的第一门课。 数学分析（微积分学） 微积分学是高级计算机图形学的重要成分。如果打算学习研究图形学，我强烈建议你应该对微积分学有初步认识。理由不仅仅是微积分学是一种很有用的工具，还有许多研究者用微积分学的术语来描述他们的问题和解决办法。另外，在许多重要的数学领域，微积分学被作为进一步学习的前提。学习了基本代数之后，微积分学又是一种能为你打开多数计算机图形学与后继的数学学习之门的课程。 最优化 在计算机图形学里，我们常常为了期望的目标寻求一种合适的描述对象或者对象集的方法。例如安排灯的位置使得房间的照明看起来有种特殊的“感觉”，动画里的人物要怎样活动四肢才能实现一个特殊的动作，怎样排版才不会使页面混乱。以上这些例子可以归结为最优化问题。十年前的计算机图形学几乎没有最优化技术的文献，不过最近这个领域越来越重视最优化理论。我认为在计算机图形学里，最优化的重要性非常重要。 微分几何 微分几何学研究描述和控制光滑曲线，曲面的方程。如果你要计算出经过某个远离曲面的点并垂直于曲面的矢量（法向矢量）就会用到微分几何学。让一辆汽车以特定速度在曲线上行驶也牵涉到微分几何学。有一种通用的绘制光滑曲面的图形学技术，叫做“凹凸帖图”，这个技术用到了微分几何学。另外，要研究曲面的一些几何性质，如曲率、可展性、测地性质等，需要较多的微分几何知识。如果要着手于用曲线和曲面来创造形体（在图形学里称之为建模），你至少应该学习微分几何学的基础。 数值方法（计算方法） 几乎任何时候，我们在计算机里用近似值代替精确值来表示和操作数值，所以计算过程总是会有误差。而且对于给定的数值问题，常常有多种解决的方法，一些方法会更块，更精确或者对内存的需求更少。数值方法研究的对象包括“计算方法”和“科学计算”等等。这是一个很广阔的领域，而且我将提及的其他几门数学其实是数值方法的一些分支。这些分支包括抽样法理论，矩阵方程组，数值微分方程组和最优化。 推荐的参考书: Numerical Recipes in C++: The Art of Scientific Computing William Press, Saul Teukolsky, William Vetterling and Brian Flannery Cambridge University Press 抽样法理论和信号处理 在计算机图形学里我们反复使用储存在正规二维数组里的数字集合来表示一些对象，例如图片和曲面。这时，我们就要用抽样法来表示这些对象。如果要控制这些对象的品质，抽样法理论就变得尤为重要。抽样法应用于图形学的常见例子是当物体被绘制在屏幕上时，它的轮廓呈现锯齿状的边缘。这锯齿状的边缘（被认为是“混淆”现象）是非常让人分散注意力的，用抽样法中著名的技术例如回旋，傅立叶变换，空间和频率的函数表示就能把这个现象减少到最小。这些思想在图像和音频处理领域是同样重要的。 推荐的参考书: The Fourier Transform and Its Applications Ronald N. Bracewell McGraw Hill 矩阵计算 计算机图形学的许多问题要用到矩阵方程组的数值解法。一些涉及矩阵的问题包括：找出最好的位置与方向以使对象们互相匹配（最小二乘法），创建一个覆盖所给点集的曲面，并使皱折程度最小（薄板样条算法），还有材质模拟，例如水和衣服等。在图形学里矩阵表述相当流行，因此在用于图形学的数学中我对矩阵方程组的评价是很高的。 推荐的参考书: Matrix Computations Gene Golub and Charles Van Loan Johns Hopkins University Press 物理学（物理模拟） 物理学显然不是数学的分支，它是自成一家的学科。但是在计算机图形学的某些领域，物理学和数学是紧密联系的。在图形学里，牵涉物理学的问题包括光与物体的表面是怎样互相影响的，人与动物的移动方式，水与空气的流动。为了模拟这些自然现象，物理学的知识是必不可少的。这和解微分方程紧密联系，我将会在下一节提到微分方程。 微分方程的数值解法（有限元方法） 我相信对于计算机图形学来说，解微分方程的技巧是非常重要的。像我们刚才讨论的，计算机图形学致力于模拟源于真实世界的物理系统。波浪是怎样在水里形成的，动物是怎样在地面上行走的，这就是两个模拟物理系统的例子。模拟物理系统的问题经常就是怎样解微分方程的数值解。请注意，微分方程的数值解法与微分方程的符号解法是有很大差异的。符号解法求出没有误差的解，而且时常只用于一些非常简单的方程。有时大学课程里的“微分方程”只教符号解法，不过这并不会对多数计算机图形学的问题有帮助。 在对物理系统的模拟中，我们把世界细分为许多表示成矢量的小元素。然后这些元素之间的关系就可以用矩阵来描述。虽然要处理的矩阵方程组往往没有很精确的解，但是取而代之的是执行了一系列的计算，这些计算产生一个表示成数列的近似解。这就是微分方程的数值解法。请注意，矩阵方程的解法与微分方程数值解法的关系是很密切的。 概率论与统计学 计算机图形学的许多领域都要用到概率论与统计学。当研究者涉足人类学科时，他们当然需要统计学来分析数据。图形学相关领域涉及人类学科，例如虚拟现实和人机交互(HCI)。另外，许多用计算机描绘真实世界的问题牵涉到各种未知事件的概率。两个例子：一棵成长期的树,它的树枝分杈的概率；虚拟的动物如何决定它的行走路线。最后，一些解高难度方程组的技巧用了随机数来估计方程组的解。重要的例子：蒙特卡罗方法经常用于光如何传播的问题。以上仅是一部分在计算机图形学里使用概率论和统计学的方法。 另外，在机器学习和统计学习中，需要非常多和深入的统计学知识。 拓扑学 用一句话来形容拓扑学，它研究油炸圈饼与咖啡杯为什么在本质上是相同的。答案是他们都是只有一个洞的曲面。对于计算机图形学来说，拓扑学的形式（符号表示法）是表达思想的简便方法，常用于分析一些曲面的性质，在形状分析、形状匹配和搜索中得到应用。 黎曼几何 黎曼几何是研究流形曲面上的微积分与微分几何。不同与三维欧氏空间，它研究的曲面是在流形曲面上，其中用到不同的度量。这部分数学知识有点抽象，但是同样有效地被用到计算机图形学中。如共形几何理论就被发展起来在计算机图形学中得到广泛的应用。 抽象代数 抽象代数就是研究群论，环论和域的代数学。相对于线性代数，内容也比较抽象。在计算机图形学上也时有用到。 计算几何 计算几何学研究如何用计算机高效地表示与操作几何体。典型问题如，碰撞检测，把多边形分解为三角形，找出最靠近某个位置的点，这个学科包括了运算法则，数据结构和数学。图形学的研究者，只要涉足创建形体（建模），就要大量用到计算几何学。 推荐的参考书: Computational Geometry in C Joseph O'Rourke Cambridge University Press Computational Geometry: An Introduction Franco Preparata and Michael Shamos Springer-Verlag 其他几何学 一些其他的几何学，如《仿射几何》、《射影几何》在计算机图形学的某些问题上用得比较多，对工程具有较大的促进应用。 总结：数学应用和数学理论 对于图形学来说，以上提到的许多数学学科都有个共同点：比起这些数学的理论价值，我们更倾向于发掘它们的应用价值。不要惊讶。计算机图形学的许多问题和物理学者与工程师们研究的问题是紧密联系的，并且物理学者与工程师们使用的数学工具正是计算机图形学研究者们使用的。多数研究纯数学理论的学科从不被用于计算机图形学。不过这不是绝对的。请注意这些特例：分子生物学正利用节理论来研究DNA分子动力学，亚原子物理学用到了抽象群论。也许有一天，纯数学理论也能推动计算机图形学的发展，谁知道呢？ 事实上，文章中所提到一些数学分支，按照我国的教育体制，在数学系本科的学生（或者硕士研究生阶段的理工科学生）基本都能接触到。但是大学所学习的数学比较偏重于证明以构建完备的数学理论框架，而不太注重实际的使用，现在的大学教师授课的方式也是这样。 我认为，学习数学最好的方式就是使用它，使用它越多，你就觉得它越有用，越有趣，学得就越好，也越快，越扎实。当然，很少有人能精通全部的知识，对于计算机图形学的学习和实践，应当采取掌握较为宽广的数学知识基础，在需要的时候，对相关的数学知识再进行深入的学习和挖掘；不要因为自身数学知识的匮乏而沮丧，更不能因此而敌视数学，保持对计算机图形学强烈的兴趣和乐观上进的学习态度是学习计算机图形学的关键。 还有一点需要指出的是，在学习计算机图形学的过程中，你会发现各个方面的数学知识都会被用到，因此你掌握的数学知识会比较全面，也知道如何在实际中应用。这可能是应用数学在所有学科得到最好的体现。相反，一些做纯理论的数学工作者，掌握的数学知识就是他们所研究的一块，而对其他的数学知识掌握得就不够好，他们做得比较深入。当然，做应用数学和理论数学都有值得敬仰的地方，一个侧重在实际应用，而另一个侧重在理论深度，但要做好都不是很容易。数学说到底还是要学老用的。相对来讲，做计算机图形学能看到学到的数学在实际中所用了，“所用即所学”。试想一下，当你能看到自己做的美妙的东西被别人看到且被敬仰的时候，你的成就感一定会很大！ 最后说一点的就是，学习计算机图形学和从事计算机图形学的研究，除了数学基础外，还需要较强的计算机编程能力，你务必要掌握和熟练一门编程语言，一般建议C/C++，因为你要实现出你的想法，你必须编程去实现出来，做出漂亮的结果。编程也是很有趣的，只要你有兴趣，提高是非常快的！当然，这里我不阐述如何提高编程的能力和水平的方法。“数学”和“编程”，两手都要抓，两手都要硬！提醒大家一点的是，如果你对编程兴趣不大，或者就不愿编程，那你就不适合选择计算机图形学，可能更适合选择其他方向，比如统计学或理论数学。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"摘抄","slug":"摘抄","permalink":"http://adversarr.github.io/tags/%E6%91%98%E6%8A%84/"}]},{"title":"离散数学 [Overview]","slug":"study/Math/DiscreteMath/index","date":"2020-09-25T16:00:00.000Z","updated":"2021-11-30T03:10:09.765Z","comments":true,"path":"2020/09/26/study/Math/DiscreteMath/index/","link":"","permalink":"http://adversarr.github.io/2020/09/26/study/Math/DiscreteMath/index/","excerpt":"2019 - 2020 - 3 离散数学目录","text":"2019 - 2020 - 3 离散数学目录 数理逻辑 集合论 群&amp;环 格&amp;布尔代数 图的基本概念 欧拉图&amp;哈密顿图","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"最（凸）优化方法 [Overview and Intro]","slug":"study/Math/ConvexOptimization/index","date":"2020-09-25T16:00:00.000Z","updated":"2022-03-03T04:30:41.535Z","comments":true,"path":"2020/09/26/study/Math/ConvexOptimization/index/","link":"","permalink":"http://adversarr.github.io/2020/09/26/study/Math/ConvexOptimization/index/","excerpt":"2020-2021-1 最优化方法","text":"2020-2021-1 最优化方法 引言 数学优化 数学优化问题：（数学规划） 从一个可行解集合中,寻找出最优元素。 数学形式： \\[ \\begin{aligned} &amp;\\min . &amp;f_0(x)\\\\ &amp;~\\mathrm{s.t.} &amp; f_i(x) \\leq b_i, i = 1,\\dots,m \\end{aligned} \\] 其中： 优化变量：\\(x\\) 目标函数：\\(f_0:\\mathrm{R}^n\\rightarrow\\mathrm{R}\\) 约束函数：\\(f_i:\\mathrm{R}^n\\rightarrow\\mathrm{R}\\) 最优解：在所有满足约束的向量中，向量 \\(x^*\\) 对应的目标函数值最小 应用 投资组合优化 优化变量：各资产分配的资本数 约束：总预算、每⼀份资产的资本范围、最⼩收益 ⽬标：总风险或回报 电⼦设计中的器件尺⼨ 优化变量：器件的长和宽 约束：⼯程约束、时间要求、最⼤⾯积 ⽬标：总功耗 数据拟合 优化变量：模型参数 约束：先验信息、参数限制 ⽬标：预测误差 求解优化问题 一般形式的优化问题 难以求解 折中：长时间的计算代价、找不到解 特定问题 最小二乘 线性规划 凸优化问题 最小二乘 形式：\\(\\displaystyle\\min.||Ax-b||_2^2\\) 有解析解 \\(x* = (A^TA)^{-1}A^Tb\\) 有可靠的求解算法和软件 计算时间：正比于 \\(n^2k(A\\in \\mathrm{R}^{k\\times n})\\) 技术成熟 最⼩⼆乘的使⽤ 判别⼗分简单 使⽤标准⽅法增强灵活性（加权、正则化） 线性规划问题 \\[ \\begin{aligned} &amp;\\min. &amp;c^Tx\\\\ &amp;\\mathrm{~s.t.} &amp;a_i^Tx\\le b_i \\end{aligned} \\] 没有解析解 具有可靠且有效的求解算法和软件 计算时间：正⽐于\\(n^2m~(if~m \\ge n)\\)，若具有特殊结构，求解更快。 成熟技术 判别难于最⼩⼆乘 ⼀些标准的技巧可⽤于将某些问题转化为线性规划（分段线性⽅程、包含范数的问题）","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://adversarr.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"静电场","slug":"study/Physics/Ch8_9","date":"2020-08-20T06:00:00.000Z","updated":"2022-04-06T03:32:58.003Z","comments":true,"path":"2020/08/20/study/Physics/Ch8_9/","link":"","permalink":"http://adversarr.github.io/2020/08/20/study/Physics/Ch8_9/","excerpt":"基础物理学第 8 - 9 章","text":"基础物理学第 8 - 9 章 静电场电相互作用静电场的高斯定理静电场的环路定理、电势静电场中的导体、电介质静电场中的导体静电场中的电介质静电场的能量 电相互作用 真空中的静电场 电相互作用 「电荷守恒定律」：在一个与外界没有点和交换的系统内，正负电荷的代数和，在任何物理过程中都保持不变。 「电荷量子化」：微小粒子的带电量的变化不是连续的，它只能是 元电荷 e 的整数倍。 库仑定律 「库仑定律」： 在真空中，两个静止点电荷之间的相互作用力大小，与它们的电量的乘积成正比，与其距离平方成反比，作用力方向沿着它们的连线，同号电荷相斥，异号电荷相吸。 \\(\\displaystyle\\boldsymbol{F} _ {12}=k\\frac{q _ 1q _ 2}{r _ {12}^2}\\boldsymbol{e} _ {12}=\\frac{1}{4\\pi\\varepsilon _ 0}\\frac{q _ 1q _ 2}{r _ {12}^2}\\boldsymbol{e} _ {12}\\) 「静电力的叠加原理」：总静电力等于其他点电荷单独存在作用在该点电荷上的静电力的矢量和 电场和电场强度 电场、电场力、场强 「场强的叠加原理」：（类似静电力的叠加原理） 通过线积分、面积分、体积分计算电场强度。 「电偶极子」：由两个大小相等，符号相反的点电荷+q 和 -q 组成。从负电荷到正电荷的矢量称为电偶极子的臂 l，电荷 q 和 l的乘积称为电偶极矩 p（电矩）。 静电场的高斯定理 电场线 数量和场强大小成正比 电场通量 通量（Flux） 静电场的高斯定理 静电场中任何闭合曲面 S 的电场通量 \\(\\varPhi _ E\\) 等于该曲面内所包围的电荷的代数和 \\(\\sum q _ i\\) 除以 \\(\\varepsilon _ 0\\) 「注意」如何证明？类比到引力场 静电场高斯定理的微分形式 \\(\\displaystyle\\nabla\\cdot\\boldsymbol{E} =\\frac{1}{\\varepsilon}\\rho _ c\\) 静电场的环路定理 电势 静电场的环路定理 静电场力所作的功，与路径无关（静电场力是保守力） 「静电场的环路定理」：静电场中，场强沿任意闭合环路的线积分恒等于 0： \\(\\displaystyle\\oint\\boldsymbol{E}\\cdot\\mathrm{d}\\boldsymbol{l}=0\\) 微分形式： \\(\\nabla\\times \\boldsymbol{E}=0\\) 电势差和电势 \\(\\displaystyle U _ {PQ}=\\int _ P^Q\\boldsymbol{E}\\cdot\\mathrm{d}\\boldsymbol{l}\\) 常常选用无穷远为势能零点 电势叠加原理 「电势叠加原理」：点电荷系中电子厂中某点的电势，是哥哥点电荷单独存在时电场在该点的电势的代数和。 等势面 电势的梯度 \\(\\boldsymbol{E}=-\\mathrm{grad}~V\\) **静电场的基本微分方程 泊松方程：\\(\\nabla^2V=-\\frac{1}{\\varepsilon _ 0}\\rho _ e\\) 拉普拉斯方程：\\(\\nabla^2V=0\\) 静电场中的导体 静电场中的导体 导体的静电平衡条件 「条件」：导体内场强处处为 0 利用了：静电场边值问题的唯一性定理 导体是等势体，导体表面是等势面导体内部没有静电荷，电荷只分布在导体表面上导体以外靠近其表面处的场强处处与表面垂直，其大小取决于导体表面的面电荷密度。 导体壳 静电屏蔽 「腔内无带电梯」：在静电平衡状态下，导体壳的内表面上处处没有电荷，电荷只分布在外表面上，空腔内没有电场。 「有带电体」：内表面和腔内电荷的代数和为 0. 「静电屏蔽」：接地良好的道题刻可以把内部带电梯对外界的影响全部消除。 电容 电容器 「孤立导体的电容」：\\(C = \\frac{q}{V}\\) 「电容器的电容」：\\(C = \\frac{q}{U_{AB}}\\) 电容计算：平行板电容器同心球电容器同轴柱形电容器并联的电容：加和串联的电容：倒数 = 倒数加和 静电场中的电介质 电介质计划 位移极化、取向极化、极化电荷、束缚电荷 极化强度和极化电荷 \\(P = \\frac{\\sum \\boldsymbol p_i}{\\Delta V}\\) 闭合曲面 S 内向外移动的极化电荷总量为净余的极化电荷总量的负值： \\(\\displaystyle\\iint_{(S)}P\\cdot \\mathrm d S=-\\sum q&#39;_i\\) 各向同性线性电介质的极化规律 \\(P=\\chi_e\\varepsilon_0 E\\) 产生退极化场：E' 电位移 有电介质时的高斯定理 \\(D=\\varepsilon_0E+P\\) \\(D=\\varepsilon_r\\varepsilon_0E=\\varepsilon E\\) 「D的高斯定理」：\\(\\nabla\\cdot D=\\rho_0\\) \\(D = \\varepsilon E=\\varepsilon_r\\varepsilon_0E\\) \\(C=\\varepsilon_rC_0\\) 静电场的能量 带点体系的静电能 点电荷之间的相互作用能 \\(\\displaystyle W_{int}=\\frac{1}{8\\pi\\varepsilon_0}\\sum\\sum\\frac{q_iq_j}{r_{ij}}\\) 电荷连续分布情形的静电能 \\(\\displaystyle W=\\frac{1}{2}\\sum qV\\) 电荷在外电场中的能量 电容器储能 \\(\\displaystyle W=\\frac{1}{2}QU\\) 电场的能量和能量密度 「电能密度」：\\(\\displaystyle w_e = \\frac{W_e}{V} = \\frac{1}{2}DE\\) 各向同性时： \\(\\displaystyle w_e=\\frac{1}{2}\\varepsilon_0E^2(or~\\frac{1}{2}\\varepsilon_r\\varepsilon_0E^2)\\)","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"},{"name":"波","slug":"波","permalink":"http://adversarr.github.io/tags/%E6%B3%A2/"}]},{"title":"数据结构复习","slug":"study/ComputerScience/fragments/datastructure-review","date":"2020-08-18T16:00:00.000Z","updated":"2022-04-06T03:32:23.577Z","comments":true,"path":"2020/08/19/study/ComputerScience/fragments/datastructure-review/","link":"","permalink":"http://adversarr.github.io/2020/08/19/study/ComputerScience/fragments/datastructure-review/","excerpt":"数据结构复习","text":"数据结构复习 0、绪论 碎碎念 四种基本的逻辑结构： 集合结构 线性结构 树结构 图结构 ADT的概念： ADT 数据类型 &#123; 数据对象：&lt;Definition&gt; 数据关系：&lt;Definition&gt; 基本操作：&lt;Definition&gt;&#125; 注意C和C++的区别，以及常用的语句 没有 template，没有 class #define 的使用 typedef、union 的使用 异常处理：用的是 Status 表示（就是 int ），也有用 exit 的 简单提一下 #define 和 typedef： #define IDENTIFIER expr// 在编译时会被直接替换成 expr#define IDENTIFIER(x,y,z) expr// 在编译时会被直接替换成expr，并且将expr中的 x y z 替换// 例如#define PI 1.57 + 1.57cout &lt;&lt; PI; // 编译时替换成 cout &lt;&lt; 1.57 + 1.57;// 想一想 PI*PI 是什么#define ISROOT(node) (node-&gt;father == nullptr)cout &lt;&lt; ISROOT(tree._root_ptr);// 编译时替换成 cout &lt;&lt; (tree._root_ptr -&gt; father == nullptr);typedef int Status;Status x; // 等价于 int x;// 注意：不能有 template&lt; 「再碎碎念一下」template 还记得多少。new delete填程序可能考的（释放空间，析构函数）万一出卷老师一时兴起，和我一样作死用 virtual 写avl::bst 咋办typedef 和 #define 定义的顺序不一样我慌了。 时间复杂度 「全场暴毙」：写出下面这个算法的时间复杂度 // n 为 str 长度// 则 func 是 o(?)int func(char *str, char c)&#123; int cnt = 0; for (size_t i = 0; i &lt; strlen(str); ++i) if (str[i] == c) cnt ++; return cnt;&#125; Ans：\\(O(n^2)\\) 评估算法 「算法的特性」： 有穷性 确定性 可行性 输入 输出 「算法的评估」： 高效性 正确性 健壮性 可读性 「要点：」时间复杂度如何？空间复杂度如何？相比其他算法的优缺点？如何实现？（注意细节）能手算吗？ 1、线性表 「顺序表」 静态 #define MAXSIZE 100 动态 new or malloc 内存中的特点如何？ 插入o(n)： 思考：能不能用 memcpy 函数？ 删除o(n)： 这两个都要注意：表的长度要减少1 搜索o(n)： 成功的平均比较次数 ASL = ？ 失败的比较次数？ 合并 无序：\\(O(na*nb)\\) 有序：\\(O(na+nb)\\) 「链表」 单链表存储、插入、删除、合并 循环链表 双向链表 应用 多项式的表示 2、栈与队列 链式存储！ 「栈」：LIFO 定义 初始化 压栈 出栈 Q：一个 n 元素序列依次进栈，则其不同的出栈队列有多少种 A：卡特兰数 「队列」：FIFO 链式表示 循环队列（这个定义是啥？） 1. 重点是如何判断 overflow 2. 入队？出队？ 3、串 如何定义？ 截止符 \\0 编码方式：Unicode or ASCII ？「这个考到就离谱」 子串 定长存储表示（堆分配） 操作： 连接 求子串 插入（类似顺序表） 链式存储（块链） 模式匹配算法 BF算法（一个个找） KMP算法（跳转表）「如何求 next 表」 类似于有限状态自动机状态转移 KMP的时间复杂度（求 next 表） 4、数组和广义表 一维数组 多维数组 【写给自己】记得别再傻傻的用 new int ** 了！ 特殊矩阵压缩： 对称：只存储对角线及以上（下） 行号、列号的计算？ 三对角矩阵： k = 2 * i + j 稀疏矩阵： 存放方式（三元组法） 快速转置算法 矩阵乘法 十字链表存储 广义表： 都是指针、链式！ 表头表尾如何定义（链表结点） 原子节点：tag=0+原子的值 表节点：tag = 1 + 表头指针 hp + 表尾指针 tp 第二种定义： 分三个：utype，info，tp utype info tp 0 被引用次数 表头 1 数据值（atom） 下一个节点 2 （子）表 下一个节点 5、树 定义（高度、兄弟、……） 性质 完全二叉树、满二叉树 存储方式 （完全）二叉树的顺序存储：有可能编号从 1 开始 链表存储： 二叉链表：lc + data + rc 三叉链表：lc + data + father + rc 二叉树深度优先遍历（先中后） 表达式求值 【危】 二叉树层次遍历 其中使用了____（线性数据结构）？ 线索化 prec + lc + data + rc + suss 中序遍历建立 树的存储方式 双亲法、 指针法、 链表法、 孩子兄弟法 树和二叉树的转换 树的各种遍历法 森林化为二叉树 应用「堆」：上浮下沉用的是完全二叉树的顺序存储「Huffman编码树」 6、查找 查找表 关键字 属性 （无序）顺序表查找 检查哨？（这玩意的意义到现在也没懂） ASL = (n + 1) / 2 ASL = n + 1 (fail) int search(SeqTable st, KeyTp key)&#123; int i = 0; st.elem[0].key = key; for (i = st.length; st.elem[i].key != key; --i); return i;&#125; （有序）顺序表查找「二分查找法」 可以得到「判定树Decision Tree」 索引顺序表（分块查找） 特点：块间有序，块内无序 附加索引表（关键字有序） 【顺序表查找方法比较】 顺序查找 折半查找 分块查找 ASL 最大 最小 折中 表结构 有序、无序 有序 分块有序 存储结构 顺序存储结构、线性链表 顺序存储 顺序存储结构线性链表 二叉搜索树（BST） 定义：lc.key &lt;= self.key &lt;= rc.key (lc, rc exists) 如何搜索？ 递归 注意宏定义！！！（不清楚看：§1.碎碎念） #define EQ(a, b) ((a) == (b)) （没必要） 插入 先搜索，看这个元素存不存在！ 搜索成功，已经有这个元素（不插入？替换？看题目） 不成功，插入这个元素（作为叶子） 通过无序表构造二叉搜索树 删除结点 叶子？ 左右子女有一个为空？ 都非空？（直接后继：右子树“最左侧”的结点） 这边莫名q了一下「卡特兰数」：对于有 n 个关键字的集合，其关键字有 n! 种不同排列，可构成的不同的二叉搜索树有 \\(\\frac{1}{n-1}C^n_{2n}\\) 颗。 “匀称”？AVL 平衡条件：-1 &lt;= lc.height - rc.height &lt;= 1 其中：lc.height - rc.height 被称为「平衡因子」。 维持平衡方法：旋转 单旋： right(node) left(node) 双旋： 左右 leftright(node) = left(node-&gt;lc) + right(node) 右左 rightleft(node) = right(node -&gt; rc) + left(node) 什么时候用？ left ：node-&gt;lc-&gt;lc 高 right：node-&gt;rc-&gt;rc 高 leftright：node-&gt;lc-&gt;rc 高 rightleft：node-&gt;rc-&gt;lc 高 插入： 先按BST插入 检查、维持平衡 「B 树」 盲猜会考【迷之自信】 定义 实际上和BST(AVL)很像（算是BST(AVL)的推广？） BST(AVL)在每个结点上都是用一个 key 把原来的有序表分成了两块，例如：(key=1, lc = &#123;key &lt; 1&#125;, rc = &#123;key &gt; 1&#125;) 【意会一下】 B树（思想上）就是分成了k块（m/2 &lt;= k &lt;= m）：(ptr[0] = &#123;key &lt; key[1]&#125;, key[1], ptr[1] = &#123;key[1] &lt; key &lt; key[2]&#125;, key[2], ... , ptr[k] = &#123;key[k] &lt; key &lt; key[k+1]&#125;, key[k+1], ptr[k+1] = &#123;key[k+1] &lt; key])（还是提一下：分成k块只要切k-1刀，所以key从1开始索引） 细节看ppt。（平衡因子 = 0、叶子结点为 F 的作用） 查找targ_key： 从根结点开始 current_node = root 如果current_node 是 F（叶子），返回not found，否则在这个结点上找targ_key（顺序查找！就那么几个点，二分很可能效率更低！） 找到：返回 没找到，在 ptr[next] 中继续找，其中 ： next = x (key[x] &lt; targ_key &lt; key[x+1]) next = k (key[k] &lt; targ_key &amp;&amp; 该结点只有 k+1 个key) next = 0 (targ_key &lt; key[0]) 转 2 【类比二叉搜索树的查找】 插入： 平衡维持：分裂 看ppt吧，我也写不清楚，画图比较好，也就几种情况： father 的 ptr 数目（度）&lt; m？ father 的 ptr 数目（度）= m？ 这个分裂的结点是root？ 构造：不断插入 「B+」 1. 注意和B树的区别： 1. m 还是 m + 1？ 2. 看清楚上一层的key实则是子树的key的最大值 3. 最底层从左到右排列就是原表（有序） 2. 插入： 1. 平衡维持：分裂 2. 看ppt吧，我也写不清楚，画图比较好，也就几种情况： 1. father 的 ptr 数目（度）&lt; m？ 2. father 的 ptr 数目（度）= m？ 3. 这个分裂的结点是root？ 「Hash」 两个问题： 均匀的散列函数（简单快速） 解决冲突的方案 Hash函数： 「直接定址法」：Hash(key) = a * key + b（适合相对连续的数字） 「数字分析法」：选择近乎随机的某几位（书上讲的好点） 「除留余数法」：Hash(key) = key % p 「平方取中法」：一般取散列地址总数为 8 的 r 次幂，则取平方数中间的 r 位 「折叠法」：123456789 -&gt; 123+456+789 冲突解决： 「开放地址法」：线性探测法、二次探测法、伪随机探测法（书上例子挺好的，摘在下面） 「再哈希法」 「链地址法」：每一个 key 都对应一个链表 「公共区溢出法」（书上没有） Hash(key) = key % 11;[\\ \\ \\ \\ \\ 60 17 29 \\ \\ \\]# 插入 38， 且产生随机数 9# 线性探测：(d = 3)[\\ \\ \\ \\ \\ 60 17 29 38 \\ \\]# 二次：（d = -1)[\\ \\ \\ \\ 38 60 17 29 \\ \\ \\]# 伪随机：(d = 9)[\\ \\ \\ 38 \\ 60 17 29 \\ \\ \\] 方法 ASL(success) ASL(fail) 线性探测 \\(\\frac 1 2(1+\\frac 1{1-\\alpha})\\) \\(\\frac 1 2(1+\\frac 1{(1-\\alpha})^2)\\) 二次/伪随机 \\(-\\frac 1 \\alpha \\ln(1-\\alpha)\\) \\(\\frac 1 {1-\\alpha}\\) 链地址法 \\(1 + \\frac \\alpha 2\\) \\(\\alpha + e^{-\\alpha}\\) 7、图 基础概念：自己看离散「超凶」：图的基本概念 存储方式 「邻接矩阵」：A[i, j] = ( &lt; i, j &gt; in E) ? weight(i, j) : ((i == j) ? 0 : UNDEFINED) 稀疏时严重的空间浪费！ 「邻接表」：adj[i] 为 i 的出边（无向图：相临边） 逆临接表 遍历（不会吧不会吧，不会真的有人不会吧） 「DFS」 「BFS」 「MST」 「Prim」：增加点 「Kruskal」：不断连接连通分支 AOV 「拓扑排序」：O(n+e) AOE 关键路径： 路径上的点都是关键活动点 是 该路径为关键路径的 _____ 条件？ 最早可能开始时间 e[k] = 最迟允许开始时间 l[k] 有点像DP（拓扑）？怎么手算？ 最短路径 「Dijkstra算法」 念叨一句使用条件：『无负权边』 「Floyd算法」（ppt 里面没有） 「SPFA」！！（书上 ppt 都没有）：无负边的时候，绝对是最快的 8、排序 简单提几句就行了、叭、、 alg 时间复杂度 稳定？ 描述 插入 \\(O(n^2)\\) y 想想打牌的时候理牌的过程 选择 \\(O(n^2)\\) n 选剩下的最大的扔到最后 希尔 \\(O(n log n)\\) n 玄学算法复杂度（缩小增量） 冒泡 \\(O(n^2)\\) y 冒泡赛 「快排」 \\(O(n log n)\\) n 重点 堆排 \\(O(n log n)\\) n 建立（升序建立大根堆）堆，抽堆顶，维护堆 归并 \\(O(n log n)\\) y 常见（C++ STL） 基数 \\(O(n log n)\\) n 分配、收集 「快速排序」：主要思想是选一个数，做交换，让序列中左边的数都比这个数小，右边的数都比这个数大。 q一下以前见过的一个讲的很好的解释【找不到链接了，如果找到了请评论区发一下】： 快排可以用挖坑 + 填坑来理解（这个看ppt上有一个图） 记住pivot，然后把pivot的位置上挖个坑，并且设置 i, j = l, r 在右侧（j 从右向左）找一个比pivot大的，填到坑里，并且把 j 这里挖个坑【此时若出现 i &gt;= j 转 4 】 在左侧（i 从左向右）找一个比pivot小的，填到坑里，并且把 i 这里挖个坑【此时若出现 i &gt;= j 转 4 】 这个时候 i == j，而且在这里有个坑可以填，将pivot填进去 对左侧序列，右侧序列执行快排。 # 第一个是 Pivotdef qsort(seq : list, l : int, r : int): if l &gt;= r: return pivot = seq[l] i, j = l, r while (i &lt; j): while (i &lt; j and seq[j] &gt;= pivot): j-- seq[i] = seq[j] while(i &lt; j and seq[i] &lt;= pivot): i++ seq[j] = seq[i] # 此时 i == j seq[i] = pivot # 对左右两侧的表分别排序 qsort(seq, l, i - 1) qsort(seq, i + 1, r) # 随机 Pivotdef qsort(seq: list, l: int, r: int): if l == r: return p = randint(l, r) pivot = seq[p] # 随便选一个 pivot i, j = l, r while (i&lt;j): while (pivot &lt;= seq[r] and l &lt; r): r-- p, seq[p] = r, seq[r] while (pivot &gt;= seq[l] and l &lt; r): l++ p, seq[p] = l, seq[l] seq[i] = pivot qsort(seq, l, i - 1) qsort(seq, i + 1, r) 不保证正确。嘿嘿😶 排序：(ref: runoob) 插入排序 插入排序 希尔排序 希尔排序 冒泡排序 冒泡排序 快速排序 快速排序 选择排序 选择排序 堆排序 堆排序1 堆排序2 归并排序 归并排序 基数排序 基数排序","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"数据结构","slug":"数据结构","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hexo 建站实录","slug":"talk-chat/Hexo","date":"2020-08-12T16:00:00.000Z","updated":"2022-04-06T03:38:04.923Z","comments":true,"path":"2020/08/13/talk-chat/Hexo/","link":"","permalink":"http://adversarr.github.io/2020/08/13/talk-chat/Hexo/","excerpt":"建站实录","text":"建站实录 Hexo 前言 需要准备的材料： vscode VSCode 的终端内，要换成cmd.exe，按下 ctrl + , 进入设置，找到 terminal.external.windowsExec这个，修改为 C:\\Windows\\System32\\cmd.exe Node.js 安装完成后需要执行：npm config set registry https://registry.npm.taobao.org，来重新定向源。 Git客户端、以及一个配置好的 Github 账号 站点建立 https://docs.github.com/en/github/working-with-github-pages 安装Git Git 的配置 安装Node.js 安装Hexo GitHub创建个人仓库 Git：在Mirror中下载，并安装 Git-2.28.0-64-bit.exe（中间都是直接点击下一步即可） Node.js：在Mirror中下载，并安装 node-v14.8.0-x64.msi。 第一步，为你的站点设置一个代码仓库： Ref 第二步，站点初始化 Ref Note: It can take up to 20 minutes for changes to your site to publish after you push the changes to GitHub. If your don't see your changes reflected in your browser after an hour, see \"About Jekyll build errors for GitHub Pages sites.\" 部署需要时间、每小时最多部署10次，站点大小最多1G（图片不能太多太大，搞大型个人相册就免了） 第三步，找一个地方，专门存放你的这个站点，例如：D:/repos/ 在这个文件夹中 clone 下你的这个仓库。并且在 VScode 中打开这个仓库 在这里，按照： Ref 安装 Hexo。 Ref 在本机上建立站点 注意，因为直接在git下的目录中打开code，所以其中的folder就是 . （当前文件夹）不用执行cd切换工作文件夹，也就是（在VScode 终端中执行）： hexo init .npm install 初次尝试 hexo s --debug # 显示debug反馈hexo s # 精简模式 应当显示： ...INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. ctrl + 鼠标左键 点击链接看看？ deploy 配置 deploy: type: git repository: git@github.com:adversarr/adversarr.github.io.git branch: master # 注意是 master 分支 message: Site updated:&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;) 站点配置 _config.yml 实际上就按照 readme 走就行。 更换主题（以我现在用的 Fluid 为例） 注意看文档就行 主题配置 发布文章 Hexo 工作流 yaml &lt;!-- more --&gt;用法 个性化设置 搜索器 mathjax katex Valine 思维导图 其他 code Snippet 附录 参考了部分：Ref","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://adversarr.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://adversarr.github.io/tags/%E6%9D%82%E8%AE%B0/"}],"author":"Adversarr"},{"title":"正则表达式文法","slug":"study/ComputerScience/fragments/RegExp","date":"2020-06-30T16:00:00.000Z","updated":"2022-04-06T03:31:23.704Z","comments":true,"path":"2020/07/01/study/ComputerScience/fragments/RegExp/","link":"","permalink":"http://adversarr.github.io/2020/07/01/study/ComputerScience/fragments/RegExp/","excerpt":"正则表达式规则","text":"正则表达式规则 正则表达式 描述模式 连接操作 AB &lt;=&gt; &#123;AB&#125; 或操作 A|B &lt;=&gt;&#123;A,B&#125; 闭包操作 A* &lt;=&gt; U&#123;A^i&#125; i&gt;=0 空字符串 eps 括号 提升优先级 正则表达式的定义 一个正则表达式可以是： 空字符串 单个字符 被括号包含的一个正则表达式 两个正则表达式连接成的表达式 由或运算分隔的两个表达式 由闭包运算标记的表达式 描述符 名称 记法 例子 通配符 . A.B 指定的集合 包含在[]中的字符 [ABC]* 范围 包含在[]中，由-分隔 [A-Z0-9] 补集 包含在[]中的，且以^开头 [^A-Z] 闭包的简写 选项 记法 例子 至少一次 + [0-9]+（与下面这个等价） 至少 0 次 * [0-9][0-9]* 指定次数 n A&#123;n&#125; [0-9]&#123;11&#125; 指定次数范围 a &lt;= n &lt;= b A&#123;a-b&#125; [A-Z]&#123;0-2&#125; 转义符： 任意空白字符：\\s 表示闭包的字符：\\*，... 其他常见的字符：\\n，\\t，... image-20200622153014750","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"集合论","slug":"study/Math/DiscreteMath/集合论","date":"2020-06-26T16:00:00.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2020/06/27/study/Math/DiscreteMath/集合论/","link":"","permalink":"http://adversarr.github.io/2020/06/27/study/Math/DiscreteMath/%E9%9B%86%E5%90%88%E8%AE%BA/","excerpt":"","text":"集合代数 集合的基本概念 Def：子集、包含 Def：（集合）相等 Def：真子集 Def：空集 Thm：空集是一切集合的子集 Thm：空集是唯一的 Def：幂集 Def：全集 集合运算 Def：相对补集 Def：对称差集 Def：绝对补集 Def：广义并、广义交 有穷集的计数 容斥原理 集合恒等式 二元关系 有序对、笛卡尔积 Def：有序对 Def：笛卡尔积 二元关系 Def：二元关系 Def：A上的二元关系 Def：空关系、全域关系、恒等关系 关系的运算 Def：定义域、值域、域 Def：逆运算 Def：右复合 Def：R在A上的限制、像 Thm：\\((F^{-1})^{-1} = F, \\quad dom F^{-1} = ran F, ran F^{-1} = dom F\\) Thm：\\((F \\circ G ) \\circ H = F \\circ (G \\circ H),\\quad (F\\circ G)^{-1} = G^{-1} \\circ F^{-1}\\) Thm：$R I_A = I_A R = R $ Thm： \\(F \\circ (G \\cup H) = F \\circ G \\cup F \\circ H\\) \\((G \\cup H) \\circ F = G \\circ F \\cup H \\circ F\\) \\(F \\circ (G \\cap H) \\subset F \\circ G \\cap F \\circ H\\) \\((G \\cap H) \\circ F \\subset G \\circ F \\cap H \\circ F\\) Thm： \\(F \\upharpoonright (A \\cup B) = F \\upharpoonright A \\cup F \\upharpoonright B\\) \\(R [ A \\cup B ] =F[A] \\cup F[B]\\) \\(F \\upharpoonright (A \\cap B) = F \\upharpoonright A \\cap F \\upharpoonright B\\) \\(F [A \\cap B] \\subset F[A] \\cap F[B]\\) Def：R的n次幂 Thm：存在自然数\\(s, t\\)，使得\\(R^s = R^t\\) Thm： \\(R^m \\circ R^n = R^{m+n}\\) \\((R^m)^n = R^{mn}\\) Thm： \\(\\forall k \\in \\mathrm N, R^{s+k} = R^{t+k}\\) \\(\\forall k, i \\in \\mathrm N , R^{s+tp+i} =R^{s+i}, where p = t - s\\) \\(Let~S = \\{R^0, R^1, \\dots, R^t-1\\}, \\forall q \\in \\mathrm N, R^q \\in S\\) 关系的性质 Def：自反的、反自反的 Def：对称、反对称 Def：传递 Thm 自反 iff \\(I_A \\subseteq R\\) 反自反 iff \\(R\\cap I_A = \\emptyset\\) 对称 iff \\(R = R^{-1}\\) 反对称 iff \\(R\\cap R^{-1} \\subseteq I_A\\) 传递 iff \\(R\\circ R \\subseteq R\\) 关系的闭包 Def：自反闭包、传递闭包、对称闭包 Warshall算法 Thm：自反/传递/对称 iff \\(r,t,s(R) =R\\) Thm：\\(R_1 \\subseteq R_2\\Rightarrow r,s,t(R_1)\\subseteq r,s,t(R_2)\\) Thm：R是自反的=&gt;s,t(R) 是自反的 R是对称的=&gt;r,t(R)是对称的 R是传递的=&gt;r(R)是传递的 等价关系和划分 Def：等价关系 Def：等价类 Thm： \\(\\forall A, [x] 是 A 的非空子集\\) \\(\\forall x, y \\in A, (xRy \\rightarrow [x] = [y])\\) \\(forall x, y \\in A, (x \\not R y \\rightarrow [x]与[y]不交\\) \\(\\cup{[x]| x\\in A} = A\\) Def：划分 偏序关系 Def：偏序关系 Def :（偏序）小于 Def：全序关系 Def：偏序集 Def：覆盖 Def：最小元、最大元、极小元、极大元 Def：上界、下界、上确界、下确界 函数 函数的定义 Def：函数 Def：函数相等 Def：从A到B的函数 Def：“B上A” Def：函数的像、完全原像 Def：满射、单射、双射 Def：常函数、恒等函数、单调递增/减、严格单调递增、特征函数、自然映射 集合的复合和反函数 Thm：\\(dom(F\\circ G)= \\{ x| x\\in dom(F) \\wedge x \\in dom(G)\\}\\) Thm： \\(f,g满射\\rightarrow f\\circ g满射\\) \\(f,g单射\\rightarrow f\\circ g单射\\) \\(f,g双射\\rightarrow f\\circ g双射\\) Thm 若 f 双射，则\\(f^{-1}\\)双射 双射函数和集合基数 Def：等势 Thm：等势是等价关系 Thm：康托定理 Def：优势 若存在从A到B的单射函数，则称B优势于A B真优势于A Thm： A优势于A A优势于B，B优势于A，则A, B等势 传递 Def：集合后继 用空集和后继\\(n^+\\)可以吧自然数定义为集合 Def：一个集合是有穷的，当且仅当其于某个自然数等势，反之为无穷集 Def：集合基数、\\(alef_0\\) Thm：集合基数和优势、等势的关系 Def：可数集 可数集的子集是可数集 可数个可数集的并是可数集 两个可数集的笛卡尔积是可数集 无穷集 A 的幂集 P(A) 不是可数集","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"欧拉图和哈密顿图","slug":"study/Math/DiscreteMath/EulerHarmiltonGraph","date":"2020-06-24T16:00:00.000Z","updated":"2022-03-03T04:30:41.415Z","comments":true,"path":"2020/06/25/study/Math/DiscreteMath/EulerHarmiltonGraph/","link":"","permalink":"http://adversarr.github.io/2020/06/25/study/Math/DiscreteMath/EulerHarmiltonGraph/","excerpt":"","text":"欧拉图 Def： （欧拉通路）经过图中所有边一次且仅一次的通路 （欧拉回路）经过图中所有边一次且仅一次的回路 （欧拉图）有欧拉回路 （半欧拉图）有欧拉通路 Thm：无向图 G 是欧拉图，当且仅当其连通且没有奇度顶点。 Thm：无向图 G 是半欧拉图，当且仅当其连通且恰有两个奇度顶点。 Thm：有向图 D 是欧拉图，当且仅当其是强连通的且每个顶点的出度等于入度。 Thm：有向图 D 是半欧拉图，当且仅当其是单向连通的且有两个奇度顶点，一个入度比出度大 1，一个入度比出度小 1，其余每个顶点的出度等于入度。 Thm：G 是非平凡的欧拉图，当且仅当 G 是连通的且为几个不重合的圈的并 Fleury Alg （求欧拉回路）任取 \\(v_0\\in V(G)\\)，令 \\(P_0=v_0\\)设 \\(P_i = v_0e_1\\dots e_iv_i\\)，若 \\(E(G) -\\{e_1,e_2,\\dots,e_i\\}\\)中没有与 \\(v_i\\)关联的边，则停止，否则按以下条件选下一条边：\\(e_{i+1}\\) 与 \\(v_i\\) 关联优先选：\\(e_{i+1}\\) 不是 \\(G-\\{e_1,\\dots,e_i\\}\\) 中的桥 哈密顿图 Def： （哈密顿通路）经过图中所有点一次且仅一次的通路 （哈密顿回路）经过图中所有点一次且仅一次的回路 （哈密顿图）有哈密顿回路 （半哈密顿图）有哈密顿通路 Thm：G 是哈密顿图，则\\(\\forall (V_1 \\in V\\wedge v_1\\neq\\emptyset)\\quad p(G-V_1) \\le |V_1|\\) Thm：G 是半哈密顿图，则\\(\\forall (V_1 \\in V\\wedge v_1\\neq\\emptyset)\\quad p(G-V_1) \\le |V_1|+1\\) Thm：\\(\\forall v_i,v_j\\) 不相邻，则 \\(d(v_i)+d(v_j)\\ge n-1\\)，则有哈密顿通路 Thm：\\(\\forall v_i,v_j\\) 不相邻，则 \\(d(v_i)+d(v_j)\\ge n\\)，则有哈密顿回路 Thm：若 \\(u,v\\) 是 n 阶无向简单图的两个不相邻的顶点，且 \\(d(u)+d(v)\\ge n\\) 则 \\(G\\) 是哈密顿图当且仅当 \\(G\\cup (u,v)\\) 时哈密顿图。 Thm：若 \\(D\\) 是竞赛图，则其中有哈密顿通路 最短路问题","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://adversarr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"谈谈编程","slug":"talk-chat/AboutProgramming1","date":"2020-06-23T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/06/24/talk-chat/AboutProgramming1/","link":"","permalink":"http://adversarr.github.io/2020/06/24/talk-chat/AboutProgramming1/","excerpt":"编程十载。","text":"编程十载。 笔者江苏南京人，小学听人说编程有点意思随便学了点 Basic，觉着程序设计挺有趣，便一直没有放下编程的学习。当时挺自信，用 Basic 也能写点东西，虽然看上去不怎样，却能解决点实际问题： Q：解不定方程：2 x + 3 y = 100, x y 是正整数。 FOR I = 1 TO 50 FOR J = 1 TO 33 IF 2*I+3*J = 100 THEN PRINT I PRINT J END IF NEXT JNEXT I Well，写的不好，但是至少我知道怎样去解决一些问题。要解这个方程实际上不需要这么麻烦。但是当时学到的确实是解决问题的方法：编一个程序、枚举各种情况、得到答案。 当然，如果我们仔细看一看这一个程序，实则三种最基础的程序结构都有： 顺序：PRINT I PRINT J 分支：IF ... THEN ... (ELSE ...) END IF 循环：FOR I = 1 TO 50 NEXT I 确实，我们需要这三种结构就能创建整个程序了，至少当时的我，还能记得，这三个程序足以撑起你需要的一切。 上了初中，接触的是 Pascal，勉强写了两年，就跳去学“高大上”的 C++ 了，做点对比： var a,b,c: int;Procedure foo(para: int)begin writeln(para+1)end;begin readln(a, b, c); foo(a); foo(b); foo(c);end. #include &lt;iostream&gt;using namespace std;void foo(int para) &#123; cout &lt;&lt; para; &#125;int main()&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; foo(a);foo(b);foo(c); return 0;&#125; 当时写的也是懵懵懂懂的，但也能说出些道道来：什么是函数，什么是形参实参之类的。当然，这些只是为了应付当年的 NOIP 比赛（现csp），写的程序里面大多是这样的： int main()&#123; int a[10000000]; int n; for(int i = 1;i&lt;=n;++i) cin&gt;&gt; a[i]; ......&#125; 当时还是挺自信，这玩意挺好啊，能解决问题，在赛场上也能拿点分。但是到了大学就不一样了。c++ 程设这门课主要难点在于 OOP 与动态内存部分，各种 bug 都来了，我还记得，当时上的最多的网站：Docs，是微软的技术文档，每天沉浸在理解、记忆如何去写一个可以编译的程序之中，觉得生活确实充实。 但是如果你问我，到底学到了什么，我只能说，我学会了如何写出一个能够编译的 cpp。 疫情期间，有更多的时间看了看国外的开放课程（MIT Open Course），例如： Intro to EECS 6.01I MIT：计科、电子方向的导论课 讲的很浅显易懂，大概涉及以下几个方面 Topics State Machine Differential Equations and Operations Circuit ... ... 在第一节课，教授指出了这门课的目的：形成思维方法，从以下几个方面去思考问题和知识。 Primitives（原语） Combination（组合） Abstractions（抽象） Patterns（模式） 以电路为例 Example (Circuit) Primitives Ohm's Law Node Combination KVL KCL Equations Node method, Loop method Abstractions Parallel Combinations Series Combinations Patterns in Series Combinations: \\(I = V / (R_1 + R_2)\\) in Parallel Combinations: \\(V_1 = R_1 I,\\dots\\) FunctionalProgramming.luaview rawlocal function get_accumulator(start) start = start or 0 return function() start = start + 1 return start endendlocal acc = get_accumulator()for i = 1, 10, 2 do print(acc())end","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://adversarr.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"杂谈","slug":"杂谈","permalink":"http://adversarr.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"Lambda 演算简介（2）","slug":"study/ComputerScience/LambdaCalculi/LambdaCalc2","date":"2020-06-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.763Z","comments":true,"path":"2020/06/11/study/ComputerScience/LambdaCalculi/LambdaCalc2/","link":"","permalink":"http://adversarr.github.io/2020/06/11/study/ComputerScience/LambdaCalculi/LambdaCalc2/","excerpt":"Lambda 演算中的常见概念","text":"Lambda 演算中的常见概念 布尔、函数、列表等基本数据类型 布尔值的表示与运算 概念 Lambda 表达式 记法 f(x) = expr \\(\\mathrm{\\lambda x.expr}\\) lambda x.expr true \\(\\mathrm{\\lambda x.\\lambda y.x}\\) lambda x.lambda y.x false \\(\\mathrm{\\lambda x.\\lambda y.y}\\) lambda x.lambda y.y e1 and e2 \\(\\mathrm{[e1][e2][false]}\\) [e1][e2][false] e1 or e2 \\(\\mathrm{[e1][true][e2]}\\) [e1][true][e2] not e1 \\(\\mathrm{[e1][false][true]}\\) [e1][false][true] (if q tp fp) \\(\\mathrm{[q][tp][fp]}\\) [q][tp][fp] 毫无疑问，这是一个联结词完备集，现在来简单验证一下这个定义是正确的： true and false =&gt; (lambda x.lambday.y) = false 当然，读者也可以尝试着写出 not and or 的表达式，证明其正确性。在此略去。 这样看 Lambda 表达式并不是很直观，但是如果认为这些 Lambda 表达式是柯里化后的表达式，则可以给出： true &lt;=&gt; lambda x y.x false &lt;=&gt; lambda x y.y (if q tp fp) &lt;=&gt; lambda q tp fp.(q tp fp)（注意结合 true 和 false 的定义看） 多元函数、列表的递归定义 概念 Lambda 表达式 记法 f(x, y) = expr \\(\\mathrm{\\lambda x.\\lambda y.expr}\\) lambda x.lambda y.expr（柯里化） cons e1 e2 \\(\\mathrm{\\lambda a.\\lambda b.(\\lambda s.s~a~d)~e1~e2}\\) lambda a.lambda d.(lambda s.s a d) e1 e2 car expr \\(\\mathrm{[expr][true]}\\) [expr] [true] cdr expr \\(\\mathrm{[expr]~[false]}\\) [expr] [false] empty \\(\\mathrm{\\lambda x.[true]}\\) lambda x.[true] empty? expr \\(\\mathrm{[expr](\\lambda x.\\lambda y.[false])}\\) [expr](lambda x.lambda y.[false]) (list e1 e2...) \\(\\mathrm{[cons][e1][cons][e2]\\dots[empty]}\\) [cons][e1][cons][e2]...[empty] 其中： car cons e1 e2 \\(\\mathop {\\rightarrow}\\limits^\\beta\\) e1 cdr cons e1 e2 \\(\\mathop {\\rightarrow}\\limits^\\beta\\) e2 演算提示不得不说，这个代数定义实在精彩，希望读者能拿纸笔算一算。在这里给出一定的提示cons = lambda a.lambda d.(lambda s.s a d)一式中：a 为 car（二元组的第一元素）d 为 cdr（二元组的第二元素）s 为 选择器（selector），注意 true 和false 的定义。cons 实则返回的是一个选择器（也就是一个函数）。请读者计算empty? (cons e1 e2) 和empty? empty。 数 概念 Lambda 表达式 记法 0 \\(\\mathrm{[empty]}\\) [false] 1 \\(\\mathrm{[cons][true][false]}\\) [true] add1 n \\(\\mathrm{[cons][true][}n]\\) [cons][true][n] sub1 n \\(\\mathrm{[cdr][n]}\\) [cdr][n] zero? n \\(\\mathrm{[empty?][}n]\\) [empty?][n] 需要注意的是，如果我们不用 [true] 和 [false] 表示 0 和 1 ，而将其适当展开，我们可以得到这样的表达式： [0] = lambda x y.y [n+1] = lambda x y.x [n] 读者应该发现，在定义集合的势的时候，我们用了类似的处理方法： 一个自然数可以定义为集合： \\(0=\\emptyset\\) 后继：\\(n^+=n\\cup\\{n\\}\\) 一个有穷集的势定义为与其等势的一个自然数。 在定义这些运算之后，我们给出加法的定义： 概念 Lambda 表达式 记法 add x y \\(\\mathrm{\\lambda x.\\lambda y.\\lambda s.\\lambda z.(x~s~(y~s~z))}\\) lambda x y.lambda s z.(x s (y s z)) 以后在使用时，即可直接使用这些概念，进行演算。 简单类型的Lambda 演算 回顾前文中所有的Lambda 演算，我们发现，我们所有的演算，都是在Lambda 表达式中进行的，并没有脱开这些表达式，没有用到 数 布尔 等常见的类型，在此引入这些概念： 类型化lambda演算的主要变化是增加了一个叫做「基类型」（base types）的概念。在类型化lambda演算中，你可以使用一些由原子值构成的论域（universe）， 这些值分为不同的简单类型。因此，例如，我们可以有一个类型 \\(N\\)，它由包含了自然数集合，也可以有一个类型 \\(B\\)，对应布尔值true / false，以及一个对应于字符串类型的类 \\(S\\)。 现在我们有了基本类型，接下来我们讨论函数的类型。函数将一种类型（参数的类型）的值映射到的第二种类型（返回值的类型）的值。对于一个接受类型A的输入参数，并且返回类型B的值的函数，我们将它的类型写为\\(A \\rightarrow B\\) 。\\(\\rightarrow\\)叫做函数类型构造器（function type constructor），它是右关联的，所以 \\(A \\rightarrow B \\rightarrow C\\) 表示 \\(A \\rightarrow (B \\rightarrow C)\\)。 TODO: 未完待续","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Lambda演算","slug":"Lambda演算","permalink":"http://adversarr.github.io/tags/Lambda%E6%BC%94%E7%AE%97/"}]},{"title":"Lambda 演算简介（3）","slug":"study/ComputerScience/LambdaCalculi/LambdaCalc3","date":"2020-06-10T16:00:00.000Z","updated":"2022-03-03T04:30:41.764Z","comments":true,"path":"2020/06/11/study/ComputerScience/LambdaCalculi/LambdaCalc3/","link":"","permalink":"http://adversarr.github.io/2020/06/11/study/ComputerScience/LambdaCalculi/LambdaCalc3/","excerpt":"Lambda 演算中的 Y 组合子","text":"Lambda 演算中的 Y 组合子 Y 组合子：递归实现 在之前，我们都在做一些简单的操作，例如实现了分支结构 s e1 e2 ，现在我们要考虑如何实现第二种结构：循环与递归（recursion）。 在 Lambda 演算的世界里，递归是容易实现的，利用如下的 Y 组合子： Y = lambda y.(lambda x.y (x x)) (lambda x.y (x x)) 即：\\(\\mathrm{Y = \\lambda y.(\\lambda x.y~(x~x))~(\\lambda x.y~(x~x))}\\) 我们试着计算 Y Y 的值： Y Y(beta) =&gt;(lambda x.Y (x x)) (lambda x.Y (x x))(alpha)=&gt;(lambda x.Y (x x)) (lambda z.Y (z z))(beta) =&gt;Y ((lambda z.Y (z z)) (lambda z.Y (z z)))(alpha)=&gt;(lambda a. (lambda b . a (b b)) (lambda b. a (b b))) ((lambda z. Y (z z)) (lambda z. Y (z z)))(beta) =&gt;Y (Y Y)...... =&gt;Y (Y (Y Y))...... 可以发现，Y 组合子通过 Y Y 创造了自身！这似乎是一个无穷递归，我们换一个例子看一看：假定 f 是一个关于 x 的函数，例如f = (lambda x.add1 x) (Y f) x(beta) =&gt;(lambda y.(y (lambda x.y (x x) lambda x.y(x x))) f) x(alpha)=&gt;(f ((lambda x.f (x x)) (lambda x.f (x x)))) x(beta) &lt;=(f (Y f)) x...... &lt;=(f (f ( ... f(Y f))...) x 这还不够，因为 f 是一个一元的函数，按照这个形式，即使给 f 一定的条件，使之在某处停下，我们也无法使之停下的条件与任何一个 x 有关。就以上面的表达式为例： (Y f) =&gt; add1 (add1 (add1 ... )) x 内部的 add1 并不会停下！ 例如：f (f (f)) x 在这里，前面是先演算的内容，但是很明显在第三层停下递归并不是 x 所控制的。这并不是我们想要的，但是已经十分接近了！给这个形式做一些改变，则需要一个形式保留下来这个结构，并且将 add1 换为一个二元运算 mult： (Y (lambda t.lambda x.mult x (t x)))) a...... =&gt;(lambda t.lambda x.mult x (t x) (Y lambda t.lambda x.mult(t x)) x) a(alpha)=&gt;(lambda t.lambda x&#x27;.mult x&#x27; (t x&#x27;) (Y lambda t.lambda x.mult(t x)) x) a(beta) =&gt;(lambda x&#x27;. mult x&#x27; (Y (lambda t.lambda x.mult x (t x))) x)) a(beta) =&gt;mult a (Y (lambda t.lambda x.mult x (t x))) a)...... =&gt;mult a (mult a (mult a ( ... ))) 最后我们加上一些判断，使之在某个地方停下，以及对于 x 的变换： LET: metafact = lambda fact . (lambda n . IsZero n 1 (Mult n (fact (Pred n)))) metafact (Y metafact) n=&gt; lambda n. zero? n 1 (mult n (Y metafact (Pred n))) n=&gt; mult n (Y metafact (Pred n))=&gt; mult n (metafact ((lambda x.metafact (x x)) (lambda x.metafact (x x))) (Pred n))=&gt; mult n (metafact (Y metafact) (Pred n)) 一点思考读者应分析结构：lambda t.lambda x.f (t x) x，指出其中f 和 t 的作用：（在此仅给出个人的理解）f 为函数算子t 为传入形式的复制如果从柯里化的角度看 Y 组合子是否更好？ SKI组合子 先给出 SKI 组合子的定义： S = (lambda x y z.(x z (y z))) K = (lambda x y. x) I = (lambda x.x) 这个定义时很奇怪的，如何说呢，请看： S K K x=&gt;(K x) (K x)=&gt;(lambda x y. x) x (K x)=&gt;x 也就是说 I = S K K，其中 = 表示外延等价（extensional equivalence），当 E x 和 E' x 总是有相同的约化结果恒成立，则称 E = E'。（另一种等价指内涵等价（intensional equivalence），当E 与 E 完全相同或经过 \\(\\alpha\\)-转换后有相同的结果）。 在此略去 组合子演算 部分，这一部分可以参考这篇文章","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Lambda演算","slug":"Lambda演算","permalink":"http://adversarr.github.io/tags/Lambda%E6%BC%94%E7%AE%97/"}]},{"title":"编程语言和 Lambda 演算叙旧","slug":"study/ComputerScience/LambdaCalculi/LambdaCalc0","date":"2020-06-08T16:00:00.000Z","updated":"2022-04-06T03:30:54.425Z","comments":true,"path":"2020/06/09/study/ComputerScience/LambdaCalculi/LambdaCalc0/","link":"","permalink":"http://adversarr.github.io/2020/06/09/study/ComputerScience/LambdaCalculi/LambdaCalc0/","excerpt":"摘自Wikipedia，知乎等。","text":"摘自Wikipedia，知乎等。 Lambda 演算历史 在 20 世纪 60 年代中期的一系列论文中，Landin1阐述了关于编程语言的两个重要观察。首先，他认为所有编程语言都共享一套用于指定计算的基本工具，但在数据和数据原语的选择上存在差异。这组通用工具包含名称、过程、应用程序、异常机制、可变数据结构，以及其他形式的非局部控制（non-local control）。用于数值计算的应用程序的语言通常包括几种形式的数值常量和大型数值原语集，而用于字符串操作的语言通常提供高效的字符串匹配和操作原语。 其次，Landin 敦促程序员和实现者（implementors）都应该把编程语言看作是一种先进的、符号形式的算术和代数。由于我们在幼儿园和高中的时候就已经习惯了用数字、布尔值和更复杂的数据结构进行计算，用程序进行计算应该也很容易。程序评估、许多形式的程序编辑、程序转换和优化只是简单的、更复杂的计算形式。这种计算处理的不是简单的算术表达式，而是程序和程序片段。 Landin 定义了编程语言 Iswim。他设计的基础是 Church2 的 Lambda 演算。Church 提出 Lambda 演算作为一种函数的演算（calculus of functions）。鉴于 Landin 对于在程序中，过程（Procedure）起到核心作用，并且作为所有语言的通用工具的理解，Lambda 演算是一个十分自然的构建起点（a nature starting point）。然而，为了支持基本数据和相关原语以及赋值和控制构造， Landin 使用适当的构造扩展了 Lambda 演算。他将扩展后的编程语言的语义与一台抽象机进行了类比，因为他不知道如何将 Lambda 演算理论扩展为完整的编程语言理论。实际上，（Landin 提出的）Lambda 演算甚至没有解释纯函数子语言的语义，因为 Iswim 总是对过程（Procedure）中的参数进行计算（意为执行该 Procedure 中的计算操作）。因此，Landin 并没有完成他的目标，即建立所有编程语言的一个理想的核心，并定义其语义的等式演算方法。 从 Plotkin3 在 20 世纪 70 年代中期关于抽象机器与等式计算器的关系的研究开始，Landin 的研究未完成的部分由许多研究者共同填补，包括 Felleisen、Mason、Talcott 和他们的合作者。Plotkin 的工作包括创建一个实现了 Iswim 的基本功能的子语言，这需要在此基础上采用一种名为 Lambda 演算的“值代入”（call-by-value variant of the lambda-calculus）的计算方法。Felleisen 和他的同事用公理扩展了等式理论，这些公理解释了几种不同类型的命令式语言工具。梅森和塔尔科特研究了将等式理论用于完全类似 Iswim 的语言，作为程序验证和转换编程（Transformational Programming）的工具。 尽管 Iswim 并未成为一个被广泛应用的语言，Iswim 的设计哲学依旧体现在现代编程语言中，最值得注意的是 Scheme 和 ML，和它的语言（语义？）分析（langurage analysis）和设计方法基本上适用于所有编程语言。 这本书的目的是为了说明设计、分析和使用的等式理论像 Lambda 演算在编程语言内容（content of programming langurage）中的设计与分析。着眼于 ML 和 Scheme，但针对的是一般的高阶语言。 Landin 的 ISWIM 的功能核心是对 Church 的纯 Lambda 演算的扩展，使用原始数据及其相关的原始函数。Church 以一种函数的演算，提出了 Lambda 演算。Lambda 演算提供了一个简单且规范的语法来编写 donw 函数，以及一个简单的等式系统（指等式理论）来指定程序的行为。由于在编程语言中，由用户定义的过程是函数的直观对等物（intuitive counterpart of functions），所以对于希望仅基于数据和用户定义过程定义编程语言的 Landin 来说，该系统是一个自然的选择。与纯演算不同，ISWIM 包含基本常量和函数常量来模拟原始数据；为了避免特殊化（Specialization），我们的 ISWIM 变体包含用于原始数据操作的通用子语言。 Peter John Landin↩︎ Alonzo Church↩︎ Gordon Plotkin↩︎","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Lambda演算","slug":"Lambda演算","permalink":"http://adversarr.github.io/tags/Lambda%E6%BC%94%E7%AE%97/"}]},{"title":"Lambda 演算简介（1）","slug":"study/ComputerScience/LambdaCalculi/LambdaCalc1","date":"2020-06-08T16:00:00.000Z","updated":"2022-04-06T03:32:58.062Z","comments":true,"path":"2020/06/09/study/ComputerScience/LambdaCalculi/LambdaCalc1/","link":"","permalink":"http://adversarr.github.io/2020/06/09/study/ComputerScience/LambdaCalculi/LambdaCalc1/","excerpt":"摘自 Wikipedia，知乎等。","text":"摘自 Wikipedia，知乎等。 何为 Lambda 演算 Lambda 演算（Lambda Calculus）是一套从数理逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用，以及以递归的形式定义、实现一个系统。它由数学家阿隆佐·邱奇在 20 世纪 30 年代首次发表。Lambda 演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值，它能模拟单一磁带图灵机的计算过程；尽管如此，Lambda 演算强调的是变换规则的运用，而非实现它们的具体机器。 Lambda 演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式。因此普遍公认是一种更接近软件而非硬件的方式。对函数式编程语言造成很大影响，比如Lisp、ML语言和Haskell语言。在 1936 年邱奇利用 Lambda 演算给出了对于判定性问题（Entscheidungs problem）的否定：关于两个 Lambda 表达式是否等价的命题，无法由一个“通用的算法”判断，这是不可判定性能够证明的头一个问题，甚至还在停机问题之先。 后文中使用的一些 Racket 语义\\(\\sum\\limits_{i=0}^ni\\)：(define (sumto n) (/ (* n (+ n 1)) 2))求整数的位数：(define (crunch n) (if (&lt; n 10) 1 (+ 1 (crunch (/ n 10)))))断言：posn?，number?，zero?，positive?...多分支判断：cond相当于 c 中的 switch-case语句（等价 (if p a1 a2) 递归）复杂数据类型复杂数据类型构成：make-posn p q，posn?，posn-x，posn-y元组化：(define (bunchify n) (if (= n 1) 1 (make-posn n (bunchify (- n 1))))))元组个数：bunch-size(define (bunch-size b) (if (number? b) 1 (+ (bunch-size (posn-x b)) (bunch-size (posn-y b)))))从 bunch 中删除e：delete-es b e高级数据结构二元组：cons（(define-struct cons (car cdr))）取第一个：car取第二个：cdr列表：list 计算模型（Computation Models） 图灵机是一种抽象机器，它在无限长磁带上进行计算。如果一个问题可以用图灵机解决，我们说它是可计算的。否则，它是不可计算的。 停机问题不可计算的一个例子：停机问题。它询问是否存在一个程序，该程序接受一个程序作为输入，并决定它是否停止。现在思考这样的Racket 函数：(define (doesnthalt x) (doesnthalt x))(define (foo x) (if (halts? x) (doesnthalt 10) true))这里的 doesnthalt 函数形成无穷递归。进而我们证明 (foo foo) 是不可确定的如果 (foo foo) 停机，则 foo停机，则(foo foo) =&gt; (doesnthalt 10)(foo foo) 是不可计算的，形成矛盾。如果 (foo foo) 不停机，则(foo foo) =&gt; true ，foo停机，形成矛盾。在两种情况下，都产生了矛盾，故停机问题是不可计算的。 Lambda 演算语法 Lambda 演算包括了建构 Lambda 项，和对 Lambda 项运行归约的操作。Lambda 演算只有三类表达式： 变量（Variable）：\\(\\mathrm{x,y,a,b}\\) 抽象（Abstraction）：\\(\\mathrm{(\\lambda x.~expression)}\\) \\(\\mathrm{expression}\\) 是一个 Lambda 表达式 应用（Application）：\\(\\mathrm{(e_1,e_2)}\\) 其中 \\(e_1,e_2\\) 为 Lambda 表达式 常用表示法\\(\\mathrm{(\\lambda x .expression)}\\)：(lambda x. expression)\\(\\mathrm{(\\lambdax.plus~x~x)~y}\\)：(lambda x. plus x x) y（前缀表达式）在后文中都使用这种记法，并且采用前缀表达式。下面介绍一些速记：表达式等价记法(lambda x. expression)lambda x. expression(e)ee1 e2 e3(e1 e2) e3lambda x.e1 e2lambda x. (e1 e2)这里给出一些 Lambda 表达式的例子：xx xx y zlambda x. xlambda x. x xlambda x.(lambda y. x)(lambda x. x) (lambda y. y)Lambda 演算技巧：柯里化如果仔细看 Lambda 演算的定义，便会发现，Lambda演算只接受一个参数，这似乎是一个极大的问题，因为我们连加法都无法合理的处理，因而我们将其使用柯里化。柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。在直觉上，柯里化声称：“如果你固定某些参数，你将得到接受余下参数的一个函数”由这个理论，我们来构建一个加法运算：lambda x.(lambda y. plus xy)如果我们可以简化运算、并且提升可阅读性的话，我们也可以用前一种记法，即lambda x y. plus xy。这就是柯里化的最简单使用方法，也就是说，一个复杂的多参数函数可以柯里化为一个函数。添加多个参数的函数并没有真正添加任何东西，只不过简化了语法，所以下面继续介绍的时候，在方便的时候用到多参数函数。 自由变量 我们在此给出自由变量的严格定义： 用 \\(\\mathrm{FV[exp]}\\) 表示一个集合，表示在一个 Lambda 表达式 \\(\\mathrm{exp}\\) 中的所有自由变量： \\(\\mathrm{exp}\\) 是变量，则 \\(\\mathrm{FV(exp) = \\{exp\\}}\\) \\(\\mathrm{exp}\\) 是应用 \\(\\mathrm{(e1~e2)}\\)，则 \\(\\mathrm{FV(exp) = FV[e1]\\cup FV[e2]}\\) \\(\\mathrm{exp}\\) 是抽象 \\(\\lambda \\mathrm{x.~deri}\\)，则 \\(\\mathrm{FV(exp) = FV(deri) \\backslash \\{x\\}}\\) 例如： lambda x . plus x y：在这个表达式中，y 和 plus 是自由的，而 x 不是自由的。 lambda x y . y x：在这个表达式中x和y都不是自由的。 lambda y . (lambda x . plus x y)：在内层演算lambda x . plus x y中，y和plus是自由的，x不是自由的。在完整表达中，x和y不是自由的，plus 是自由的 我们会经常使用free(x)来表示在表达式x中自由的标识符。 Lambda 演算中的代换法 \\(\\mathrm{e1[x\\leftarrow e2]}\\) 表示代换。代换可以不严谨地理解为：将 \\(\\mathrm{e1}\\) 中的所有出现的自由变量 \\(\\mathrm x\\) 替换为 \\(\\mathrm{e2}\\)。 严格的定义如下： \\(\\mathrm{x[x\\leftarrow e]}\\Longrightarrow\\mathrm e\\) \\(\\mathrm{(e1,e2)[x\\leftarrow e3]}\\Longrightarrow \\mathrm{(e1[x\\leftarrow e3],e2[x\\leftarrow e3])}\\) \\(\\mathrm{(\\lambda x.e1)[x\\leftarrow e2]}\\Longrightarrow \\mathrm{(\\lambda x.e1)}\\) （在其中，\\(\\mathrm x\\) 不是自由变量） \\(\\mathrm{(\\lambda y.e1)[x\\leftarrow e2]}\\Longrightarrow \\mathrm{(\\lambda y.e1[x\\leftarrow e2])}\\) Lambda 演算原则 为了推广这个代换法，我们引入 \\(\\alpha\\)-转化和 \\(\\beta\\)-规约的概念： alpha-转化 如果两个 Lambda 表达式\\((\\mathrm{\\lambda x.e1}),(\\mathrm{\\lambda y.e2})\\)满足\\(\\mathrm y\\not\\in\\mathrm{FV[e1]}\\) 并且 \\(\\mathrm{e2=e1[x\\leftarrow y]}\\) 则称这两个表达式是 \\(\\alpha\\)-等价（\\(\\alpha\\)-equivalent）的。用符号 \\(\\mathop{\\rightarrow}\\limits^\\alpha\\) 表示这一转化。 \\(\\alpha\\)-转化翻译成 转化 一词，是因为其注重了其转化的语义。 在英文中我们使用：equivalent 表示该关系，实则描述的是一种等价关系。 beta-规约 \\(\\beta\\)-规约是一个操作：将\\(\\mathrm{(\\lambda x.e1)~e2}\\)，转化为 \\(\\mathrm{e1[x\\leftarrow e2]}\\)。用符号 \\(\\mathop {\\rightarrow}\\limits^\\beta\\) 表示这一操作。 规约来自：reduction 一词，个人认为翻译为 约化 更为准确。 alpha-转化和 beta-规约的实例\\[\\begin{aligned}\\mathrm{(\\lambda x.a~x~b)~(\\lambda y.y)}&amp;\\mathop{\\rightarrow}\\limits^\\beta\\mathrm{a~(\\lambda y.y)~b}\\\\\\mathrm{(\\lambda x.a~x~b)~(\\lambda y.x)}&amp;\\mathop{\\rightarrow}\\limits^\\alpha\\mathrm{(\\lambda q.a~q~b)~(\\lambda y.x)}\\\\&amp;\\mathop{\\rightarrow}\\limits^\\beta \\mathrm{a~(\\lambda y.x)~b}\\end{aligned}\\] 约化 若给出一个从 \\(\\mathrm {e1}\\) 到 \\(\\mathrm{e2}\\) 演算序列，且 \\(\\mathrm e2\\) 无法继续演算，则称 \\(\\mathrm e1\\) 约化为 \\(\\mathrm{e2}\\)。 如果一个表达式 \\(\\mathrm e1\\) 存在一个约化，则称其为可约化的（called redex） 开始我们的演算 以 \\(\\mathrm{(\\lambda x.a~x~b)~((\\lambda y.y)~z)}\\) 为例，下面给出两种可能的方案去约化 Lambda 表达式。 普通（惯常）顺序（Normal Order）：从最外层的可约化的式子开始，先化为\\(\\mathrm{a~((\\lambda y.y)~z)~b}\\) 应用（调用）顺序（Applicative Order）：也从最外层开始，但先化为 \\(\\mathrm{(\\lambda x.a~x~b)~z}\\) 请读者指出这两种顺序的区别：（注：在 non-lazy 非惰性计算时使用的是第二种顺序） 一个完全约化（fully-reduced）的 Lambda 表达式形式没有可约化的表达式。同时，若给出从 \\(\\mathrm {e1}\\) 到 \\(\\mathrm{e2}\\) 演算序列，则 \\(\\mathrm e2\\) 不可约化，且在该演算序列中的所有表达式都约化为 \\(\\mathrm e2\\)（存在且唯一）。 一个无穷递归的例子\\(\\mathrm{(\\lambda x.x~x)~(\\lambdax.x~x)}\\)毫不夸张的说，这是世界上最小的无穷循环（递归）。但是，思考这样的例子：\\(\\mathrm{(\\lambda x.y)~((\\lambdax.x~x)~(\\lambda x.x~x))}\\)对于普通顺序演算，结果为 \\(y\\)，对于应用顺序演算，结果则是无穷递归。更一般的说，若一个 Lambda表达式可以（可能）被约化为一个完全约化的表达式，则普通顺序一定能演算到该形式，但应用顺序可能无法导出答案。 惰性计算（Lazy-Evaluation） 惰性计算需要我们对可约化的表达式进行注释（annotate）。以下面一个表达式为例，我们对表达式进行约化： \\[ \\mathrm{(\\lambda x.f~x~x)~((\\lambda y.y)~z)} \\] 使用普通顺序： \\[ \\begin{aligned} &amp;\\mathrm{(\\lambda x.f~x~x)~((\\lambda y.y)~z)}\\\\ \\Rightarrow&amp;\\mathrm{f~((\\lambda y.y)~z)~((\\lambda y.y)~z)}\\\\ \\Rightarrow&amp;\\mathrm{f~z~((\\lambda y.y)~z)}\\\\ \\Rightarrow&amp;\\mathrm{f~z~z} \\end{aligned} \\] 普通顺序先对第一个抽象（abstraction）使用 \\(\\beta\\)-规约 使用应用顺序： \\[ \\begin{aligned} &amp;\\mathrm{(\\lambda x.f~x~x)~((\\lambda y.y)~z)}\\\\ \\Rightarrow&amp;\\mathrm{(\\lambda x.f~x~x)~z}\\\\ \\Rightarrow&amp;\\mathrm{f~z~z} \\end{aligned} \\] 应用顺序先对第二个抽象（abstraction）使用 \\(\\beta\\)-规约 使用惰性计算： \\[ \\begin{aligned} &amp;\\mathrm{(\\lambda x.f~x~x)~((\\lambda y.y)~z)}\\\\ \\Rightarrow&amp;\\mathrm{f~((\\lambda y.y)~z)~((\\lambda y.y)~z)}\\\\ \\Rightarrow&amp;\\mathrm{f~z~z} \\end{aligned} \\] 看似惰性计算很像普通顺序，但是，除了在后台运算时，所有等价的可约化表达式，在约化后会同时被替换。","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Lambda演算","slug":"Lambda演算","permalink":"http://adversarr.github.io/tags/Lambda%E6%BC%94%E7%AE%97/"}]},{"title":"物理学绪论","slug":"study/Physics/Ch0Pre","date":"2020-06-07T16:00:00.000Z","updated":"2022-04-06T03:32:35.586Z","comments":true,"path":"2020/06/08/study/Physics/Ch0Pre/","link":"","permalink":"http://adversarr.github.io/2020/06/08/study/Physics/Ch0Pre/","excerpt":"基础物理学 绪论","text":"基础物理学 绪论 什么是物理 学习物理的目的 矢量代数基本知识 标量 只有大小（正负均可） 矢量 大小方向（一定是正值） 矢量的书写 \\(\\vec{A}\\)或\\(\\pmb{A}\\) \\(A\\vec{e_A}\\) 矢量表示方法 几何表示：有向线段 解析表示：（直角坐标系） \\(\\vec{A}=A_x\\vec{i}+A_y\\vec{j}+A_z\\vec{k}\\) 矢量方向 \\(\\cos \\alpha = \\frac{A_x}{|A|}\\) 矢量运算 加法、减法 乘法 点乘 叉乘 矢量的求导、积分","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"}],"author":"Clover"},{"title":"质点运动学","slug":"study/Physics/Ch1KinematicsOfMassPoint","date":"2020-06-07T16:00:00.000Z","updated":"2022-04-06T03:32:58.042Z","comments":true,"path":"2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/","link":"","permalink":"http://adversarr.github.io/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/","excerpt":"想当初，我还做了这么多笔记？","text":"想当初，我还做了这么多笔记？ 质点运动的描述 力学：研究机械运动(宏观物体之间或物体内各部分之间的相对位置的变动)。 运动学：研究物体运动的描述及运动学量间的关系。 动力学：研究物体运动与物体间相互作用间的联系。 静力学：研究物体在相互作用下的平衡问题。 质点、参考系和坐标系 质点 (理想化的模型) 若物体的形状和大小可以忽略，则可视为一个具有一定质量的几何点。 物体可看作质点来处理的条件： 作平动的物体 两物体间的距离远大于物体本身的线度 参考系 (运动具有相对性) 研究物体运动时所选定的参照物体。 运动具有相对性(relativity)，为此研究运动时需选定参考系(reference system)，为确定各时刻物体相对参考系的位置需建立坐标系(coordinate system)。 坐标系 定量表示物体的位置。 质点运动的矢量描述（位移、速度、加速度） 位置矢量(位矢、径矢 Position Vector) 从坐标原点\\(O\\)指向质点所在位置\\(P\\)的有向线段，表征在空间某个质点 $ P $ 的位置的矢量\\(\\vec{r}=\\vec{OP}\\). 大小（模）：\\(r=\\sqrt{x^{2}+y^{2}+z^{2}}\\) 方向：\\(\\cos \\alpha=\\frac{x}{r} ,\\quad \\cos \\beta=\\frac{y}{r} ,\\quad \\cos \\gamma=\\frac{z}{r}\\) 运动方程 \\(\\pmb{r}=\\pmb{r}(t)=x(t) \\pmb{i}+y(t) \\pmb{j}+z(t) \\pmb{k}\\) 参数方程：\\(x=x(t) \\quad y=y(t) \\quad z=z(t)\\) 从中小区参数\\(t\\)可以得到质点运动的轨道方程 位移（反映位置的变化） 时间间隔内质点位置的变化 \\(\\Delta \\pmb{r} = \\pmb{r}(t+\\Delta t) - \\pmb{r}(t).\\) 当质点在空间运动时，位矢\\(r\\) 是时间\\(t\\)的函数，\\(\\pmb{r}=\\pmb{r}(t).\\) (1,1) 在时刻\\(t\\)，质点位矢为\\(\\pmb{r}_A = \\pmb{r}(t)\\); 在时刻\\(t+\\Delta t\\),质点位矢为\\(\\pmb{r}_B=\\pmb{r}(t+\\Delta t)\\) 于是，质点在时间间隔\\(\\Delta t\\)内的位置变化，可以用自 A 到 B 的矢量\\(\\Delta \\pmb{r}\\)来表示，即\\(\\Delta \\pmb{r} = \\pmb{r}(t+\\Delta t) - \\pmb{r}(t).\\) png 在直角坐标系中： \\[ \\begin{aligned} \\Delta \\pmb{r}&amp;=\\Delta x \\pmb{i}+\\Delta \\pmb{y}+\\Delta z \\pmb{k} \\\\ |\\Delta \\pmb{r}|&amp;=\\sqrt{\\Delta x^{2}+\\Delta y^{2}+\\Delta z^{2}} \\end{aligned} \\] 注意： \\(\\widehat{A B}\\) 路程（标量） \\(\\Delta \\pmb{r}\\)​ 位移（矢量） \\({\\pmb{r}}\\) 位矢、与坐标原点有关 \\({\\Delta \\pmb{r}}\\) 位移、与坐标原点无关 ${||} $ 位矢增量的大小 \\({|\\Delta r|}\\) 位矢大小的增量 速度（Velocity）——反映质点运动的快慢和方向 平均速度（单位时间内质点的位移）：\\(\\bar{v}=\\frac{\\Delta \\pmb{r}}{\\Delta t}.\\) 瞬时速度（质点某时刻的速度）：\\(v=\\lim \\limits_{\\Delta t \\to 0}\\frac{\\Delta \\pmb{r}}{\\Delta t}\\) 直角坐标系中 \\(\\vec{v}=v_{x} \\vec{i}+v_{y} \\vec{j}+v_{z} \\vec{k}\\) 大小：\\(v=|\\vec{v}|=\\sqrt{v_{x}^{2}+v_{y}^{2}+v_{z}^{2}}\\) 方向：为轨道上质点所在处切线方向并指向前进的一侧 速率： 平均速率：\\(\\bar{v}=\\frac{\\Delta s}{\\Delta t}\\) 瞬时速率：\\(v=|v|=\\lim\\limits_{\\Delta t \\to 0} \\frac{|\\Delta \\pmb{r}|}{\\Delta t}=\\lim\\limits_{\\Delta t \\to 0} \\frac {\\Delta s}{\\Delta t}=\\frac{ds}{dt}\\) 注意：一般情况下：\\(|\\Delta \\pmb{r}| \\neq \\Delta s \\quad |\\pmb{v}| \\neq \\bar{v}\\) ​ 当\\(\\Delta t \\to 0\\) 时：\\(|\\Delta \\vec{r}| \\rightarrow|\\mathrm{d} \\vec{r}|=\\mathrm{d} s \\quad|\\vec{v}|=v\\) 加速度（Acceleration）——反映瞬时速度的变化 平均加速度：\\(\\bar{a}=\\frac{\\pmb{v}_2-\\pmb{v}_1}{\\Delta t}=\\frac{\\Delta \\pmb{v}}{\\Delta t}\\) 瞬时加速度：\\(a=\\lim\\limits_{\\Delta t \\to 0}\\frac{v_b-v_a}{\\Delta t}=\\lim\\limits_ {\\Delta t \\to 0} \\frac{\\Delta \\pmb{v}}{\\Delta t}=\\frac{d^2 r}{dt^2}\\) 加速度的方向：速度增量的方向 加速度的大小：\\(|\\pmb{a}|=\\sqrt{a_{x}^{2}+a_{y}^{2}+a_{z}^{2}}\\) 直角坐标系中：\\(\\pmb{a}=a_{x} \\pmb{i}+a_{y} \\pmb{j}+a_{z} \\pmb{k}\\) 注意：一般而言，加速度与同一时刻速度的方向之间并没有一定的关联。 思考： 位矢、速度和加速度，与参考系的选择是否有关？ 一旦参考系选定了，它们就与参考点的选择是否有关？ 矢量描述质点运动的优点 矢量描述与具体坐标系的选择无关，因此便于作一般性的定义陈述和公式推导。 坐标系的适当选择 具体计算时，根据具体问题的特点选择。例如： 质点的加速度为常矢量时，可选用直角坐标系； 质点作平面运动的加速度总是指向空间某一固定点时，可选用平面极坐标系； 质点的运动轨迹固定或已知时，可选用自然坐标系。 速度、加速度在不同坐标系中的分量表示 直角坐标系的特点 各单位矢量\\((e_x,e_y,e_z)\\) 或\\((i,j,k)\\)都是不随时间变化的常矢量，即：\\(\\frac{e_x}{dt}=\\frac{e_y}{dt}=\\frac{e_z}{dt}=\\frac{i}{dt}=\\frac{j}{dt}=\\frac{k}{dt}=0\\) 因此有： \\[ \\begin{aligned} r&amp;=x\\pmb{i}+y\\pmb{j}+z\\pmb{k} \\\\ v&amp;=\\frac{dx}{dt}\\pmb{i}+\\frac{yx}{dt}\\pmb{j}+\\frac{dz}{dt}\\pmb{k}=v_x\\pmb{i}+v_y\\pmb{j}+v_z\\pmb{k} \\\\ a&amp;=\\frac{d^2x}{dt}\\pmb{i}+\\frac{d^2y}{dt}\\pmb{j}+\\frac{d^2z}{dt}\\pmb{k}=a_x\\pmb{i}+a_y\\pmb{j}+a_z\\pmb{k} \\end{aligned} \\] 注意：\\(v_x,v_y,v_z\\)和 \\(a_x,a_y,a_z\\) 都是可正可负的量。 a的方向 正负号的含义：如图所示，当质点在\\(P\\)点处时， \\(a_x\\)与\\(v_x\\)的符号相同，说明质点在\\(x\\)轴上的投影是在作加速运动；而\\(a_y\\)与\\(v_y\\)的符号相反，说明质点在\\(y\\)轴上的投影是在作减速运动。 实例 在地球表面附近不太大的范围内，重力加速度 g 可以看成是常量。在忽略空气阻力的情况下，二维抛体运动的水平分量和竖直分量将互相独立。这时可选取平面直角坐标系，如图所示。[missing Pic] \\[ \\begin{cases} \\frac{dx}{dt}=v_0\\cos{\\theta_0} \\\\ \\frac{dy}{dt}=v_0\\sin{\\theta_0}-gt \\end{cases} \\] 积分后可得： \\[ \\begin{cases} x=(v_0\\cos\\theta_0) t \\\\ y=(v_0\\sin\\theta_0) t \\end{cases} \\] 消去时间\\(t\\)可得描写抛体运动轨迹的抛物线方程 \\[ y=x\\tan\\theta_0 - \\frac{gx^2}{2v_0^2\\cos^{2}{\\theta_0}} \\] 射高：由\\(v_y=0\\)可得\\(t=v_0\\sin\\theta_0/g\\)，由此可确定： \\[ y_{max}=\\frac{v_0^2\\sin^2\\theta_0}{2g} \\] 射程：由\\(y=0\\)可得\\(t=2v_9\\sin\\theta_0/g\\)，由此可确定 \\[ x_{max}=\\frac{v_0^2\\sin2\\theta_0}{g} \\] 平面极坐标系、横向速度和径向速度 微分 如图所示，在一选定的参考系上选取一点\\(O\\)为原点，并从它出发引一条有刻度的射线\\(Ox\\) 为极轴，即建立起了一个平面极坐标系。 该平面上任意一点 \\(A\\) 的位矢的长度为\\(\\overline{OA}= r\\)，它与极轴间的夹角为\\(\\theta\\)，称为辐角。只要 \\(r\\) 和 \\(\\theta\\) 给定，\\(A\\)点的位置就确定了。 \\[ \\bar{e}_{\\theta}\\quad \\frac{\\mathrm{d} \\pmb{e}_{\\theta}}{\\mathrm{d} t}=-\\frac{\\mathrm{d} \\theta}{\\mathrm{d} t} \\pmb{e}_{r} \\\\ \\pmb{v} =\\dot{r} \\pmb{e}_{r}+r \\dot{\\theta} \\pmb{e}_{\\theta}\\\\ \\pmb{a}=\\left(\\ddot{r}-r \\dot{\\theta}^{2}\\right) \\pmb{e}_{r}+(r \\ddot{\\theta}+2 \\dot{r} \\dot{\\theta}) \\pmb{e}_{\\theta} \\] 在平面极坐标系中，两个互相垂直的单位矢量\\(e_r\\)和\\(e_\\theta\\)，分别沿着 \\(r\\) 和 $$ 增加的方向，它们都不是常矢量。 \\[ A(r, \\theta) \\quad \\vec{r}= r \\vec{e}_{r} \\\\ \\frac{\\mathrm{d} \\pmb{e}_{r}}{\\mathrm{d} t}=\\frac{\\mathrm{d} \\theta}{\\mathrm{d} t} \\pmb{e}_{\\theta} \\quad \\frac{\\mathrm{d} \\pmb{e}_{\\theta}}{\\mathrm{d} t} =-\\frac{\\mathrm{d} \\theta}{\\mathrm{d} t} \\pmb{e}_{r} \\] 关于各物理量的表达式，可用以下两种方法得到： （a）图解法 01a_6b 位矢：\\(\\pmb{r}=r\\pmb{e}_r\\) 位移：\\(\\Delta \\boldsymbol{r}=\\Delta \\boldsymbol{r}_{1}+\\Delta \\boldsymbol{r}_{2}\\) 横向位移：\\(\\Delta \\boldsymbol{r}_{1}=\\overline{AC}\\) 径向位移:\\(\\Delta r_{2}=\\overline{C B}\\) 当\\(\\Delta t\\)很小时，由 \\[ \\begin{cases} &amp;|O A|=|O C|=r\\\\ &amp;|O B|-|O C|=\\Delta r \\end{cases} \\] 可得： \\[ \\begin{aligned} \\Delta \\boldsymbol{r}_{1} &amp; \\approx r \\Delta \\theta \\boldsymbol{e}_{\\theta} \\\\ \\Delta \\boldsymbol{r}_{2} &amp; \\approx \\Delta r \\boldsymbol{e}_{r} \\\\ \\boldsymbol{v}&amp;=\\lim _{\\Delta t \\rightarrow 0} \\frac{\\Delta \\boldsymbol{r}}{\\Delta t}=\\lim_{\\Delta t \\rightarrow 0} \\frac{r \\Delta \\theta \\boldsymbol{e}_{\\theta}}{\\Delta t}+\\lim_{\\Delta t \\rightarrow 0} \\frac{\\Delta r \\boldsymbol{e}_{r}}{\\Delta t} \\\\ &amp;=r \\dot{\\theta} \\boldsymbol{e}_{\\theta}+\\dot{r} \\boldsymbol{e}_{r}=v_{\\theta} \\boldsymbol{e}_{\\theta}+v_{r} \\boldsymbol{e}_{r} \\end{aligned} \\] 横向速度：\\(v_{\\theta} e_{\\theta}=r \\dot{\\theta} e_{\\theta}\\) 径向速度：\\(v_{r} \\boldsymbol{e}_{r}=\\dot{r} \\boldsymbol{e}_{r}\\) ​ 其中：\\(\\dot{\\theta}=\\mathrm{d} \\theta / \\mathrm{d} t, \\quad \\dot{r}=\\mathrm{d} r / \\mathrm{d} t\\) （b）矢量微分法 根据\\(\\pmb{e}_r\\)和\\(\\pmb{e}_{\\theta}\\)与\\(\\pmb{i}\\)和\\(\\pmb{j}\\)之间的关系式：\\(\\pmb{e}_{r}=\\pmb{i} \\cos \\theta+\\pmb{j} \\sin \\theta \\quad \\pmb{e}_{\\theta}=-\\pmb{i} \\sin \\theta+\\pmb{j} \\cos \\theta\\) 按照矢量求导规则，可得： \\[ \\begin{aligned} \\frac{\\mathrm{d} \\pmb{e}_{r}}{\\mathrm{d}t}&amp;=\\lim\\limits_{\\Delta t \\rightarrow 0} \\frac{\\Delta e_{r}}{\\Delta t}=\\lim\\limits_{\\Delta t \\rightarrow 0} \\frac{\\Delta \\theta}{\\Delta t} \\pmb{e}_{\\theta}=\\dot{\\theta} \\pmb{e}_{\\theta} \\\\ \\frac{\\mathrm{d} \\pmb{e}_{\\theta}}{\\mathrm{d} t}&amp;=\\lim_{\\Delta t \\rightarrow 0} \\frac{\\Delta \\pmb{e}_{\\theta}}{\\Delta t}=\\lim_{\\Delta t \\rightarrow 0} \\frac{\\Delta \\theta}{\\Delta t}\\left(-e_{r}\\right)=-\\dot{\\theta} e_{r} \\\\ \\boldsymbol{v} &amp;=\\frac{\\mathrm{d} \\boldsymbol{r}}{\\mathrm{d} t}=\\frac{\\mathrm{d}\\left(r \\boldsymbol{e}_{r}\\right)}{\\mathrm{d} t}=\\dot{r} \\boldsymbol{e}_{r}+r \\frac{\\mathrm{d} \\boldsymbol{e}_{r}}{\\mathrm{d} t}=\\dot{r} \\boldsymbol{e}_{r}+r \\dot{\\theta} \\boldsymbol{e}_{\\theta} \\\\ \\boldsymbol{a} &amp;=\\frac{\\mathrm{d} \\boldsymbol{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d}\\left(\\dot{\\boldsymbol{r}} \\boldsymbol{e}_{r}\\right)}{\\mathrm{d} t}+\\frac{\\mathrm{d}\\left(r \\dot{\\theta} \\boldsymbol{e}_{\\theta}\\right)}{\\mathrm{d} t} \\\\ &amp;=\\dot{r}^{*} \\boldsymbol{e}_{r}+\\dot{r} \\dot{\\theta} \\boldsymbol{e}_{\\theta}+\\dot{r} \\dot{\\theta} \\boldsymbol{e}_{\\theta}+r \\ddot{\\theta} \\boldsymbol{e}_{\\theta}-r \\dot{\\theta}^{2} \\boldsymbol{e}_{r} \\\\ &amp;=\\left(\\ddot{r}-r \\dot{\\theta}^{2}\\right) \\boldsymbol{e}_{r}+(r \\ddot{\\theta}+2 \\dot{r} \\dot{\\theta}) \\boldsymbol{e}_{\\theta} \\end{aligned} \\] 径向加速度：\\(a_{r} \\boldsymbol{e}_{r}=\\left(\\ddot{r}-r \\dot{\\theta}^{2}\\right) \\boldsymbol{e}_{r}\\) 横向加速度：\\(a_{\\theta} \\boldsymbol{e}_{\\theta}=(r \\ddot{\\theta}+2 \\dot{r} \\dot{\\theta}) \\boldsymbol{e}_{\\theta}\\) 自然坐标系、切向加速度和法向加速度（在质点运动轨迹已知的情况下选用）\\(S=S(t)\\) 自然坐标系：选定轨迹上任一点\\(O\\)为原点，用轨迹的长度\\(s\\)描写质点位置，并规定两个正交单位矢量——切向单位矢量\\(\\pmb{e}_t\\)和法向单位矢量\\(\\pmb{e}_n\\). 曲率圆：通过曲线上的一点\\(A\\)及其两个邻近的点作一个圆，在这三个点无限趋近的极限情况下，这个圆称为\\(A\\)点的曲率圆，其半径称为曲率半径\\(\\rho\\)。 曲率 速度：\\(\\boldsymbol{v}=\\boldsymbol{v} \\boldsymbol{e}_{t}=\\frac{\\mathrm{d}s}{\\mathrm{d}t}\\pmb{e}_t\\)（只有切向） 速率：\\(v=\\frac{\\mathrm{d} s}{\\mathrm{d} t}\\) 加速度：\\(\\vec{a}=\\dot{v} \\vec{e}_{t}+\\frac{v^{2}}{\\rho} \\vec{e}_{n}\\) 切向加速度：\\(a_t=\\frac{\\mathrm{d}v}{\\mathrm{d}t}\\) 法向加速度：\\(a_n=\\frac{v^2}{\\rho}\\) 当\\(\\Delta t\\)很小时，\\(\\Delta \\pmb {e}_{t} \\approx \\pmb{e}_{n} \\Delta \\varphi\\)，利用 \\[ \\begin{cases} &amp;\\frac{1}{\\rho}=\\lim _{\\Delta s \\rightarrow 0} \\frac{\\Delta \\varphi}{\\Delta s}=\\frac{\\mathrm{d} \\varphi}{\\mathrm{d} s}\\\\ &amp;\\mathrm{d} e_{\\mathrm{t}}=e_{\\mathrm{n}} \\mathrm{d} \\varphi=e_{\\mathrm{n}} \\frac{\\mathrm{d} s}{\\rho} \\end{cases} \\] 可得： \\[ \\begin{aligned} a &amp;=\\frac{\\mathrm{d} v}{\\mathrm{d} t}=\\frac{\\mathrm{d}}{\\mathrm{d} t}\\left(v \\boldsymbol{e}_{\\mathrm{t}}\\right)=\\frac{\\mathrm{d} v}{\\mathrm{d} t} \\boldsymbol{e}_{\\mathrm{t}}+v \\frac{\\mathrm{d} \\boldsymbol{e}_{\\mathrm{t}}}{\\mathrm{d} t} \\\\ &amp;=\\frac{\\mathrm{d} v}{\\mathrm{d} t} \\boldsymbol{e}_{\\mathrm{t}}+v \\frac{\\mathrm{d} s}{\\mathrm{d} t} \\frac{1}{\\rho} \\boldsymbol{e}_{\\mathrm{n}} \\\\ &amp;=\\frac{\\mathrm{d} v}{\\mathrm{d} t} \\boldsymbol{e}_{\\mathrm{t}}+\\frac{v^{2}}{\\rho} \\boldsymbol{e}_{\\mathrm{n}}=a_{\\mathrm{t}} \\boldsymbol{e}_{\\mathrm{t}}+a_{\\mathrm{n}} \\boldsymbol{e}_{\\mathrm{n}} \\end{aligned} \\] 相对运动 在解决实际问题时，常常需要处理参考系与参考系之间变换的问题。 如图 1 - 10 所示，参考系\\(S&#39;\\)相对于参考系\\(S\\)作平移。 坐标系变换 设参考系 相对于参考系\\(S\\)的位矢为\\(R\\)，则参考系\\(S&#39;\\)和参考系\\(S\\)间的 相对运动速度(牵连速度)：\\(\\pmb{v}_r=\\frac{\\mathrm{d} \\pmb{R}}{\\mathrm{d}t}\\) 加速度\\(\\pmb{a}_r\\)(牵连加速度)：\\(\\pmb{a}_r=\\frac{\\mathrm{d} \\pmb{v}_r}{\\mathrm{d}t}=\\frac{\\mathrm{d}^2 \\pmb{R}}{\\mathrm{d}t^2}\\) 若质点 P 在参考系\\(S\\)和\\(S&#39;\\)中的位矢、速度和加速度分别为\\(r,v,a\\)和\\(r&#39;,v&#39;,a&#39;\\), 则它们间的变换关系分别为： \\[ \\begin{aligned} \\pmb{r}&#39;&amp;=\\pmb{r}-\\pmb{R} \\\\ \\pmb{v}&#39;&amp;=\\frac{\\mathrm{d}\\pmb{r}}{\\mathrm{d} t}=\\frac{\\mathrm{d}\\pmb{R}}{\\mathrm{d}t}=\\pmb{v} -\\pmb{v}_r \\\\ \\pmb{a}&#39;&amp;=\\frac{\\mathrm{d}\\pmb{v}}{\\mathrm{d}t}-\\frac{\\mathrm{d}\\pmb{v}_r}{\\mathrm{d}t}=\\pmb{a}-\\pmb{a}_r \\end{aligned} \\] 这些变换关系式是建立在绝对时空观基础上的，在相对论中它们将被建立在相对论时空观基础上的洛伦兹变换所取代。 经典力学时空观： 在两个作相对运动的参考系中，时间的测量是绝对的，空间的测量也是绝对的，与参考系无关。时间和长度的的绝对性是经典力学或牛顿力学的基础。 习题 坐标系变换一般是飞机在空中飞行的风速和飞机速度，或者水中的行船问题等类似的问题画个图就 vans当然坐标系变换也可以是证明题，例如：证明：把两个物体以不同的速度抛出，则二者的相对速度是常矢量坐标系的互化常用的坐标系有：直角坐标系在一个倾角为\\(\\alpha\\)的山坡上开炮，相同的速度大小情况下，当发射角为多少时最远。（真的就高中题目呗）极坐标系一根细棒在水平面内以恒定角速度 \\(\\omega\\)旋转，有一只昆虫从圆心出发，以恒定速率 \\(u\\) 向外爬，求爬行速度和加速度。径向加速度：\\(a_{r}\\boldsymbol{e}_{r}=\\left(\\ddot{r}-r \\dot{\\theta}^{2}\\right)\\boldsymbol{e}_{r}\\)横向加速度：\\(a_{\\theta}\\boldsymbol{e}_{\\theta}=(r \\ddot{\\theta}+2 \\dot{r} \\dot{\\theta})\\boldsymbol{e}_{\\theta}\\)速度：\\(v=r \\dot{\\theta}\\boldsymbol{e}_{\\theta}+\\dot{r} \\boldsymbol{e}_{r}\\)实际上只需要记住：\\(\\dot e_\\theta=-\\dot \\theta e_r,\\dot e_r = \\dot\\theta e_\\theta\\)","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"},{"name":"运动学","slug":"运动学","permalink":"http://adversarr.github.io/tags/%E8%BF%90%E5%8A%A8%E5%AD%A6/"}],"author":"Clover"},{"title":"动量守恒和质点动力学","slug":"study/Physics/Ch2ConservationOfMomentumAndDynamicsofMassPoint","date":"2020-06-07T16:00:00.000Z","updated":"2022-04-06T03:32:58.023Z","comments":true,"path":"2020/06/08/study/Physics/Ch2ConservationOfMomentumAndDynamicsofMassPoint/","link":"","permalink":"http://adversarr.github.io/2020/06/08/study/Physics/Ch2ConservationOfMomentumAndDynamicsofMassPoint/","excerpt":"想当初，我也记过这么多东西，吖……","text":"想当初，我也记过这么多东西，吖…… Kinematics：研究如何描述物体的运动 基本问题：已知\\(\\pmb{r},\\pmb v,\\pmb a\\)中某一个求另外两个 解决问题的武器：根据定义进行微积分运算 Dynamics：研究外界作用与物体运动的关系 基本问题：已知运动求力，或已知力求运动 解决问题的武器：牛顿定律，动量定理及其守恒定律，动能定理及能量守恒定律，角动量定理及其守恒定律 惯性定律和惯性系 惯性定律 伽利略的推理：当一个球沿斜面向下滚动时速度增大，沿斜面向上滚动时速度减小，因此当球沿水平面滚动时其速度应该是既不增大也不减小。若没有摩擦力，球将会永远滚下去。 惯性定律（牛顿第一定律）： 任何物体，只要没有外力改变它的状态，便会永远保持静止或匀速直线运动的状态。 或者说：自由粒子永远保持静止或匀速直线运动的状态。 或者说：孤立质点静止或作匀速直线运动 在现实世界中，孤立质点可理解为质点虽受外界作用，但外界作用相互抵消。 惯性参考系 惯性定律在其中严格成立的参考系。 按定义，在各个惯性系之间是不能有加速运动的。换言之，相互有加速运动的参考系，不可能都是惯性系。 局部的惯性系：在引力场中作自由运动的参考系。 基本的惯性系：固定在地面上的参考系。地面赤道处的向心加速度约为\\(3.4 \\times 10 ^ {2} m/s^2\\). 近似的惯性系：地面、地球、太阳系、FK4 系等。 某参考系是否可看作惯性系，只能根据观察和实验来确定 相对惯性系做匀速直线运动的参考系也是惯性系 质量、动量和动量守恒定律 理想实验：两质点间的相互作用理想实验：假设两个质点只受到它们之间相互作用的影响，而与宇宙间的其他物质隔绝。实验内容：在时刻\\(t\\)：质点 1 在\\(A\\)，速度为\\(v_1\\)质点 2 在\\(B\\)，速度为\\(v_2\\)在稍后的时刻\\(t&#39;\\)：质点 1 在\\(A&#39;\\)，速度为\\(v_1&#39;\\)质点 2 在\\(B&#39;\\)，速度为\\(v_2&#39;\\)在时间间隔\\(\\Deltat\\)内，两质点的速度变化分别为：\\(\\Delta v_1 = v_1&#39;-v_1\\)\\(\\Delta v_2 = v_2&#39;-v_2\\)实验结果分析(从实验数据归纳出的四点结论)：在任意给定的时间间隔\\(\\Deltat\\)内，速度变化\\(\\Deltav_1\\)和\\(\\Deltav_2\\)的方向相反。\\(\\Delta t \\to 0\\)时，矢量\\(\\mathrm{d} v_1\\)和\\(\\mathrm{d}v_2\\)排在两质点的瞬时连线上。不论时间间隔大小如何，两物体速度变化的大小之比为定值\\(\\Delta v_1=-K_{12}\\Delta v_2\\)比例系数与质点有关（与如何运动无关）：\\(K_{12}=\\frac{m_2}{m_1}\\) 物体的质量（Mass） 惯性质量：表征物体速度改变难易程度（即惯性大小）的物理量 为了便于比较，并从中找出表征质点惯性大小的物理量，我们进行以下特别设计的实验： 实验: 选取某一质点\\(0\\)作为标准质点，并让质点\\(1,2,3,\\dots\\)分别与标准质点\\(0\\)相互作用，使标准质点\\(0\\)产生同样的速度变化 . 为了标明是相应于这种特定情况下的实验结果，我们将这类实验中 各质点的速度变化分别表示为\\(\\Delta v_0,\\Delta v_1^0,\\Delta v_2^0,\\dots\\) 于是，\\(\\Delta v_1^0,\\Delta v_2^0,\\dots\\)的大小就反映出了 各质点在相互作用过程中速度改变的难易程度，即质点惯性的大小，速度改变大的质点惯性小。 分析: 将前述理想实验的普遍结果\\(\\Delta v_1=-K_{12}\\Delta v_2\\)应用于这里所安排的特殊实验，我们可以对于各个质点对\\(\\lbrace 0,1\\rbrace,\\lbrace 0,2\\rbrace,\\lbrace 0,3\\rbrace,\\dots\\)所进行的实验，分别写出： \\[ \\Delta v_0=-K_{01}\\Delta v_1^0 \\\\ \\Delta v_0=-K_{02}\\Delta v_2^0 \\\\ \\Delta v_0=-K_{03}\\Delta v_3^0 \\\\ \\dots \\] 式中的比例常数\\(K_{0i}\\)对所给定的每一对质点\\(\\lbrace 0 , i \\rbrace\\)是确定的，与它们怎样运动无关。因此，我们可以把这些比例常数写为： \\[ K_{01}=\\frac{m_1}{m_0} \\\\ K_{02}=\\frac{m_2}{m_0} \\\\ K_{03}=\\frac{m_3}{m_0} \\\\ \\dots \\] 式中的\\(m_0,m_1,m_2,m_3,\\dots\\)分别称为质点\\(0,1,2,3,\\dots\\)的质量。 实际上，上述实验过程相当于把标准质点\\(0\\)的质量\\(m0\\)取为单位质量。在国际单位制中，质量的单位是 kg，即：\\(m_0=1\\space \\mathrm{kg}\\). 这样定义的质量，其大小反映了质点在相互作用过程中速度改变的难易程度，即质点惯性的大小，因此称为惯性质量，以区别于由万有引力定律定义的引力质量。 引力质量（gravitational mass）：用天平测出的，表征引力性质的质量 相对论质量：物体的质量随速度变化而变化 \\(m=m_0/\\sqrt{1-v^2/c^2}\\) 动量、动量守恒定律 动量和（两粒子相互作用过程中的守恒量） \\[ \\begin{aligned} &amp;K_{12}=\\frac{m_2}{m_1},\\quad\\Delta v_1=-K_{12}\\Delta v_2 \\\\ &amp;\\Delta v_1 = v_1&#39;-v_1 ,\\quad \\Delta v_2 = v_2&#39;-v_2 \\\\ \\Rightarrow\\space&amp;m_1v_1&#39;+m_2v_2&#39;=m_1v_1+m_2v_2 \\end{aligned} \\] 我们发现，在两质点的相互作用过程中，每个质点的质量\\(m\\)与其速度\\(v\\)的乘积之和是守恒量。通常用\\(\\pmb{p}=m\\pmb{v}\\)来表示这个乘积，称为这个质点的动量。 动量守恒定律（孤立系） 动量守恒定律（孤立系）可表述为： 一系统由两个质点组成，如果这两个质点只受到它们之间的相互作用，则这系统的总动量保持恒定，即 \\[ \\begin{aligned} &amp;\\pmb{p}_1&#39;+\\pmb{p}_2=\\pmb{p}_1+\\pmb{p}_2 \\\\ or \\quad &amp;\\pmb{p}_1+\\pmb{p}_2=Constant \\end{aligned} \\] 动量守恒定律的普适性 从现代物理学的理论高度来认识，动量守恒定律是惯性参考系中空间平移不变性的直接推论(见§4 - 4)，因而是物理学中最基本的普适原理之一。 从科学实践的角度来看，迄今为止，人们尚未发现动量守恒定律有任何例外，它在理论探讨和实际应用中发挥了巨大的作用。 在实验中每当观察到似乎是违反动量守恒定律的现象时，物理学家就提出一些新的假设来补救，最后总是以有所新发现而胜利告终。 \\(\\beta\\)衰变：原子核\\(X\\)放出电子\\({e^-}\\)后转化为原子核\\(Y\\). 预测：按动量守恒定律，若\\({X}\\)是孤立而静止的，则\\({X\\rightarrow Y~+~e^-}\\)产生的\\({Y}\\)必定会在与放射出来的\\({e^-}\\)的相反方向上反冲。 实验结果：云室照片显示二者径迹不在一条直线上。 分析：若坚持认为动量守恒定律是正确的，则必须假设这里还存在一个未被发现的粒子。 1930 年，泡利提出了中微子假说(例题 2.1)。 中微子既不带电又几乎无质量，在实验中极难测量。 1956 年，首次通过实验直接证明了中微子的存在。 力 冲量和动量定理 力的定义 利用动量的概念：\\(\\Delta p_1=-\\Delta p_2\\) 写成微分形式：\\(\\frac{\\mathrm{d}p_1}{\\mathrm{d}t}=-\\frac{\\mathrm{d}p_2}{\\mathrm{d}t}\\) \\(\\Rightarrow F=\\frac{\\mathrm{d}p_1}{\\mathrm{d}t}\\) 力：一个物体的动量对时间的变化率，定义为该物体所受到的外力。 \\(\\frac{\\mathrm{d}p_1}{\\mathrm{d}t}=-\\frac{\\mathrm{d}p_2}{\\mathrm{d}t}\\)表明，在任意时刻，构成孤立系的两个质点的动量瞬时变化率大小相等，方向相反。从另一个角度来看，当两个质点相互作用时，我们可以说每一个质点对另一个质点都作用一个力。 与此同时，质点 1 对质点 2 的作用力\\(F_{21}\\)，则为单位时间内质点 1 传递给质点 2 的动量，即\\(F_{12}=-F_{21}\\) 力的累积效应： 对\\(t\\)积累：\\(I,\\Delta p\\) 冲量 、动量定理、动量守恒 对\\(r\\)积累：\\(W,\\Delta E\\) 功、动能定理、机械能守恒 力的叠加原理、质点系动量守恒的条件 质点系：由若干个相互作用着的质点组成。 力的叠加原理：假定每个质点\\(i\\)的动量\\(p_i\\)的增加是所有其他质点传递给它的动量的矢量和；换言之，每个质点\\(i\\)所受到的力\\(F_i\\)，等于所有其他质点\\(j\\)对它的作用力\\(F_{ij}\\)的矢量和，即\\(\\frac{dp_i}{dt}=F_i=\\sum\\limits_{j \\neq i}{F_{ij}}\\)。 系统：从一个大体系中分离出一部分作为考虑对象。 外界：大体系的其余部分。 内力：系统内各质点之间的相互作用力 外力：外界质点对它们的作用力。 利用牛顿第三定律可以证明，系统的内力之和为零。因此，系统所受到的总力\\(F\\)等于系统所受到的合外力。 \\[ F=F^{in}+F^{ex}=\\sum{(F^{in}+F^{ex})}=\\sum F^{ex} \\] 所以，系统的总动量的瞬时变化率，就等于系统所受到的合外力。如果系统所受到的合外力为零，则有\\(\\frac{dp}{dt}=0\\quad p=\\sum{p_i}=Constant\\) 这是动量守恒定律的推广。 只要系统(不限于两个质点)所受到的合外力为零，其总动量就是守恒的。当\\(F^{ex}&lt;&lt;F^{in}\\)可忽略外力的作用。 若系统所受到的合外力的某个分量等于零，则总动量的相应分量是守恒的。 系统的动量守恒是指系统的总动量不变，系统内任一物体的动量是可变的，需注意各物体的动量要相对于同一惯性参考系。 动量守恒定律只在惯性参考系中成立, 是自然界最普遍，最基本的定律之一 。 牛顿运动定律 系统只包含一个质点，则有\\(F = \\frac{dp}{dt}=\\frac{dmv}{dt}\\) 换言之，一个质点所受到的力\\(F\\)，可由其本身动量\\(p=mv\\)的瞬时变化率来表征。 若质量 m 不随时间改变，则上式又可写为\\(F=m \\cdot a\\) 冲量和动量定理 冲量 利用\\(F = \\frac{dp}{dt}\\) \\[ \\int_{t_1}^{t_2}Fdt=p_2-p_1=m(v_2-v_1) \\] \\(I=\\int_{t_1}^{t_2}Fdt\\)称为在该时间间隔内作用在质点上的冲量。 质点的冲量定理 在一段时间内质点动量的增量，等于在此时间间隔内作用在该质点上的冲量。 特殊情形：冲击力物体之间的相互作用力，使物体在很短时间内动量发生了有限(或可观)的变化。冲击力与时间的关系曲线下的面积就等于力的冲量\\(I\\)(或动量的增量\\(p_2-p_1\\))的大小。平均冲击力：\\(\\overline{F}=\\frac{\\int_{t_1}^{t_2}Fdt}{t_2-t_1}=\\frac{p_2-p_1}{t_2-t_1}\\)实例：作用力\\(F\\)大小有限，作用时间非常短促，即\\(t_2-t_1\\to 0\\quad I \\to 0\\quad p_2-p_1 \\to0\\)物体的动量(或运动状态)将不会发生有限或可观的变化。变质量系统问题例题 2.2 火箭运动的基本原理密舍尔斯基方程：\\(m&#39;\\frac{\\mathrmd\\vec{v}}{\\mathrm dt}=\\vec{F}+\\vec u \\frac {\\mathrm d m&#39;}{\\mathrm dt}\\)\\(\\vec{u}\\)（离开的质量部分）相对速度 质点系的动量定理 作用于系统的合外力的冲量等于系统动量的增量\\(I=\\int F^{ex}\\mathrm {d} t\\) 注意 区分外力和内力 内力京能改变系统内单个物体的动量但不能改变系统的总动量 牛顿运动定律及其运用 动力学以牛顿运动定律为基础，研究物体运动状态发生改变所遵循的规律。 牛顿运动定律的表述 牛顿第一定律：任何物体，只要没有外力改变它的状态，便永远保持静止或匀速直线运动的状态。惯性：物体保持其运动状态不变的性质。 牛顿第二定律：在受到外力作用时，物体所获得的加速度的大小与外力矢量和的大小成正比，并与物体的质量成反比，加速度的方向与外力矢量和的方向相同，即\\(F=ma\\) 牛顿第三定律：两物体相互作用时，作用力和反作用力大小相等，方向相反，在同一条直线上。若用 1 和 2 表示这两个物体，则有\\(F_{12}=-F_{21}\\). 作用力和反作用力总是成对出现。 作用力和反作用力分别作用于两个物体，因此不能平衡或抵消。 作用力和反作用力属于同一种性质的力。 牛顿运动定律成立的条件：惯性参考系中的质点。 牛顿运动定律和守恒定律 力的概念和牛顿运动定律 当我们只讨论一个物体的运动时，可以只分析该物体本身所受到的各种力，直接应用力的概念和牛顿运动定律来解决问题。 牛顿运动定律是以力的概念为核心的，认为力是改变物体运动状态的原因。 在净力(净力，是指作用于同一物体上的多个力的合，通常为矢量和。)\\(F\\)的作用下，一个质量为 m 的质点将按牛顿第二定律受到加速。 隔离体法：设想把系统的各个部分隔离开来，应用牛顿运动定律来分析它的每一部分的运动。 质点系：设想把所研究的系统看成是一个内部有相互作用的质点系，将牛顿运动定律应用到质点系的每一个质点上，然后再研究整个物体或物体系的运动。 这时，往往并不需要了解每个质点的运动情况，而只要知道某些整体运动的特征。开山填沟的定向爆破问题。 运动定理、守恒定律 运动定理：动量定理、角动量定理和动能定理等。 按照历史的发展过程，运动定理和守恒定律起初是从牛顿运动定律导出来的。 然而，物理学的发展表明，即使在牛顿运动定律不再适用的许多场合，守恒定律仍然有效。这样，原来仅仅作为牛顿运动定律辅助工具而引入的运动定理的推论——守恒定律，就成为比牛顿运动定律更为基本的规律了。 除了基本的重要性外，守恒定律的应用对于解决很多实际问题也是十分重要的，这在物理学的近代发展中起了重要的作用。 两类动力学问题 作用在物体上的力&lt;=&gt;物体的运动情况或平衡状态 已知作用在物体上的力，由力学规律来决定该物体的运动情况或平衡状态 这类动力学问题代表一种纯粹演绎的过程，它是对物理学和工程学的问题作出成功的分析和设计的基础。 已知物体的运动情况或平衡状态，由力学规律来推论作用在物体上的力 这类动力学问题包括了力学的归纳性和探索性的应用，这是发现新定律的一个重要途径。 牛顿从开普勒行星运动规律归纳出万有引力定律，卢瑟福通过\\(\\beta\\)粒子散射实验发现原子的有核结构，人们还正在进一步通过高能粒子的散射实验去了解粒子的结构及其相互作用等等。 当然，通过整理实验观测结果去寻求力，往往是比较困难的。 自然界中几种常见力 万有引力 \\(F_{21}=-G\\frac{m_1m_2}{r^2}{e}_r,\\\\ e_r=\\frac{\\vec r}{r}\\) \\(g_0=9.83m/s^2\\) 星体之间，地球与地球表面附近的物体之间，以及所有物体与物体之间都存在着一种相互吸引的力。 惯性质量和引力质量： 弹性力 胡克定律：\\(F=-kx\\) 物体发生弹性形变后，内部产生欲恢复形变的力。弹簧弹性力、绳索内张力、正压力和支持力） 摩擦力 静摩擦力、最大静摩擦力、滑动摩擦力 伽利略相对性原理和非惯性系 伽利略相对性原理 对于一个封闭船舱内所发生的现象，伽利略曾生动地描绘道：\"即使船运动得相当快，在跳跃时你也将和以前一样。在船底板上跳过相同的距离，你跳向船尾也不会比跳向船头来得远，虽然你跳在空中时，脚下的船底板向着你跳的相反方向移动。……水滴将像先前一样滴进下面的罐子，一滴也不会滴向船尾。\" 在一个相对于惯性系作匀速直线运动的参考系内部，所发生的一切力学过程都不受系统作匀速直线运动的影响。 不可能利用在惯性系内部进行的任何力学实验，来确定该系统作匀速直线运动的速度。 伽利略相对性原理（力学相对性原理）：力学定律在所有惯性系中都是相同的。 推论：相对于一惯性系作匀速直线运动的一切参考系都是惯性系。 力学规律对于一切惯性系都是等价的，不存在特殊的绝对的惯性系。 伽利略变换 上述等价性并不是说在不同的惯性系中所看到的现象都是相同的。同一物体的运动轨道和运动速度，在不同惯性系中看来显然可以是不同的。我们有必要建立关于一个事件在两个惯性系中的两组时空坐标之间的变换关系。 事件：某一时刻发生在空间某一点上的一个事例。 在四维时空空间中，一个事件对应于一个时空点。 在§1-2中讨论相对运动时，我们导出了质点在两个相互作平移的参考系(惯性系或非惯性系)中的位矢、速度和加速度之间的变换关系式。 现在，我们来讨论两个相对作匀速直线运动的惯性参考系\\(S\\)和\\(S&#39;\\)之间的变换关系。 由于坐标轴的取向可以任意选择，我们取\\(x\\)和\\(x&#39;\\)轴沿相对速度\\(v_r\\)的方向。若把矢量式\\(r&#39;=r-R,\\quad R=v_rt\\)写成分量形式，并将时间关系也明确地表达出来，即得两惯性系\\(S\\)和\\(S&#39;\\)之间的时空坐标变换关系式为： \\[ \\begin{aligned} x&#39;&amp;=x-v_rt, \\\\ y&#39;&amp;=y, \\\\ z&#39;&amp;=z, \\\\ t&#39;&amp;=t \\end{aligned} \\] 该变换称为伽利略变换，它给出了同一时空点在惯性系 和 中时空坐标之间的变换公式。 绝对时空观：伽利略变换式\\(t&#39;=t\\)意味着，在这里我们定义了一个与参考系无关的绝对的时间。实际上，绝对时间的假设还必然会引出长度具有绝对性的结论，即物体的长度也与参考系无关。经典力学正是建立在这样一种绝对时空观基础上的，而伽利略变换就是它的具体体现。 非惯性系 惯性系：研究地面上一般物体在不太长时间内所进行的力学过程时，可以把地球看成是近似程度相当好的惯性系。 非惯性系：（在要求较高精度的问题中，特别是在研究大气环流等大尺度的运动时，我们必须考虑到地球的非惯性系因素的影响。） 相对于惯性系做加速运动的参考系 牛顿运动定律只在惯性系中成立。原则上，我们可以以惯性系为基础，处理在非惯性系中物体运动的力学问题。 目标：用普遍的物理考虑(引进惯性力的概念)，使我们能够用统一的(牛顿运动定律)形式来处理非惯性系和惯性系中物体运动的力学问题。 出发点：具体讨论非惯性系相对于惯性系的运动。 固联在地面上的参考系，其原点 O 随着地球的自转而绕地轴 C 作圆周运动，其坐标架的运动可以分解为随原点的平移和围绕原点的转动两部分。 一般而言，一个参考系的运动，可以看成是由两部分组成的： 跟随原点的平移，即固联在参考系上的任一直线在各时刻的方向始终保持平行的运动； 坐标轴围绕原点的转动。 几点结论： 加速平移的后果是产生惯性力. 转动的后果是产生惯性离心力和科里奥利力。 惯性力与质点的速度无关，而科里奥利力却依赖于质点的速度。 加速平移参考系中的惯性力 假设非惯性系\\(S&#39;&#39;\\)相对于惯性系\\(S\\)以加速度\\(a_r\\)平移，则质点在\\(S&#39;&#39;\\)系和\\(S\\)系中的加速度\\(a&#39;&#39;\\)和 a 满足式\\(\\pmb a&#39;&#39;=\\pmb a-\\pmb a_r\\) 在惯性系\\(S\\)中，牛顿运动定律成立，我们有\\(\\pmb F=m\\pmb a\\) 在非惯性系\\(S&#39;&#39;\\)中，牛顿第二定律的上述表达式可以写为\\(\\pmb F = m(\\pmb a&#39;&#39;+\\pmb a_r)\\) 如果我们设想有一个附加的力——惯性力: \\(\\pmb F_{\\bold i}=-m\\pmb a_r\\) 惯性力是在而非惯性系中物体受到的一种\"力\"， 惯性力由于非惯性系相对于惯性系加速运动引起的，与非惯性系加速度方向相反。 惯性力是虚拟力，没有施力物体、反作用力 惯性力可以测量和感受，可以看成是实在的力 从惯性系看，惯性力是惯性的一种表现形式 注意：动量守恒只在惯性系中成立！ 惯性离心力 圆盘实验： 水平圆盘以角速度\\(\\omega\\)绕通过圆心的竖直轴转动 惯性离心力：\\(\\pmb{F}_\\mathrm i=m\\omega^2\\pmb r\\) 科里奥利力 类比为何卫星上升可以减速 如果在绕竖直轴 O 的一个匀角速度 w 运行的圆盘中心有一个光滑小孔，m 以匀速 v'向外运动。则 \\[ \\begin{aligned} a&amp;=\\frac{dv}{dt}=\\frac{\\mathrm{d}(\\dot r \\vec e_r+r\\dot \\theta \\vec e_ \\theta )}{\\mathrm d t}\\\\ &amp;=\\ddot r \\vec e_r+\\dot r\\dot\\theta\\vec e_\\theta+\\dot r\\dot \\theta\\vec e_\\theta+r\\ddot\\theta\\vec e_\\theta+r\\dot \\theta(-\\dot \\theta\\vec e_r)\\\\ &amp;=-r\\dot\\theta^2\\vec e_r+2v\\dot \\theta \\vec e_\\theta \\end{aligned} \\] 在这里：\\(-r\\dot\\theta^2\\vec e_r\\)是惯性离心力的表示，而后者就是科里奥利力\\(\\pmb F_\\mathrm c=-2mv&#39;w\\pmb e_\\theta = 2m\\pmb v&#39; \\times\\pmb \\omega\\) 习题 这部分好难，唉 知道运动状态求力最简单的题目，例如例题 2-2一辆货车以 \\(3m/s\\)恒定速度前进，煤以 \\(5t/s\\)的速率竖直注入车厢，求牵引力实际上很简单，用微元法并运用动量守恒列方程即可，一道十分简单的变质量运动问题。也有例题 2-17超速离心机的转速为 \\(1000转/s\\)，求转轴 \\(10\\mathrm{cm}\\)处的分子受到惯性力和重力之比变质量系统问题题解稍难一些的变质量运动问题：例题 2-7一架喷气式飞机以 \\(v=210~\\mathrm{m/s}\\) 飞行，其引擎每秒吸入\\(75~\\mathrm{kg}\\) 空气，并与 \\(3~\\mathrm{kg}\\) 燃料混合后，以相对于飞机\\(u=490~\\mathrm{m/s}\\)的速度向后喷出，求推力。实际上可以直接给出一个标准的解题方式：设火箭在 \\(t\\) 时刻有质量 \\(m&#39;\\)，速度为 \\(v\\)，使用微元法，在 \\(dt\\) 时间内，有燃料 \\(dm\\) 相对火箭以 \\(u\\) 的速度喷出，火箭速度为 \\(v+dv\\)：\\[\\begin{array}{l}\\vec F\\mathrm dt=m&#39;\\mathrm d\\vec v+\\vec u\\mathrm dm\\\\\\Rightarrow\\vec v =\\vec v_0+\\mathrm u\\ln\\frac {m&#39;}{m&#39;_0}\\end{array}\\]用微元法是解决变质量系统问题的常用方法例题 2.2 火箭运动的基本原理密舍尔斯基方程：\\(m&#39;\\frac{\\mathrmd\\vec{v}}{\\mathrm dt}=\\vec{F}+\\vec u \\frac {\\mathrm d m&#39;}{\\mathrm dt}\\)\\(\\vec{u}\\)（离开的质量部分）相对速度知道力求运动状态这一部分的题目相对简单，选择合理的坐标系并且列出运动方程即可。一般分情况讨论的问题居多例题 2-11给定一个平面和三个木块（水平一排相靠放在桌上），现 F作用在最左侧的木块，讨论不同推力、不同摩擦系数情况下，物体的相互作用力大小。这里直接列一些公式和条件即可解出，求运动状态的特征不明显。或者是例题 2-14物体 \\(m\\) 从高度为 \\(h\\) 初下落如水中，在水中有粘滞阻力 \\(bv^2\\) 求 \\(x(t),v(t)\\)直角坐标系下解出结果即可极坐标系下常常有旋转半径约束，只需要记住 \\(\\displaystyleF=mr^2\\omega=mvr=m\\frac{v^2}r\\)例题 2-19有一个密度均匀的球体，以角速度 \\(\\omega\\)绕自身几何对称轴旋转，若维持其表面物质不因快速旋转二被甩掉的力只有万有引力，求其密度的最小值。伽利略变换、相对运动、非惯性系这类题目较少，但实则非常难升降机中光滑桌面上有物体 \\(m_A=100g\\) ，通过滑轮与物体 \\(m_B=200g\\) 相连。当升降机以加速度 \\(a\\) 上升，求升降机内、地面上两人看到的\\(A,B\\) 的加速度。细心一点，多花点时间计算和复查，问题不大。动量定理、动量守恒多用矢量表示动量。设有一静止的原子核，衰变辐射出一个电子和一个反中微子后成为一个新的原子核。已知电子和反中微子的运动方向互相垂直，且电子动量为\\(1.2\\times10^{-22}\\mathrm{kg·m·s^{-1}}\\)，反中微子的动量为\\(6.4\\times10^{-23}\\mathrm{kg·m·s^{-1}}\\)。问新的原子核的动量的值和方向如何？动量定理的题目一般不难：质量\\(m=1kg\\)的质点从 O 点开始沿半径R=2m 的圆周逆时针运动。以 O 点为自然坐标原点，已知质点的运动方程为 \\(s=0.5\\pi t^2\\mathrm m\\)。试求从 \\(t=\\sqrt 2s\\) 到 \\(t=2s\\) 这段时间内质点所受合外力的冲量。","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"}],"author":"Clover"},{"title":"机械能守恒","slug":"study/Physics/Ch3ConservationofMechanicalEnergy","date":"2020-06-07T16:00:00.000Z","updated":"2022-04-06T03:32:58.023Z","comments":true,"path":"2020/06/08/study/Physics/Ch3ConservationofMechanicalEnergy/","link":"","permalink":"http://adversarr.github.io/2020/06/08/study/Physics/Ch3ConservationofMechanicalEnergy/","excerpt":"基础物理学Ch3 机械能守恒 这部分就简单提一句","text":"基础物理学Ch3 机械能守恒 这部分就简单提一句 功 动能定理 功（Work） 力对质点所作的功为力在质点位移方向的分量（大小）与位移大小的乘积。（功是标量，过程量） 一段位移的功\\(\\mathrm dW=\\vec F\\cdot \\mathrm d {\\vec r}\\) 注：功的大小和参考系有关。 合力的功（第二型曲线积分） 功率（Power）：反应做功快慢程度的物理量 平均功率 瞬时功率 功率单位 质点的动能定理（Theoremof Kinetic Energy）动能：\\(E_\\mathrm{k}=\\frac{1}{2}mv^2=\\frac{p^2}{2m}\\)动能定理：合外力对质点所做的功，等于质点动能的增量。功和动能都与参考系有关，动能定理只能适用于惯性系！ 保守力 势能 万有引力、重力、弹性力做功的特点 万有引力做功万有引力：\\(\\vecF=-G\\frac{m&#39;m}{r^3}\\vec r\\)做功：\\(W=(-G\\frac{m&#39;m}{r_A})-(-G\\frac{m&#39;m}{r_B})\\)重力做功\\(\\vec P=-mg\\vec k\\)\\(W=\\int_A^b \\vec P \\cdot \\mathrm d \\vecr=mgz_A-mgz_B\\)弹性力做功\\(W=\\frac{1}{2}kx_A^2-\\frac{1}{2}kx_B^2\\) 保守力和非保守力 保守力：力所做的功与路径无关，仅取决于质点的始末位置，具有这种特征的力统称为保守力。 物体沿闭合路径运动一周，保守力对它所做功为零 实则是旋度为零 非保守力：做功与路径有关 旋度不恒为零 有关旋度，参见 Post not found: Advanced-Mathematics/Vectors-and-Analytic-Geometry-Integration 势能（Potential Energy） 保守力做功等于势能的减少或势能增量的负值。 势能：与物体间相互作用及相对位置有关的能量 势能是空间位置的函数 势能具有相对性，势能大小与势能零点的选取有关 . 势能是属于系统的 ，所以又称为相互作用势能. 势能的计算：物体在某位置时的势能 引力势能，以无穷远处为势能零点 重力势能，以地面为势能零点 弹性势能，以物体为势能零点 势能函数与保守力的关系 积分形式：\\(W= - \\Delta E_p\\) 微分形式：\\(\\vec F \\mathrm d\\vec r= -\\mathrm d E_p\\)（对\\(\\vec r\\)的偏导） \\(\\nabla\\)算符举例： \\[ \\nabla=( \\begin{matrix} \\frac{\\mathrm d}{\\mathrm d x}, \\frac{\\mathrm d}{\\mathrm d y}, \\frac{\\mathrm d}{\\mathrm d z} \\end{matrix}) \\] 保守体系的平衡及平衡条件： stable 稳定平衡 不稳定平衡 随遇平衡 条件：\\(\\nabla E_p=0\\) 功能原理 机械能守恒定律 质点系的动能定理 \\(\\sum W_i =W_{ext}+W_{int}\\) \\(\\Rightarrow W_{ext}+W{int}=\\sum E_{ki}+ \\sum E_{ki0}\\) 质点系的功能原理 质点系在运动过程中，所有外力的功和系统内非保守内力的功的总和等于系统机械能够的增量。\\(W_{ext}+W_{int(非保守力)}=E-E_0\\) 机械能守恒定律 当\\(W_{ext}+W_{int(非保守力)}=0\\)时：\\(E=E_0\\) 当作用于质点系的外力和非保守内力都不做功或所做功的代数和等于零时，系统的总机械能保持不变。 功总是和能量的变化与转换过程相联系，功是能量变化和转换的一种量度，而能量是代表物体系统在一定条件下所具有的作功本领。 守恒定律的特点和优点：不研究过程细节而能对系统的状态下结论。 势能函数 质心参考系 质心的定义 由 n 个质点组成的质点系，其质心的位矢：\\(\\vec r_C=\\frac{\\sum m\\vec r}{\\sum m}\\) 质心运动定理 \\(\\vec F^{ex}=m\\vec a_c\\) 质心参考系的特点 零动量参考系： \\(\\sum p = \\sum m\\vec v = 0\\) \\(\\sum m\\vec r = 0,\\quad \\sum m\\vec a =0\\) 克尼希定理： 质点系相对基本参考系的动能（绝对动能） 等于质点系在质心参考系中的动能（相对动能）加上质心动能 \\(E_k = \\frac{1}{2} mv_c^2 + E_k&#39;= \\frac{1}{2} mv_c^2 + \\sum \\frac{1}{2} m_i v_i ^2\\)","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"}],"author":"Clover"},{"title":"角动量守恒","slug":"study/Physics/Ch4","date":"2020-06-07T16:00:00.000Z","updated":"2022-04-06T03:32:58.003Z","comments":true,"path":"2020/06/08/study/Physics/Ch4/","link":"","permalink":"http://adversarr.github.io/2020/06/08/study/Physics/Ch4/","excerpt":"基础物理学Ch4 角动量守恒","text":"基础物理学Ch4 角动量守恒 角动量、角动量守恒定律 「角动量」：\\(\\vec L = \\vec r \\times \\vec p = \\vec r \\times m \\vec v\\)（角动量、动量矩） 在圆周运动中：\\(L = mr^2 w\\) 角动量守恒定律：\\(L_1+L_2= const\\)一个系统由两个质点组成，若两个质点只受到它们之间的相互作用，则这个系统的总角动量保持恒定。 力矩 、角动量定理 力矩、质点的角动量定理 \\(L = r\\times p\\Rightarrow\\) (对t微分) \\(\\displaystyle\\frac{\\mathrm d L}{\\mathrm d t} = r\\times F\\) 定义为\\(M\\)（力矩） 反之，对上式积分，\\(\\int \\vec M \\mathrm d t = \\vec L _ 2 - \\vec L _ 1\\)（角冲量）（或者写成 \\(\\mathrm d \\vec L = \\vec M \\mathrm d t\\) ）地方 「角动量定理」：质点对任一固定点的角动量的时间变化率，等于外力对该点的力矩。 质点系的角动量定理 \\(L = \\sum L = \\sum r \\times p=\\sum r\\times mv\\) 对 \\(t\\) 求导：\\(\\frac{\\mathrm d L}{\\mathrm d t} = M^{ex}+M^{in}\\) 而在质点系中，由牛顿第三定律：\\(M^{in}=0\\) 「质点系的角动量定理」： - 质点系对惯性系中某个参考点的角动量的时间变化率，等与作用在该质点系上的所有外力对该给定参考点的总力矩。 - \\(\\frac {\\mathrm d L}{\\mathrm d t} = M^{ex}\\) 「质点系的角动量守恒定律」：（总外力矩为零时）\\(L = const , \\mathrm dL =0\\) 质心系的角动量定理 「质点组相对于质心的角动量」： \\(L = \\vec r_c \\times m\\vec v_c+\\sum \\vec r_i \\times m_i \\vec v_i&#39; = L_c+m\\boldsymbol r_c\\times\\boldsymbol a_c\\) 质点系对固定点 O 的角动量 L，等于质点系对其质心 C 的角动量 \\(L_c\\) 加上质量集中在质心上随之运动时对 O 点的角动量 \\(m\\boldsymbol r_c\\times\\boldsymbol a_c\\) 「质心系角动量定理」 \\(M_c^{ex} = \\frac{\\mathrm dL_c}{\\mathrm dt}\\) 质点系对质心的角动量的时间变化率，等与作用在该质点系上的所有外力对质心的总力矩。 「质点组对质心的角动量守恒」 质点在有心力场中的运动 质心在有心力场中运动的一般描述 \\[ \\begin{cases} e_r方向\\qquad m(\\ddot{r} - r\\dot\\theta^2)=F(r)\\\\ e_\\theta 方向\\qquad m(2\\dot r\\dot\\theta + r\\ddot\\theta)=0 \\end{cases} \\] 机械能守恒和角动量守恒 离心势能和有效势 机械能守恒定律可以改写为：\\(\\displaystyle\\tilde{E}_p(r)=E_p(r)+\\frac{L^2}{2mr^2}\\) 有效势能 离心势能 将二维问题，化为一维问题。 「守恒定律」动量能量角动量质量电荷宇称守恒定律","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"}],"author":"Clover"},{"title":"刚体运动学","slug":"study/Physics/Ch5","date":"2020-06-07T16:00:00.000Z","updated":"2022-04-06T03:32:58.003Z","comments":true,"path":"2020/06/08/study/Physics/Ch5/","link":"","permalink":"http://adversarr.github.io/2020/06/08/study/Physics/Ch5/","excerpt":"基础物理学Ch5 刚体运动学","text":"基础物理学Ch5 刚体运动学 基本问题： 运动 动力学 能量 刚体运动学 「刚体」：在外力作用下，形状大小不变的物体（任意两个质点之间的距离保持不变）这是一个理想模型！ 「运动形式」： 平动 转动 定轴转动 定点转动 滚动（平面平行运动） 刚体的平动 平动：所有点的运动轨迹都保持完全相同（任意两点连线总平行与初始位置间的连线） 特点：各点运动特征相同 化为质点运动求解 定轴转动 角坐标：\\(\\theta(t)\\) 角位移：\\(\\Delta \\theta\\) 角速度矢量：\\(\\omega = \\lim \\frac{\\Delta \\theta}{\\Delta t}\\) 定轴转动的特点： 每个质点均做圆周运动 ，圆面为转动平面。 任一质点运动\\(\\Delta \\theta \\omega \\alpha\\)相同，但是\\(v,a\\)不同 运动描述仅需一个角坐标 角量\\(\\omega\\)与线量\\(v\\)的关系：\\(\\vec v = \\omega r \\vec{e_t} = \\vec \\omega \\times \\vec r\\) 「匀变速定轴转动的运动学公式」 质点平动 刚体绕轴转动 \\(v=v_0+at\\) \\(\\omega = \\omega_0+\\alpha t\\) \\(x=x_0+v_0t+\\frac 1 2 at^2\\) \\(\\theta = \\theta_0+\\omega_0 t + \\frac 1 2 \\alpha t^2\\) \\(v^2 = v_0^2 + 2 a (x -x_0)\\) \\(\\omega^2 = \\omega_0^2 +2 a (\\theta -\\theta_0)\\) 平面平行运动（滚动） 平面平行运动可以看成： 刚体随质心的平动：\\(\\vec v,~\\vec a\\) 刚体绕质心的转动：\\(\\vec \\omega,~\\vec \\alpha\\) 只考虑纯滚动的情况下（接触点速度为 0）： 平动路程\\(s = R \\theta\\) 质心速度大小\\(v_c = R\\omega\\) 质心加速度大小\\(a = R \\alpha\\) 刚体动力学 转动惯量 意义：转动惯性的量度 计算方法： 离散：\\(\\sum m r ^2\\) 连续：\\(\\int r^2 \\mathrm d m\\) 取决于质量、形状、位置。 质量是\\(m\\)长度\\(l\\)的棒，以中点为轴：\\(I = \\frac{1}{12} ml^2\\)质量是\\(m\\)长度\\(l\\)的棒，以一个端点为轴：\\(I = \\frac{1}{3} ml^2\\)质量是\\(m\\)半径\\(R\\)的圆盘，以中心为轴：\\(I = \\frac{1}{2} mR^2\\)平行轴定理：质量为 m的刚体，如果对其质心轴的转动惯量为 \\(I_C\\)则，对于任意与该轴平行的轴而言，相距为 d 时的转动惯量：\\(I_O=I_C+md^2\\)垂直轴定理（对于一个薄板而言）：\\(I_z = I_x +I_y\\) 刚体定轴转动的角动量定理和角动量守恒 「刚体定轴转动的角动量」：\\(L_z = \\sum\\limits_i m_i r_i^2\\omega = I\\omega\\) 「刚体定轴转动的角动量定理」：\\(\\int M_z \\mathrm{d}t = I\\omega_2 -I \\omega_1\\) 「刚体定轴转动的角动量守恒定律」：\\(if M_z = 0 ,\\ then \\ L_z = I\\omega = const\\) 「刚体定轴转动的角冲量定理」：\\(\\int M_z\\mathrm dt=I_z\\omega -I_z\\omega_0\\) 刚体定轴转动的动能定理 微分形式\\(\\mathrm{ d} W = \\vec{F}\\cdot \\mathrm d \\vec{r} = F_t r\\mathrm{d} \\theta = M_z \\mathrm d \\theta\\) 力矩对定轴转动刚体做功：\\(W = \\int _{\\theta_1}^{\\theta_2}M_z \\mathrm{d} \\theta\\) 力矩的功率：\\(P= \\frac{\\mathrm{d} W}{\\mathrm{ d} t}=M_z \\omega\\) 「刚体定轴转动的动能」：\\(E_k = \\frac 1 2 I\\omega^2\\) 「刚体绕定轴转动的动能定理」：\\(W = \\int_{\\theta_1}^{\\theta_2} I \\omega \\mathrm{d} \\omega = E_{k2} - E_{k1 = }=\\frac 1 2 I\\omega_2^2-\\frac 1 2 I\\omega_1^2\\) 刚体的定点转动（进动）（Precession） 陀螺的进动角速度：\\(\\omega_\\mathrm p = \\frac {\\mathrm d \\phi}{\\mathrm d t} = \\frac{|\\mathrm d L|}{\\mathrm d t\\cdot L\\sin \\theta} = \\frac{mgr_c}{I\\omega}\\) 注意角加速度的方向。注意理解场平架陀螺仪工作原理。 刚体动力学：总结 质心运动定理：\\(\\vec{F}= m\\vec{a_c}\\) 转动定律：\\(M_c = I_c \\alpha ,\\quad v_c = R \\omega\\) 平面平行运动能量：（科尼希定理）\\(E_k = E_{kc} +E_k&#39; = \\frac{1}{2} mv_c^2 + \\frac{1}{2}I_c \\omega^2\\)","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"}],"author":"Clover"},{"title":"狭义相对论","slug":"study/Physics/Ch7","date":"2020-06-07T16:00:00.000Z","updated":"2022-04-06T03:32:54.942Z","comments":true,"path":"2020/06/08/study/Physics/Ch7/","link":"","permalink":"http://adversarr.github.io/2020/06/08/study/Physics/Ch7/","excerpt":"基础物理学Ch7 狭义相对论","text":"基础物理学Ch7 狭义相对论 狭义相对论的基本假设 绝对时空观与伽利略相对性原理 长度、时间间隔、质量、相互作用力与参考系无关 速度、位移、加速度满足伽利略变换关系（速度变换式、时空变换式） 电磁学发展及其与绝对时空观的规律 电磁学规律： Maxwell方程组 \\(c = \\frac{1}{\\sqrt{\\epsilon_0 \\mu_0}}\\) 电磁学规律与绝对时空观的矛盾 光速与参考系无关 矛盾解决 伽利略速度变换正确，而光速只适用于特殊的参考系：以太参考系 相对性原理对电磁学规律也适用，为了保持光速不变，需要建立新的时空变换关系 狭义相对论的基本内容 事件何时发生？在哪里发生？ 事件之间相隔多远？相隔多久？ 时间和空间是否有关联？ 时间和长度的测量与参考系是否有关？ 物体的质量与运动是否有关？ 两个基本假设 相对性原理（The Relativity Postulate）：物理性质在所有惯性系中具有相同的表达形式 光速不变原理（The Speed of Light Postulate） 相对论时空观 \\(S\\)系观测，\\(S&#39;\\)系运动 同时具有相对意义。 时间延缓（Time Dilation） 固有时：某个参考系中同一个地点发生的两事件的时间间隔 在\\(S\\)系中观测：\\(\\Delta t=\\frac{\\Delta t_0}{ \\sqrt{1-(v/c)^2}}\\) 运动的钟走得慢 时间间隔是相对的，与参考系有关。 长度收缩（length contraction） 固有长度：静止棒在一个静止的坐标系中的长度 在\\(S\\)系中观测：\\(l = l&#39; \\sqrt{1-(v/c)^2}\\) 运动的棒长度变短或收缩，长度或时间间隔是相对的，与参考系有关。 洛伦兹变换 \\[ \\begin{cases} （S观测\\rightarrow S&#39;观测）已知P在S系中的时空坐标t,x: \\\\ \\qquad x = vt+x&#39;\\sqrt{1-\\beta^2} \\rightarrow x&#39; = \\frac{x- vt}{\\sqrt{1-\\beta ^2}}\\\\ （S观测\\rightarrow S&#39;观测）已知P在S系中的时空坐标t,x： \\\\ \\qquad x&#39; = x\\sqrt{1-\\beta^2} - vt&#39;\\rightarrow t&#39; = \\frac{t-\\frac v c^2 x}{\\sqrt{1-\\beta^2}} \\end{cases} \\] \\[ \\Rightarrow \\begin{cases} x&#39; = \\gamma (x- vt)\\\\ y&#39; = y\\\\ z&#39; = z\\\\ t&#39; = \\gamma(t -\\frac{v}{c^2}x)\\\\ \\gamma = \\frac{1}{\\sqrt{1 - \\beta ^2}} \\end{cases} \\] 做全微分： \\[ \\begin{aligned} &amp;dx&#39; =\\gamma({dx - vdt}),\\\\ &amp;dt&#39; = \\gamma(dt - (v/c^2)dx)\\\\ \\Rightarrow &amp;u_x&#39; = \\frac{dx}{dt} = \\frac{u_x -v}{1-\\frac v {c^2}u_x }\\\\ \\end{aligned} \\] 类似的，可以得到： 正变换： \\[ \\left\\{ \\begin{aligned} u_{x}^{\\prime}&amp;=\\frac{u_{x}-v}{1-\\frac{v}{c^{2}} u_{x}} \\\\ u_{y}^{\\prime}&amp;=\\frac{u_{y}}{\\gamma\\left(1-\\frac{v}{c^{2}} u_{x}\\right)} \\\\ u_{z}^{\\prime}&amp;=\\frac{u_{z}}{\\gamma\\left(1-\\frac{v}{c^{2}} u_{x}\\right)} \\end{aligned} \\right. \\] 逆变换： \\[ \\left\\{ \\begin{aligned} u_{x} &amp;=\\frac{u_{x}^{\\prime}+v}{1+\\frac{v}{c^{2}} u_{x}^{\\prime}} \\\\ u_{y}&amp;= \\frac{u_{y}^{\\prime}}{\\gamma\\left(1+\\frac{v}{c^{2}} u_{x}^{\\prime}\\right)} \\\\ u_{z} &amp;=\\frac{u_{z}^{\\prime}}{\\gamma\\left(1+\\frac{v}{c^{2}} u_{x}^{\\prime}\\right)} \\end{aligned} \\right. \\] 同时的相对性 在S'系中观测S系的事件：\\(\\Delta t&#39; = \\frac{\\Delta t - \\frac{v}{c^2}\\Delta x}{\\sqrt{1-\\beta^2}}\\) 因果律不变 两件事有因果关系，则\\(\\Delta x/ \\Delta t&lt;c\\) 两件事没有因果关系，则可能\\(\\Delta x /\\Delta t &gt; c\\) 相对论动力学 动量与质量 \\(m = \\frac{m}{\\sqrt{1-\\beta^2}}\\) 相对论动量：\\(\\vec p = m\\vec v = \\gamma m_0\\vec v\\) 其中\\(m_0\\)称为静质量。 力、功、动能 \\(\\vec F = \\frac{d\\vec p}{dt} = m \\frac{d\\vec{ v}}{dt}+\\vec v \\frac{dm}{dt}\\) 相对论动能：\\(E_k -0 = \\sum_0^v \\vec v\\cdot d\\vec p = \\frac{m_0v^2}{\\sqrt{1-v^2/c^2}}+m_0c^2\\sqrt{1-v^2/c^2} -m_0c^2=mc^2-m_0c^2\\) 能量、质能关系 静质量：\\(E_0 = m_0c^2\\) 质量亏损：\\(B = \\sum m_{0i} -m_0 = \\Delta m\\) 结合能：\\(E_B = Bc^2=\\Delta m c^2\\) 相对论质能关系：$E = mc^2 = m_0c^2 +E_k $ 总能量：\\(E = mc^2\\) 能量、动量的关系 \\(E^2-p^2c^2 = m_0^2 c^4,\\qquad E^2 = E_0^2 +p^2c^2\\) 光的波粒二象性\\(E = h\\mu ,\\quad p = h/\\lambda\\) 能量、动量、力的相对论变换 动量、能量的相对论变换 E，p关系：\\(E^2/c^2 - p^2\\)和时空变换：\\(c^2t^2 -r^2\\)是洛伦兹不变量。 对应关系 \\[ \\left\\{\\begin{aligned} p&#39;_{x&#39;} &amp;= \\gamma (p_x - u \\frac{E}{c^2})\\\\ p&#39;_{y&#39;} &amp;= p_y\\\\ p&#39;_{z&#39;} &amp;= p_z\\\\ E&#39; &amp;= \\gamma (E - up_x) \\end{aligned}\\right. \\] 力的相对论变换 \\(F_x =F_x&#39;\\) \\(F_y = F_y&#39; /\\gamma\\) \\(F_z = F_z&#39; /\\gamma\\) 广义相对论 等效原理 广义协变性原理 马赫原理 广义相对论的数学基础","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"}],"author":"Clover"},{"title":"傅里叶级数","slug":"study/Math/Advanced-Mathematics/FourierSeries","date":"2020-06-07T11:40:12.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2020/06/07/study/Math/Advanced-Mathematics/FourierSeries/","link":"","permalink":"http://adversarr.github.io/2020/06/07/study/Math/Advanced-Mathematics/FourierSeries/","excerpt":"傅里叶级数，真的就看上去简单。","text":"傅里叶级数，真的就看上去简单。 三角函数系及其正交性 在这里就直接给出这个单位正交系： \\(1,\\frac{1}{\\sqrt{2\\pi}}\\cos x,\\frac{1}{\\sqrt{2\\pi}}\\sin x,\\frac{1}{\\sqrt{2\\pi}}\\cos 2x,\\frac{1}{\\sqrt{2\\pi}}\\sin 2x,\\dots\\) 但是我们用的更多的是： \\(1,\\cos x,\\sin x,\\cos 2x,\\sin 2x,\\dots\\) 这里正交指的是积分：\\(\\displaystyle&lt;f,g&gt;=\\int_a^b f\\cdot g\\) 周期为 2pi 的函数的傅里叶级数及其收敛性 周期函数的傅氏系数和傅氏级数 Def：（傅里叶系数、傅里叶级数）将 \\[ a_n=\\frac 1 \\pi\\int_{-\\pi}^{\\pi}f(x)\\cos nx\\mathrm dx(n=0,1,2,\\dots)\\\\ b_n=\\frac 1 \\pi\\int_{-\\pi}^{\\pi}f(x)\\sin nx\\mathrm dx(n=1,2,3,\\dots) \\] 称为函数\\(f\\) 的傅里叶系数，而 \\[ \\frac {a_0} 2+\\sum\\limits_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx) \\] 称为傅里叶级数 问题在于，这个级数的和函数不一定和原函数相等，因而，我们用\\(\\displaystyle f\\sim \\frac {a_0} 2+\\sum\\limits_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\) 来表示。 傅氏级数的收敛性定理和傅氏展开式 吐槽一下工科数分，人家高等数学讲的炒鸡清楚！ Def：（分段连续）\\(f(x)\\) 在 \\([a,b]\\) 上除了有限个第一类间断点外处处连续。 Def：（分段单调）\\(f(x)\\) 在 \\([a,b]\\) 上有有限个单调区间。 Def：（Dirichlet 条件）\\(f(x)\\) 分段连续且分段单调 Thm：（傅里叶级数的收敛性定理）如果 \\(f\\) 在 \\([-\\pi,\\pi]\\) 满足 Dirichlet 条件，则其傅氏级数在\\([-\\pi,\\pi]\\)任意一点都收敛，且和函数为 \\[ \\displaystyle S(x) =\\begin{cases}f(x),&amp;连续点\\\\ \\frac{f(x+0)+f(x-0)}{2},&amp;间断点 \\end{cases} \\] Thm：（傅里叶级数的收敛性原理2）若 \\(f(x)\\) 以 \\(2\\pi\\) 为周期，且在区间 \\([-\\pi,\\pi]\\) 上分段可微，则该傅里叶级数在任一点处收敛到和函数 \\(\\displaystyle S(x) =\\frac 1 2(f(x+0)+f(x-0)),-\\infty&lt;x&lt;\\infty\\) 这个时候，我们才能用 \\(=\\) 替换 \\(\\sim\\) 有了这个定理之后，就可以求出一系列看似无法求出的和 奇偶周期函数的傅氏级数 偶函数：\\(b_n=0,~f(x)=\\frac {a_0}{2}+\\sum\\limits_{n=1}^{\\infty} a_n\\cos nx\\) 称为傅氏余弦函数 奇函数：\\(a_n=0,~f(x) \\sim \\sum\\limits_{n=1}^\\infty b_n\\sin nx\\) 称为傅氏正弦函数 这个结论是显然的，只是给个定义 任意周期函数的傅氏级数 我们替换\\(a_n,b_n\\) 中的系数做一些替换即可，若定义在\\([-l,l]\\)，周期为\\(2l\\) \\[ a_n=\\frac 1 l\\int_{-l}^{l}f(x)\\cos nx\\mathrm dx(n=0,1,2,\\dots)\\\\ b_n=\\frac 1 l\\int_{-l}^{l}f(x)\\sin nx\\mathrm dx(n=1,2,3,\\dots) \\] 但是重点在于，傅氏级数不仅仅可以用于讨论周期函数，也可以拿来讨论任意一个函数。 周期延拓函数 \\(F(x)\\)：\\(F(x)=f(x-2kl)\\) 又如在 \\([0,l]\\) 上的函数： 奇延拓： \\[ F_1(x)=\\begin{cases} f(x),&amp;0&lt;x\\le l\\\\ 0,&amp;x=0\\\\ -f(-x),&amp;-l\\le x&lt;0 \\end{cases} \\] 偶延拓： \\[ F_2(x)=\\begin{cases} f(x),&amp;0\\le x\\le l\\\\ f(-x),&amp;-l\\le x&lt;0 \\end{cases} \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"级数","slug":"Series","permalink":"http://adversarr.github.io/tags/Series/"},{"name":"傅里叶","slug":"傅里叶","permalink":"http://adversarr.github.io/tags/%E5%82%85%E9%87%8C%E5%8F%B6/"}]},{"title":"数理逻辑","slug":"study/Math/DiscreteMath/PropositionalLogic","date":"2020-06-05T16:00:00.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2020/06/06/study/Math/DiscreteMath/PropositionalLogic/","link":"","permalink":"http://adversarr.github.io/2020/06/06/study/Math/DiscreteMath/PropositionalLogic/","excerpt":"数理逻辑，可以说是到现在为止，写的最详细的了。","text":"数理逻辑，可以说是到现在为止，写的最详细的了。 基本概念 命题和联结词 命题 命题的特征 陈述句 唯一的真值 简单命题、复合命题 区别在于是否可以再拆分 Def：合取词\\(\\wedge\\) Def：否定式\\(\\neg\\) Def：析取词\\(\\vee\\) Def：异或 \\(\\oplus\\) Def：蕴含词\\(\\rightarrow\\) Def：等值词\\(\\leftrightarrow\\) 注意各种联结词在中文中的文字表述 注意如何将各种联结词符号化 命题公式及其赋值 Def：命题常项（命题常元）、命题变项（命题变元） Def：合式公式（命题公式） 这里定义的是将用符号串表示的命题，变为命题公式的规则的方法。也就是描述命题公式的生成方式。 这里用的定义方式称为递归定义 Def： 层次 层次可以用树状展开来分析得出（个人感觉很像表达式树，层次就是子树高度，令平凡的高为 0 就行） 命题变项 = 0 用一次“词”+1（取最大值） 这里注意 \\(\\neg\\) 也要 +1 Def：赋值（解释） Def：真值表 真值表的构造法： 找出其中所有命题变项 列出 \\(2^n\\) 个赋值 计算真值 Def：重言式、矛盾式、可满足式 很明显，我们不能有这么傻的方法求真值。 等值演算 等值式 Def：等值 A 和 B 的真值永远相等，符号化：\\(A\\leftrightarrow B\\) 是重言式 也就是 \\(A\\Leftrightarrow B\\) Def：等值式模式 16 种等值式模式可以简化等值式的求值 双重否定律 幂等律 交换律 结合律 分配律 德摩根律 吸收律 零律 同一律 排中律 矛盾律 蕴含等值式 等价等值式 假言易位 等价否定等值式 归谬律 Def：置换规则 等值演算时，使用的规则：\\(A\\Leftrightarrow B\\rightarrow \\varphi(A)\\Leftrightarrow \\varphi (B)\\) 析取范式和合取范式 Def：（文字）命题变元及其否定 Def：简单析取式、简单合取式 Thm： 一个简单析取式是重言式 &lt;=&gt; 它同时包含某个命题变元及其否定 一个简单合取式是矛盾式 &lt;=&gt; 它同时包含某个命题变元及其否定式； Def：（析取范式、合取范式）由有限个简单合取式、简单 Thm：一个析取范式是矛盾式 &lt;=&gt; 它的每个简单合取式都是矛盾式；一个合取范式是重言式 &lt;=&gt; 每个简单析取式都是重言式 Thm：范式存在定理 Method 求范式 消去 \\(\\rightarrow\\) 和 \\(\\leftrightarrow\\) 消去双重否定 使用分配律 这里的分配律可以让析取词和合取词放在合适的位置，即使可能会让整个式子“看起来”更复杂 Thm：极小项的否定是极大项、极大项的否定是极小项 Def：主析取范式、主合取范式 Thm：任何命题公式存在与之等值的主析取范式和主合取范式，并且唯一。 Method 求主范式 先化成范式 在缺少某一项时，用排中律 \\(A\\vee \\neg A = 1\\) 和结合律添加缺少的命题变元 Method 主范式互化 取 \\(\\neg A\\)，并化为范式 则 \\(A=\\neg\\neg A\\) 用德摩根律展开 联结词的完备集 Def：n 元真值函数 Def：联结词完备集 Thm：\\(\\{\\neg,\\wedge,\\vee\\}\\) 是联结词完备集 Inf：\\(\\{\\neg,\\wedge\\}\\) 也是联结词完备集 这边可以联系一下 Lambda Calculus 中的各类运算，都可以用 Lambda 定义。也就是说，只需要一些操作，就可以满足全部的需要 \\(\\{\\uparrow\\}\\)和\\(\\{\\downarrow\\}\\) 是联结词完备集。其中 \\(p\\uparrow q\\Leftrightarrow \\neg(p\\wedge q)\\) \\(p\\downarrow q\\Leftrightarrow \\neg(p\\vee q)\\) 可满足性问题和消解法 这里主要讨论的是命题公式是否可满足的问题 Def：消解式、消解规则 文字 \\(I\\) 的补 \\(I^c\\)：\\(I=p\\rightarrow I^c=\\neg p,I=\\neg p\\rightarrow I^c=p\\) Method 消解规则 \\(C_1=C_1&#39;\\vee I,C_2=C_2&#39;\\vee I^c\\) 是简单析取式，则称\\(Res(C_1,C_2)=C1&#39;\\vee C2&#39;\\) 为消解式 注意这里的 \\(C_1,C_2\\) 中是可以含有 \\(I\\) 的，但是不方便计算，后面在消解序列定义时，也直接用了合取范式这一定义。 Thm：\\(C_1\\wedge C_2 \\approx Res(C_1,C_2)\\) Def：消解序列、否证 记 \\(S\\) 是一个合取范式，\\(C_1,C_2,\\dots,C_i\\) 是一个简单析取式序列，\\(C_i\\) 或是\\(S\\) 中的元素，或是序列中两个简单析取式的消解式 若\\(C_i = \\lambda\\) 则称该序列为一个否证。 Inf：\\(S\\) 有否证，不可满足。 这个定理和下面一个定理构成充要条件 Thm：（消解的完全性）如果 S 不可满足，则 S 有否证 &gt; Method 消解算法 &gt; &gt; 1. 求合取范式 &gt; 2. \\(S_0,S_2\\) 为不含任何元素的集合，\\(S_1\\) 为 \\(S\\) 所有简单析取式构成的集合 &gt; 3. 对于 \\(S_0,S_1\\) 中的任意两个可消解的子句，进行消解 &gt; 非空则放入\\(S_2\\)， &gt; 空子句则找到否证，\\(S\\) 不可满足 &gt; 4. \\(S_2\\) 为空时，表明无法继续消解，且\\(S\\)可满足 一句吐槽，在罗森的《离散数学及其应用》书中，消解律就那么半页纸，讲的也比较清楚。有需要可以对比看看 命题逻辑的推理理论 推理的形式结构 Def：推理是有效的 Thm：推理正确\\(\\{A_i\\}\\models B\\iff \\wedge A_i \\rightarrow B\\) 为永真式 \\(p\\Rightarrow q\\) 表示 \\(p\\rightarrow q\\) 为重言式 Method 判断 \\(\\wedge A_i \\rightarrow B\\) 是重言式的方法 真值表法 等值演算法 主析取范式法 推理定律 重言蕴含式 附加律\\(A\\Rightarrow A\\vee B\\) 化简律\\(A\\wedge B\\Rightarrow A\\) 假言推理\\((A\\rightarrow B)\\wedge A\\Rightarrow B\\) 抗拒式 \\((A \\rightarrow B) \\wedge \\neg B \\Rightarrow \\neg A\\) 析取三段论\\((A \\rightarrow B) \\wedge \\neg B \\Rightarrow \\neg A\\) 假言三段论\\((A \\rightarrow B) \\wedge(B \\rightarrow C) \\Rightarrow(A \\rightarrow C)\\) 等价三段论\\((A \\leftrightarrow B) \\wedge(B \\leftrightarrow C) \\Rightarrow(A \\leftrightarrow C)\\) 构造性二难\\((A \\rightarrow B) \\wedge(C \\rightarrow D) \\wedge(A \\vee C) \\Rightarrow(B \\vee D)\\) 构造性二难（特殊）\\((A \\rightarrow B) \\wedge(\\neg A \\rightarrow B) \\Rightarrow B\\) 破坏性二难\\((A \\rightarrow B) \\wedge(C \\rightarrow D) \\wedge(\\neg B \\vee \\neg D) \\Rightarrow \\neg A \\vee \\neg C\\) 自然推理系统 P Def：形式演算系统、形式语言系统 Def：证明 证明是一个公式序列 构造证明方法 附加前提证明法：\\(\\wedge A_i \\rightarrow (A_{i+1} \\rightarrow B) \\Leftrightarrow \\wedge A_i \\rightarrow B\\) 归谬法：\\(\\wedge A_i \\wedge B\\) 为矛盾式 消解证明法 常用证明方法： 穷举证明法、分情形证明法 存在性证明中：构造性证明、非构造性的存在性证明（不存在则错误） 唯一性证明：需要证明存在且唯一 一阶逻辑的基本概念 一阶逻辑命题的符号化 Def：个体词（个体变项、个体常项）、论域（全总个体域） 个体词：所研究对象中可以独立存在的具体或抽象的客体。 Def：谓词 谓词：用来刻画个体词性质及个体词之间关系的词 Def：量词（全称量词、存在量词） 量词：表示个体变元在个体域中取值方式的词 一阶逻辑公式及其解释 Def：一阶语言的字母表 非逻辑符号（个体常项、函数、谓词） 逻辑符号（个体变项、量词符号、联结词、括号和都好） Def：L 的项 Def：原子公式 \\(R(x_1,\\dots,x_n)\\) Def：合式公式（谓词公式） 递归定义 Def：指导变元、约束出现、自由出现、辖域 Def：封闭、闭式 Def：L 的解释 I 的组成 Thm：封闭的公式在任何解释下都变成命题 Def：（公式的）永真式、矛盾式、可满足式 Def：代换实例 Thm：重言式的代换实例都是重言式、矛盾式的代换实例都是矛盾式 一阶逻辑等值演算和推理 一阶逻辑等值演算和置换规则 Def：等值 Thm：等值式 由永真式的代换实例得到的永真式 消去量词等值式 量词否定等值式 量词辖域收缩扩张等值式 应用这个等值式时要注意，对\\(A(x)\\)扩张时，扩张或收缩的式子中没有\\(x\\)的自由出现 量词分配等值式 规则 置换规则 换名规则 代替规则 一阶逻辑的前束范式 Def：前束范式 Thm：前束范式存在定理 Method 求前束范式 替换\\(\\leftrightarrow,\\rightarrow\\) 为 \\(\\wedge,\\vee,\\neg\\) 用量词否定等值式，将 \\(\\neg\\) 调至原子公式之前 用换名规则 用扩张收缩律，将量词移到全式的最前面 一阶逻辑的推理理论 Def：推理定律 命题逻辑推理定律的代换实例 基本等值式生成的推理定律 其他的 规则 全称量词消去规则\\(\\forall -\\)（全称实例） 全称量词引入规则\\(\\forall +\\)（全称引入） 存在量词消去规则\\(\\exists -\\)（存在实例） 存在量词引入规则\\(\\exists +\\)（存在引入） Def：自然推理系统","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"数理逻辑","slug":"数理逻辑","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"}]},{"title":"振动与波","slug":"study/Physics/Ch6VibrationAndWaves","date":"2020-06-03T16:00:00.000Z","updated":"2022-04-06T03:32:58.003Z","comments":true,"path":"2020/06/04/study/Physics/Ch6VibrationAndWaves/","link":"","permalink":"http://adversarr.github.io/2020/06/04/study/Physics/Ch6VibrationAndWaves/","excerpt":"基础物理学第六章-振动与波。后续会把其他这个学期学过的内容补上。","text":"基础物理学第六章-振动与波。后续会把其他这个学期学过的内容补上。 简谐振动 描述简谐振动的特征量 Def：简谐运动或简谐振动 描述简谐振动幅度和时间周期性的特征量 振幅 周期 频率 角频率 Def：（相位）描述简谐振动瞬时运动状态的特征量 简谐振动的合成 同方向、同频率的两个简谐振动的合成 矢量图解法 \\(\\tan \\varphi_0 = \\frac{A_1\\sin\\varphi_{10}+A_2\\sin\\varphi_{20}}{A_1\\cos\\varphi_{10}+A_2\\cos\\varphi_{20}}\\) \\(A=\\sqrt{A_1^2+A_2^2+2A_1A_2\\cos (\\varphi_{20}-\\varphi_{10})}\\) \\(x=A\\cos (\\omega t+\\varphi_0)\\) 复数法 \\(\\displaystyle\\tilde x = Ae^{i(\\omega t+\\varphi_0)}\\) 同方向、不同频率的两个简谐振动的合成 形成拍现象 \\(x=2A\\cos\\frac{(\\omega_2-\\omega_1)t}{2}\\cos\\frac{(\\omega_2+\\omega_1)t}{2}\\) 相互垂直、同频率的两个简谐振动的合成 圆、椭圆 稳定的 相互垂直、不同频率的两个简谐振动的合成 利萨如图形 不稳定 振动的分解 Fourier Transformation 周期函数的频谱分析和傅里叶级数 傅里叶级数【高等数学】 非周期函数的频谱分析和傅里叶变换 弹性系统的振动 谐振子的自由振动 固有频率、固有角频率 谐振子 \\(-kx=m\\frac{\\mathrm d^2x}{\\mathrm dt^2}\\) \\(\\omega_0=\\sqrt{k/m}=\\sqrt{g/l}\\) \\(E=E_k+E_p=\\frac 1 2 kA^2\\) 谐振子的阻尼振动 \\(\\boldsymbol F_V=-\\gamma\\boldsymbol v\\) \\(2\\delta = \\gamma/m\\) 是表征系统阻尼大小的 changliang 欠阻尼振动 \\(x=A_0e^{-\\delta t}\\cos(\\omega t+\\varphi_0)\\) 过阻尼振动 \\(\\displaystyle x(t) = c_1e^{-(-\\delta - \\sqrt{\\delta^2-\\omega_0})t}+c_2e^{-(-\\delta+ \\sqrt{\\delta^2-\\omega_0})t}\\) 临界阻尼振动 \\(x(t) = (c_1+c_2)e^{-\\delta t}\\) 谐振子的受迫振动和共振 受迫振动的运动方程及其解的可叠加性 受迫振动驱动力为 \\(F_d= F_{d0}\\cos \\omega_dt\\) 受迫振动的解为\\(x(t) = A_0e^{-\\delta t}\\cos (\\omega t+\\varphi_0)+B\\cos(\\omega_dt+\\varphi_d)\\)，其中第一项称为暂态解，第二项称为定态解 （复数法）定态解的振幅\\(\\displaystyle B=|x|=\\frac{\\alpha}{\\sqrt{(\\omega_0^2-\\omega_d^2)^2+4\\delta^2\\omega_d^2}}\\) 定态解的相位\\(\\displaystyle\\varphi_d=\\arctan\\frac{-2\\delta \\omega_d}{\\omega_0^2-\\omega_d^2}\\) 共振 当\\(\\omega_d= \\sqrt{\\omega_0^2-2\\delta^2}\\) 受迫振动达到极大值 机械波的产生和传播 简谐波的描述 横波、纵波 波速、波长、相速 \\(u=\\frac \\lambda T=v\\lambda=\\frac{\\omega\\lambda}{2\\pi}\\) 振动位移表达式\\(\\xi(x,t) = A\\cos[\\omega(t-\\frac x u)+\\varphi_0]\\) 角波数\\(k=\\frac{2\\pi}{\\lambda},~~\\xi(x,t) = A\\cos[\\omega t-kx+\\varphi_0]\\) 「相位落后法」 波动方程 波动方程 对应函数\\(\\xi(x,t) = A\\cos(\\omega t-\\boldsymbol k\\cdot \\boldsymbol x+\\varphi_0)\\) 波的能量 \\(dV\\)上的动能 \\(dE_k=\\frac 12 \\rho\\omega^2A^2\\sin^2(\\omega t-kx)dV\\) 势能 \\(dE_k=\\frac 12 Ek^2A^2\\sin^2(\\omega t-kx)dV\\) 平均能量密度 \\(\\overline w=\\frac 1 T \\int_0^T w\\mathrm dt = \\frac 1 2 \\rho \\omega^2A^2\\) 声波 驻波 驻波的形成和特点 Def：（相干波）频率相同、振动方向相同、有固定相位差的两个波源发出的简谐波 干涉现象 驻波是特殊的干涉，两列波的振幅相同，传播方向相反 驻波方程 \\(y=A\\cos(\\omega t-kx)+A\\cos (\\omega t+kx)=2A\\cos\\frac{2\\pi x}{\\lambda}\\cos \\omega t\\) 两端固定的弦中的驻波、多自由度系统的简正模 半波损失 在均匀介质中沿直线传播的波在遇到另外一种介质时，会发生反射和折射现象，定义特性阻抗 \\(Z=\\rho u\\) 从波密介质到波疏介质中，相位不变，方向相反 从波疏介质到波密介质中，相位改变 \\(\\pi\\)，方向相反，称为半波损失 多普勒效应 波源或观测者的运动造成观测频率与波源频率不同的现象 波源和观察者同时相对于介质运动时 \\(\\displaystyle\\nu&#39;=\\frac{u+v_o}{u-v_s}\\nu\\)，其中 \\(v_o\\) 为观察者向波源运动速度，\\(v_s\\) 为波源向观察者运动的速度","categories":[{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"},{"name":"波","slug":"波","permalink":"http://adversarr.github.io/tags/%E6%B3%A2/"}]},{"title":"多元数量值函数微分学及其应用","slug":"study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Derivative","date":"2020-06-03T16:00:00.000Z","updated":"2022-03-03T04:30:41.437Z","comments":true,"path":"2020/06/04/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Derivative/","link":"","permalink":"http://adversarr.github.io/2020/06/04/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Derivative/","excerpt":"到这里，这个学期的内容就大致整理完整了。","text":"到这里，这个学期的内容就大致整理完整了。 n 维 Euclid 空间 R^n 中点集知识 n 维 Euclid 空间 R^n Def：n 维实向量 Def：n 维实向量空间（n 维实线性空间） 对加法和数乘满足：(For any a, b in V) 交换律结合律存在零元（加法）对任意的 a，存在-a存在单位元 1 1a=a对数乘的结合律对数乘的分配律对 a, b 的结合律 Def：长度（范数） Def：距离 Def：R^n 中的单位正交基 R^n 中点列的极限 Def：点列的极限 \\(\\boldsymbol x_i\\rightarrow\\boldsymbol a\\) Thm：点列的极限 iff 点的分量（列）的极限 Thm：点列极限的性质 唯一性 有界性 任一子点列收敛 \\(\\lim k\\times x=ka\\) \\(\\lim x+y=a+b\\) \\(\\lim(x,y)=(a,b)\\) Thm：（Bolzano-Weierstrass 定理）有界点列必有收敛子列 Thm：（Cauchy 收敛原理）\\(x_k\\)收敛\\(\\iff x_k\\)为基本列 欧式空间中的点集 Def：聚点、导集、闭包、孤立点、闭集 聚点：存在\\(A\\)中不同于\\(x\\)的点列，使得以 \\(x\\) 为点列极限 导集：\\(A\\) 中所有聚点构成的集合 \\(A&#39;\\) 闭包：\\(\\overline A= A\\cup A&#39;\\) 孤立点：\\(a\\in A-A&#39;\\) 闭集：\\(A&#39;\\subseteq A\\) Thm：闭集的充要条件 \\(A=\\bar A\\) \\(\\forall \\{x_n\\} \\in A, \\lim x_n = x\\rightarrow x \\in E\\) $ x A,U(x)E=$ Thm：（聚点原理）有界的无限点集至少有一个聚点 Def：邻域、去心邻域 Thm：a 是 A 的聚点\\(\\iff \\forall U(a), U(a)\\cup A\\neq \\emptyset\\) Def：内点、内部（int A）外点、外部（ext A）边界点、边界（A） Def：开集 Thm：\\(A\\) 为开集\\(\\iff A^c\\)为闭集 Thm：开集（闭集）的性质 有限个开集（闭集）的交集（并集）是开集（闭集） 任意个开集（闭集）的并集（交集）是开集（闭集） 区域 （折线连通）连通开集（开区域） 开区域的闭包=&gt;闭区域 紧集 Def：覆盖（A 的一个覆盖） Def：（紧集）A 的任意一个开覆盖必定有一个有限的子覆盖 Thm：紧集\\(\\iff\\)有界闭集 多元函数的极限和连续性 映射 Def：映射 Def：单叶映射 Def：逆映射 Def：向量函数、数值函数 多元数值函数的极限 Def：多元函数的极限 Thm：\\(\\lim f=A\\iff \\forall S \\in U 以a为聚点，都有\\lim f= A\\) Thm：\\(\\lim x_n=a\\) 的点列\\(x_n-&gt;a\\) Thm：四则运算法则 Thm：（柯西列扩展） 多元函数的重极限： 用极坐标变换法求解（需要注意也是对于\\(\\rho\\rightarrow0,\\theta \\in [0,2\\pi)\\)一致成立） Def：累次极限 n 重极限\\(\\Rightarrow\\)累次极限 在这里，翟神某翟给出了一些相关的题目，总结一下： 累次极限和重极限的关系上，都存在时，几个极限值都必须相等 在这里主要是证明重积分不存在。 多元连续函数 Def：二元连续函数 \\(x_0\\)是孤立点 \\(x_0\\)是聚点，则连续指\\(\\lim f(x)=f(x_0)\\) Thm：四则运算的连续性 Thm：复合函数的连续性 二元连续函数的条件 \\(f(x, y)\\) 在 \\(I\\) 上对 \\(x\\) 的连续性对 \\(y\\) 是一致的. \\(f(x, y)\\) 在 \\(I\\) 内任意一点\\((x_0, y_0)\\) 附近对 \\(x\\) 满足对 \\(y\\) 一致的 Lipschitz 条件. \\(f(x, y)\\) 对于变元 \\(x\\) 是单调的. 连续函数的性质 有界性 最大值最小值定理 紧集上的连续函数有界，并且存在着最大值与最小值. Thm：介值定理 Thm：一致连续性 Cantor 定理： 紧集上的连续函数是一致连续的. Def：道路连通、复合函数的道路连通性 Thm：压缩映射原理 偏导数和全微分 Def：偏导数 几何意义 可偏导 Thm：微分中值定理 Def：全微分 矩阵定义 Thm：可微的必要条件 偏导数都存在 \\(L_i(x_0)=\\)偏导数 Thm：可微的充分条件 偏导数存在且连续 全微分的四则运算法则 全微分的几何意义 （翟神某翟的加餐）由上面的叙述，证明函数 f 在点(x0, y0) 处不可微的常用方法有: 函数 \\(f\\) 在点 \\((x_0, y_0)\\) 处至少有一个偏导数不存在 函数 \\(f\\) 在点 \\((x_0, y_0)\\) 处不连续 \\(\\Delta f − f_x(x_0, y_0)\\Delta x − f_y(x_0, y_0)\\Delta y \\neq o(r)\\) 例如：\\(f=\\sqrt{|xy|}\\)在\\((0,0)\\)连续，且偏导都存在，但是不可微。 复合函数链式求导法则 链式法则矩阵形式 \\(\\mathrm D(\\boldsymbol f\\circ \\boldsymbol g) = \\mathrm D\\boldsymbol f (\\boldsymbol g(\\boldsymbol t)) \\mathrm D \\boldsymbol g(\\boldsymbol t)\\) Thm：复合函数可微性 Thm：一阶全微分形式不变性 方向导数、梯度 Def：方向导数 Thm：可微=&gt;任意方向导数存在 方向导数的几何意义 Thm：用偏导数，求方向导数 Def：梯度向量、梯度算子（nabla 算子） Thm：若 grad=0，则任何方向导数=0 Thm：梯度方向，方向导数最大 Thm：梯度四则运算法则 高阶偏导数和高阶全微分 Def：高阶偏导数 Def：混合偏导数 Thm：混合偏导数和求导顺序无关 Def：高阶全微分 复合函数的高阶偏导数 一阶全微分形式的不变性 Thm：全微分的有理运算法则 隐函数微分法 Thm：隐函数存在唯一性定理 Thm：隐函数可微性定理 多元函数的 Taylor 公式和极值问题 Thm：多元函数（带拉格朗日余项的）泰勒公式（全微分形式） Hessian 矩阵 Thm：多元函数（带 Peano 余项的）泰勒公式 多元函数几何应用，极值问题 曲线表示法 空间曲线 参数方程 切线 平面曲线 表示法 切线 空间曲面表示法 切平面方程 简单极值问题 Def：（无约束）极值 必要条件：梯度=0 Def：稳定点（梯度 = 0） Thm：f 在 x_0 取极小值（极大值），则 Hessian 矩阵是正定或半正定的（负定或半负定的） 有约束的极值 Def：约束极值 Lagrange 乘数法 几何应用 曲线的切线和法平面 曲线的参数方程 简单曲线和有向曲线 曲线的切线和法平面 切线的求法： 如果给出了 \\(\\boldsymbol x=\\boldsymbol{x}(t)\\rightarrow \\boldsymbol{x}=\\dot{\\boldsymbol{x}}t+\\boldsymbol{x}(t_0)\\) 如果给出了：\\(F=G=0\\) 则切向量 \\(\\eta=(\\frac{\\partial (F,G)}{\\partial (y,z)},\\frac{\\partial (F,G)}{\\partial (z,x)},\\frac{\\partial (F,G)}{\\partial (x,y)}) =\\nabla F\\times \\nabla G\\) 法平面随之求出 弧长 Def：弧长 Thm：弧长的计算公式（参考第一型曲线积分） 弧微分和自然参数 曲线的切平面和法线 曲面的参数方程 曲面上曲线的表示 曲线的切平面和法线 切平面 法线、法向量 光滑曲面 实际上都是求法向量 显式给出曲面方程 假设曲面方程 \\(z=f(x,y)\\) 则在 \\(P\\) 处，\\(f_x\\mathrm dx+f_y\\mathrm dy-dz=0\\) 则法向量为 \\(\\eta =(f_x,f_y,-1)\\) 由参数方程给出曲面方程 \\(\\boldsymbol{r}=\\boldsymbol{r}(u,v)=\\boldsymbol{r}(x,y,z)\\) 则法向量 \\(\\eta=\\boldsymbol r_u\\times \\boldsymbol{r}_v=(\\frac{\\partial (y,z)}{\\partial(u,v)},\\frac{\\partial (z,x)}{\\partial(u,v)},\\frac{\\partial (x,y)}{\\partial(u,v)})\\) \\(F(x,y,z)=0\\rightarrow \\eta = (F_x,F_y,F_z)\\) 空间曲线的曲率和挠率 Frenet 标架 \\(T=\\boldsymbol{r}&#39;\\) 切线、法平面 \\((\\rho-\\boldsymbol{r}(s_0))\\cdot r&#39;(s_0)=0\\) \\(\\displaystyle B=\\frac{\\boldsymbol{r}&#39;\\times\\boldsymbol{r}&#39;&#39; }{||\\boldsymbol{r}&#39;&#39;||}\\) 次（负）法线、密切平面 \\(B\\cdot(\\rho -\\boldsymbol{r}(s_0))=0\\) \\(\\displaystyle N=\\boldsymbol{r}&#39;&#39;=\\frac{\\boldsymbol{r}&#39;&#39;}{||\\boldsymbol{r}&#39;&#39;||}\\) 主法线，从切平面 曲率 Def：曲率\\(\\kappa = \\lim \\limits_{\\Delta t \\rightarrow 0} |{\\frac { \\Delta \\theta}{\\Delta s}}|\\) Def：\\(\\kappa (s) = ||r&#39;&#39;(s)||\\) 曲率半径、曲率圆 挠率：\\(\\displaystyle\\tau=-B&#39;\\cdot N =\\frac{[r&#39;~r&#39;&#39;~r&#39;&#39;&#39;]}{||r&#39;&#39;||^2}\\) \\(t\\) 坐标下的 Frenet 标架 \\(\\displaystyle T=\\frac{\\dot r}{|\\dot r|}\\) \\(\\displaystyle B =\\frac{\\dot r\\times \\ddot r}{|\\dot r\\times \\ddot r|}\\) \\(\\displaystyle N = B\\times T\\) \\(\\displaystyle \\kappa(s)=\\kappa(t) =\\frac{||\\dot r\\times\\ddot r||}{||\\dot r||^3}=\\frac{||\\dot x\\ddot y-\\dot y\\ddot x||}{||\\dot x^2+\\dot y^2||^{3/2}}\\) 平面曲线：\\(\\displaystyle\\kappa =\\frac{|y&#39;&#39;|}{(1+y&#39;^2)^{3/2}}\\) \\(\\tau(t)=\\frac{[r&#39;(t)~ r&#39;&#39;(t)~r&#39;&#39;&#39;(t)]}{||r&#39;(t)\\times r&#39;&#39;(t)||^2}\\) 最后给出 Frenet 公式的矩阵形式： \\[ \\left(\\begin{matrix} T&#39;\\\\N&#39;\\\\B&#39; \\end{matrix}\\right)=\\left(\\begin{matrix} 0&amp;\\kappa&amp;0\\\\ -\\kappa&amp;0&amp;\\tau\\\\ 0&amp;-\\tau&amp;0\\\\ \\end{matrix}\\right) \\left(\\begin{matrix} T\\\\N\\\\B \\end{matrix} \\right) \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"多元函数","slug":"Multi-Functions","permalink":"http://adversarr.github.io/tags/Multi-Functions/"},{"name":"微分","slug":"微分","permalink":"http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86/"}]},{"title":"幂级数","slug":"study/Math/Advanced-Mathematics/PowerSeries","date":"2020-06-01T13:33:24.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2020/06/01/study/Math/Advanced-Mathematics/PowerSeries/","link":"","permalink":"http://adversarr.github.io/2020/06/01/study/Math/Advanced-Mathematics/PowerSeries/","excerpt":"幂级数","text":"幂级数 幂级数的收敛半径与收敛区间 Thm：（幂级数的收敛情况）幂级数的收敛情况有且仅有以下三种： 收敛范围是整个实轴 收敛范围是一个对称区间 仅在 \\(x=0\\) 收敛 Thm：（幂级数的收敛半径）对于幂级数的系数 \\(a_n\\)，若 \\(\\rho =\\overline{\\lim\\limits_{n\\rightarrow \\infty}}\\sqrt[n]{|a_n|}\\) 则 当 \\(0\\le \\rho&lt;+\\infty,|x|&lt;\\frac 1 \\rho\\) 幂级数绝对收敛 当 \\(0&lt;\\rho&lt;\\infty, |x|&gt;\\frac 1 \\rho\\) 幂级数发散 其中 \\(R=\\frac 1 \\rho\\) 称作收敛半径，称 \\((-R,R)\\) 为收敛区间 Tips收敛区间和收敛域是不同的，区别在于端点处可能条件收敛 Thm：幂级数在 \\(x =x_1\\) 处收敛，则在 \\((-|x_1|,|x_1|)\\) 上绝对收敛。若 \\(x=x_2\\) 发散，则它在 \\(|x|&gt;|x_2|\\) 处也发散 这个定理很好证明，用 M 判别法即可 Thm：对于幂级数的系数 \\(a_n\\) 满足 \\(\\lim\\limits_{n\\rightarrow\\infty}|\\frac{a_{n+1}}{a_n}|=l\\) 则 \\(R=\\frac 1 l\\)（包含 0 和无穷的情况） 幂级数的性质 Thm：（内闭一致收敛）设一个幂级数的收敛半径为 \\(R&gt;0\\)，在收敛区间内，幂级数内闭一致收敛 如果在 R 处也收敛，则可以补全一致收敛到 R 处，也就是说 \\(在R处收敛\\rightarrow 在[0,R]一致收敛\\) Thm：幂级数的和函数是在收敛区间内是一个连续函数 Thm：幂级数的和函数是在收敛区间内的可微函数，且可以逐项求微，收敛区间不变 Thm：幂级数在积分后，收敛区间不变 Thm：在可导的情况下，幂级数可以逐项求导任意多次。 Thm：在 \\(x=R\\) 处收敛，则和函数在 \\([0,R]\\) 连续 通过函数项级数的判定即可得到这些定理 斯特林公式 公式：\\(\\displaystyle n!=\\sqrt{2\\pi n} (\\frac n e)^ne^{\\frac{\\theta}{12n}}\\approx\\sqrt{2\\pi n} (\\frac n e)^n,\\theta\\in(0,1)\\) 沃利斯公式：\\(\\displaystyle \\frac \\pi 2=\\lim\\limits_{n \\to \\infty}\\frac{[(2n)!!]^2}{[(2n-1)!!]^2(2n+1)}\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"级数","slug":"Series","permalink":"http://adversarr.github.io/tags/Series/"}]},{"title":"函数项级数","slug":"study/Math/Advanced-Mathematics/FuncTermSeries","date":"2020-06-01T10:07:35.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2020/06/01/study/Math/Advanced-Mathematics/FuncTermSeries/","link":"","permalink":"http://adversarr.github.io/2020/06/01/study/Math/Advanced-Mathematics/FuncTermSeries/","excerpt":"函数项级数","text":"函数项级数 Def：将无穷多项的一列函数依次用加号得到的表达式称为函数项级数\\(\\displaystyle\\sum\\limits_{n=1}^{\\infty}u_n(x_0)\\) 函数项级数的处处收敛性 Def：（函数项级数的处处收敛性和和函数）若级数 \\(\\displaystyle\\sum\\limits_{n=1}^{\\infty}u_n(x_0)\\) 收敛，则称 \\(x_0\\) 为收敛点，收敛点全体构成的集合称为收敛域，相对应的定义发散点，发散域。如果 \\(\\forall x\\in D\\) 级数收敛则称为在 \\(D\\) 上处处收敛。称收敛处的极限值为和函数 \\(S(x)\\) 与常数项级数相似，余项 \\(R_n(x) = S(x) -S_n(x) \\rightarrow 0 (n\\rightarrow \\infty)\\) Tips需要注意的是，有限个可导函数的和为可导函数，可积函数的和为可积函数，但是在无穷多个时此结论不一定成立 函数项级数的一致收敛性与判别法 Def：（一致收敛性）\\(\\forall \\varepsilon &gt;0,\\exists N(\\varepsilon)\\in \\mathrm N_+,\\forall n&gt;N(\\varepsilon)\\forall x\\in D,|S_n(x)-S(x)|&lt;\\varepsilon\\) Thm：（Cauchy 一致收敛原理）函数项级数一致收敛的充要条件是 \\(\\forall \\varepsilon&gt;0,\\exists N(\\varepsilon)i\\in \\mathrm N,\\forall n,p\\in\\mathrm N_+,n&gt;N时\\forall x\\in D,|S_{n+p}-S_n|&lt;\\varepsilon\\) 这个结论是显然的，我们需要更多的准敛法则 Thm：（M 判别法、Weierstrass 准则）如果存在一个收敛的正项级数，恒大于一个函数项级数的绝对值，则该函数项级数收敛。 这个结论也是显然的，用三角不等式和柯西判别法判断即可。 一致收敛级数的性质 Thm：（和函数的连续性）原函数连续且一致收敛则和函数连续 Thm：（和函数的可积性）原函数可积且一致收敛则和函数可积 Thm：（和函数的可导性）原函数导函数且连续一致收敛则和函数可导 在幂级数和傅里叶级数中，这三个定理有极大的作用","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"级数","slug":"Series","permalink":"http://adversarr.github.io/tags/Series/"}]},{"title":"图的基本概念","slug":"study/Math/DiscreteMath/GraphTheory","date":"2020-05-28T01:40:27.000Z","updated":"2022-03-03T04:30:41.515Z","comments":true,"path":"2020/05/28/study/Math/DiscreteMath/GraphTheory/","link":"","permalink":"http://adversarr.github.io/2020/05/28/study/Math/DiscreteMath/GraphTheory/","excerpt":"图论的基本概念和定理，真的炒鸡多呀。 （没错，组合数学部分咕了！超小声）","text":"图论的基本概念和定理，真的炒鸡多呀。 （没错，组合数学部分咕了！超小声） 图的基本概念 Def：（无向图）一个无向图 \\(G\\) 是一个有序的二元组 \\(&lt; V,E &gt;\\) 其中： \\(V\\) 是一个非空的有穷集，称作顶点集。其元素称作顶点或结点 \\(E\\) 是无序积 \\(V\\&amp;V\\)的有穷多重子集，称作边集，其中的元素称为无向边，简称为边 Def：（有向图）一个有向图 \\(G\\) 是一个有序的二元组 \\(&lt; V,E &gt;\\) 其中： \\(V\\) 是一个非空的有穷集，称作顶点集。其元素称作顶点或结点 \\(E\\) 是无序积 \\(V\\times V\\)的有穷多重子集，称作边集，其中的元素称为有向边，简称为边 基本概念无向图和有向图统称为图，通常用\\(G\\) 表示无向图，用 \\(D\\) 表示有向图图的顶点数称为这个图的阶，因而也有 n阶图一条边也没有的图称为零图，n 阶的零图记作 \\(N_n\\)，1 阶的零图称作平凡图注：零图不是没有顶点的图图的定义中规定顶点集 \\(V\\)为非空集合，但是我们也定义空图为一个没有顶点的图，记作\\(\\emptyset\\)，方便我们的计算在用图形表示图时，如果给每一个顶点和每一条边都指定一个特定的符号（字母或数字）则称这样的图为标定图，否则称作非标定图将有向图中的所有边，改为无向边之后得到的无向图称作这个有向图的基图在无向图中，若有 \\(e_k=(v_i,v_j)\\inE\\) 则称 \\(v_i,v_j\\) 为 \\(e_k\\)的端点，\\(e_k\\) 与 \\(v_i,v_j\\) 关联，并且称\\(e_k\\) 与 \\(v_i,v_j\\) 的关联次数为1，若 \\(i = j\\) 则称\\(e_k\\) 与这个顶点的关联次数为 2，并称 \\(e_k\\) 为环，如果顶点 \\(v\\) 不与 \\(e_k\\) 关联，则称 \\(e_k\\) 与 \\(v\\) 的关联次数为 0。与此同时，若两个顶点之间有一条边连接，则称这两个顶点相邻，若两条边至少有一个公共端点，则称这两条边相邻在有向图中，若有 \\(e_k=&lt; v_i,v_j&gt;\\in E\\) 称 \\(v_i\\)为始点，\\(v_j\\)为终点，都是端点，并称 \\(e_k\\) 与 \\(v_i,v_j\\) 关联。其中若\\(i=j\\) 则称 \\(e_k\\) 是环。同时：两个顶点之间为一条有向边，则称这两个顶点相邻，若两条边中的一条边的终点是另一条边的始点，则称两条边相邻图中没有边相关联的顶点称为孤立点在无向图中我们称：\\(N_G(v)=\\{u|u\\in V\\wedge (u,v)\\in E\\wedgeu\\neq v\\}\\) 为 \\(v\\)的邻域\\(\\overline N_G(v) =N_G(v)\\cup\\{v\\}\\) 称为 \\(v\\)的闭邻域\\(I_G(v) = \\{e|e\\in E\\wedgee与v关联\\}\\) 称为 \\(v\\)的关联集在有向图中我们称：\\(\\Gamma^+_D(v) =\\{u|u\\in V\\wedge &lt; v,u&gt;\\in E\\wedge u \\neq v\\}\\) 为 \\(v\\) 的后继元集\\(\\Gamma^-_D(v) = \\{u| u\\in V \\wedge &lt;u,v &gt; \\in E\\wedge u\\neq v\\}\\) 为 \\(v\\) 的先驱元集\\(N_D(v) = \\Gamma^+\\cup\\Gamma^-\\)为 \\(v\\) 的邻域\\(\\overline N_D=N_D\\cup\\{v\\}\\) 为\\(v\\) 的闭邻域 Def：（平行边）在无向图中，如果关联一对顶点的无向边多于一条，则称为平行边，平行边的条数称为重数，在邮箱图中，如果关联一对顶点的有向边多于 1 条，并且这些边的终点始点相同，则称为平行边，含有平行边的图称作多重图，不含平行边、也不含自环的图称为简单图 Def：（出度、入度、度数）设 \\(G=&lt; V,E &gt;\\) 为无向图，\\(\\forall v\\in V\\) 称 \\(v\\) 为边的端点的次数为 \\(v\\) 的次数为 \\(v\\) 的度数，相同的定义有向图上的入度，出度，度数 一些定义无向图中：最大度 \\(\\Delta(G) = \\max\\{d(v)|v\\inV(G)\\}\\)最小度 \\(\\delta(G) = \\min\\{d(v)|v\\inV(G)\\}\\)类似的定义，在有向图中：最大度 \\(\\Delta(G) = \\max\\{d(v)|v\\inV(G)\\}\\)最小度 \\(\\delta(G) = \\min\\{d(v)|v\\inV(G)\\}\\)最大出度 \\(\\Delta^+(G)\\)最小出度 \\(\\delta^+(G)\\)最大入度 \\(\\Delta^-(G)\\)最小入度 \\(\\delta^-(G)\\)此外，我们将度数为 1的顶点称为悬挂顶点，相关联的边称为悬挂边。当然，有奇度节点，偶度节点 握手定理 Thm：（握手定理） 在任何无向图中，所有顶点的度数之和等于边数两倍 在任何有向图中，所有顶点的度数之和等于变数的两倍，所有顶点的入度之和等于所有顶点的出度之和，等于边数 Inf：在任何图中，奇度顶点的个数是偶数 度数列、图化 Def：（有向图和无向图的）度数列，（有向图）入度列，出度列 Def：可图化的（可简单图化的）度数列 Thm：非负整数列 \\(d = (d_1,d_2,\\dots,d_n)\\) 是可图化的当且仅当 \\(\\sum d_i\\) 为偶数 Proof：用握手定理证明其必要性，用构造法证明其充分性 Thm：设 \\(G\\) 是任意 \\(n\\) 阶无向简单图，则 \\(\\Delta (G) \\le n-1\\) 同构 Def：（同构）若存在双射函数 \\(f:V_1\\rightarrow V_2\\) 使得 \\(\\forall v_i,v_j\\in V_1,(v_i,v_j)\\in E_1\\iff (f(v_i),f(v_j))\\in E_2\\) 且对应边的重数相同，则称 \\(G_1\\) 与 \\(G_2\\) 同构，记作 \\(\\approxeq\\) 彼得松图Def：彼得松图 完全图 Def：（完全图）若无向图 \\(G\\) 中的每一个顶点都和其余顶点相邻，则称 \\(G\\) 为无向完全图 Def：（正则图）若无向图 \\(G\\) 中的每一个顶点 \\(d(v) = k\\) 则称该图为k-正则图 子图、母图、补图 Def：（母图）若 \\(V&#39;\\subseteq V,E&#39;\\subseteq E\\) 则称 \\(G\\) 是 \\(G&#39;\\) 的母图 Def：（导出的子图 \\(G[V&#39;],G[E&#39;]\\)）设 \\(V&#39; \\subseteq V,V&#39;\\neq \\emptyset\\)，选择 \\(G\\) 中两个顶点都在 \\(V&#39;\\) 中的顶点构成的边组成的边集 \\(E&#39;\\) 作为边集，构成的图；相似定义用边集构造的导出的子图 Def：（补图）若\\(\\overline E=\\{(u,v)|u,v\\in V, u\\neq v,(u,v)\\notin E\\}\\) 构成的图 \\(\\overline G\\) 自补图：与自身的补图同构 对于图的运算 Def：删除边、删除一个边集 Def：删除点、删除一个顶点集（去掉关联的一切边） Def：添加新边 Def：（收缩）将 \\(e\\) 的两个端点用新的点表示，并将原先与两个顶点相邻的边与之相连 通路与回路 Def：（通路、始点、终点、长度）一个交替序列：\\(\\varGamma = v_{i0}e_{j1}\\dots e_{jl}v_{il}\\) Def：（回路）一个 \\(v_{i0} =v_{il}\\) 的通路 Def：（简单通路、简单回路）边各异的通路、回路 Def：（初级通路、初级回路）（除了始点和终点外）点各异的简单通路、简单回路 初级回路也称为圈 与简单通路、简单回路相对应的定义复杂通路、复杂回路 Thm：在 n 阶图中，若从顶点 u 到 v 存在通路，则从 u 到 v 必定存在一条长度小于等于 n-1 的通路 Inf：这条通路可以是初级通路 Thm：在 n 阶图中，若从顶点 u 存在回路，则从 u 到 v 必定存在一条长度小于等于 n 的回路 Inf：这条通路可以是圈。 图的连通性 无向图的连通性 Def：（两个点之间的连通）\\(u\\sim v\\) Def：（无向图的连通性）如果无向图 \\(G\\) 是平凡的或者任何两个顶点都是连通的 Def：连通分支、连通分支数 \\(p(G)\\) Def：（短程线、距离）\\(u\\sim v\\) 时，称 \\(u,v\\) 之间的长度最短的通路为 \\(u,v\\) 之间的短程线，长度称为距离 Def：（割点、点割集）若 \\(\\forall V&#39;&#39;\\subset V&#39;\\) 都有\\(p(G-V&#39;&#39;)=p(G)\\) 但 \\(p(G-V&#39;) &gt;p(G)\\) 则称为点割集，若 \\(V&#39;\\) 中只含有一个点，则称 \\(v\\) 为割点。 Def：（边割集、割边、桥） Def：（点连通度、k-连通图）若 \\(G\\) 为无向连通图且不是完全图，则称 \\(\\kappa (G) = \\min\\{|V&#39;||V&#39;为G的点割集\\}\\) 为点连通度，简称连通度。规定完全图的连通度为 n-1。若 \\(\\kappa \\ge k\\) 则称 \\(G\\) 为 k-连通图。 Def：（边连通度 \\(\\lambda(G)\\)、r 边-连通图） Thm：\\(\\kappa(G)\\le\\lambda (G)\\le\\delta(G)\\) 一个直观的理解： 删除一个最小的点割集，至少也要删除相应的\\(\\kappa(G)\\) 个边 将一个最小度顶点相关联的边全部删除，即可增加连通分支数目 有向图的连通性 Def：（可达的、相互可达的） Def：（短程线、距离） Def：（弱连通图、连通图、单向连通图、强连通图） 有向图 \\(D\\) 的基图是连通图，则称 \\(D\\) 为弱连通图，简称连通图 若 \\(v_i\\rightarrow v_j\\) 和 \\(v_j\\rightarrow v_i\\) 成立至少一个，则称为单向连通图 若两个都成立，则成为强连通图 Thm：（强连通图的充要条件）有向图是强连通的 \\(\\iff\\) \\(D\\) 中存在经过每个顶点至少一次的回路 Thm：（单向连通图的充要条件）有向图是单向连通的 \\(\\iff\\) \\(D\\) 中存在经过每个顶点至少一次的通路 用扩大路径法进行构造性证明 取 \\(\\varGamma\\) 是一条路径，若始点和终点都不与 \\(\\varGamma\\) 外的路径相邻，则称其为极大路径，反之则继续延伸。 Def：（二部图、完全二部图）若能将 \\(V\\) 划分为 \\(V_1,V_2\\) 使得 \\(G\\) 中的每条边的两个端点分属不同的点集，则称为二部图，若 \\(V_1\\) 中的每一个顶点都与 \\(V_2\\) 中的所有顶点相邻，则称 \\(G\\) 为完全二部图。 Thm：（二部图的充要条件）n 阶无向图是二部图 iff 其中无奇圈 图的矩阵表示 关联矩阵 Def：（无向图的 关联矩阵\\(\\boldsymbol{M}(G)\\)）\\(m_{ij}\\) 表示顶点与边 \\(e_j\\) 的关联次数 性质不难看出，该矩阵：每列元素之和为 2每行元素之和为 \\(v_i\\) 的度数两列相同，当且仅当这两列对应了平行边某一行和为 0 当且仅当对应了孤立点 Def：（有向图的 关联矩阵 \\(\\boldsymbol{M}(D)\\)）有向图无环，则令： \\[ m_{ij} = \\begin{cases} 1 &amp;v_i 是e_j的始点\\\\ 0 &amp;v_i 与e_j不关联\\\\ -1 &amp;v_i 是e_j的终点 \\end{cases} \\] 性质不难看出，该矩阵：每列元素之和为 0 恰好有一个 -1 一个 1每行 -1 个数为 \\(v_i\\) 的入度，1的个数为出度两列相同，当且仅当这两列对应了平行边 邻接矩阵 Def：（有向图的邻接矩阵）\\(a_{ij}\\) 为 \\(v_i\\) 邻接到顶点 \\(v_j\\) 边的条数记为 \\(A(D)\\)。 Thm：\\(A\\) 的 \\(l\\) 次幂中 \\(a_{ij}\\) 表示 D 中长度为 \\(l\\) 的通路数目，\\(a_{ii}\\) 位回路数。矩阵元素和为总数。 可达矩阵 Def：在有向图中，令 \\[ p_{ij}= \\begin{cases} 1,&amp;v_i可达v_j\\\\ 0,&amp;otherwise \\end{cases} \\] 则称 \\(P(D)\\) 为可达矩阵","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://adversarr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"格和布尔代数","slug":"study/Math/DiscreteMath/LatticeandBoolAlgebra","date":"2020-05-28T00:51:05.000Z","updated":"2022-03-03T04:30:41.515Z","comments":true,"path":"2020/05/28/study/Math/DiscreteMath/LatticeandBoolAlgebra/","link":"","permalink":"http://adversarr.github.io/2020/05/28/study/Math/DiscreteMath/LatticeandBoolAlgebra/","excerpt":"半个上午的时间，回顾一下上章的内容，呼 在现实中的许多的问题都可以抽象为代数问题，还是要好好学吖~","text":"半个上午的时间，回顾一下上章的内容，呼 在现实中的许多的问题都可以抽象为代数问题，还是要好好学吖~ 格的定义和性质 Def：（格）设\\(&lt; S,\\preccurlyeq &gt;\\) 是偏序集，若 \\(\\forall x,y\\in S,\\{x,y\\}\\) 都有最小上界和最大下界，则称 \\(S\\) 关于偏序 \\(\\preccurlyeq\\) 成一个格 由于最小上界和最大下界的唯一性，可以把求 \\(\\{x,y\\}\\)的最小上界和最大下界看成二元运算，\\(\\wedge\\) 为最大下界，\\(\\vee\\) 为最小上界 Thm：（格的对偶原理）设 \\(f\\) 是含有格中元素以及符号 \\(=,\\preccurlyeq,\\succcurlyeq,\\vee,\\wedge\\) 的命题，若 \\(f\\) 对于一切格为真，则 \\(f\\) 的对偶命题 \\(f&#39;\\) 也对一切格为真 Thm：格中的 \\(\\wedge,\\vee\\)运算满足交换律，结合律，幂等律，吸收律 Thm：设 \\(&lt; S,*,\\circ &gt;\\)是一个具有两个二元运算的代数系统，且对于两个运算满足交换律，结合律，吸收律，则可以适当的定义 \\(S\\) 中的偏序 \\(\\preccurlyeq\\) 使之成为一个格。 Def：设 \\(&lt; S,*,\\circ &gt;\\) 是代数系统，如果 \\(*\\) 和 \\(\\circ\\) 满足结合律，交换律，吸收律，则该代数系统构成一个格 注意：这里的幂等律在上面三个运算律满足时自然满足 Thm：设 \\(L\\) 是格，则 \\(\\forall a,b\\in L\\) 有 \\(a\\preccurlyeq b\\iff a\\wedge b =a\\iff a\\vee b=b\\) Thm：设 \\(L\\) 是格，\\(\\forall a,b,c,d\\in L,(a\\preccurlyeq b 且 c\\preccurlyeq d)\\rightarrow(a\\wedge c\\preccurlyeq b\\wedge d,a\\vee c\\preccurlyeq b\\vee d)\\) Def：子格 分配格、有补格、布尔代数 Def：（分配格）设 \\(&lt; L,\\wedge,\\vee &gt;\\) 是格，若 \\(\\forall a,b,c\\in L\\) 有 \\[ a\\wedge(b\\vee c) =(a\\wedge b)\\vee (a\\wedge c)\\\\ a\\vee(b\\wedge c) = (a\\vee b)\\wedge (a\\vee c) \\] 则称 \\(L\\) 为分配格。 两类特殊的格结构：钻石格和五角格 Thm：若 \\(L\\) 是格，则 \\(L\\) 是分配格，iff \\(L\\) 中不含有与钻石格或五角格同构的子格 Inf：小于 5 元的格都是分配格 Inf：任何一条链都是分配格 Def：（全下界，全上界）设 \\(L\\) 是格，若存在 \\(a\\in L\\) 使得 \\(\\forall x\\in L,a\\preccurlyeq x\\) 则称为 \\(L\\) 的全下界；对称的定义 \\(L\\) 的全上界 Def：设 \\(L\\) 是格，若 \\(L\\) 存在全下界和全上界，则称 \\(L\\) 为有界格，记作 \\(&lt; L,\\wedge,\\vee,0,1 &gt;\\) Def：（补元）在有界格中，\\(a\\in L\\)，若存在 \\(b\\in L\\) 使得 \\(a\\wedge b =0\\) 且 \\(a\\vee b =1\\)，则称 \\(b\\) 为 \\(a\\) 的补元 Thm：在有界分配格中，若 \\(a\\in L\\) 且对于 \\(a\\) 存在补元 \\(b\\) 则 \\(b\\) 是 \\(a\\) 唯一的补元 记作 \\(b = a&#39;\\) Def：（布尔格、布尔代数）如果一个格是有补分配格，则称之为布尔格或布尔代数 Thm：在布尔代数中 \\(\\forall a\\in B,(a&#39;)&#39; = a\\) \\(\\forall a,b\\in B,(a\\wedge b)&#39; =(a&#39;\\vee b&#39;),(a\\vee b)&#39; = (a&#39;\\wedge b&#39;)\\) 在这个定理中，第一条称作双重否定律，第二条称作德摩根律，在命题代数和集合代数中的双重否定律，实则是该定理的特例 Def：设\\(&lt;B,*,\\circ&gt;\\)是代数系统，若运算满足： 交换律 分配律（\\(*\\) 对 \\(\\circ\\) \\(\\circ\\) 对 \\(*\\) 都有分配律） 同一律 \\(a*1=a,a\\circ 0=a\\) 补元律（所有元素的补元存在且唯一） 则称之为一个布尔代数 Def：（原子）在格中，若 \\(0\\prec b\\preccurlyeq a\\iff b=a\\) 则称 \\(a\\) 是 L 中的原子 Thm：（有限布尔代数的表示定理）设 \\(B\\) 是有限布尔代数，\\(A\\) 是由 \\(B\\) 的全体原子构成的集合，则 \\(B\\) 同构于 \\(A\\) 的幂集代数 \\(P(A)\\) Inf：任何有限布尔代数的基数为 \\(2^n\\) Inf：任何等势的有限布尔代数都是同构的","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"代数结构","slug":"Algebra-Structure","permalink":"http://adversarr.github.io/tags/Algebra-Structure/"}]},{"title":"群与环","slug":"study/Math/DiscreteMath/GroupTheory","date":"2020-05-26T16:00:00.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2020/05/27/study/Math/DiscreteMath/GroupTheory/","link":"","permalink":"http://adversarr.github.io/2020/05/27/study/Math/DiscreteMath/GroupTheory/","excerpt":"期末复习了 qwwww","text":"期末复习了 qwwww 群的定义和性质 Def：群 设 \\(V = &lt;S,\\circ&gt;\\) 是代数系统，\\(\\circ\\) 是二元运算，且是可结合的，则称 \\(V\\) 是半群 设 \\(V\\) 是一个半群，存在关于 \\(\\circ\\) 运算的单位元，则称 \\(V\\) 是幺半群，也称为独异点 若 \\(V\\) 是一个独异点，\\(e\\in S\\) 是其单位元，若 \\(\\forall a \\in S,a^{-1}\\in S\\) 则称 \\(V\\) 为群，通常用 \\(G\\) 代表 常见的群有：整数加群、有理数加群、实数加群、复数加群 Klein 四元群： e a b c e e a b c a a e c b b b c e a c c b a e Def：平凡群、有限群、无限群、交换群 若群 \\(G\\) 是有穷集，则称 \\(G\\) 为有限群，反之称为无限群。其中 \\(G\\) 的基数称为群 \\(G\\) 的阶 若 \\(G\\) 中只含有单位元，称之为平凡群 若二元运算 \\(\\circ\\) 是可交换的，则称 \\(G\\) 为交换群或是 Abel 群。 Def：幂运算 \\[ a^n= \\begin{cases} e,\\qquad &amp;n = 0\\\\ a^{n-1}a,&amp; n &gt;0\\\\ (a^{-1})^m,&amp; n&gt;0,n = -m \\end{cases} \\] Def：（元素的阶）将使得 \\(a^k = e\\) 成立的最小正整数 \\(k\\) 称为 \\(a\\) 的阶。有 \\(k\\) 阶元，也有无限阶元。 Thm：幂运算满足 \\((a^{-1})^{-1} = a\\) \\((ab)^{-1} = b^{-1}a^{-1}\\) \\(a^na^m = a^{m+n}\\) \\((a^n)^m = a^{mn}\\) 交换群中，\\((ab)^n = a^nb^n\\) Thm：群中满足消去律 Thm：设群 \\(G\\) 中有元素 \\(a\\) 满足 \\(|a|\\) 为 \\(r\\) 则： \\(a^k = e\\iff r|k\\) \\(|a^{-1}|=|a|\\) 子群和群的陪集分解 Def：子群、真子群 Def：（判定定理 1）设 \\(G\\) 为群，\\(H\\) 是 \\(G\\) 的非空子集，则 \\(H\\) 是 \\(G\\) 的子群，当且仅当下列条件同时成立 \\(\\forall a,b\\in H,ab\\in H\\) \\(\\forall a\\in H, a^{-1}\\in H\\) Thm：（判定定理 2）设 \\(G\\) 为群，\\(H\\) 是 \\(G\\) 的非空子集，则 \\(H\\) 是 \\(G\\) 的子群，当且仅当 \\(\\forall a,b\\in H, ab^{-1}\\in H\\) Thm：（判定定理 3）设 \\(G\\) 为群，\\(H\\) 是 \\(G\\) 的非空子集，则 \\(H\\) 是 \\(G\\) 的有穷子群，当且仅当 \\(\\forall a,b\\in H,ab\\in H\\) Def：（中心）设 \\(G\\) 是群，令 \\(C\\) 是与 \\(G\\) 中所有元素都可交换的元素构成的集合，\\(C=\\{a|a\\in G\\wedge \\forall x\\in G(ax=xa)\\}\\) 则称 \\(C\\) 为 \\(G\\) 的中心，且是 \\(G\\) 的一个子群。 Def：（由 \\(B\\) 生成的子群）设 \\(B\\) 是 \\(G\\) 的子集，将所有包含 \\(B\\) 的子群的交记作 \\(&lt;B&gt;\\)。 Caution未知正确性：\\(&lt;B&gt;\\) 中只含有 \\(B\\) 中的元素或其逆元。 Def：设 \\(H\\) 是群 \\(G\\) 的子群，\\(a\\in G\\)，令\\(Ha =\\{ha|h\\in H\\}\\) 称之为子群 \\(H\\) 在 \\(G\\) 中的右陪集，并称 \\(a\\) 为 \\(Ha\\) 的代表元素。 Thm：设 \\(H\\) 是 \\(G\\) 的子群，则 \\(He =H\\) \\(\\forall a\\in G, a\\in Ha\\) Thm：设 \\(H\\) 是 \\(G\\) 的子群，则 \\(\\forall a,b\\in G\\) TFAE \\(a\\in Hb\\) \\(ab^{-1}\\in H\\) \\(Ha=Hb\\) Thm：设 \\(H\\) 是 \\(G\\) 的子群，在 \\(G\\) 上定义二元关系：\\(\\forall a,b\\in G &lt;a,b&gt;\\in R\\iff ab^{-1}\\in H\\) 则 \\(R\\) 是 \\(G\\) 上的等价关系，且 \\([a]_R =Ha\\) Inf：设 \\(H\\) 是 \\(G\\) 的子群，则 \\(\\forall a,b\\in G, Ha = Hb 或 Ha\\cap Hb =\\emptyset\\) \\(\\cup\\{Ha|a\\in G\\} = G\\) Tips于此同时，\\(H\\) 的所有右陪集的集合\\(\\{Ha|a\\in G\\}\\) 恰好构成 G的一个划分，并且，这个划分的所有划分快都和 \\(H\\) 等势。用同样的方法可以定义 \\(H\\)的左陪集。 Def：（指数）\\(H\\) 在 \\(G\\) 中的左右陪集数相等，记作 \\(H\\) 在 \\(G\\) 中的指数 \\([G:H]\\) Thm：（Lagrange 定理）设 \\(G\\) 是一个有限群，\\(H\\) 是 \\(G\\) 的子群，则 \\(|G| = |H|\\cdot [G:H]\\) Inf：设 \\(G\\) 是 \\(n\\) 阶群，则 \\(\\forall a\\in G\\)，\\(|a|\\) 是 \\(n\\) 的因子，且 \\(a^n =e\\) Inf：设 \\(G\\) 是素数阶的群，则存在 \\(a\\in G\\)，使得\\(G=&lt;a&gt;\\) 循环群和置换群 Def：（循环群）若存在 \\(a\\in G\\) 使得 \\(G = &lt;a&gt;\\) 则称 \\(G\\) 为循环群，称 \\(a\\) 为 \\(G\\) 的生成元 其中，若 \\(a\\) 是 \\(n\\) 阶元，则 \\(|G| = n\\) 则称 \\(G\\) 为 \\(n\\) 阶循环群，若 \\(a\\) 是无限阶元，则称 \\(G\\) 是无限循环群 Thm：设 \\(G=&lt;a&gt;\\) 是循环群， \\(G\\) 是无限循环群，则 \\(G\\) 只有两个生成元，即为 \\(a\\) 和 \\(a^{-1}\\) \\(G\\) 是 \\(n\\) 阶循环群，则 \\(G\\) 含有 \\(\\phi(n)\\) 个生成元，对于任何小于且与 \\(n\\) 互素的自然数 \\(r\\)，\\(a^r\\) 是 \\(G\\) 的生成元 Thm： 设 \\(G\\) 是循环群，则 \\(G\\) 的子群是循环群 \\(G\\) 是无限循环群，则 \\(G\\) 的子群除了 \\(\\{e\\}\\) 之外都是无限循环群 若 \\(G\\) 是 \\(n\\) 阶循环群，则对于 \\(n\\) 的每一个正因子 \\(d\\)，\\(G\\) 恰好含有一个 \\(d\\) 阶子群","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"代数结构","slug":"Algebra-Structure","permalink":"http://adversarr.github.io/tags/Algebra-Structure/"}]},{"title":"无穷级数","slug":"study/Math/Advanced-Mathematics/ConstantSeries","date":"2020-05-24T16:00:00.000Z","updated":"2022-04-06T03:33:16.282Z","comments":true,"path":"2020/05/25/study/Math/Advanced-Mathematics/ConstantSeries/","link":"","permalink":"http://adversarr.github.io/2020/05/25/study/Math/Advanced-Mathematics/ConstantSeries/","excerpt":"级数部分相关定理。","text":"级数部分相关定理。 常数项级数 常数项级数的概念、性质、原理 Def：（级数）我们把一个形如 \\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 的式子称为无穷级数 Def：级数的部分和、级数的敛散性、级数和的定义 Thm：性质，若 \\(a_n\\) 和 \\(b_n\\) 级数收敛，则 线性性质 \\(\\sum\\limits_{k=0}^{\\infty}(a_k+b_k) =\\sum\\limits_{k=0}^{\\infty} a_k+ \\sum\\limits_{k=0}^{\\infty}b_k\\) 若 \\(a_n\\le b_n\\) 则 \\(\\sum\\limits_{k=0}^{\\infty}a_n\\le\\sum\\limits_{k=0}^{\\infty}b_n\\) 任意更改有限项不改变敛散性 在不改变次序的情况下，任意添加括号所得到的新的级数敛散性不变，和不变 Thm：（Cauchy 收敛原理）级数\\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 收敛的充要条件是 \\(\\forall\\varepsilon&gt;0,\\exists N\\in \\mathbf{N}_+\\forall p\\in \\mathbf{N}_+(n&gt;N \\rightarrow |\\sum\\limits_{k=n+1}^{n+p}a_k|&lt;\\varepsilon)\\) 正项级数的审敛准则 Thm：正项级数\\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 收敛的充要条件是其部分和数列 \\(\\{S_n\\}\\) 有上界 Thm：（比较准则 1 ）设\\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 和 \\(\\sum\\limits_{k=0}^{\\infty}b_n\\) 是正项级数，且 \\(\\forall n\\in \\mathbf N_+,a_n\\le b_n\\)，则 \\(\\sum\\limits_{k=0}^{\\infty}b_n\\) 收敛，则 \\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 收敛 \\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 发散，则 \\(\\sum\\limits_{k=0}^{\\infty}b_n\\) 发散 Thm：（比较准则 2 极限形式）设\\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 和 \\(\\sum\\limits_{k=0}^{\\infty}b_n\\) 是正项级数，且有\\(\\lim \\frac{a_n}{b_n} =\\lambda\\) 则： \\(\\lambda&gt;0\\) 则两个级数有相同的敛散性 \\(\\lambda = 0\\) 若 \\(\\sum\\limits_{k=0}^{\\infty}b_n\\) 收敛，则 \\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 收敛 \\(\\lambda = \\infty\\) 若 \\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 发散，则 \\(\\sum\\limits_{k=0}^{\\infty}b_n\\) 发散 Thm：（达朗贝尔判别法、D'Alembert 准则）若正项级数\\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 满足 \\(\\lim\\limits_{n\\rightarrow \\infty} \\frac{u_{n+1}}{u_n} = l\\) 则 \\(l&lt;1\\)，收敛 \\(l&gt;1\\)，发散 \\(l=1\\)，敛散性不定 Thm：（柯西判别法、Cauchy 准则）若正项级数\\(\\sum\\limits_{k=0}^{\\infty}a_n\\) 满足 \\(\\lim\\limits_{n\\rightarrow \\infty} \\sqrt[n]{a_n} = \\lambda\\) 则 \\(\\lambda&lt;1\\)，收敛 \\(\\lambda&gt;1\\)，发散 \\(\\lambda=1\\)，敛散性不定 *Thm：（拉阿伯判别法）若正项级数满足：\\(\\lim\\limits_{n\\rightarrow \\infty} n(\\frac{u_n}{u_{n+1}} -1)=R\\) 则 \\(R&gt;1\\)，收敛 \\(R&lt;1\\)，发散 \\(R=1\\)，敛散性不定 例：讨论 \\(\\displaystyle\\sum\\limits_{k=0}^{\\infty}\\frac{(2n-1)!!}{2n!!}\\cdot\\frac{1}{2n+1}\\) 的敛散性 解：应用拉阿伯判别法 \\(R = \\frac 3 2\\) 故级数收敛 Thm：（积分判别准则）若存在一个单调下降的非负函数 \\(f(x)\\) 使得 \\(f(n) = u_n\\)，则无穷积分与无穷级数有相同的敛散性 任意项级数 Def：交错级数 \\(\\sum\\limits_{k=0}^{\\infty}(-1)^n\\cdot a_n\\) Thm：（Leibniz 准则）若交错级数满足 \\(u_n\\ge u_{n+1}\\) \\(\\lim\\limits_{n\\rightarrow \\infty} u_n = 0\\) 则该交错级数收敛 Def：绝对收敛，条件收敛 Thm：（绝对收敛准则）若级数 \\(\\sum\\limits_{n=1}^{\\infty} |a_n|\\) 收敛，则级数 \\(\\sum\\limits_{n=1}^{\\infty} a_n\\) 收敛 Thm：若级数绝对收敛，则其的任何一个重排绝对收敛，且和相等 Thm：若级数 \\(\\sum\\limits_{n=1}^{\\infty} a_n = A\\) 和 \\(\\sum\\limits_{n=1}^{\\infty} b_n = B\\) 绝对收敛，则各项相乘得到的乘积项按任何次序排列得到的级数 \\(\\sum\\limits_{n=1}^{\\infty} c_n\\) 绝对收敛于 \\(AB\\) Lemma：（Abel 变换式）\\(\\sum\\limits_{k =1}^{m}\\alpha_k\\beta_k = \\sum\\limits_{k=1}^{m-1}(\\alpha_k-\\alpha_k+1)B_k +a_mB_m\\) Lemma：（Abel 引理）若数组\\(\\{\\alpha_k\\}\\) 是单调的，又有数组 \\(\\{\\beta_k\\}\\) 的部分和为 \\(B_n\\) 满足不等式 \\(|B_n| = |\\sum\\limits_{k=1}^{n}\\beta_k|\\le M\\)，则有 \\(\\sum\\limits_{k=1}^m \\alpha_k\\beta_k\\le M(|\\alpha_1|+2|\\alpha_m|)\\) Thm：（狄利克雷判别法）若 \\(\\{a_n\\}\\) 单调且 \\(\\lim\\limits_{k\\rightarrow\\infty} a_k=0\\) 级数 \\(\\sum\\limits_{k=1}^\\infty b_k\\) 部分和序列有界，则级数 \\(\\sum\\limits_{k=1}^\\infty a_kb_k\\) 收敛 Thm：（Abel 判别法）若 \\(\\{a_k\\}\\) 单调有界，且 \\(\\sum\\limits_{k=1}^\\infty\\) 级数收敛，则级数 \\(\\sum\\limits_{k=1}^\\infty a_kb_k\\) 收敛","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"级数","slug":"Series","permalink":"http://adversarr.github.io/tags/Series/"}]},{"title":"外微分形式与微积分","slug":"study/Math/Advanced-Mathematics/Exterior-Differential","date":"2020-05-23T16:00:00.000Z","updated":"2022-03-03T04:30:41.515Z","comments":true,"path":"2020/05/24/study/Math/Advanced-Mathematics/Exterior-Differential/","link":"","permalink":"http://adversarr.github.io/2020/05/24/study/Math/Advanced-Mathematics/Exterior-Differential/","excerpt":"些些写累了，准备 白嫖 维基百科。关于外微分形式与场论中几个公式，在教材中并没有给出完整的说明，在这里简单记录一下。","text":"些些写累了，准备 白嫖 维基百科。关于外微分形式与场论中几个公式，在教材中并没有给出完整的说明，在这里简单记录一下。 以下内容收集自 Wikipedia 外微分形式 定义 一个 \\(k\\) 阶的微分形式的外微分是 \\(k+1\\) 阶的微分形式。对于一个 \\(k\\) 阶形式的 \\(ω = f_I\\mathrm dx_I\\)，其外微分形式为\\({\\displaystyle \\mathrm d{\\omega }=\\sum _{i=1}^{n}{\\frac {\\partial f_{I}}{\\partial x_{i}}}\\mathrm dx_{i}\\wedge \\mathrm dx_{I}}\\)。 对于一般的k-形式 \\(\\sum f_I dx_I\\) （其中多重指标 \\(I\\) 取遍所有\\(\\{1, ..., n\\}\\)的为 \\(k\\) 基数的有序子集），我们只作了线性推广。注意如果上面有 \\(i=I\\) 则 \\(\\mathrm dx_{i}\\wedge\\mathrm dx_{I}=0\\)。 性质 外微分满足： 线性 楔积法则：\\(\\displaystyle{ d(\\omega \\wedge \\eta )=d\\omega \\wedge \\eta +(-1)^{ {\\rm {deg\\,} }\\omega }(\\omega \\wedge d\\eta )}\\) \\(\\mathrm d^2 =0\\) 微积分中的外微分 梯度 对于一个 0-形式，也就是一个光滑函数 \\(f: R^n\\rightarrow R\\)，我们有 \\({\\displaystyle df=\\sum _{i=1}^{n}{\\frac {\\partial f}{\\partial x_{ i } } }\\,dx_{i}}\\)，所以对于向量场 \\(\\boldsymbol V\\) 而言：\\({\\displaystyle df(V)=\\langle {\\mathrm{grad} }f,V\\rangle }\\) 旋度 对于一个 1-形式，\\({\\displaystyle \\omega =\\sum _{i}f_{i}\\,dx_{i}}\\) 在 \\(R^3\\) 上，有： \\[ {\\displaystyle \\omega =\\sum _{i}f_{i}\\,dx_{i}} \\] 它限制到三维情况 \\({\\displaystyle \\omega =u\\,dx+v\\,dy+w\\,dz}\\) 就是 \\[ {\\displaystyle d\\omega =\\left({\\frac {\\partial v}{\\partial x}}-{\\frac {\\partial u}{\\partial y}}\\right)dx\\wedge dy+\\left({\\frac {\\partial w}{\\partial y}}-{\\frac {\\partial v}{\\partial z}}\\right)dy\\wedge dz+\\left({\\frac {\\partial u}{\\partial z}}-{\\frac {\\partial w}{\\partial x}}\\right)dz\\wedge dx.} \\] 因此，对于向量场 \\({\\displaystyle U}, {\\displaystyle V=[u,v,w]}\\) 和 \\({\\displaystyle W}\\) 我们有 \\({\\displaystyle d\\omega (U,W)=\\langle {\\mathrm{curl}}\\,V\\times U,W\\rangle }\\) 其中 \\(\\mathrm {curl} V\\) 代表V的旋度，\\(\\times\\) 是向量积，而 \\(&lt;,&gt;\\) 是标量积。 散度 对于一个 2-形式 \\({\\displaystyle \\omega =\\sum _{i,j}h_{i,j}\\,dx_{i}\\wedge dx_{j},}\\) 对于三维，若\\({\\displaystyle \\omega =p\\,dy\\wedge dz+q\\,dz\\wedge dx+r\\,dx\\wedge dy}\\) \\({\\displaystyle d\\omega} {\\displaystyle =\\left({\\frac {\\partial p}{\\partial x}}+{\\frac {\\partial q}{\\partial y}}+{\\frac {\\partial r}{\\partial z}}\\right)dx\\wedge dy\\wedge dz}{\\displaystyle ={\\mathrm{div}}V\\,dx\\wedge dy\\wedge dz,}\\) 其中 \\(V\\) 是一个向量场定义为 \\({\\displaystyle V=[p,q,r].}\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"外微分形式","slug":"Wedge-Differential","permalink":"http://adversarr.github.io/tags/Wedge-Differential/"},{"name":"向量空间","slug":"Vector-Space","permalink":"http://adversarr.github.io/tags/Vector-Space/"}],"author":"Clover"},{"title":"多元函数积分学及其应用","slug":"study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Integration","date":"2020-05-22T16:00:00.000Z","updated":"2022-03-03T04:30:41.415Z","comments":true,"path":"2020/05/23/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Integration/","link":"","permalink":"http://adversarr.github.io/2020/05/23/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Integration/","excerpt":"多元函数积分学复习提纲。些些在 5.20 被强行塞了一大把狗粮之后，才知道下个星期就要考试，现在才开始预习...","text":"多元函数积分学复习提纲。些些在 5.20 被强行塞了一大把狗粮之后，才知道下个星期就要考试，现在才开始预习... 多元数量值函数积分的概念和性质 质量的计算 多元数量值函数积分的概念 Def：多元数量值函数积分 积分存在的条件和性质 线性性质 对积分域的可加性 积分不等式 中值定理 二重积分的计算 二重积分的几何意义 直角坐标系下二重积分的计算法 极坐标系下二重积分的计算法 曲线坐标下二重积分的计算法 三重积分的计算 化三重积分为单积分与二重积分的累次积分 柱面、球面坐标下的三重积分计算法 曲线坐标下的三重积分 柱面坐标及柱面坐标下的三重积分计算法 球面坐标和球面坐标下的三重积分计算法 含参变量的积分和反常重积分 含参变量的积分 Def：含参变量\\(y\\)的积分 Thm：（连续性）\\(f\\in C(D) \\rightarrow F(y) = \\int^b_af(x,y)\\mathrm d x 在[c,d]上连续\\) Inf：（连续性的极限形式表达）\\(\\displaystyle\\lim \\limits_{y\\rightarrow y_0} \\int_a^bf(x,y)\\mathrm d x = \\int_a^b f(x,y_0)\\mathrm d x = \\int_a^b[\\lim\\limits_{y\\rightarrow y_0} f(x,y)]\\mathrm dx\\) Thm：（可导性）\\(f,f_y\\in C(C)\\)，则 $F(y) = f(x,y) dx $有连续导数，且积分和求导运算可交换 Thm：（积分顺序交换性）\\(f \\in C, F(y) = \\int f\\mathrm dx ,G(x) = \\int f\\mathrm dy\\rightarrow \\int F(y) \\mathrm d y = \\int G(x) \\mathrm dx\\) Thm：设 \\(f(x,y)\\in C(D), x_i (y) \\in C[c,d]\\) 则，\\(F(y) = \\int_{x_1(y)}^ {x_2(y)}f(x,y)\\mathrm dx\\) 在\\([c,d]\\)上连续 Thm：\\(F&#39;(y) = \\int _{x_1(y)}^ {x_2(y)}f_y(x,y)\\mathrm dx+ f(x_2, y]x_2&#39; - f(x_1,y) x_1&#39;\\) 反常重积分 无界区域的二重积分 Thm：（收敛判别法）\\(f(x,y)\\) 在无界区域上连续，若存在\\(\\rho_0&gt;0\\)，使当\\(\\rho \\ge \\rho_0\\) 有\\(|f|\\le \\frac {M}{\\rho^\\alpha}\\)，且 \\(M,\\alpha\\)为常数，则当\\(\\alpha &gt;2\\)时反常二重积分\\(\\int\\int f \\mathrm d \\sigma\\)收敛 无界函数的二重积分 Def：无界函数的二重积分\\(\\lim\\limits_{d\\rightarrow 0} \\int\\int f\\mathrm d \\sigma\\) Thm：（收敛判别法）设 \\(f(x,y)\\) 在有界区域上除了\\(P_0\\)外处处连续，若 \\(|f|\\le \\frac {M}{\\rho ^\\alpha}\\)在除 \\(P_0\\) 外的区域上处处成立，则当 \\(\\alpha &lt;2\\)时，反常二重积分收敛 第一型线积分与面积分 第一型线积分 第一型线积分的计算公式 \\(r = r(t)\\rightarrow \\int_{(C)}f ds = \\int_{(C)}f \\sqrt{\\dot x^2+\\dot y^2+\\dot z^2}\\mathrm d t\\) 第一型面积分 曲面的面积 Thm：（用 \\(u,v\\) 变量表示曲面）\\(S = \\int\\int\\limits_{(\\sigma)}||\\boldsymbol r_u \\times \\boldsymbol r_v|| \\mathrm d u \\mathrm d v\\) Thm：（用 \\(z = f(x,y)\\) 表示曲面）\\(S = \\iint \\limits_{(\\sigma)} ||\\boldsymbol r_x \\times \\boldsymbol r_y || \\mathrm dx\\mathrm dy = \\iint\\limits_{(S)} \\sqrt{1+f_x^2+f_y^2}\\mathrm dx \\mathrm dy\\) 第一型曲面积分的计算 Thm：（用 \\(u,v\\) 变量表示曲面）\\(I = \\iint\\limits_{(S)} f(x,y,z)\\mathrm dS = \\iint\\limits_{(\\sigma)}f||\\boldsymbol r_u \\times \\boldsymbol r_v|| \\mathrm d u \\mathrm d v\\) Thm：（用 \\(z = f(x,y)\\) 表示曲面）\\(I = \\iint\\limits_{(S)} f \\sqrt{1+f_x^2+f_y^2}\\mathrm dx \\mathrm dy\\) 第二型线积分和面积分 场的概念 Def：数量场、向量场、场函数 场的几何描述 第二型线积分 Def：第二型线积分\\(\\int_{(C)} \\boldsymbol A(M)\\cdot \\boldsymbol{\\mathrm d s} = \\lim\\limits_{d\\rightarrow 0} \\sum\\limits_{k=1}^n \\boldsymbol{A}(\\overline {M_k})\\cdot \\overrightarrow{M_{k-1}M_k}\\) 第二型线积分的性质 积分结果与方向有关 可加性 第二型线积分的计算 \\(\\int_{(C)}\\boldsymbol A(M)\\cdot \\boldsymbol{\\mathrm ds} = \\int_{(C)}P\\mathrm dx +Q\\mathrm dy +R\\mathrm dz =\\int P\\dot x+Q\\dot y+R\\dot z \\mathrm dt\\) 两类线积分的联系 \\(\\int_{(C)}\\boldsymbol A(M) \\cdot \\boldsymbol{\\mathrm ds} = \\int \\boldsymbol A(M)\\cdot \\boldsymbol e_r \\mathrm ds\\) 第二型面积分 Def：第二型面积分 \\(\\iint\\limits_{(S)} \\boldsymbol A(M)\\cdot \\boldsymbol {\\mathrm dS} = \\lim\\limits_{d\\rightarrow 0}\\sum\\limits_{k=1}^n \\boldsymbol A(M_k)\\cdot \\boldsymbol e_n(M_k) \\Delta S_k\\) Thm：（用外微分形式表示）\\(\\iint A(M)\\cdot \\boldsymbol{\\mathrm dS} = \\iint\\limits_{(S)}P\\mathrm dy \\wedge \\mathrm dz +Q\\mathrm dz \\wedge dx + R\\mathrm dx\\wedge \\mathrm dy\\) 两种面积分的联系 \\(\\iint_{(S)} \\boldsymbol A(M)\\cdot \\mathrm d \\boldsymbol S = \\iint (P\\cos\\alpha + Q\\cos\\beta + R\\cos\\gamma)\\mathrm dS\\) 第二型面积分的计算 \\(\\iint_{(S)} R(x,y,z) \\mathrm dx\\wedge \\mathrm dy = \\pm \\iint\\limits_{(\\sigma_{xy})} R(x,y,z(x,y))\\mathrm dx\\mathrm dy\\) 其余式同理。其中当曲面法向量与 \\(z+\\) 同向时取 \\(+\\) 号，反之取 \\(-\\) 号 各种积分的联系及其在场论中的应用 Green 公式 Def：单连通域，复连通域 Thm：Green 公式 \\(\\iint_{(\\sigma)}(\\frac{\\delta Q}{\\delta x} - \\frac{\\delta P}{\\delta y} \\mathrm d \\sigma = \\oint_{(\\pm C)} P\\mathrm dx + Q\\mathrm dy\\) Inf：任何一条分段光滑的闭曲线所围成的平面区域的面积为 \\(A = \\frac 1 2 \\oint_{(+C)} x\\mathrm dy - y\\mathrm dx= \\oint_{(+C)} x\\mathrm dy = -\\oint_{(+C)} y\\mathrm dx\\) 平面线积分与路径无关的条件 Thm：TFAE 沿区域内任何一条分段光滑的简单闭曲线的线积分 \\(\\oint P\\mathrm dx+Q\\mathrm dy = 0\\) 线积分 \\(\\int P\\mathrm dx +Q\\mathrm dy\\) 的值在区域内与积分路径无关 被积表达式\\(P\\mathrm dx +Q\\mathrm dy\\) 是某个二元函数的全微分 Def：（环流量、环量）称眼闭曲线 \\(C\\) 的第二型线积分为向量场 \\(A\\) 沿闭曲线 \\(C\\) 的环量。 Def：（势函数、位函数、有势场） 该结论表明，对于一个连续向量场而言，无旋、保守、有势是等价的。 势函数的求法 用线积分求解 用偏积分求解 用凑全微分法求解 Gauss 公式和散度 Gauss 公式 Thm：（Gauss 公式）\\(\\iiint_{(V)} (\\frac{\\partial P}{\\partial x} +\\frac{\\partial Q}{\\partial y} +\\frac{\\partial R}{\\partial z})\\mathrm dV = \\iint P \\mathrm dy\\wedge \\mathrm dz +Q\\mathrm dz\\wedge \\mathrm dx+R\\mathrm dx\\wedge \\mathrm dy\\) Thm：（Gauss 公式）\\(\\iiint_{(V)}\\nabla \\cdot \\boldsymbol A \\mathrm dV = \\iint_{(S)} \\boldsymbol A\\cdot \\mathrm d \\boldsymbol S\\) 通量和通量密度 Def：（通量）\\(\\boldsymbol A(M)\\) 对曲面 \\((S)\\) 的第二型面积分 \\(\\iint\\limits_{(S)} \\boldsymbol A \\cdot \\mathrm d \\boldsymbol S\\) 散度的定义及其计算 Def：（散度）\\(\\mathrm{div} \\boldsymbol A(M) = \\lim\\limits_{(\\Delta V)\\rightarrow M}\\frac{1}{\\Delta V} \\iint \\boldsymbol A(M)\\cdot \\mathrm d\\boldsymbol S\\) Thm：（散度的计算公式）\\(\\mathrm{div} A = \\nabla \\cdot \\boldsymbol A = \\frac{\\partial P}{\\partial x} +\\frac{\\partial Q}{\\partial y} +\\frac{\\partial R} {\\partial z}\\) Inf：（用散度表示 Gauss 公式）\\(\\iiint\\limits_{(V)} \\mathrm{div} \\mathrm A \\mathrm d V = \\iint\\boldsymbol A\\cdot \\mathrm d \\boldsymbol S\\) 散度的运算法则和公式 \\(\\mathrm{div}(C\\boldsymbol A) = C\\mathrm{div} \\boldsymbol A\\) \\(\\mathrm{div}(\\boldsymbol A\\pm\\boldsymbol B) = \\mathrm{div}(\\boldsymbol A) \\pm \\mathrm{div}(\\boldsymbol B)\\) \\(\\mathrm{div}(u\\boldsymbol A) = u\\mathrm{div} \\boldsymbol A + \\nabla u \\cdot \\boldsymbol A\\) Stokes 公式和旋度 Stokes 公式 Thm：（Stokes 公式）\\(\\oint_{(C)} P\\mathrm dx + Q\\mathrm dy +R\\mathrm dz = \\iint\\limits_{(S)}(\\frac{\\partial R}{\\partial y} -\\frac{\\partial Q}{\\partial z})\\mathrm dy\\wedge \\mathrm dz +(\\frac{\\partial p}{\\partial z}-\\frac{\\partial R}{\\partial x}) \\mathrm dz\\wedge \\mathrm dx + (\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y})\\mathrm dx\\wedge \\mathrm dy\\) Inf：（利用 nabla 算子表示的 Stokes 公式）\\(\\oint_{(C)} \\boldsymbol A\\cdot \\mathrm d \\boldsymbol s = \\iint_{(S)} (\\nabla \\times \\boldsymbol A)\\cdot \\mathrm d \\boldsymbol S = \\iint_{(S)} (\\nabla \\times \\boldsymbol A)\\cdot \\boldsymbol e_n \\mathrm dS\\) 环量和环量密度 环量密度 \\(\\lim\\limits_{(\\Delta )\\rightarrow M } \\frac {1} {\\Delta S}\\oint_{(\\Delta C)}\\boldsymbol A\\cdot \\mathrm d \\boldsymbol s\\) 旋度的定义及其计算公式 Def：（旋度）\\(\\mathrm{rot} \\boldsymbol A\\) 用行列式表示 Thm：（旋度的计算公式）\\(\\oint_{(C)}\\boldsymbol A\\cdot \\mathrm d \\boldsymbol s=\\iint\\limits_{(S)} \\mathrm{rot}\\boldsymbol A \\cdot \\mathrm d \\boldsymbol S\\) 旋度的运算法则 \\(\\mathrm{rot} (C\\boldsymbol A) = C\\mathrm{rot} \\boldsymbol A\\) $ (AB) =A B $ \\(\\mathrm {rot}(u\\boldsymbol A) = u\\mathrm{rot} \\boldsymbol A +(\\nabla u)\\times \\boldsymbol A\\) 场的其他计算公式 \\(\\mathrm{div}(\\boldsymbol A\\times \\boldsymbol B) =\\boldsymbol B\\cdot \\mathrm{rot}\\boldsymbol A\\) \\(\\mathrm{div}(\\mathrm{rot} \\boldsymbol A) = 0\\) \\(\\mathrm{rot} (\\nabla u) = 0\\) \\(\\mathrm{div}(\\nabla u)=\\Delta u\\) 其中 $= + + $ \\(\\mathrm{rot}(\\mathrm{rot} \\boldsymbol A) =\\mathbf{grad}(\\mathrm{div} A)-\\Delta \\boldsymbol A\\) 几种重要的特殊向量场 Def：一维单连域、二维单连域 无旋场 Def：（保守场）积分与路径无关 Def：（无旋场）\\(\\nabla \\times \\boldsymbol A = \\boldsymbol 0\\) Def：（有势场，势函数）\\(\\boldsymbol A = \\nabla u\\) Thm：在一维单连域上，\\(A = (P,Q,R) \\in C^{(1)}\\)，TFAE 无旋场 闭曲线上的环量恒为 0 保守场 有势场 无源场 Def：（无源场）\\(\\nabla \\cdot \\boldsymbol A = 0\\) Def：向量管 Thm：在二维单连域上，\\(A\\in C^{(1)}\\)，TFAE 无源场 \\(A\\) 沿任何一个不子交的闭曲面的通量为零 存在一个向量函数 \\(\\boldsymbol B\\) 使得 \\(\\boldsymbol A = \\nabla \\times \\boldsymbol B\\) 调和场 Def：（调和场）既无源、也无旋的场 满足 Laplace 方程 满足 Posisson 方程 补录 重积分 Def：（大和，小和）\\(M_i = \\sup\\limits_{x\\in\\Omega_i}\\{f(\\boldsymbol{x})\\},\\quad m_i =\\inf\\limits_{x\\in\\Omega_i }\\{f(\\boldsymbol{ x})\\}\\) \\(S^+= \\sum M_iV_i,S^-=\\sum m_iV_i\\) Thm：TFAE 可积 大和与小和差的极限为 0 （ \\(||\\Delta||\\rightarrow 0\\) ） 振幅充分小 （积分）大和 = （积分）小和 重积分变换 Def：（正则变换）如果一个变换满足 \\(T\\in C^{(1)}(G)\\) 单射 \\(\\det DT(\\boldsymbol u)\\neq 0\\) 对任一 \\(\\boldsymbol u\\)成立 Def：（重积分的变换公式）若 \\(G,T\\) 满足以下条件之一： \\(G\\) 是 \\(R^m\\) 中的开集，\\(T\\) 是正则变换， \\(\\Omega\\) 是 \\(G\\) 内的闭可测图形，\\(f\\in C(T(\\Omega))\\) \\(G\\) 同上，\\(T\\in C^1(G)\\)，\\(\\Omega \\in G\\) 是闭可测区域，\\(T\\) 是 \\(\\Omega\\) 上的正则变换，\\(f\\in C(T(\\Omega))\\) 则：\\(\\int_{T(\\varOmega)}f\\mathrm dV = \\int_\\varOmega f\\circ T|\\det DT|\\mathrm dV\\) 外微分形式 场论总结 Def：（梯度） \\(\\mathrm{grad} u = \\nabla u\\)，其中 \\(\\nabla\\) 算子为 \\((\\frac{\\partial}{\\partial x},\\frac{\\partial}{\\partial y},\\frac{\\partial}{\\partial z})\\) Def：向量线 Def：（通量、散度）给定向量场 \\(F\\) 和双侧曲面 \\(S\\) 通量：\\(\\iint_S \\boldsymbol{F}\\cdot \\mathrm d \\boldsymbol{s}\\) 散度：\\(\\mathrm{div} \\boldsymbol{F} = \\lim\\limits_{S\\rightarrow M}\\frac{\\iint_S \\boldsymbol{F}\\cdot \\mathrm d \\boldsymbol{s}}{V} = \\nabla \\cdot \\boldsymbol{F}\\) Def：（环量、旋度）给定向量场和定向曲线 环量：\\(\\oint \\boldsymbol{F}\\cdot \\mathrm d \\boldsymbol{s}\\) 方向旋量：\\(h_n = \\mathrm{rot} \\boldsymbol{F}\\cdot \\boldsymbol{n}\\) 旋度：\\((\\frac{\\partial R}{\\partial y} -\\frac{\\partial Q}{\\partial z})\\boldsymbol{i} +(\\frac{\\partial p}{\\partial z}-\\frac{\\partial R}{\\partial x}) \\boldsymbol{j} + (\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y})\\boldsymbol k\\)","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"向量空间","slug":"Vector-Space","permalink":"http://adversarr.github.io/tags/Vector-Space/"},{"name":"多元函数","slug":"Multi-Functions","permalink":"http://adversarr.github.io/tags/Multi-Functions/"}],"author":"Clover"},{"title":"向量空间与解析几何","slug":"study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry","date":"2020-05-21T16:00:00.000Z","updated":"2022-03-03T04:30:41.496Z","comments":true,"path":"2020/05/22/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry/","link":"","permalink":"http://adversarr.github.io/2020/05/22/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry/","excerpt":"临近期末，来一波概念回顾。","text":"临近期末，来一波概念回顾。 向量及其运算 向量的概念 Def：（向量）一个既有大小又有方向的量 Def：向量的模（或长度），范数 \\(|a|\\)，零向量 \\(\\mathbf 0\\)，单位向量 向量的线性运算 向量的加法和减法 交换律 结合律 存在幺元 \\(\\mathbf 0\\) 存在逆元 \\(- a\\) （模的）三角不等式 向量的数乘 向量的数量积和数量积 向量在轴上的投影 Def：向量夹角 Def：（向量在轴上的投影） \\((\\vec{AB})_l = |\\vec{AB}| \\cos (\\vec {AB}, l)\\) 向量的数量积 Def：数量积 Thm：数量积的性质 $ a a = | a|^2$ \\(\\cos ( a, b) =\\frac{ a \\cdot b}{| a|| b|}\\) $ a b a b = 0$ 交换律、数乘的结合律、分配律 向量的向量积 Def：向量积 Thm：向量积的性质 $ a b = 0a b$ 反交换律 分配律 数乘的结合律 向量的混合积 Def：（混合积）\\([{abc}] = a \\cdot ( b \\times c)\\) 几何意义：是以 \\({a,b,c}\\) 为相邻棱构成的平行六面体的体积 Thm：混合积的性质 $ a, b, c 共面 $ 空间直角坐标系及向量运算的坐标表示 空间直角坐标系 空间直角坐标系的建立： Def：坐标轴、坐标原点、坐标平面、卦限 点的坐标： Def：横坐标、纵坐标、竖坐标 坐标轴的平移 向量的坐标表示 向量的坐标 Def：基向量 Def：坐标表示式 向量的模和方向余弦 Def：\\(a\\) 的方向角 Def：（\\(a\\) 的方向余弦）\\(\\cos \\alpha = \\frac x {| a|},\\cos \\beta = \\frac y {| a|},\\cos \\gamma = \\frac z {| a|}\\) 向量运算的坐标表示 向量加减法和数乘的坐标表示 数量积的坐标表示 向量积的坐标表示（行列式） 混合积的坐标表示 平面与直线 平面方程 点法式方程 一般方程 截距式方程 三点式方程 直线方程 一般方程（两平面的交） 标准方程 两点式方程 参数方程 向量式方程 相关问题 夹角直线与直线直线与平面平面与平面 距离点到平面点到直线 \\(\\displaystyle d =\\frac{|\\vec{M_0M_1}\\times a|}{|a|}\\)异面直线的距离 \\(\\displaystyle d =\\frac{|[\\vec{M_0M_1}a_1a_2]|}{|a_1\\times a_2|}\\) 直线与平面的交点 过直线的平面束 空间曲面和空间曲线 球面和柱面 球面方程 柱面方程 空间曲线 一般方程（两个平面的交线） 参数方程 空间曲线在坐标面上的投影 锥面 母线、准线、顶点 如何通过母线、准线、顶点构造 旋转曲面 如何构造？ 几种常见的二次曲面 椭圆锥面椭球面单叶双曲面双叶双曲面椭圆抛物面双曲抛物面椭圆柱面双曲柱面抛物柱面","categories":[{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"向量空间","slug":"Vector-Space","permalink":"http://adversarr.github.io/tags/Vector-Space/"},{"name":"解析几何","slug":"Analytic-Geometry","permalink":"http://adversarr.github.io/tags/Analytic-Geometry/"}],"author":"Clover"}],"categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"课程","slug":"课程","permalink":"http://adversarr.github.io/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"计算机科学","slug":"计算机科学","permalink":"http://adversarr.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"杂谈","slug":"杂谈","permalink":"http://adversarr.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"程序设计","slug":"程序设计","permalink":"http://adversarr.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"GAMES 在线课","slug":"GAMES-在线课","permalink":"http://adversarr.github.io/tags/GAMES-%E5%9C%A8%E7%BA%BF%E8%AF%BE/"},{"name":"物理仿真","slug":"物理仿真","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86%E4%BB%BF%E7%9C%9F/"},{"name":"物理","slug":"物理","permalink":"http://adversarr.github.io/tags/%E7%89%A9%E7%90%86/"},{"name":"数据库","slug":"数据库","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数学","slug":"数学","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"夏令营","slug":"夏令营","permalink":"http://adversarr.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"},{"name":"微分几何","slug":"微分几何","permalink":"http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/"},{"name":"仿真模拟","slug":"仿真模拟","permalink":"http://adversarr.github.io/tags/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/"},{"name":"布料","slug":"布料","permalink":"http://adversarr.github.io/tags/%E5%B8%83%E6%96%99/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://adversarr.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://adversarr.github.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"数值分析","slug":"数值分析","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"},{"name":"常微分方程","slug":"常微分方程","permalink":"http://adversarr.github.io/tags/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"},{"name":"编程","slug":"编程","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://adversarr.github.io/tags/C/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://adversarr.github.io/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"},{"name":"复变函数","slug":"复变函数","permalink":"http://adversarr.github.io/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"实变函数","slug":"实变函数","permalink":"http://adversarr.github.io/tags/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://adversarr.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"编译原理","slug":"编译原理","permalink":"http://adversarr.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"信号与系统","slug":"信号与系统","permalink":"http://adversarr.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"凸优化","slug":"凸优化","permalink":"http://adversarr.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"概率论","slug":"概率论","permalink":"http://adversarr.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"摘抄","slug":"摘抄","permalink":"http://adversarr.github.io/tags/%E6%91%98%E6%8A%84/"},{"name":"离散数学","slug":"离散数学","permalink":"http://adversarr.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"波","slug":"波","permalink":"http://adversarr.github.io/tags/%E6%B3%A2/"},{"name":"数据结构","slug":"数据结构","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂记","slug":"杂记","permalink":"http://adversarr.github.io/tags/%E6%9D%82%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"http://adversarr.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"杂谈","slug":"杂谈","permalink":"http://adversarr.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"Lambda演算","slug":"Lambda演算","permalink":"http://adversarr.github.io/tags/Lambda%E6%BC%94%E7%AE%97/"},{"name":"运动学","slug":"运动学","permalink":"http://adversarr.github.io/tags/%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"name":"级数","slug":"Series","permalink":"http://adversarr.github.io/tags/Series/"},{"name":"傅里叶","slug":"傅里叶","permalink":"http://adversarr.github.io/tags/%E5%82%85%E9%87%8C%E5%8F%B6/"},{"name":"数理逻辑","slug":"数理逻辑","permalink":"http://adversarr.github.io/tags/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"},{"name":"高等数学","slug":"Advanced-Mathematics","permalink":"http://adversarr.github.io/tags/Advanced-Mathematics/"},{"name":"多元函数","slug":"Multi-Functions","permalink":"http://adversarr.github.io/tags/Multi-Functions/"},{"name":"微分","slug":"微分","permalink":"http://adversarr.github.io/tags/%E5%BE%AE%E5%88%86/"},{"name":"代数结构","slug":"Algebra-Structure","permalink":"http://adversarr.github.io/tags/Algebra-Structure/"},{"name":"外微分形式","slug":"Wedge-Differential","permalink":"http://adversarr.github.io/tags/Wedge-Differential/"},{"name":"向量空间","slug":"Vector-Space","permalink":"http://adversarr.github.io/tags/Vector-Space/"},{"name":"解析几何","slug":"Analytic-Geometry","permalink":"http://adversarr.github.io/tags/Analytic-Geometry/"}]}